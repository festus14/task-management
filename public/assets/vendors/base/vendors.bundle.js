/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
(function (global, factory) {

    "use strict";

    if (typeof module === "object" && typeof module.exports === "object") {

        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory(global, true) :
            function (w) {
                if (!w.document) {
                    throw new Error("jQuery requires a window with a document");
                }
                return factory(w);
            };
    } else {
        factory(global);
    }

// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
    "use strict";

    var arr = [];

    var document = window.document;

    var getProto = Object.getPrototypeOf;

    var slice = arr.slice;

    var concat = arr.concat;

    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var fnToString = hasOwn.toString;

    var ObjectFunctionString = fnToString.call(Object);

    var support = {};

    var isFunction = function isFunction(obj) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };


    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };


    var preservedScriptAttributes = {
        type: true,
        src: true,
        noModule: true
    };

    function DOMEval(code, doc, node) {
        doc = doc || document;

        var i,
            script = doc.createElement("script");

        script.text = code;
        if (node) {
            for (i in preservedScriptAttributes) {
                if (node[i]) {
                    script[i] = node[i];
                }
            }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }


    function toType(obj) {
        if (obj == null) {
            return obj + "";
        }

        // Support: Android <=2.3 only (functionish RegExp)
        return typeof obj === "object" || typeof obj === "function" ?
            class2type[toString.call(obj)] || "object" :
            typeof obj;
    }

    /* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module


    var
        version = "3.3.1",

        // Define a local copy of jQuery
        jQuery = function (selector, context) {

            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init(selector, context);
        },

        // Support: Android <=4.0 only
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    jQuery.fn = jQuery.prototype = {

        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function () {
            return slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function (num) {

            // Return all the elements in a clean array
            if (num == null) {
                return slice.call(this);
            }

            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function (elems) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        each: function (callback) {
            return jQuery.each(this, callback);
        },

        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },

        first: function () {
            return this.eq(0);
        },

        last: function () {
            return this.eq(-1);
        },

        eq: function (i) {
            var len = this.length,
                j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },

        end: function () {
            return this.prevObject || this.constructor();
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;

            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {

            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {

                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) ||
                        (copyIsArray = Array.isArray(copy)))) {

                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && Array.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({

        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function (msg) {
            throw new Error(msg);
        },

        noop: function () {
        },

        isPlainObject: function (obj) {
            var proto, Ctor;

            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") {
                return false;
            }

            proto = getProto(obj);

            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) {
                return true;
            }

            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },

        isEmptyObject: function (obj) {

            /* eslint-disable no-unused-vars */
            // See https://github.com/eslint/eslint/issues/6125
            var name;

            for (name in obj) {
                return false;
            }
            return true;
        },

        // Evaluates a script in a global context
        globalEval: function (code) {
            DOMEval(code);
        },

        each: function (obj, callback) {
            var length, i = 0;

            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }

            return obj;
        },

        // Support: Android <=4.0 only
        trim: function (text) {
            return text == null ?
                "" :
                (text + "").replace(rtrim, "");
        },

        // results is for internal usage only
        makeArray: function (arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret,
                        typeof arr === "string" ?
                            [arr] : arr
                    );
                } else {
                    push.call(ret, arr);
                }
            }

            return ret;
        },

        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function (first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for (; j < len; j++) {
                first[i++] = second[j];
            }

            first.length = i;

            return first;
        },

        grep: function (elems, callback, invert) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function (elems, callback, arg) {
            var length, value,
                i = 0,
                ret = [];

            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }

                // Go through every key on the object,
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }

// Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

    function isArrayLike(obj) {

        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = toType(obj);

        if (isFunction(obj) || isWindow(obj)) {
            return false;
        }

        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && (length - 1) in obj;
    }

    var Sizzle =
        /*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
        (function (window) {

            var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,

                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,

                // Instance-specific data
                expando = "sizzle" + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                    }
                    return 0;
                },

                // Instance methods
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf as it's faster than native
                // https://jsperf.com/thor-indexof-vs-for/5
                indexOf = function (list, elem) {
                    var i = 0,
                        len = list.length;
                    for (; i < len; i++) {
                        if (list[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                },

                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                // Regular expressions

                // http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = "[\\x20\\t\\r\\n\\f]",

                // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                    // Operator (capture 2)
                    "*([*^$|!~]?=)" + whitespace +
                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                    "*\\]",

                pseudos = ":(" + identifier + ")(?:\\((" +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                    // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                    // 3. anything else (capture 2)
                    ".*" +
                    ")\\)|)",

                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rwhitespace = new RegExp(whitespace + "+", "g"),
                rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

                rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

                rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp("^" + identifier + "$"),

                matchExpr = {
                    "ID": new RegExp("^#(" + identifier + ")"),
                    "CLASS": new RegExp("^\\.(" + identifier + ")"),
                    "TAG": new RegExp("^(" + identifier + "|[*])"),
                    "ATTR": new RegExp("^" + attributes),
                    "PSEUDO": new RegExp("^" + pseudos),
                    "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                        "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                        "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                    "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                },

                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,

                rnative = /^[^{]+\{\s*\[native \w/,

                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                rsibling = /[+~]/,

                // CSS escapes
                // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                funescape = function (_, escaped, escapedWhitespace) {
                    var high = "0x" + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace ?
                        escaped :
                        high < 0 ?
                            // BMP codepoint
                            String.fromCharCode(high + 0x10000) :
                            // Supplemental Plane codepoint (surrogate pair)
                            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                },

                // CSS string/identifier serialization
                // https://drafts.csswg.org/cssom/#common-serializing-idioms
                rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                fcssescape = function (ch, asCodePoint) {
                    if (asCodePoint) {

                        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                        if (ch === "\0") {
                            return "\uFFFD";
                        }

                        // Control characters and (dependent upon position) numbers get escaped as code points
                        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                    }

                    // Other potentially-special ASCII characters get backslash-escaped
                    return "\\" + ch;
                },

                // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                unloadHandler = function () {
                    setDocument();
                },

                disabledAncestor = addCombinator(
                    function (elem) {
                        return elem.disabled === true && ("form" in elem || "label" in elem);
                    },
                    {dir: "parentNode", next: "legend"}
                );

// Optimize for push.apply( _, NodeList )
            try {
                push.apply(
                    (arr = slice.call(preferredDoc.childNodes)),
                    preferredDoc.childNodes
                );
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ?

                        // Leverage slice if possible
                        function (target, els) {
                            push_native.apply(target, slice.call(els));
                        } :

                        // Support: IE<9
                        // Otherwise append directly
                        function (target, els) {
                            var j = target.length,
                                i = 0;
                            // Can't trust NodeList.length
                            while ((target[j++] = els[i++])) {
                            }
                            target.length = j - 1;
                        }
                };
            }

            function Sizzle(selector, context, results, seed) {
                var m, i, elem, nid, match, groups, newSelector,
                    newContext = context && context.ownerDocument,

                    // nodeType defaults to 9, since context defaults to document
                    nodeType = context ? context.nodeType : 9;

                results = results || [];

                // Return early from calls with invalid selector or context
                if (typeof selector !== "string" || !selector ||
                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                    return results;
                }

                // Try to shortcut find operations (as opposed to filters) in HTML documents
                if (!seed) {

                    if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                        setDocument(context);
                    }
                    context = context || document;

                    if (documentIsHTML) {

                        // If the selector is sufficiently simple, try using a "get*By*" DOM method
                        // (excepting DocumentFragment context, where the methods don't exist)
                        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

                            // ID selector
                            if ((m = match[1])) {

                                // Document context
                                if (nodeType === 9) {
                                    if ((elem = context.getElementById(m))) {

                                        // Support: IE, Opera, Webkit
                                        // TODO: identify versions
                                        // getElementById can match elements by name instead of ID
                                        if (elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }

                                    // Element context
                                } else {

                                    // Support: IE, Opera, Webkit
                                    // TODO: identify versions
                                    // getElementById can match elements by name instead of ID
                                    if (newContext && (elem = newContext.getElementById(m)) &&
                                        contains(context, elem) &&
                                        elem.id === m) {

                                        results.push(elem);
                                        return results;
                                    }
                                }

                                // Type selector
                            } else if (match[2]) {
                                push.apply(results, context.getElementsByTagName(selector));
                                return results;

                                // Class selector
                            } else if ((m = match[3]) && support.getElementsByClassName &&
                                context.getElementsByClassName) {

                                push.apply(results, context.getElementsByClassName(m));
                                return results;
                            }
                        }

                        // Take advantage of querySelectorAll
                        if (support.qsa &&
                            !compilerCache[selector + " "] &&
                            (!rbuggyQSA || !rbuggyQSA.test(selector))) {

                            if (nodeType !== 1) {
                                newContext = context;
                                newSelector = selector;

                                // qSA looks outside Element context, which is not what we want
                                // Thanks to Andrew Dupont for this workaround technique
                                // Support: IE <=8
                                // Exclude object elements
                            } else if (context.nodeName.toLowerCase() !== "object") {

                                // Capture the context ID, setting it first if necessary
                                if ((nid = context.getAttribute("id"))) {
                                    nid = nid.replace(rcssescape, fcssescape);
                                } else {
                                    context.setAttribute("id", (nid = expando));
                                }

                                // Prefix every selector in the list
                                groups = tokenize(selector);
                                i = groups.length;
                                while (i--) {
                                    groups[i] = "#" + nid + " " + toSelector(groups[i]);
                                }
                                newSelector = groups.join(",");

                                // Expand context for sibling selectors
                                newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                                    context;
                            }

                            if (newSelector) {
                                try {
                                    push.apply(results,
                                        newContext.querySelectorAll(newSelector)
                                    );
                                    return results;
                                } catch (qsaError) {
                                } finally {
                                    if (nid === expando) {
                                        context.removeAttribute("id");
                                    }
                                }
                            }
                        }
                    }
                }

                // All others
                return select(selector.replace(rtrim, "$1"), context, results, seed);
            }

            /**
             * Create key-value caches of limited size
             * @returns {function(string, object)} Returns the Object data after storing it on itself with
             *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *    deleting the oldest entry
             */
            function createCache() {
                var keys = [];

                function cache(key, value) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if (keys.push(key + " ") > Expr.cacheLength) {
                        // Only keep the most recent entries
                        delete cache[keys.shift()];
                    }
                    return (cache[key + " "] = value);
                }

                return cache;
            }

            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created element and returns a boolean result
             */
            function assert(fn) {
                var el = document.createElement("fieldset");

                try {
                    return !!fn(el);
                } catch (e) {
                    return false;
                } finally {
                    // Remove from its parent by default
                    if (el.parentNode) {
                        el.parentNode.removeChild(el);
                    }
                    // release memory in IE
                    el = null;
                }
            }

            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle(attrs, handler) {
                var arr = attrs.split("|"),
                    i = arr.length;

                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }

            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                        a.sourceIndex - b.sourceIndex;

                // Use IE sourceIndex if available on both nodes
                if (diff) {
                    return diff;
                }

                // Check if b follows a
                if (cur) {
                    while ((cur = cur.nextSibling)) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }

                return a ? 1 : -1;
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for :enabled/:disabled
             * @param {Boolean} disabled true for :disabled; false for :enabled
             */
            function createDisabledPseudo(disabled) {

                // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                return function (elem) {

                    // Only certain elements can match :enabled or :disabled
                    // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                    // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                    if ("form" in elem) {

                        // Check for inherited disabledness on relevant non-disabled elements:
                        // * listed form-associated elements in a disabled fieldset
                        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                        // * option elements in a disabled optgroup
                        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                        // All such elements have a "form" property.
                        if (elem.parentNode && elem.disabled === false) {

                            // Option elements defer to a parent optgroup if present
                            if ("label" in elem) {
                                if ("label" in elem.parentNode) {
                                    return elem.parentNode.disabled === disabled;
                                } else {
                                    return elem.disabled === disabled;
                                }
                            }

                            // Support: IE 6 - 11
                            // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                            return elem.isDisabled === disabled ||

                                // Where there is no isDisabled, check manually
                                /* jshint -W018 */
                                elem.isDisabled !== !disabled &&
                                disabledAncestor(elem) === disabled;
                        }

                        return elem.disabled === disabled;

                        // Try to winnow out elements that can't be disabled before trusting the disabled property.
                        // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                        // even exist on them, let alone have a boolean value.
                    } else if ("label" in elem) {
                        return elem.disabled === disabled;
                    }

                    // Remaining elements are neither :enabled nor :disabled
                    return false;
                };
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                        var j,
                            matchIndexes = fn([], seed.length, argument),
                            i = matchIndexes.length;

                        // Match elements found at the specified indexes
                        while (i--) {
                            if (seed[(j = matchIndexes[i])]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            /**
             * Checks a node for validity as a Sizzle context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext(context) {
                return context && typeof context.getElementsByTagName !== "undefined" && context;
            }

// Expose support vars for convenience
            support = Sizzle.support = {};

            /**
             * Detects XML nodes
             * @param {Element|Object} elem An element or a document
             * @returns {Boolean} True iff elem is a non-HTML XML node
             */
            isXML = Sizzle.isXML = function (elem) {
                // documentElement is verified for cases where it doesn't yet exist
                // (such as loading iframes in IE - #4833)
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== "HTML" : false;
            };

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function (node) {
                var hasCompare, subWindow,
                    doc = node ? node.ownerDocument || node : preferredDoc;

                // Return early if doc is invalid or already selected
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }

                // Update global variables
                document = doc;
                docElem = document.documentElement;
                documentIsHTML = !isXML(document);

                // Support: IE 9-11, Edge
                // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                if (preferredDoc !== document &&
                    (subWindow = document.defaultView) && subWindow.top !== subWindow) {

                    // Support: IE 11, Edge
                    if (subWindow.addEventListener) {
                        subWindow.addEventListener("unload", unloadHandler, false);

                        // Support: IE 9 - 10 only
                    } else if (subWindow.attachEvent) {
                        subWindow.attachEvent("onunload", unloadHandler);
                    }
                }

                /* Attributes
	---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties
                // (excepting IE8 booleans)
                support.attributes = assert(function (el) {
                    el.className = "i";
                    return !el.getAttribute("className");
                });

                /* getElement(s)By*
	---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function (el) {
                    el.appendChild(document.createComment(""));
                    return !el.getElementsByTagName("*").length;
                });

                // Support: IE<9
                support.getElementsByClassName = rnative.test(document.getElementsByClassName);

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programmatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function (el) {
                    docElem.appendChild(el).id = expando;
                    return !document.getElementsByName || !document.getElementsByName(expando).length;
                });

                // ID filter and find
                if (support.getById) {
                    Expr.filter["ID"] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute("id") === attrId;
                        };
                    };
                    Expr.find["ID"] = function (id, context) {
                        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                            var elem = context.getElementById(id);
                            return elem ? [elem] : [];
                        }
                    };
                } else {
                    Expr.filter["ID"] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== "undefined" &&
                                elem.getAttributeNode("id");
                            return node && node.value === attrId;
                        };
                    };

                    // Support: IE 6 - 7 only
                    // getElementById is not reliable as a find shortcut
                    Expr.find["ID"] = function (id, context) {
                        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                            var node, i, elems,
                                elem = context.getElementById(id);

                            if (elem) {

                                // Verify the id attribute
                                node = elem.getAttributeNode("id");
                                if (node && node.value === id) {
                                    return [elem];
                                }

                                // Fall back on getElementsByName
                                elems = context.getElementsByName(id);
                                i = 0;
                                while ((elem = elems[i++])) {
                                    node = elem.getAttributeNode("id");
                                    if (node && node.value === id) {
                                        return [elem];
                                    }
                                }
                            }

                            return [];
                        }
                    };
                }

                // Tag
                Expr.find["TAG"] = support.getElementsByTagName ?
                    function (tag, context) {
                        if (typeof context.getElementsByTagName !== "undefined") {
                            return context.getElementsByTagName(tag);

                            // DocumentFragment nodes don't have gEBTN
                        } else if (support.qsa) {
                            return context.querySelectorAll(tag);
                        }
                    } :

                    function (tag, context) {
                        var elem,
                            tmp = [],
                            i = 0,
                            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                            results = context.getElementsByTagName(tag);

                        // Filter out possible comments
                        if (tag === "*") {
                            while ((elem = results[i++])) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                // Class
                Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                    if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                        return context.getElementsByClassName(className);
                    }
                };

                /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See https://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];

                if ((support.qsa = rnative.test(document.querySelectorAll))) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function (el) {
                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // https://bugs.jquery.com/ticket/12359
                        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
                            "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                            "<option selected=''></option></select>";

                        // Support: IE8, Opera 11-12.16
                        // Nothing should be selected when empty strings follow ^= or $= or *=
                        // The test attribute must be unknown in Opera but "safe" for WinRT
                        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                        if (el.querySelectorAll("[msallowcapture^='']").length) {
                            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                        }

                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if (!el.querySelectorAll("[selected]").length) {
                            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                        }

                        // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                        if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                            rbuggyQSA.push("~=");
                        }

                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if (!el.querySelectorAll(":checked").length) {
                            rbuggyQSA.push(":checked");
                        }

                        // Support: Safari 8+, iOS 8+
                        // https://bugs.webkit.org/show_bug.cgi?id=136851
                        // In-page `selector#id sibling-combinator selector` fails
                        if (!el.querySelectorAll("a#" + expando + "+*").length) {
                            rbuggyQSA.push(".#.+[+~]");
                        }
                    });

                    assert(function (el) {
                        el.innerHTML = "<a href='' disabled='disabled'></a>" +
                            "<select disabled='disabled'><option/></select>";

                        // Support: Windows 8 Native Apps
                        // The type and name attributes are restricted during .innerHTML assignment
                        var input = document.createElement("input");
                        input.setAttribute("type", "hidden");
                        el.appendChild(input).setAttribute("name", "D");

                        // Support: IE8
                        // Enforce case-sensitivity of name attribute
                        if (el.querySelectorAll("[name=d]").length) {
                            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                        }

                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if (el.querySelectorAll(":enabled").length !== 2) {
                            rbuggyQSA.push(":enabled", ":disabled");
                        }

                        // Support: IE9-11+
                        // IE's :disabled selector does not pick up the children of disabled fieldsets
                        docElem.appendChild(el).disabled = true;
                        if (el.querySelectorAll(":disabled").length !== 2) {
                            rbuggyQSA.push(":enabled", ":disabled");
                        }

                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        el.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:");
                    });
                }

                if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                    docElem.webkitMatchesSelector ||
                    docElem.mozMatchesSelector ||
                    docElem.oMatchesSelector ||
                    docElem.msMatchesSelector)))) {

                    assert(function (el) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call(el, "*");

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call(el, "[s!='']:x");
                        rbuggyMatches.push("!=", pseudos);
                    });
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                /* Contains
	---------------------------------------------------------------------- */
                hasCompare = rnative.test(docElem.compareDocumentPosition);

                // Element contains another
                // Purposefully self-exclusive
                // As in, an element does not contain itself
                contains = hasCompare || rnative.test(docElem.contains) ?
                    function (a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !!(bup && bup.nodeType === 1 && (
                            adown.contains ?
                                adown.contains(bup) :
                                a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                        ));
                    } :
                    function (a, b) {
                        if (b) {
                            while ((b = b.parentNode)) {
                                if (b === a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                /* Sorting
	---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare ?
                    function (a, b) {

                        // Flag for duplicate removal
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if (compare) {
                            return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
                            a.compareDocumentPosition(b) :

                            // Otherwise we know they are disconnected
                            1;

                        // Disconnected nodes
                        if (compare & 1 ||
                            (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                            // Choose the first element that is related to our preferred document
                            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                return -1;
                            }
                            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                return 1;
                            }

                            // Maintain original order
                            return sortInput ?
                                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                0;
                        }

                        return compare & 4 ? -1 : 1;
                    } :
                    function (a, b) {
                        // Exit early if the nodes are identical
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var cur,
                            i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [a],
                            bp = [b];

                        // Parentless nodes are either documents or disconnected
                        if (!aup || !bup) {
                            return a === document ? -1 :
                                b === document ? 1 :
                                    aup ? -1 :
                                        bup ? 1 :
                                            sortInput ?
                                                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                                0;

                            // If the nodes are siblings, we can do a quick check
                        } else if (aup === bup) {
                            return siblingCheck(a, b);
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ((cur = cur.parentNode)) {
                            ap.unshift(cur);
                        }
                        cur = b;
                        while ((cur = cur.parentNode)) {
                            bp.unshift(cur);
                        }

                        // Walk down the tree looking for a discrepancy
                        while (ap[i] === bp[i]) {
                            i++;
                        }

                        return i ?
                            // Do a sibling check if the nodes have a common ancestor
                            siblingCheck(ap[i], bp[i]) :

                            // Otherwise nodes in our document sort first
                            ap[i] === preferredDoc ? -1 :
                                bp[i] === preferredDoc ? 1 :
                                    0;
                    };

                return document;
            };

            Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements);
            };

            Sizzle.matchesSelector = function (elem, expr) {
                // Set document vars if needed
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }

                // Make sure that attribute selectors are quoted
                expr = expr.replace(rattributeQuotes, "='$1']");

                if (support.matchesSelector && documentIsHTML &&
                    !compilerCache[expr + " "] &&
                    (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                    (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                    try {
                        var ret = matches.call(elem, expr);

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (ret || support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11) {
                            return ret;
                        }
                    } catch (e) {
                    }
                }

                return Sizzle(expr, document, null, [elem]).length > 0;
            };

            Sizzle.contains = function (context, elem) {
                // Set document vars if needed
                if ((context.ownerDocument || context) !== document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };

            Sizzle.attr = function (elem, name) {
                // Set document vars if needed
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }

                var fn = Expr.attrHandle[name.toLowerCase()],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                        fn(elem, name, !documentIsHTML) :
                        undefined;

                return val !== undefined ?
                    val :
                    support.attributes || !documentIsHTML ?
                        elem.getAttribute(name) :
                        (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
            };

            Sizzle.escape = function (sel) {
                return (sel + "").replace(rcssescape, fcssescape);
            };

            Sizzle.error = function (msg) {
                throw new Error("Syntax error, unrecognized expression: " + msg);
            };

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function (results) {
                var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);

                if (hasDuplicate) {
                    while ((elem = results[i++])) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null;

                return results;
            };

            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function (elem) {
                var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                if (!nodeType) {
                    // If no nodeType, this is expected to be an array
                    while ((node = elem[i++])) {
                        // Do not traverse comment nodes
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if (typeof elem.textContent === "string") {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes

                return ret;
            };

            Expr = Sizzle.selectors = {

                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                    ">": {dir: "parentNode", first: true},
                    " ": {dir: "parentNode"},
                    "+": {dir: "previousSibling", first: true},
                    "~": {dir: "previousSibling"}
                },

                preFilter: {
                    "ATTR": function (match) {
                        match[1] = match[1].replace(runescape, funescape);

                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                        if (match[2] === "~=") {
                            match[3] = " " + match[3] + " ";
                        }

                        return match.slice(0, 4);
                    },

                    "CHILD": function (match) {
                        /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                        match[1] = match[1].toLowerCase();

                        if (match[1].slice(0, 3) === "nth") {
                            // nth-* requires argument
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                            match[5] = +((match[7] + match[8]) || match[3] === "odd");

                            // other types prohibit arguments
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }

                        return match;
                    },

                    "PSEUDO": function (match) {
                        var excess,
                            unquoted = !match[6] && match[2];

                        if (matchExpr["CHILD"].test(match[0])) {
                            return null;
                        }

                        // Accept quoted arguments as-is
                        if (match[3]) {
                            match[2] = match[4] || match[5] || "";

                            // Strip excess characters from unquoted arguments
                        } else if (unquoted && rpseudo.test(unquoted) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize(unquoted, true)) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                            // excess is a negative index
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }

                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice(0, 3);
                    }
                },

                filter: {

                    "TAG": function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === "*" ?
                            function () {
                                return true;
                            } :
                            function (elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                    },

                    "CLASS": function (className) {
                        var pattern = classCache[className + " "];

                        return pattern ||
                            (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                            classCache(className, function (elem) {
                                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                            });
                    },

                    "ATTR": function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);

                            if (result == null) {
                                return operator === "!=";
                            }
                            if (!operator) {
                                return true;
                            }

                            result += "";

                            return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                    operator === "^=" ? check && result.indexOf(check) === 0 :
                                        operator === "*=" ? check && result.indexOf(check) > -1 :
                                            operator === "$=" ? check && result.slice(-check.length) === check :
                                                operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                                                    operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                                        false;
                        };
                    },

                    "CHILD": function (type, what, argument, first, last) {
                        var simple = type.slice(0, 3) !== "nth",
                            forward = type.slice(-4) !== "last",
                            ofType = what === "of-type";

                        return first === 1 && last === 0 ?

                            // Shortcut for :nth-*(n)
                            function (elem) {
                                return !!elem.parentNode;
                            } :

                            function (elem, context, xml) {
                                var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType,
                                    diff = false;

                                if (parent) {

                                    // :(first|last|only)-(child|of-type)
                                    if (simple) {
                                        while (dir) {
                                            node = elem;
                                            while ((node = node[dir])) {
                                                if (ofType ?
                                                    node.nodeName.toLowerCase() === name :
                                                    node.nodeType === 1) {

                                                    return false;
                                                }
                                            }
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }

                                    start = [forward ? parent.firstChild : parent.lastChild];

                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if (forward && useCache) {

                                        // Seek `elem` from a previously-cached index

                                        // ...in a gzip-friendly way
                                        node = parent;
                                        outerCache = node[expando] || (node[expando] = {});

                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        uniqueCache = outerCache[node.uniqueID] ||
                                            (outerCache[node.uniqueID] = {});

                                        cache = uniqueCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = nodeIndex && cache[2];
                                        node = nodeIndex && parent.childNodes[nodeIndex];

                                        while ((node = ++nodeIndex && node && node[dir] ||

                                            // Fallback to seeking `elem` from the start
                                            (diff = nodeIndex = 0) || start.pop())) {

                                            // When found, cache indexes on `parent` and break
                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                break;
                                            }
                                        }

                                    } else {
                                        // Use previously-cached element index if available
                                        if (useCache) {
                                            // ...in a gzip-friendly way
                                            node = elem;
                                            outerCache = node[expando] || (node[expando] = {});

                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[node.uniqueID] ||
                                                (outerCache[node.uniqueID] = {});

                                            cache = uniqueCache[type] || [];
                                            nodeIndex = cache[0] === dirruns && cache[1];
                                            diff = nodeIndex;
                                        }

                                        // xml :nth-child(...)
                                        // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                        if (diff === false) {
                                            // Use the same loop as above to seek `elem` from the start
                                            while ((node = ++nodeIndex && node && node[dir] ||
                                                (diff = nodeIndex = 0) || start.pop())) {

                                                if ((ofType ?
                                                    node.nodeName.toLowerCase() === name :
                                                    node.nodeType === 1) &&
                                                    ++diff) {

                                                    // Cache the index of each encountered element
                                                    if (useCache) {
                                                        outerCache = node[expando] || (node[expando] = {});

                                                        // Support: IE <9 only
                                                        // Defend against cloned attroperties (jQuery gh-1709)
                                                        uniqueCache = outerCache[node.uniqueID] ||
                                                            (outerCache[node.uniqueID] = {});

                                                        uniqueCache[type] = [dirruns, diff];
                                                    }

                                                    if (node === elem) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // Incorporate the offset, then check against cycle size
                                    diff -= last;
                                    return diff === first || (diff % first === 0 && diff / first >= 0);
                                }
                            };
                    },

                    "PSEUDO": function (pseudo, argument) {
                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args,
                            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                Sizzle.error("unsupported pseudo: " + pseudo);

                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if (fn[expando]) {
                            return fn(argument);
                        }

                        // But maintain support for old signatures
                        if (fn.length > 1) {
                            args = [pseudo, pseudo, "", argument];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                markFunction(function (seed, matches) {
                                    var idx,
                                        matched = fn(seed, argument),
                                        i = matched.length;
                                    while (i--) {
                                        idx = indexOf(seed, matched[i]);
                                        seed[idx] = !(matches[idx] = matched[i]);
                                    }
                                }) :
                                function (elem) {
                                    return fn(elem, 0, args);
                                };
                        }

                        return fn;
                    }
                },

                pseudos: {
                    // Potentially complex pseudos
                    "not": markFunction(function (selector) {
                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [],
                            results = [],
                            matcher = compile(selector.replace(rtrim, "$1"));

                        return matcher[expando] ?
                            markFunction(function (seed, matches, context, xml) {
                                var elem,
                                    unmatched = matcher(seed, null, xml, []),
                                    i = seed.length;

                                // Match elements unmatched by `matcher`
                                while (i--) {
                                    if ((elem = unmatched[i])) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) :
                            function (elem, context, xml) {
                                input[0] = elem;
                                matcher(input, null, xml, results);
                                // Don't keep the element (issue #299)
                                input[0] = null;
                                return !results.pop();
                            };
                    }),

                    "has": markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),

                    "contains": markFunction(function (text) {
                        text = text.replace(runescape, funescape);
                        return function (elem) {
                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                        };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    "lang": markFunction(function (lang) {
                        // lang value must be a valid identifier
                        if (!ridentifier.test(lang || "")) {
                            Sizzle.error("unsupported lang: " + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function (elem) {
                            var elemLang;
                            do {
                                if ((elemLang = documentIsHTML ?
                                    elem.lang :
                                    elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),

                    // Miscellaneous
                    "target": function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },

                    "root": function (elem) {
                        return elem === docElem;
                    },

                    "focus": function (elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },

                    // Boolean properties
                    "enabled": createDisabledPseudo(false),
                    "disabled": createDisabledPseudo(true),

                    "checked": function (elem) {
                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                    },

                    "selected": function (elem) {
                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if (elem.parentNode) {
                            elem.parentNode.selectedIndex;
                        }

                        return elem.selected === true;
                    },

                    // Contents
                    "empty": function (elem) {
                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                        // nodeType < 6 works because attributes (2) do not appear as children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeType < 6) {
                                return false;
                            }
                        }
                        return true;
                    },

                    "parent": function (elem) {
                        return !Expr.pseudos["empty"](elem);
                    },

                    // Element/input types
                    "header": function (elem) {
                        return rheader.test(elem.nodeName);
                    },

                    "input": function (elem) {
                        return rinputs.test(elem.nodeName);
                    },

                    "button": function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === "button" || name === "button";
                    },

                    "text": function (elem) {
                        var attr;
                        return elem.nodeName.toLowerCase() === "input" &&
                            elem.type === "text" &&

                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                    },

                    // Position-in-collection
                    "first": createPositionalPseudo(function () {
                        return [0];
                    }),

                    "last": createPositionalPseudo(function (matchIndexes, length) {
                        return [length - 1];
                    }),

                    "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),

                    "even": createPositionalPseudo(function (matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "odd": createPositionalPseudo(function (matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; --i >= 0;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    })
                }
            };

            Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
            for (i in {radio: true, checkbox: true, file: true, password: true, image: true}) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in {submit: true, reset: true}) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }

// Easy API for creating new setFilters
            function setFilters() {
            }

            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();

            tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                var matched, match, tokens, type,
                    soFar, groups, preFilters,
                    cached = tokenCache[selector + " "];

                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }

                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;

                while (soFar) {

                    // Comma and first run
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            // Don't consume trailing commas as valid
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push((tokens = []));
                    }

                    matched = false;

                    // Combinators
                    if ((match = rcombinators.exec(soFar))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            // Cast descendant combinators to space
                            type: match[0].replace(rtrim, " ")
                        });
                        soFar = soFar.slice(matched.length);
                    }

                    // Filters
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                            (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }

                    if (!matched) {
                        break;
                    }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly ?
                    soFar.length :
                    soFar ?
                        Sizzle.error(selector) :
                        // Cache the tokens
                        tokenCache(selector, groups).slice(0);
            };

            function toSelector(tokens) {
                var i = 0,
                    len = tokens.length,
                    selector = "";
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    skip = combinator.next,
                    key = skip || dir,
                    checkNonElements = base && key === "parentNode",
                    doneName = done++;

                return combinator.first ?
                    // Check against closest ancestor/preceding element
                    function (elem, context, xml) {
                        while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                return matcher(elem, context, xml);
                            }
                        }
                        return false;
                    } :

                    // Check against all ancestor/preceding elements
                    function (elem, context, xml) {
                        var oldCache, uniqueCache, outerCache,
                            newCache = [dirruns, doneName];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                        if (xml) {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    if (matcher(elem, context, xml)) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    outerCache = elem[expando] || (elem[expando] = {});

                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                                    if (skip && skip === elem.nodeName.toLowerCase()) {
                                        elem = elem[dir] || elem;
                                    } else if ((oldCache = uniqueCache[key]) &&
                                        oldCache[0] === dirruns && oldCache[1] === doneName) {

                                        // Assign to newCache so results back-propagate to previous elements
                                        return (newCache[2] = oldCache[2]);
                                    } else {
                                        // Reuse newcache so results back-propagate to previous elements
                                        uniqueCache[key] = newCache;

                                        // A match means we're done; a fail means we have to keep checking
                                        if ((newCache[2] = matcher(elem, context, xml))) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                        return false;
                    };
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ?
                    function (elem, context, xml) {
                        var i = matchers.length;
                        while (i--) {
                            if (!matchers[i](elem, context, xml)) {
                                return false;
                            }
                        }
                        return true;
                    } :
                    matchers[0];
            }

            function multipleContexts(selector, contexts, results) {
                var i = 0,
                    len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }

            function condense(unmatched, map, filter, context, xml) {
                var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                for (; i < len; i++) {
                    if ((elem = unmatched[i])) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }

                return newUnmatched;
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function (seed, results, context, xml) {
                    var temp, i, elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,

                        // Get initial elements from seed or context
                        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && (seed || !selector) ?
                            condense(elems, preMap, preFilter, context, xml) :
                            elems,

                        matcherOut = matcher ?
                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            postFinder || (seed ? preFilter : preexisting || postFilter) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                            matcherIn;

                    // Find primary matches
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }

                    // Apply postFilter
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);

                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while (i--) {
                            if ((elem = temp[i])) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }

                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i])) {
                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push((matcherIn[i] = elem));
                                    }
                                }
                                postFinder(null, (matcherOut = []), temp, xml);
                            }

                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) &&
                                    (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }

                        // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(
                            matcherOut === results ?
                                matcherOut.splice(preexisting, matcherOut.length) :
                                matcherOut
                        );
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }

            function matcherFromTokens(tokens) {
                var checkContext, matcher, j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[tokens[0].type],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,

                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator(function (elem) {
                        return elem === checkContext;
                    }, implicitRelative, true),
                    matchAnyContext = addCombinator(function (elem) {
                        return indexOf(checkContext, elem) > -1;
                    }, implicitRelative, true),
                    matchers = [function (elem, context, xml) {
                        var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
                            (checkContext = context).nodeType ?
                                matchContext(elem, context, xml) :
                                matchAnyContext(elem, context, xml));
                        // Avoid hanging onto element (issue #299)
                        checkContext = null;
                        return ret;
                    }];

                for (; i < len; i++) {
                    if ((matcher = Expr.relative[tokens[i].type])) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                        // Return special upon seeing a positional matcher
                        if (matcher[expando]) {
                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(
                                i > 1 && elementMatcher(matchers),
                                i > 1 && toSelector(
                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})
                                ).replace(rtrim, "$1"),
                                matcher,
                                i < j && matcherFromTokens(tokens.slice(i, j)),
                                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                j < len && toSelector(tokens)
                            );
                        }
                        matchers.push(matcher);
                    }
                }

                return elementMatcher(matchers);
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function (seed, context, xml, results, outermost) {
                        var elem, j, matcher,
                            matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,
                            // We must always have either seed elements or outermost context
                            elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;

                        if (outermost) {
                            outermostContext = context === document || context || outermost;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for (; i !== len && (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                if (!context && elem.ownerDocument !== document) {
                                    setDocument(elem);
                                    xml = !documentIsHTML;
                                }
                                while ((matcher = elementMatchers[j++])) {
                                    if (matcher(elem, context || document, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if (bySet) {
                                // They will have gone through all possible matchers
                                if ((elem = !matcher && elem)) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }

                        // `i` is now the count of elements visited above, and adding it to `matchedCount`
                        // makes the latter nonnegative.
                        matchedCount += i;

                        // Apply set filters to unmatched elements
                        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                        // no element matchers and no seed.
                        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                        // numerically zero.
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while ((matcher = setMatchers[j++])) {
                                matcher(unmatched, setMatched, context, xml);
                            }

                            if (seed) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense(setMatched);
                            }

                            // Add matches to results
                            push.apply(results, setMatched);

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if (outermost && !seed && setMatched.length > 0 &&
                                (matchedCount + setMatchers.length) > 1) {

                                Sizzle.uniqueSort(results);
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                return bySet ?
                    markFunction(superMatcher) :
                    superMatcher;
            }

            compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
                var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + " "];

                if (!cached) {
                    // Generate a function of recursive functions that can be used to check each element
                    if (!match) {
                        match = tokenize(selector);
                    }
                    i = match.length;
                    while (i--) {
                        cached = matcherFromTokens(match[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }

                    // Cache the compiled function
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                    // Save selector and tokenization
                    cached.selector = selector;
                }
                return cached;
            };

            /**
             * A low-level selection function that works with Sizzle's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with Sizzle.compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            select = Sizzle.select = function (selector, context, results, seed) {
                var i, tokens, token, type, find,
                    compiled = typeof selector === "function" && selector,
                    match = !seed && tokenize((selector = compiled.selector || selector));

                results = results || [];

                // Try to minimize operations if there is only one selector in the list and no seed
                // (the latter of which guarantees us context)
                if (match.length === 1) {

                    // Reduce context if the leading compound selector is an ID
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                        context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

                        context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;

                            // Precompiled matchers will still verify ancestry, so step up a level
                        } else if (compiled) {
                            context = context.parentNode;
                        }

                        selector = selector.slice(tokens.shift().value.length);
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if (Expr.relative[(type = token.type)]) {
                            break;
                        }
                        if ((find = Expr.find[type])) {
                            // Search, expanding context for leading sibling combinators
                            if ((seed = find(
                                token.matches[0].replace(runescape, funescape),
                                rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                            ))) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                (compiled || compile(selector, match))(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    !context || rsibling.test(selector) && testContext(context.parentNode) || context
                );
                return results;
            };

// One-time assignments

// Sort stability
            support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
            setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function (el) {
                // Should return 1, but returns 4 (following)
                return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
            });

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if (!assert(function (el) {
                el.innerHTML = "<a href='#'></a>";
                return el.firstChild.getAttribute("href") === "#";
            })) {
                addHandle("type|href|height|width", function (elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                    }
                });
            }

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
            if (!support.attributes || !assert(function (el) {
                el.innerHTML = "<input/>";
                el.firstChild.setAttribute("value", "");
                return el.firstChild.getAttribute("value") === "";
            })) {
                addHandle("value", function (elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === "input") {
                        return elem.defaultValue;
                    }
                });
            }

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
            if (!assert(function (el) {
                return el.getAttribute("disabled") == null;
            })) {
                addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return elem[name] === true ? name.toLowerCase() :
                            (val = elem.getAttributeNode(name)) && val.specified ?
                                val.value :
                                null;
                    }
                });
            }

            return Sizzle;

        })(window);


    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;

// Deprecated
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;


    var dir = function (elem, dir, until) {
        var matched = [],
            truncate = until !== undefined;

        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };


    var siblings = function (n, elem) {
        var matched = [];

        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }

        return matched;
    };


    var rneedsContext = jQuery.expr.match.needsContext;


    function nodeName(elem, name) {

        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

    };
    var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);


// Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }

        // Single element
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return (elem === qualifier) !== not;
            });
        }

        // Arraylike of elements (jQuery, arguments, Array)
        if (typeof qualifier !== "string") {
            return jQuery.grep(elements, function (elem) {
                return (indexOf.call(qualifier, elem) > -1) !== not;
            });
        }

        // Filtered directly for both simple and complex selectors
        return jQuery.filter(qualifier, elements, not);
    }

    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];

        if (not) {
            expr = ":not(" + expr + ")";
        }

        if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }

        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };

    jQuery.fn.extend({
        find: function (selector) {
            var i, ret,
                len = this.length,
                self = this;

            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }

            ret = this.pushStack([]);

            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }

            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test(selector) ?
                    jQuery(selector) :
                    selector || [],
                false
            ).length;
        }
    });


// Initialize a jQuery object


// A central reference to the root jQuery(document)
    var rootjQuery,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        // Shortcut simple #id case for speed
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

        init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }

            // Method init() accepts an alternate rootjQuery
            // so migrate can support jQuery.sub (gh-2101)
            root = root || rootjQuery;

            // Handle HTML strings
            if (typeof selector === "string") {
                if (selector[0] === "<" &&
                    selector[selector.length - 1] === ">" &&
                    selector.length >= 3) {

                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];

                } else {
                    match = rquickExpr.exec(selector);
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {

                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;

                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge(this, jQuery.parseHTML(
                            match[1],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ));

                        // HANDLE: $(html, props)
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {

                                // Properties of context are called as methods if possible
                                if (isFunction(this[match])) {
                                    this[match](context[match]);

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById(match[2]);

                        if (elem) {

                            // Inject the element directly into the jQuery object
                            this[0] = elem;
                            this.length = 1;
                        }
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor(context).find(selector);
                }

                // HANDLE: $(DOMElement)
            } else if (selector.nodeType) {
                this[0] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if (isFunction(selector)) {
                return root.ready !== undefined ?
                    root.ready(selector) :

                    // Execute immediately if ready is not present
                    selector(jQuery);
            }

            return jQuery.makeArray(selector, this);
        };

// Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

// Initialize central reference
    rootjQuery = jQuery(document);


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,

        // Methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this),
                l = targets.length;

            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        closest: function (selectors, context) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                targets = typeof selectors !== "string" && jQuery(selectors);

            // Positional selectors never match, since there's no _selection_ context
            if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

                        // Always skip document fragments
                        if (cur.nodeType < 11 && (targets ?
                            targets.index(cur) > -1 :

                            // Don't pass non-elements to Sizzle
                            cur.nodeType === 1 &&
                            jQuery.find.matchesSelector(cur, selectors))) {

                            matched.push(cur);
                            break;
                        }
                    }
                }
            }

            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },

        // Determine the position of an element within the set
        index: function (elem) {

            // No argument, return index in parent
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
            }

            // Index in selector
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }

            // Locate the position of the desired element
            return indexOf.call(this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem
            );
        },

        add: function (selector, context) {
            return this.pushStack(
                jQuery.uniqueSort(
                    jQuery.merge(this.get(), jQuery(selector, context))
                )
            );
        },

        addBack: function (selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function (elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function (elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return siblings(elem.firstChild);
        },
        contents: function (elem) {
            if (nodeName(elem, "iframe")) {
                return elem.contentDocument;
            }

            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if (nodeName(elem, "template")) {
                elem = elem.content || elem;
            }

            return jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);

            if (name.slice(-5) !== "Until") {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }

            if (this.length > 1) {

                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }

                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }

            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);


// Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function (options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            createOptions(options) :
            jQuery.extend({}, options);

        var // Flag to know if list is currently firing
            firing,

            // Last fire value for non-forgettable lists
            memory,

            // Flag to know if list was already fired
            fired,

            // Flag to prevent firing
            locked,

            // Actual callback list
            list = [],

            // Queue of execution data for repeatable lists
            queue = [],

            // Index of currently firing callback (modified by add/remove as needed)
            firingIndex = -1,

            // Fire callbacks
            fire = function () {

                // Enforce single-firing
                locked = locked || options.once;

                // Execute callbacks for all pending executions,
                // respecting firingIndex overrides and runtime changes
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {

                        // Run callback and check for early termination
                        if (list[firingIndex].apply(memory[0], memory[1]) === false &&
                            options.stopOnFalse) {

                            // Jump to end and forget the data so .add doesn't re-fire
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }

                // Forget the data if we're done with it
                if (!options.memory) {
                    memory = false;
                }

                firing = false;

                // Clean up if we're done firing for good
                if (locked) {

                    // Keep an empty list if we have data for future add calls
                    if (memory) {
                        list = [];

                        // Otherwise, this object is spent
                    } else {
                        list = "";
                    }
                }
            },

            // Actual Callbacks object
            self = {

                // Add a callback or a collection of callbacks to the list
                add: function () {
                    if (list) {

                        // If we have memory from a past run, we should fire after adding
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }

                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                if (isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && toType(arg) !== "string") {

                                    // Inspect recursively
                                    add(arg);
                                }
                            });
                        })(arguments);

                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },

                // Remove a callback from the list
                remove: function () {
                    jQuery.each(arguments, function (_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);

                            // Handle firing indexes
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },

                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function (fn) {
                    return fn ?
                        jQuery.inArray(fn, list) > -1 :
                        list.length > 0;
                },

                // Remove all callbacks from the list
                empty: function () {
                    if (list) {
                        list = [];
                    }
                    return this;
                },

                // Disable .fire and .add
                // Abort any current/pending executions
                // Clear all callbacks and values
                disable: function () {
                    locked = queue = [];
                    list = memory = "";
                    return this;
                },
                disabled: function () {
                    return !list;
                },

                // Disable .fire
                // Also disable .add unless we have memory (since it would have no effect)
                // Abort any pending executions
                lock: function () {
                    locked = queue = [];
                    if (!memory && !firing) {
                        list = memory = "";
                    }
                    return this;
                },
                locked: function () {
                    return !!locked;
                },

                // Call all callbacks with the given context and arguments
                fireWith: function (context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [context, args.slice ? args.slice() : args];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },

                // Call all the callbacks with the given arguments
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },

                // To know if the callbacks have already been called at least once
                fired: function () {
                    return !!fired;
                }
            };

        return self;
    };


    function Identity(v) {
        return v;
    }

    function Thrower(ex) {
        throw ex;
    }

    function adoptValue(value, resolve, reject, noValue) {
        var method;

        try {

            // Check for promise aspect first to privilege synchronous behavior
            if (value && isFunction((method = value.promise))) {
                method.call(value).done(resolve).fail(reject);

                // Other thenables
            } else if (value && isFunction((method = value.then))) {
                method.call(value, resolve, reject);

                // Other non-thenables
            } else {

                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                // * false: [ value ].slice( 0 ) => resolve( value )
                // * true: [ value ].slice( 1 ) => resolve()
                resolve.apply(undefined, [value].slice(noValue));
            }

            // For Promises/A+, convert exceptions into rejections
            // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
            // Deferred#then to conditionally suppress rejection.
        } catch (value) {

            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply(undefined, [value]);
        }
    }

    jQuery.extend({

        Deferred: function (func) {
            var tuples = [

                    // action, add listener, callbacks,
                    // ... .then handlers, argument index, [final state]
                    ["notify", "progress", jQuery.Callbacks("memory"),
                        jQuery.Callbacks("memory"), 2],
                    ["resolve", "done", jQuery.Callbacks("once memory"),
                        jQuery.Callbacks("once memory"), 0, "resolved"],
                    ["reject", "fail", jQuery.Callbacks("once memory"),
                        jQuery.Callbacks("once memory"), 1, "rejected"]
                ],
                state = "pending",
                promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    "catch": function (fn) {
                        return promise.then(null, fn);
                    },

                    // Keep pipe for back-compat
                    pipe: function (/* fnDone, fnFail, fnProgress */) {
                        var fns = arguments;

                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {

                                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];

                                // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && isFunction(returned.promise)) {
                                        returned.promise()
                                            .progress(newDefer.notify)
                                            .done(newDefer.resolve)
                                            .fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + "With"](
                                            this,
                                            fn ? [returned] : arguments
                                        );
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    then: function (onFulfilled, onRejected, onProgress) {
                        var maxDepth = 0;

                        function resolve(depth, deferred, handler, special) {
                            return function () {
                                var that = this,
                                    args = arguments,
                                    mightThrow = function () {
                                        var returned, then;

                                        // Support: Promises/A+ section 2.3.3.3.3
                                        // https://promisesaplus.com/#point-59
                                        // Ignore double-resolution attempts
                                        if (depth < maxDepth) {
                                            return;
                                        }

                                        returned = handler.apply(that, args);

                                        // Support: Promises/A+ section 2.3.1
                                        // https://promisesaplus.com/#point-48
                                        if (returned === deferred.promise()) {
                                            throw new TypeError("Thenable self-resolution");
                                        }

                                        // Support: Promises/A+ sections 2.3.3.1, 3.5
                                        // https://promisesaplus.com/#point-54
                                        // https://promisesaplus.com/#point-75
                                        // Retrieve `then` only once
                                        then = returned &&

                                            // Support: Promises/A+ section 2.3.4
                                            // https://promisesaplus.com/#point-64
                                            // Only check objects and functions for thenability
                                            (typeof returned === "object" ||
                                                typeof returned === "function") &&
                                            returned.then;

                                        // Handle a returned thenable
                                        if (isFunction(then)) {

                                            // Special processors (notify) just wait for resolution
                                            if (special) {
                                                then.call(
                                                    returned,
                                                    resolve(maxDepth, deferred, Identity, special),
                                                    resolve(maxDepth, deferred, Thrower, special)
                                                );

                                                // Normal processors (resolve) also hook into progress
                                            } else {

                                                // ...and disregard older resolution values
                                                maxDepth++;

                                                then.call(
                                                    returned,
                                                    resolve(maxDepth, deferred, Identity, special),
                                                    resolve(maxDepth, deferred, Thrower, special),
                                                    resolve(maxDepth, deferred, Identity,
                                                        deferred.notifyWith)
                                                );
                                            }

                                            // Handle all other returned values
                                        } else {

                                            // Only substitute handlers pass on context
                                            // and multiple values (non-spec behavior)
                                            if (handler !== Identity) {
                                                that = undefined;
                                                args = [returned];
                                            }

                                            // Process the value(s)
                                            // Default process is resolve
                                            (special || deferred.resolveWith)(that, args);
                                        }
                                    },

                                    // Only normal processors (resolve) catch and reject exceptions
                                    process = special ?
                                        mightThrow :
                                        function () {
                                            try {
                                                mightThrow();
                                            } catch (e) {

                                                if (jQuery.Deferred.exceptionHook) {
                                                    jQuery.Deferred.exceptionHook(e,
                                                        process.stackTrace);
                                                }

                                                // Support: Promises/A+ section 2.3.3.3.4.1
                                                // https://promisesaplus.com/#point-61
                                                // Ignore post-resolution exceptions
                                                if (depth + 1 >= maxDepth) {

                                                    // Only substitute handlers pass on context
                                                    // and multiple values (non-spec behavior)
                                                    if (handler !== Thrower) {
                                                        that = undefined;
                                                        args = [e];
                                                    }

                                                    deferred.rejectWith(that, args);
                                                }
                                            }
                                        };

                                // Support: Promises/A+ section 2.3.3.3.1
                                // https://promisesaplus.com/#point-57
                                // Re-resolve promises immediately to dodge false rejection from
                                // subsequent errors
                                if (depth) {
                                    process();
                                } else {

                                    // Call an optional hook to record the stack, in case of exception
                                    // since it's otherwise lost when execution goes async
                                    if (jQuery.Deferred.getStackHook) {
                                        process.stackTrace = jQuery.Deferred.getStackHook();
                                    }
                                    window.setTimeout(process);
                                }
                            };
                        }

                        return jQuery.Deferred(function (newDefer) {

                            // progress_handlers.add( ... )
                            tuples[0][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onProgress) ?
                                        onProgress :
                                        Identity,
                                    newDefer.notifyWith
                                )
                            );

                            // fulfilled_handlers.add( ... )
                            tuples[1][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onFulfilled) ?
                                        onFulfilled :
                                        Identity
                                )
                            );

                            // rejected_handlers.add( ... )
                            tuples[2][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onRejected) ?
                                        onRejected :
                                        Thrower
                                )
                            );
                        }).promise();
                    },

                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            // Add list-specific methods
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
                    stateString = tuple[5];

                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(
                        function () {

                            // state = "resolved" (i.e., fulfilled)
                            // state = "rejected"
                            state = stateString;
                        },

                        // rejected_callbacks.disable
                        // fulfilled_callbacks.disable
                        tuples[3 - i][2].disable,

                        // rejected_handlers.disable
                        // fulfilled_handlers.disable
                        tuples[3 - i][3].disable,

                        // progress_callbacks.lock
                        tuples[0][2].lock,

                        // progress_handlers.lock
                        tuples[0][3].lock
                    );
                }

                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire);

                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                    return this;
                };

                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function (singleValue) {
            var

                // count of uncompleted subordinates
                remaining = arguments.length,

                // count of unprocessed arguments
                i = remaining,

                // subordinate fulfillment data
                resolveContexts = Array(i),
                resolveValues = slice.call(arguments),

                // the master Deferred
                master = jQuery.Deferred(),

                // subordinate callback factory
                updateFunc = function (i) {
                    return function (value) {
                        resolveContexts[i] = this;
                        resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (!(--remaining)) {
                            master.resolveWith(resolveContexts, resolveValues);
                        }
                    };
                };

            // Single- and empty arguments are adopted like Promise.resolve
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject,
                    !remaining);

                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (master.state() === "pending" ||
                    isFunction(resolveValues[i] && resolveValues[i].then)) {

                    return master.then();
                }
            }

            // Multiple arguments are aggregated like Promise.all array elements
            while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            }

            return master.promise();
        }
    });


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    jQuery.Deferred.exceptionHook = function (error, stack) {

        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
            window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
        }
    };


    jQuery.readyException = function (error) {
        window.setTimeout(function () {
            throw error;
        });
    };


// The deferred used on DOM ready
    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function (fn) {

        readyList
            .then(fn)

            // Wrap jQuery.readyException in a function so that the lookup
            // happens at the time of error handling instead of callback
            // registration.
            .catch(function (error) {
                jQuery.readyException(error);
            });

        return this;
    };

    jQuery.extend({

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Handle when the DOM is ready
        ready: function (wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);
        }
    });

    jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
    }

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
    if (document.readyState === "complete" ||
        (document.readyState !== "loading" && !document.documentElement.doScroll)) {

        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout(jQuery.ready);

    } else {

        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed);

        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed);
    }


// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if (toType(key) === "object") {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }

            // Sets one value
        } else if (value !== undefined) {
            chainable = true;

            if (!isFunction(value)) {
                raw = true;
            }

            if (bulk) {

                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }

            if (fn) {
                for (; i < len; i++) {
                    fn(
                        elems[i], key, raw ?
                            value :
                            value.call(elems[i], i, fn(elems[i], key))
                    );
                }
            }
        }

        if (chainable) {
            return elems;
        }

        // Gets
        if (bulk) {
            return fn.call(elems);
        }

        return len ? fn(elems[0], key) : emptyGet;
    };


// Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
    function fcamelCase(all, letter) {
        return letter.toUpperCase();
    }

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
    function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }

    var acceptData = function (owner) {

        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
    };


    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

        cache: function (owner) {

            // Check if the owner object already has a cache
            var value = owner[this.expando];

            // If not, create one
            if (!value) {
                value = {};

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) {
                        owner[this.expando] = value;

                        // Otherwise secure it in a non-enumerable property
                        // configurable must be true to allow the property to be
                        // deleted when data is removed
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }

            return value;
        },
        set: function (owner, data, value) {
            var prop,
                cache = this.cache(owner);

            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if (typeof data === "string") {
                cache[camelCase(data)] = value;

                // Handle: [ owner, { properties } ] args
            } else {

                // Copy the properties one-by-one to the cache object
                for (prop in data) {
                    cache[camelCase(prop)] = data[prop];
                }
            }
            return cache;
        },
        get: function (owner, key) {
            return key === undefined ?
                this.cache(owner) :

                // Always use camelCase key (gh-2257)
                owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function (owner, key, value) {

            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined ||
                ((key && typeof key === "string") && value === undefined)) {

                return this.get(owner, key);
            }

            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i,
                cache = owner[this.expando];

            if (cache === undefined) {
                return;
            }

            if (key !== undefined) {

                // Support array or space separated string of keys
                if (Array.isArray(key)) {

                    // If key is an array of keys...
                    // We always set camelCase keys, so remove that.
                    key = key.map(camelCase);
                } else {
                    key = camelCase(key);

                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ?
                        [key] :
                        (key.match(rnothtmlwhite) || []);
                }

                i = key.length;

                while (i--) {
                    delete cache[key[i]];
                }
            }

            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {

                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function (owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();

    var dataUser = new Data();


//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function getData(data) {
        if (data === "true") {
            return true;
        }

        if (data === "false") {
            return false;
        }

        if (data === "null") {
            return null;
        }

        // Only convert to a number if it doesn't change the string
        if (data === +data + "") {
            return +data;
        }

        if (rbrace.test(data)) {
            return JSON.parse(data);
        }

        return data;
    }

    function dataAttr(elem, key, data) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = getData(data);
                } catch (e) {
                }

                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend({
        hasData: function (elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },

        data: function (elem, name, data) {
            return dataUser.access(elem, name, data);
        },

        removeData: function (elem, name) {
            dataUser.remove(elem, name);
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function (elem, name, data) {
            return dataPriv.access(elem, name, data);
        },

        _removeData: function (elem, name) {
            dataPriv.remove(elem, name);
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data,
                elem = this[0],
                attrs = elem && elem.attributes;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);

                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {

                            // Support: IE 11 only
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }

            return access(this, function (value) {
                var data;

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {

                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                this.each(function () {

                    // We always store the camelCased key
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },

        removeData: function (key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });


    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;

            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || Array.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function () {
                    jQuery.dequeue(elem, type);
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function (elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function () {
                    dataPriv.remove(elem, [type + "queue", key]);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ?
                this :
                this.each(function () {
                    var queue = jQuery.queue(this, type, data);

                    // Ensure a hooks for this queue
                    jQuery._queueHooks(this, type);

                    if (type === "fx" && queue[0] !== "inprogress") {
                        jQuery.dequeue(this, type);
                    }
                });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },

        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, obj) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function () {
                    if (!(--count)) {
                        defer.resolveWith(elements, [elements]);
                    }
                };

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");


    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var isHiddenWithinTree = function (elem, el) {

        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;

        // Inline style trumps all
        return elem.style.display === "none" ||
            elem.style.display === "" &&

            // Otherwise, check computed style
            // Support: Firefox <=43 - 45
            // Disconnected elements can have computed display: none, so first confirm that elem is
            // in the document.
            jQuery.contains(elem.ownerDocument, elem) &&

            jQuery.css(elem, "display") === "none";
    };

    var swap = function (elem, options, callback, args) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };


    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale,
            maxIterations = 20,
            currentValue = tween ?
                function () {
                    return tween.cur();
                } :
                function () {
                    return jQuery.css(elem, prop, "");
                },
            initial = currentValue(),
            unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

            // Starting value computation is required for potential unit mismatches
            initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
                rcssNum.exec(jQuery.css(elem, prop));

        if (initialInUnit && initialInUnit[3] !== unit) {

            // Support: Firefox <=54
            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
            initial = initial / 2;

            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];

            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;

            while (maxIterations--) {

                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                    maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;

            }

            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);

            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
        }

        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;

            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ?
                initialInUnit + (valueParts[1] + 1) * valueParts[2] :
                +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }


    var defaultDisplayMap = {};

    function getDefaultDisplay(elem) {
        var temp,
            doc = elem.ownerDocument,
            nodeName = elem.nodeName,
            display = defaultDisplayMap[nodeName];

        if (display) {
            return display;
        }

        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");

        temp.parentNode.removeChild(temp);

        if (display === "none") {
            display = "block";
        }
        defaultDisplayMap[nodeName] = display;

        return display;
    }

    function showHide(elements, show) {
        var display, elem,
            values = [],
            index = 0,
            length = elements.length;

        // Determine new display value for elements that need to change
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }

            display = elem.style.display;
            if (show) {

                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === "none") {
                    values[index] = dataPriv.get(elem, "display") || null;
                    if (!values[index]) {
                        elem.style.display = "";
                    }
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                    values[index] = getDefaultDisplay(elem);
                }
            } else {
                if (display !== "none") {
                    values[index] = "none";

                    // Remember what we're overwriting
                    dataPriv.set(elem, "display", display);
                }
            }
        }

        // Set the display of the elements in a second loop to avoid constant reflow
        for (index = 0; index < length; index++) {
            if (values[index] != null) {
                elements[index].style.display = values[index];
            }
        }

        return elements;
    }

    jQuery.fn.extend({
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }

            return this.each(function () {
                if (isHiddenWithinTree(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    var rcheckableType = (/^(?:checkbox|radio)$/i);

    var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);

    var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);


// We have to close these tags to support XHTML (#13200)
    var wrapMap = {

        // Support: IE <=9 only
        option: [1, "<select multiple='multiple'>", "</select>"],

        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

        _default: [0, "", ""]
    };

// Support: IE <=9 only
    wrapMap.optgroup = wrapMap.option;

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;


    function getAll(context, tag) {

        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;

        if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");

        } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");

        } else {
            ret = [];
        }

        if (tag === undefined || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
        }

        return ret;
    }


// Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;

        for (; i < l; i++) {
            dataPriv.set(
                elems[i],
                "globalEval",
                !refElements || dataPriv.get(refElements[i], "globalEval")
            );
        }
    }


    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        for (; i < l; i++) {
            elem = elems[i];

            if (elem || elem === 0) {

                // Add nodes directly
                if (toType(elem) === "object") {

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                    // Convert non-html into a text node
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));

                    // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));

                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }

        // Remove wrapper from fragment
        fragment.textContent = "";

        i = 0;
        while ((elem = nodes[i++])) {

            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }

            contains = jQuery.contains(elem.ownerDocument, elem);

            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");

            // Preserve script evaluation history
            if (contains) {
                setGlobalEval(tmp);
            }

            // Capture executables
            if (scripts) {
                j = 0;
                while ((elem = tmp[j++])) {
                    if (rscriptType.test(elem.type || "")) {
                        scripts.push(elem);
                    }
                }
            }
        }

        return fragment;
    }


    (function () {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");

        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");

        div.appendChild(input);

        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var documentElement = document.documentElement;


    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

// Support: IE <=9 only
// See #13393 for more info
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }

    function on(elem, types, selector, data, fn, one) {
        var origFn, type;

        // Types can be a map of types/handlers
        if (typeof types === "object") {

            // ( types-Object, selector, data )
            if (typeof selector !== "string") {

                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }

        if (data == null && fn == null) {

            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {

                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {

                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }

        if (one === 1) {
            origFn = fn;
            fn = function (event) {

                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };

            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }

    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {

        global: {},

        add: function (elem, types, handler, data, selector) {

            var handleObjIn, eventHandle, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.get(elem);

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {

                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                        jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup ||
                        special.setup.call(elem, data, namespaces, eventHandle) === false) {

                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, selector, mappedTypes) {

            var j, origCount, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] &&
                    new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];

                    if ((mappedTypes || origType === handleObj.origType) &&
                        (!handler || handler.guid === handleObj.guid) &&
                        (!tmp || tmp.test(handleObj.namespace)) &&
                        (!selector || selector === handleObj.selector ||
                            selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);

                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown ||
                        special.teardown.call(elem, namespaces, elemData.handle) === false) {

                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
            }
        },

        dispatch: function (nativeEvent) {

            // Make a writable jQuery.Event from the native event object
            var event = jQuery.event.fix(nativeEvent);

            var i, j, ret, matched, handleObj, handlerQueue,
                args = new Array(arguments.length),
                handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
                special = jQuery.event.special[event.type] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;

            for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
            }

            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;

                j = 0;
                while ((handleObj = matched.handlers[j++]) &&
                !event.isImmediatePropagationStopped()) {

                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                    // a subset or equal to those in the bound event (both can have no namespace).
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
                            handleObj.handler).apply(matched.elem, args);

                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        handlers: function (event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            if (delegateCount &&

                // Support: IE <=9
                // Black-hole SVG <use> instance trees (trac-13180)
                cur.nodeType &&

                // Support: Firefox <=42
                // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                // Support: IE 11 only
                // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                !(event.type === "click" && event.button >= 1)) {

                for (; cur !== this; cur = cur.parentNode || this) {

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if (matchedSelectors[sel] === undefined) {
                                matchedSelectors[sel] = handleObj.needsContext ?
                                    jQuery(sel, this).index(cur) > -1 :
                                    jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matchedSelectors[sel]) {
                                matchedHandlers.push(handleObj);
                            }
                        }
                        if (matchedHandlers.length) {
                            handlerQueue.push({elem: cur, handlers: matchedHandlers});
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            cur = this;
            if (delegateCount < handlers.length) {
                handlerQueue.push({elem: cur, handlers: handlers.slice(delegateCount)});
            }

            return handlerQueue;
        },

        addProp: function (name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,

                get: isFunction(hook) ?
                    function () {
                        if (this.originalEvent) {
                            return hook(this.originalEvent);
                        }
                    } :
                    function () {
                        if (this.originalEvent) {
                            return this.originalEvent[name];
                        }
                    },

                set: function (value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },

        fix: function (originalEvent) {
            return originalEvent[jQuery.expando] ?
                originalEvent :
                new jQuery.Event(originalEvent);
        },

        special: {
            load: {

                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {

                // Fire native event if possible so blur/focus sequence is correct
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {

                // For checkbox, fire native event so checked state will be right
                trigger: function () {
                    if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function (event) {
                    return nodeName(event.target, "a");
                }
            },

            beforeunload: {
                postDispatch: function (event) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = function (elem, type, handle) {

        // This "if" is needed for plain objects
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };

    jQuery.Event = function (src, props) {

        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
            src.defaultPrevented === undefined &&

            // Support: Android <=2.3 only
            src.returnValue === false ?
                returnTrue :
                returnFalse;

            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (#504, #13143)
            this.target = (src.target && src.target.nodeType === 3) ?
                src.target.parentNode :
                src.target;

            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,

        preventDefault: function () {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

// Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,

        which: function (event) {
            var button = event.button;

            // Add which for key events
            if (event.which == null && rkeyEvent.test(event.type)) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) {
                    return 1;
                }

                if (button & 2) {
                    return 3;
                }

                if (button & 4) {
                    return 2;
                }

                return 0;
            }

            return event.which;
        }
    }, jQuery.event.addProp);

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function (event) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    jQuery.fn.extend({

        on: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {

                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
                    handleObj.namespace ?
                        handleObj.origType + "." + handleObj.namespace :
                        handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if (typeof types === "object") {

                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {

                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });


    var

        /* eslint-disable max-len */

        // See https://github.com/eslint/eslint/issues/3229
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

        /* eslint-enable */

        // Support: IE <=10 - 11, Edge 12 - 13 only
        // In IE/Edge using regex groups here causes severe slowdowns.
        // See https://connect.microsoft.com/IE/feedback/details/1736512/
        rnoInnerhtml = /<script|<style|<link/i,

        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") &&
            nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

            return jQuery(elem).children("tbody")[0] || elem;
        }

        return elem;
    }

// Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }

    function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
        } else {
            elem.removeAttribute("type");
        }

        return elem;
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;

            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};

                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }

        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);

            dataUser.set(dest, udataCur);
        }
    }

// Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }

    function domManip(collection, args, callback, ignored) {

        // Flatten any nested arrays
        args = concat.apply([], args);

        var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[0],
            valueIsFunction = isFunction(value);

        // We can't cloneNode fragments that contain checked, in WebKit
        if (valueIsFunction ||
            (l > 1 && typeof value === "string" &&
                !support.checkClone && rchecked.test(value))) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (valueIsFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }

        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;

            if (fragment.childNodes.length === 1) {
                fragment = first;
            }

            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for (; i < l; i++) {
                    node = fragment;

                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);

                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) {

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(scripts, getAll(node, "script"));
                        }
                    }

                    callback.call(collection[i], node, i);
                }

                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;

                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);

                    // Evaluate executable scripts on first document insertion
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") &&
                            !dataPriv.access(node, "globalEval") &&
                            jQuery.contains(doc, node)) {

                            if (node.src && (node.type || "").toLowerCase() !== "module") {

                                // Optional AJAX dependency, but won't run scripts if not present
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
                            }
                        }
                    }
                }
            }
        }

        return collection;
    }

    function remove(elem, selector, keepData) {
        var node,
            nodes = selector ? jQuery.filter(selector, elem) : elem,
            i = 0;

        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }

            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
            }
        }

        return elem;
    }

    jQuery.extend({
        htmlPrefilter: function (html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },

        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements,
                clone = elem.cloneNode(true),
                inPage = jQuery.contains(elem.ownerDocument, elem);

            // Fix IE cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
                !jQuery.isXMLDoc(elem)) {

                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);

                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }

            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }

            // Return the cloned set
            return clone;
        },

        cleanData: function (elems) {
            var data, elem, type,
                special = jQuery.event.special,
                i = 0;

            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if ((data = elem[dataPriv.expando])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });

    jQuery.fn.extend({
        detach: function (selector) {
            return remove(this, selector, true);
        },

        remove: function (selector) {
            return remove(this, selector);
        },

        text: function (value) {
            return access(this, function (value) {
                return value === undefined ?
                    jQuery.text(this) :
                    this.empty().each(function () {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            this.textContent = value;
                        }
                    });
            }, null, value, arguments.length);
        },

        append: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },

        before: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },

        after: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },

        empty: function () {
            var elem,
                i = 0;

            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {

                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;

                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                    !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                    value = jQuery.htmlPrefilter(value);

                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};

                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {
                    }
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function () {
            var ignored = [];

            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;

                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }

                // Force callback invocation
            }, ignored);
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems,
                ret = [],
                insert = jQuery(selector),
                last = insert.length - 1,
                i = 0;

            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);

                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push.apply(ret, elems.get());
            }

            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function (elem) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if (!view || !view.opener) {
            view = window;
        }

        return view.getComputedStyle(elem);
    };

    var rboxStyle = new RegExp(cssExpand.join("|"), "i");


    (function () {

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {

            // This is a singleton, we need to execute it only once
            if (!div) {
                return;
            }

            container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
                "margin-top:1px;padding:0;border:0";
            div.style.cssText =
                "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
                "margin:auto;border:1px;padding:1px;" +
                "width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);

            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";

            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
            // Some styles come back with percentage values, even though they shouldn't
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

            // Support: IE 9 - 11 only
            // Detect misreporting of content dimensions for box-sizing:border-box elements
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;

            // Support: IE 9 only
            // Detect overflow:scroll screwiness (gh-3699)
            div.style.position = "absolute";
            scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

            documentElement.removeChild(container);

            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }

        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }

        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
            reliableMarginLeftVal,
            container = document.createElement("div"),
            div = document.createElement("div");

        // Finish early in limited (non-browser) environments
        if (!div.style) {
            return;
        }

        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        jQuery.extend(support, {
            boxSizingReliable: function () {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function () {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function () {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function () {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function () {
                computeStyleTests();
                return scrollboxSizeVal;
            }
        });
    })();


    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret,

            // Support: Firefox 51+
            // Retrieving style before computed somehow
            // fixes an issue with getting wrong values
            // on detached elements
            style = elem.style;

        computed = computed || getStyles(elem);

        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];

            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?

            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + "" :
            ret;
    }


    function addGetHookIf(conditionFn, hookFn) {

        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function () {
                if (conditionFn()) {

                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }


    var

        // Swappable if display is none or starts with table
        // except "table", "table-cell", or "table-caption"
        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = {position: "absolute", visibility: "hidden", display: "block"},
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },

        cssPrefixes = ["Webkit", "Moz", "ms"],
        emptyStyle = document.createElement("div").style;

// Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(name) {

        // Shortcut for names that are not vendor prefixed
        if (name in emptyStyle) {
            return name;
        }

        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
    function finalPropName(name) {
        var ret = jQuery.cssProps[name];
        if (!ret) {
            ret = jQuery.cssProps[name] = vendorPropName(name) || name;
        }
        return ret;
    }

    function setPositiveNumber(elem, value, subtract) {

        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ?

            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
            value;
    }

    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0,
            extra = 0,
            delta = 0;

        // Adjustment may not be necessary
        if (box === (isBorderBox ? "border" : "content")) {
            return 0;
        }

        for (; i < 4; i += 2) {

            // Both box models exclude margin
            if (box === "margin") {
                delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            }

            // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
            if (!isBorderBox) {

                // Add padding
                delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                // For "border" or "margin", add border
                if (box !== "padding") {
                    delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);

                    // But still keep track of it otherwise
                } else {
                    extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }

                // If we get here with a border-box (content + padding + border), we're seeking "content" or
                // "padding" or "margin"
            } else {

                // For "content", subtract padding
                if (box === "content") {
                    delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }

                // For "content" or "padding", subtract border
                if (box !== "margin") {
                    delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }

        // Account for positive content-box scroll gutter when requested by providing computedVal
        if (!isBorderBox && computedVal >= 0) {

            // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
            // Assuming integer scroll gutter, subtract the rest and round down
            delta += Math.max(0, Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
                computedVal -
                delta -
                extra -
                0.5
            ));
        }

        return delta;
    }

    function getWidthOrHeight(elem, dimension, extra) {

        // Start with computed style
        var styles = getStyles(elem),
            val = curCSS(elem, dimension, styles),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            valueIsBorderBox = isBorderBox;

        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if (rnumnonpx.test(val)) {
            if (!extra) {
                return val;
            }
            val = "auto";
        }

        // Check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = valueIsBorderBox &&
            (support.boxSizingReliable() || val === elem.style[dimension]);

        // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        if (val === "auto" ||
            !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {

            val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];

            // offsetWidth/offsetHeight provide border-box values
            valueIsBorderBox = true;
        }

        // Normalize "" and auto
        val = parseFloat(val) || 0;

        // Adjust for the element's box model
        return (val +
            boxModelAdjustment(
                elem,
                dimension,
                extra || (isBorderBox ? "border" : "content"),
                valueIsBorderBox,
                styles,

                // Provide the current computed size to request scroll gutter calculation (gh-3589)
                val
            )
        ) + "px";
    }

    jQuery.extend({

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {

                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {

            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name),
                style = elem.style;

            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) {
                name = finalPropName(origName);
            }

            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);

                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) {
                    return;
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                if (type === "number") {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }

                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) ||
                    (value = hooks.set(elem, value, extra)) !== undefined) {

                    if (isCustomProp) {
                        style.setProperty(name, value);
                    } else {
                        style[name] = value;
                    }
                }

            } else {

                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks &&
                    (ret = hooks.get(elem, false, extra)) !== undefined) {

                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra, styles) {
            var val, num, hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name);

            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) {
                name = finalPropName(origName);
            }

            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }

            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }

            return val;
        }
    });

    jQuery.each(["height", "width"], function (i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function (elem, computed, extra) {
                if (computed) {

                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test(jQuery.css(elem, "display")) &&

                    // Support: Safari 8+
                    // Table columns in Safari have non-zero offsetWidth & zero
                    // getBoundingClientRect().width unless display is changed.
                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a disconnected node
                    // in IE throws an error.
                    (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
                        swap(elem, cssShow, function () {
                            return getWidthOrHeight(elem, dimension, extra);
                        }) :
                        getWidthOrHeight(elem, dimension, extra);
                }
            },

            set: function (elem, value, extra) {
                var matches,
                    styles = getStyles(elem),
                    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                    subtract = extra && boxModelAdjustment(
                        elem,
                        dimension,
                        extra,
                        isBorderBox,
                        styles
                    );

                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && support.scrollboxSize() === styles.position) {
                    subtract -= Math.ceil(
                        elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
                        parseFloat(styles[dimension]) -
                        boxModelAdjustment(elem, dimension, "border", false, styles) -
                        0.5
                    );
                }

                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) &&
                    (matches[3] || "px") !== "px") {

                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }

                return setPositiveNumber(elem, value, subtract);
            }
        };
    });

    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
        function (elem, computed) {
            if (computed) {
                return (parseFloat(curCSS(elem, "marginLeft")) ||
                    elem.getBoundingClientRect().left -
                    swap(elem, {marginLeft: 0}, function () {
                        return elem.getBoundingClientRect().left;
                    })
                ) + "px";
            }
        }
    );

// These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0,
                    expanded = {},

                    // Assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [value];

                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] =
                        parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (prefix !== "margin") {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len,
                    map = {},
                    i = 0;

                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;

                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }

                    return map;
                }

                return value !== undefined ?
                    jQuery.style(elem, name, value) :
                    jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });


    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }

    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ?
                hooks.get(this) :
                Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased,
                hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 ||
                    tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function (tween) {

                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 &&
                    (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
                        jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
    jQuery.fx.step = {};


    var
        fxNow, inProgress,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule);
            } else {
                window.setTimeout(schedule, jQuery.fx.interval);
            }

            jQuery.fx.tick();
        }
    }

// Animations created synchronously will run synchronously
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return (fxNow = Date.now());
    }

// Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = {height: type};

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween,
            collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
            if ((tween = collection[index].call(animation, prop, value))) {

                // We're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
            isBox = "width" in props || "height" in props,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHiddenWithinTree(elem),
            dataShow = dataPriv.get(elem, "fxshow");

        // Queue-skipping animations hijack the fx hooks
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function () {

                // Ensure the complete handler is called before this completes
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // Detect show/hide animations
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {

                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;

                        // Ignore all other no-op show/hide data
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }

        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
        }

        // Restrict "overflow" and "display" styles during box animations
        if (isBox && elem.nodeType === 1) {

            // Support: IE <=9 - 11, Edge 12 - 15
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY and Edge just mirrors
            // the overflowX value there.
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery.css(elem, "display");
            if (display === "none") {
                if (restoreDisplay) {
                    display = restoreDisplay;
                } else {

                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide([elem], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, "display");
                    showHide([elem]);
                }
            }

            // Animate inline elements as inline-block
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {

                    // Restore the original display value at the end of pure show/hide animations
                    if (!propTween) {
                        anim.done(function () {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }

        // Implement show/hide animations
        propTween = false;
        for (prop in orig) {

            // General show/hide setup for this element animation
            if (!propTween) {
                if (dataShow) {
                    if ("hidden" in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, "fxshow", {display: restoreDisplay});
                }

                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) {
                    dataShow.hidden = !hidden;
                }

                // Show elements before animating them
                if (hidden) {
                    showHide([elem], true);
                }

                /* eslint-disable no-loop-func */

                anim.done(function () {

                    /* eslint-enable no-loop-func */

                    // The final step of a "hide" animation is actually hiding the element
                    if (!hidden) {
                        showHide([elem]);
                    }
                    dataPriv.remove(elem, "fxshow");
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
            }

            // Per-property setup
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always(function () {

                // Don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

                    // Support: Android 2.3 only
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }

                deferred.notifyWith(elem, [animation, percent, remaining]);

                // If there's more to do, yield
                if (percent < 1 && length) {
                    return remaining;
                }

                // If this was an empty animation, synthesize a final progress notification
                if (!length) {
                    deferred.notifyWith(elem, [animation, 1, 0]);
                }

                // Resolve the animation and report its conclusion
                deferred.resolveWith(elem, [animation]);
                return false;
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end,
                        animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0,

                        // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }

                    // Resolve when we played the last frame; otherwise, reject
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [animation, 1, 0]);
                        deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                }
            }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
                        result.stop.bind(result);
                }
                return result;
            }
        }

        jQuery.map(props, createTween, animation);

        if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        // Attach callbacks from options
        animation
            .progress(animation.opts.progress)
            .done(animation.opts.done, animation.opts.complete)
            .fail(animation.opts.fail)
            .always(animation.opts.always);

        jQuery.fx.timer(
            jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })
        );

        return animation;
    }

    jQuery.Animation = jQuery.extend(Animation, {

        tweeners: {
            "*": [function (prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
            }]
        },

        tweener: function (props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.match(rnothtmlwhite);
            }

            var prop,
                index = 0,
                length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },

        prefilters: [defaultPrefilter],

        prefilter: function (callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });

    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing ||
            isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };

        // Go to the end state if fx are off
        if (jQuery.fx.off) {
            opt.duration = 0;

        } else {
            if (typeof opt.duration !== "number") {
                if (opt.duration in jQuery.fx.speeds) {
                    opt.duration = jQuery.fx.speeds[opt.duration];

                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }

        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function () {
            if (isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {

            // Show any hidden elements after setting opacity to 0
            return this.filter(isHiddenWithinTree).css("opacity", 0).show()

            // Animate to the value specified
                .end().animate({opacity: to}, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function () {

                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                    // Empty animations, or finishing resolves immediately
                    if (empty || dataPriv.get(this, "finish")) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ?
                this.each(doAnimation) :
                this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function () {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--;) {
                    if (timers[index].elem === this &&
                        (type == null || timers[index].queue === type)) {

                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function () {
                var index,
                    data = dataPriv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // Enable finishing flag on private data
                data.finish = true;

                // Empty the queue first
                jQuery.queue(this, type, []);

                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }

                // Look for any active animations, and finish them
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }

                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }

                // Turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each(["toggle", "show", "hide"], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply(this, arguments) :
                this.animate(genFx(name, true), speed, easing, callback);
        };
    });

// Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer,
            i = 0,
            timers = jQuery.timers;

        fxNow = Date.now();

        for (; i < timers.length; i++) {
            timer = timers[i];

            // Run the timer and safely remove it when done (allowing for external removal)
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };

    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (inProgress) {
            return;
        }

        inProgress = true;
        schedule();
    };

    jQuery.fx.stop = function () {
        inProgress = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,

        // Default speed
        _default: 400
    };


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";

        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };


    (function () {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));

        input.type = "checkbox";

        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();


    var boolHook,
        attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });

    jQuery.extend({
        attr: function (elem, name, value) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }

            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] ||
                    (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }

            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }

                if (hooks && "set" in hooks &&
                    (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                elem.setAttribute(name, value + "");
                return value;
            }

            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            ret = jQuery.find.attr(elem, name);

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === "radio" &&
                        nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },

        removeAttr: function (elem, value) {
            var name,
                i = 0,

                // Attribute names can contain non-HTML whitespace characters
                // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                attrNames = value && value.match(rnothtmlwhite);

            if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                    elem.removeAttribute(name);
                }
            }
        }
    });

// Hooks for boolean attributes
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {

                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };

    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle,
                lowercaseName = name.toLowerCase();

            if (!isXML) {

                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ?
                    lowercaseName :
                    null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });


    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });

    jQuery.extend({
        prop: function (elem, name, value) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks &&
                    (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                return (elem[name] = value);
            }

            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            return elem[name];
        },

        propHooks: {
            tabIndex: {
                get: function (elem) {

                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");

                    if (tabindex) {
                        return parseInt(tabindex, 10);
                    }

                    if (
                        rfocusable.test(elem.nodeName) ||
                        rclickable.test(elem.nodeName) &&
                        elem.href
                    ) {
                        return 0;
                    }

                    return -1;
                }
            }
        },

        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function (elem) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;

                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }

    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });


    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }


    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }

    function classesToArray(value) {
        if (Array.isArray(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
        }
        return [];
    }

    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }

            classes = classesToArray(value);

            if (classes.length) {
                while ((elem = this[i++])) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }

            if (!arguments.length) {
                return this.attr("class", "");
            }

            classes = classesToArray(value);

            if (classes.length) {
                while ((elem = this[i++])) {
                    curValue = getClass(elem);

                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {

                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") > -1) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value,
                isValidValue = type === "string" || Array.isArray(value);

            if (typeof stateVal === "boolean" && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }

            if (isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(
                        value.call(this, i, getClass(this), stateVal),
                        stateVal
                    );
                });
            }

            return this.each(function () {
                var className, i, self, classNames;

                if (isValidValue) {

                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = classesToArray(value);

                    while ((className = classNames[i++])) {

                        // Check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }

                    // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {

                        // Store className if set
                        dataPriv.set(this, "__className__", className);
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) {
                        this.setAttribute("class",
                            className || value === false ?
                                "" :
                                dataPriv.get(this, "__className__") || ""
                        );
                    }
                }
            });
        },

        hasClass: function (selector) {
            var className, elem,
                i = 0;

            className = " " + selector + " ";
            while ((elem = this[i++])) {
                if (elem.nodeType === 1 &&
                    (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        }
    });


    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, valueIsFunction,
                elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] ||
                        jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks &&
                        "get" in hooks &&
                        (ret = hooks.get(elem, "value")) !== undefined
                    ) {
                        return ret;
                    }

                    ret = elem.value;

                    // Handle most common string cases
                    if (typeof ret === "string") {
                        return ret.replace(rreturn, "");
                    }

                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }

                return;
            }

            valueIsFunction = isFunction(value);

            return this.each(function (i) {
                var val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (valueIsFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";

                } else if (typeof val === "number") {
                    val += "";

                } else if (Array.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {

                    var val = jQuery.find.attr(elem, "value");
                    return val != null ?
                        val :

                        // Support: IE <=10 - 11 only
                        // option.text throws exceptions (#14686, #14858)
                        // Strip and collapse whitespace
                        // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                        stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, i,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one",
                        values = one ? null : [],
                        max = one ? index + 1 : options.length;

                    if (index < 0) {
                        i = max;

                    } else {
                        i = one ? index : 0;
                    }

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) &&

                            // Don't return options that are disabled or in a disabled optgroup
                            !option.disabled &&
                            (!option.parentNode.disabled ||
                                !nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function (elem, value) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;

                    while (i--) {
                        option = options[i];

                        /* eslint-disable no-cond-assign */

                        if (option.selected =
                            jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
                        ) {
                            optionSet = true;
                        }

                        /* eslint-enable no-cond-assign */
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });

// Radios and checkboxes getter/setter
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (Array.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });


// Return jQuery for attributes-only inclusion


    support.focusin = "onfocusin" in window;


    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function (e) {
            e.stopPropagation();
        };

    jQuery.extend(jQuery.event, {

        trigger: function (event, data, elem, onlyHandlers) {

            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
                eventPath = [elem || document],
                type = hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

            cur = lastElement = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf(".") > -1) {

                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ?
                event :
                new jQuery.Event(type, typeof event === "object" && event);

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ?
                new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [event] :
                jQuery.makeArray(data, [event]);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {

                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur;
                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;

                // jQuery handler
                handle = (dataPriv.get(cur, "events") || {})[event.type] &&
                    dataPriv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }

                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default ||
                    special._default.apply(eventPath.pop(), data) === false) &&
                    acceptData(elem)) {

                    // Call a native DOM method on the target with the same name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];

                        if (tmp) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;

                        if (event.isPropagationStopped()) {
                            lastElement.addEventListener(type, stopPropagationCallback);
                        }

                        elem[type]();

                        if (event.isPropagationStopped()) {
                            lastElement.removeEventListener(type, stopPropagationCallback);
                        }

                        jQuery.event.triggered = undefined;

                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function (type, elem, event) {
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true
                }
            );

            jQuery.event.trigger(e, null, elem);
        }

    });

    jQuery.fn.extend({

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if (!support.focusin) {
        jQuery.each({focus: "focusin", blur: "focusout"}, function (orig, fix) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };

            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix);

                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix) - 1;

                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);

                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;

    var nonce = Date.now();

    var rquery = (/\?/);


// Cross-browser xml parsing
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== "string") {
            return null;
        }

        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = (new window.DOMParser()).parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }

        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };


    var
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (Array.isArray(obj)) {

            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {

                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {

                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(
                        prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                        v,
                        traditional,
                        add
                    );
                }
            });

        } else if (!traditional && toType(obj) === "object") {

            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {

            // Serialize scalar item.
            add(prefix, obj);
        }
    }

// Serialize an array of form elements or a set of
// key/values into a query string
    jQuery.param = function (a, traditional) {
        var prefix,
            s = [],
            add = function (key, valueOrFunction) {

                // If value is a function, invoke it and use its return value
                var value = isFunction(valueOrFunction) ?
                    valueOrFunction() :
                    valueOrFunction;

                s[s.length] = encodeURIComponent(key) + "=" +
                    encodeURIComponent(value == null ? "" : value);
            };

        // If an array was passed in, assume that it is an array of form elements.
        if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

            // Serialize the form elements
            jQuery.each(a, function () {
                add(this.name, this.value);
            });

        } else {

            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&");
    };

    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {

                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            })
                .filter(function () {
                    var type = this.type;

                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                    return this.name && !jQuery(this).is(":disabled") &&
                        rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                        (this.checked || !rcheckableType.test(type));
                })
                .map(function (i, elem) {
                    var val = jQuery(this).val();

                    if (val == null) {
                        return null;
                    }

                    if (Array.isArray(val)) {
                        return jQuery.map(val, function (val) {
                            return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                        });
                    }

                    return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                }).get();
        }
    });


    var
        r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,

        /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
        prefilters = {},

        /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat("*"),

        // Anchor tag for parsing the document origin
        originAnchor = document.createElement("a");
    originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

            if (isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

// Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

        var inspected = {},
            seekingTransport = (structure === transports);

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" &&
                    !seekingTransport && !inspected[dataTypeOrTransport]) {

                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }

        return target;
    }

    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {

            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }

            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev,
            converters = {},

            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while (current) {

            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }

            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }

            prev = current;
            current = dataTypes.shift();

            if (current) {

                // There's only work to do if current dataType is non-auto
                if (current === "*") {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] ||
                                    converters["* " + tmp[0]];
                                if (conv) {

                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return {state: "success", data: response};
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",

            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": JSON.parse,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            return settings ?

                // Building a settings object
                ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                // Extending ajaxSettings
                ajaxExtend(jQuery.ajaxSettings, target);
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,

                // URL without anti-cache param
                cacheURL,

                // Response headers
                responseHeadersString,
                responseHeaders,

                // timeout handle
                timeoutTimer,

                // Url cleanup var
                urlAnchor,

                // Request state (becomes false upon send and true upon completion)
                completed,

                // To know if global events are to be dispatched
                fireGlobals,

                // Loop variable
                i,

                // uncached part of the url
                uncached,

                // Create the final options object
                s = jQuery.ajaxSetup({}, options),

                // Callbacks context
                callbackContext = s.context || s,

                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context &&
                (callbackContext.nodeType || callbackContext.jquery) ?
                    jQuery(callbackContext) :
                    jQuery.event,

                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),

                // Status-dependent callbacks
                statusCode = s.statusCode || {},

                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},

                // Default abort message
                strAbort = "canceled",

                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function (key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while ((match = rheaders.exec(responseHeadersString))) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },

                    // Raw string
                    getAllResponseHeaders: function () {
                        return completed ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function (name, value) {
                        if (completed == null) {
                            name = requestHeadersNames[name.toLowerCase()] =
                                requestHeadersNames[name.toLowerCase()] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function (type) {
                        if (completed == null) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (completed) {

                                // Execute the appropriate callbacks
                                jqXHR.always(map[jqXHR.status]);
                            } else {

                                // Lazy-add the new callbacks in a way that preserves old ones
                                for (code in map) {
                                    statusCode[code] = [statusCode[code], map[code]];
                                }
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise(jqXHR);

            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "")
                .replace(rprotocol, location.protocol + "//");

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");

                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;

                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                        urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {

                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (completed) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace(rhash, "");

            // More options handling for requests with no content
            if (!s.hasContent) {

                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length);

                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === "string")) {
                    cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add or update anti-cache param if needed
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, "$1");
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
                }

                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;

                // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if (s.data && s.processData &&
                (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                s.data = s.data.replace(r20, "+");
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                    s.accepts[s.dataTypes[0]] +
                    (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                    s.accepts["*"]
            );

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend &&
                (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

                // Abort if not done already and return
                return jqXHR.abort();
            }

            // Aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }

                // If request was aborted inside ajaxSend, stop there
                if (completed) {
                    return jqXHR;
                }

                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {

                    // Rethrow post-completion exceptions
                    if (completed) {
                        throw e;
                    }

                    // Propagate others as results
                    done(-1, e);
                }
            }

            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Ignore repeat invocations
                if (completed) {
                    return;
                }

                completed = true;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);

                // If successful, handle type chaining
                if (isSuccess) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }

                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";

                        // if not modified
                    } else if (status === 304) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {

                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
                        [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {

            // Shift arguments if data argument was omitted
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });


    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,

            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            "throws": true
        });
    };


    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;

            if (this[0]) {
                if (isFunction(html)) {
                    html = html.call(this[0]);
                }

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
                    contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            var htmlIsFunction = isFunction(html);

            return this.each(function (i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function (selector) {
            this.parent(selector).not("body").each(function () {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });


    jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };


    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    };

    var xhrSuccessStatus = {

            // File protocol always yields status code 0, assume 200
            0: 200,

            // Support: IE <=9 only
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i,
                        xhr = options.xhr();

                    xhr.open(
                        options.type,
                        options.url,
                        options.async,
                        options.username,
                        options.password
                    );

                    // Apply custom fields if provided
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }

                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }

                    // Callback
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                callback = errorCallback = xhr.onload =
                                    xhr.onerror = xhr.onabort = xhr.ontimeout =
                                        xhr.onreadystatechange = null;

                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {

                                    // Support: IE <=9 only
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if (typeof xhr.status !== "number") {
                                        complete(0, "error");
                                    } else {
                                        complete(
                                            // File: protocol always yields status 0; see #8605, #14207
                                            xhr.status,
                                            xhr.statusText
                                        );
                                    }
                                } else {
                                    complete(
                                        xhrSuccessStatus[xhr.status] || xhr.status,
                                        xhr.statusText,

                                        // Support: IE <=9 only
                                        // IE9 has no XHR2 but throws on binary (trac-11426)
                                        // For XHR2 non-text, let the caller handle it (gh-2498)
                                        (xhr.responseType || "text") !== "text" ||
                                        typeof xhr.responseText !== "string" ?
                                            {binary: xhr.response} :
                                            {text: xhr.responseText},
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = xhr.ontimeout = callback("error");

                    // Support: IE 9 only
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {

                            // Check readyState before timeout as it changes
                            if (xhr.readyState === 4) {

                                // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window.setTimeout(function () {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }

                    // Create the abort callback
                    callback = callback("abort");

                    try {

                        // Do send the request (this may raise an exception)
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {

                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if (callback) {
                            throw e;
                        }
                    }
                },

                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });


// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
            s.contents.script = false;
        }
    });

// Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, " +
            "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

// Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });

// Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on(
                        "load error",
                        callback = function (evt) {
                            script.remove();
                            callback = null;
                            if (evt) {
                                complete(evt.type === "error" ? 404 : 200, evt.type);
                            }
                        }
                    );

                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });


    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
            this[callback] = true;
            return callback;
        }
    });

// Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                    "url" :
                    typeof s.data === "string" &&
                    (s.contentType || "")
                        .indexOf("application/x-www-form-urlencoded") === 0 &&
                    rjsonp.test(s.data) && "data"
            );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ?
                s.jsonpCallback() :
                s.jsonpCallback;

            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };

            // Force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function () {

                // If previous value didn't exist - remove it
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);

                    // Otherwise restore preexisting value
                } else {
                    window[callbackName] = overwritten;
                }

                // Save back as free
                if (s[callbackName]) {

                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });


// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = (function () {
        var body = document.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    })();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== "string") {
            return [];
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }

        var base, parsed, scripts;

        if (!context) {

            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument("");

                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement("base");
                base.href = document.location.href;
                context.head.appendChild(base);
            } else {
                context = document;
            }
        }

        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];

        // Single tag
        if (parsed) {
            return [context.createElement(parsed[1])];
        }

        parsed = buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
    };


    /**
     * Load a url into a page
     */
    jQuery.fn.load = function (url, params, callback) {
        var selector, type, response,
            self = this,
            off = url.indexOf(" ");

        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }

        // If it's a function
        if (isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === "object") {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,

                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function (responseText) {

                // Save response for use in complete callback
                response = arguments;

                self.html(selector ?

                    // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                    // Otherwise use the full result
                    responseText);

                // If the request succeeds, this function gets "data", "status", "jqXHR"
                // but they are ignored because response was set above.
                // If it fails, this function gets "jqXHR", "status", "error"
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                });
            });
        }

        return this;
    };


// Attach a bunch of functions for handling common AJAX events
    jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });


    jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };


    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css(elem, "position"),
                curElem = jQuery(elem),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") &&
                (curCSSTop + curCSSLeft).indexOf("auto") > -1;

            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (isFunction(options)) {

                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);

            } else {
                curElem.css(props);
            }
        }
    };

    jQuery.fn.extend({

        // offset() relates an element's border box to the document origin
        offset: function (options) {

            // Preserve chaining for setter
            if (arguments.length) {
                return options === undefined ?
                    this :
                    this.each(function (i) {
                        jQuery.offset.setOffset(this, options, i);
                    });
            }

            var rect, win,
                elem = this[0];

            if (!elem) {
                return;
            }

            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if (!elem.getClientRects().length) {
                return {top: 0, left: 0};
            }

            // Get document-relative position by adding viewport scroll to viewport-relative gBCR
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },

        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function () {
            if (!this[0]) {
                return;
            }

            var offsetParent, offset, doc,
                elem = this[0],
                parentOffset = {top: 0, left: 0};

            // position:fixed elements are offset from the viewport, which itself always has zero offset
            if (jQuery.css(elem, "position") === "fixed") {

                // Assume position:fixed implies availability of getBoundingClientRect
                offset = elem.getBoundingClientRect();

            } else {
                offset = this.offset();

                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while (offsetParent &&
                (offsetParent === doc.body || offsetParent === doc.documentElement) &&
                jQuery.css(offsetParent, "position") === "static") {

                    offsetParent = offsetParent.parentNode;
                }
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {

                    // Incorporate borders into its offset, since they are outside its content origin
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                    parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                }
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },

        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent;

                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || documentElement;
            });
        }
    });

// Create scrollLeft and scrollTop methods
    jQuery.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {

                // Coalesce documents and windows
                var win;
                if (isWindow(elem)) {
                    win = elem;
                } else if (elem.nodeType === 9) {
                    win = elem.defaultView;
                }

                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }

                if (win) {
                    win.scrollTo(
                        !top ? val : win.pageXOffset,
                        top ? val : win.pageYOffset
                    );

                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
    jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
            function (elem, computed) {
                if (computed) {
                    computed = curCSS(elem, prop);

                    // If curCSS returns percentage, fallback to offset
                    return rnumnonpx.test(computed) ?
                        jQuery(elem).position()[prop] + "px" :
                        computed;
                }
            }
        );
    });


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({Height: "height", Width: "width"}, function (name, type) {
        jQuery.each({padding: "inner" + name, content: type, "": "outer" + name},
            function (defaultExtra, funcName) {

                // Margin is only for outerHeight, outerWidth
                jQuery.fn[funcName] = function (margin, value) {
                    var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                        extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                    return access(this, function (elem, type, value) {
                        var doc;

                        if (isWindow(elem)) {

                            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                            return funcName.indexOf("outer") === 0 ?
                                elem["inner" + name] :
                                elem.document.documentElement["client" + name];
                        }

                        // Get document width or height
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;

                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                            // whichever is greatest
                            return Math.max(
                                elem.body["scroll" + name], doc["scroll" + name],
                                elem.body["offset" + name], doc["offset" + name],
                                doc["client" + name]
                            );
                        }

                        return value === undefined ?

                            // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css(elem, type, extra) :

                            // Set width or height on the element
                            jQuery.style(elem, type, value, extra);
                    }, type, chainable ? margin : undefined, chainable);
                };
            });
    });


    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup contextmenu").split(" "),
        function (i, name) {

            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ?
                    this.on(name, null, data, fn) :
                    this.trigger(name);
            };
        });

    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });


    jQuery.fn.extend({

        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },

        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {

            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ?
                this.off(selector, "**") :
                this.off(types, selector || "**", fn);
        }
    });

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
    jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;

        if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if (!isFunction(fn)) {
            return undefined;
        }

        // Simulated bind
        args = slice.call(arguments, 2);
        proxy = function () {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    };

    jQuery.holdReady = function (hold) {
        if (hold) {
            jQuery.readyWait++;
        } else {
            jQuery.ready(true);
        }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;

    jQuery.now = Date.now;

    jQuery.isNumeric = function (obj) {

        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") &&

            // parseFloat NaNs numeric-cast false positives ("")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            !isNaN(obj - parseFloat(obj));
    };


// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (typeof define === "function" && define.amd) {
        define("jquery", [], function () {
            return jQuery;
        });
    }


    var

        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }


    return jQuery;
});

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.14.5
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global.Popper = factory());
}(this, (function () {
    'use strict';

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
    var timeoutDuration = 0;
    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
            timeoutDuration = 1;
            break;
        }
    }

    function microtaskDebounce(fn) {
        var called = false;
        return function () {
            if (called) {
                return;
            }
            called = true;
            window.Promise.resolve().then(function () {
                called = false;
                fn();
            });
        };
    }

    function taskDebounce(fn) {
        var scheduled = false;
        return function () {
            if (!scheduled) {
                scheduled = true;
                setTimeout(function () {
                    scheduled = false;
                    fn();
                }, timeoutDuration);
            }
        };
    }

    var supportsMicroTasks = isBrowser && window.Promise;

    /**
     * Create a debounced version of a method, that's asynchronously deferred
     * but called in the minimum time possible.
     *
     * @method
     * @memberof Popper.Utils
     * @argument {Function} fn
     * @returns {Function}
     */
    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

    /**
     * Check if the given variable is a function
     * @method
     * @memberof Popper.Utils
     * @argument {Any} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
        var getType = {};
        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get CSS computed property of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
        if (element.nodeType !== 1) {
            return [];
        }
        // NOTE: 1 DOM access here
        var window = element.ownerDocument.defaultView;
        var css = window.getComputedStyle(element, null);
        return property ? css[property] : css;
    }

    /**
     * Returns the parentNode or the host of the element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} parent
     */
    function getParentNode(element) {
        if (element.nodeName === 'HTML') {
            return element;
        }
        return element.parentNode || element.host;
    }

    /**
     * Returns the scrolling parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} scroll parent
     */
    function getScrollParent(element) {
        // Return body, `getScroll` will take care to get the correct `scrollTop` from it
        if (!element) {
            return document.body;
        }

        switch (element.nodeName) {
            case 'HTML':
            case 'BODY':
                return element.ownerDocument.body;
            case '#document':
                return element.body;
        }

        // Firefox want us to check `-x` and `-y` variations as well

        var _getStyleComputedProp = getStyleComputedProperty(element),
            overflow = _getStyleComputedProp.overflow,
            overflowX = _getStyleComputedProp.overflowX,
            overflowY = _getStyleComputedProp.overflowY;

        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
            return element;
        }

        return getScrollParent(getParentNode(element));
    }

    var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

    /**
     * Determines if the browser is Internet Explorer
     * @method
     * @memberof Popper.Utils
     * @param {Number} version to check
     * @returns {Boolean} isIE
     */
    function isIE(version) {
        if (version === 11) {
            return isIE11;
        }
        if (version === 10) {
            return isIE10;
        }
        return isIE11 || isIE10;
    }

    /**
     * Returns the offset parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
        if (!element) {
            return document.documentElement;
        }

        var noOffsetParent = isIE(10) ? document.body : null;

        // NOTE: 1 DOM access here
        var offsetParent = element.offsetParent || null;
        // Skip hidden elements which don't have an offsetParent
        while (offsetParent === noOffsetParent && element.nextElementSibling) {
            offsetParent = (element = element.nextElementSibling).offsetParent;
        }

        var nodeName = offsetParent && offsetParent.nodeName;

        if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
            return element ? element.ownerDocument.documentElement : document.documentElement;
        }

        // .offsetParent will return the closest TH, TD or TABLE in case
        // no offsetParent is present, I hate this job...
        if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
            return getOffsetParent(offsetParent);
        }

        return offsetParent;
    }

    function isOffsetContainer(element) {
        var nodeName = element.nodeName;

        if (nodeName === 'BODY') {
            return false;
        }
        return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
    }

    /**
     * Finds the root node (document, shadowDOM root) of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} node
     * @returns {Element} root node
     */
    function getRoot(node) {
        if (node.parentNode !== null) {
            return getRoot(node.parentNode);
        }

        return node;
    }

    /**
     * Finds the offset parent common to the two provided nodes
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element1
     * @argument {Element} element2
     * @returns {Element} common offset parent
     */
    function findCommonOffsetParent(element1, element2) {
        // This check is needed to avoid errors in case one of the elements isn't defined for any reason
        if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
            return document.documentElement;
        }

        // Here we make sure to give as "start" the element that comes first in the DOM
        var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
        var start = order ? element1 : element2;
        var end = order ? element2 : element1;

        // Get common ancestor container
        var range = document.createRange();
        range.setStart(start, 0);
        range.setEnd(end, 0);
        var commonAncestorContainer = range.commonAncestorContainer;

        // Both nodes are inside #document

        if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
            if (isOffsetContainer(commonAncestorContainer)) {
                return commonAncestorContainer;
            }

            return getOffsetParent(commonAncestorContainer);
        }

        // one of the nodes is inside shadowDOM, find which one
        var element1root = getRoot(element1);
        if (element1root.host) {
            return findCommonOffsetParent(element1root.host, element2);
        } else {
            return findCommonOffsetParent(element1, getRoot(element2).host);
        }
    }

    /**
     * Gets the scroll value of the given element in the given side (top and left)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {String} side `top` or `left`
     * @returns {number} amount of scrolled pixels
     */
    function getScroll(element) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

        var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
        var nodeName = element.nodeName;

        if (nodeName === 'BODY' || nodeName === 'HTML') {
            var html = element.ownerDocument.documentElement;
            var scrollingElement = element.ownerDocument.scrollingElement || html;
            return scrollingElement[upperSide];
        }

        return element[upperSide];
    }

    /*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
    function includeScroll(rect, element) {
        var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        var modifier = subtract ? -1 : 1;
        rect.top += scrollTop * modifier;
        rect.bottom += scrollTop * modifier;
        rect.left += scrollLeft * modifier;
        rect.right += scrollLeft * modifier;
        return rect;
    }

    /*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

    function getBordersSize(styles, axis) {
        var sideA = axis === 'x' ? 'Left' : 'Top';
        var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

        return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
    }

    function getSize(axis, body, html, computedStyle) {
        return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
    }

    function getWindowSizes(document) {
        var body = document.body;
        var html = document.documentElement;
        var computedStyle = isIE(10) && getComputedStyle(html);

        return {
            height: getSize('Height', body, html, computedStyle),
            width: getSize('Width', body, html, computedStyle)
        };
    }

    var classCallCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    };

    var createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();


    var defineProperty = function (obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            obj[key] = value;
        }

        return obj;
    };

    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    /**
     * Given element offsets, generate an output similar to getBoundingClientRect
     * @method
     * @memberof Popper.Utils
     * @argument {Object} offsets
     * @returns {Object} ClientRect like output
     */
    function getClientRect(offsets) {
        return _extends({}, offsets, {
            right: offsets.left + offsets.width,
            bottom: offsets.top + offsets.height
        });
    }

    /**
     * Get bounding client rect of given element
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
        var rect = {};

        // IE10 10 FIX: Please, don't ask, the element isn't
        // considered in DOM in some circumstances...
        // This isn't reproducible in IE10 compatibility mode of IE11
        try {
            if (isIE(10)) {
                rect = element.getBoundingClientRect();
                var scrollTop = getScroll(element, 'top');
                var scrollLeft = getScroll(element, 'left');
                rect.top += scrollTop;
                rect.left += scrollLeft;
                rect.bottom += scrollTop;
                rect.right += scrollLeft;
            } else {
                rect = element.getBoundingClientRect();
            }
        } catch (e) {
        }

        var result = {
            left: rect.left,
            top: rect.top,
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
        };

        // subtract scrollbar size from sizes
        var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
        var width = sizes.width || element.clientWidth || result.right - result.left;
        var height = sizes.height || element.clientHeight || result.bottom - result.top;

        var horizScrollbar = element.offsetWidth - width;
        var vertScrollbar = element.offsetHeight - height;

        // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
        // we make this check conditional for performance reasons
        if (horizScrollbar || vertScrollbar) {
            var styles = getStyleComputedProperty(element);
            horizScrollbar -= getBordersSize(styles, 'x');
            vertScrollbar -= getBordersSize(styles, 'y');

            result.width -= horizScrollbar;
            result.height -= vertScrollbar;
        }

        return getClientRect(result);
    }

    function getOffsetRectRelativeToArbitraryNode(children, parent) {
        var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var isIE10 = isIE(10);
        var isHTML = parent.nodeName === 'HTML';
        var childrenRect = getBoundingClientRect(children);
        var parentRect = getBoundingClientRect(parent);
        var scrollParent = getScrollParent(children);

        var styles = getStyleComputedProperty(parent);
        var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
        var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

        // In cases where the parent is fixed, we must ignore negative scroll in offset calc
        if (fixedPosition && isHTML) {
            parentRect.top = Math.max(parentRect.top, 0);
            parentRect.left = Math.max(parentRect.left, 0);
        }
        var offsets = getClientRect({
            top: childrenRect.top - parentRect.top - borderTopWidth,
            left: childrenRect.left - parentRect.left - borderLeftWidth,
            width: childrenRect.width,
            height: childrenRect.height
        });
        offsets.marginTop = 0;
        offsets.marginLeft = 0;

        // Subtract margins of documentElement in case it's being used as parent
        // we do this only on HTML because it's the only element that behaves
        // differently when margins are applied to it. The margins are included in
        // the box of the documentElement, in the other cases not.
        if (!isIE10 && isHTML) {
            var marginTop = parseFloat(styles.marginTop, 10);
            var marginLeft = parseFloat(styles.marginLeft, 10);

            offsets.top -= borderTopWidth - marginTop;
            offsets.bottom -= borderTopWidth - marginTop;
            offsets.left -= borderLeftWidth - marginLeft;
            offsets.right -= borderLeftWidth - marginLeft;

            // Attach marginTop and marginLeft because in some circumstances we may need them
            offsets.marginTop = marginTop;
            offsets.marginLeft = marginLeft;
        }

        if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
            offsets = includeScroll(offsets, parent);
        }

        return offsets;
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element) {
        var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var html = element.ownerDocument.documentElement;
        var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
        var width = Math.max(html.clientWidth, window.innerWidth || 0);
        var height = Math.max(html.clientHeight, window.innerHeight || 0);

        var scrollTop = !excludeScroll ? getScroll(html) : 0;
        var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

        var offset = {
            top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
            left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
            width: width,
            height: height
        };

        return getClientRect(offset);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
        var nodeName = element.nodeName;
        if (nodeName === 'BODY' || nodeName === 'HTML') {
            return false;
        }
        if (getStyleComputedProperty(element, 'position') === 'fixed') {
            return true;
        }
        return isFixed(getParentNode(element));
    }

    /**
     * Finds the first parent of an element that has a transformed property defined
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} first transformed parent or documentElement
     */

    function getFixedPositionOffsetParent(element) {
        // This check is needed to avoid errors in case one of the elements isn't defined for any reason
        if (!element || !element.parentElement || isIE()) {
            return document.documentElement;
        }
        var el = element.parentElement;
        while (el && getStyleComputedProperty(el, 'transform') === 'none') {
            el = el.parentElement;
        }
        return el || document.documentElement;
    }

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} popper
     * @param {HTMLElement} reference
     * @param {number} padding
     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
     * @param {Boolean} fixedPosition - Is in fixed position mode
     * @returns {Object} Coordinates of the boundaries
     */
    function getBoundaries(popper, reference, padding, boundariesElement) {
        var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        // NOTE: 1 DOM access here

        var boundaries = {top: 0, left: 0};
        var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

        // Handle viewport case
        if (boundariesElement === 'viewport') {
            boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
        } else {
            // Handle other cases based on DOM element used as boundaries
            var boundariesNode = void 0;
            if (boundariesElement === 'scrollParent') {
                boundariesNode = getScrollParent(getParentNode(reference));
                if (boundariesNode.nodeName === 'BODY') {
                    boundariesNode = popper.ownerDocument.documentElement;
                }
            } else if (boundariesElement === 'window') {
                boundariesNode = popper.ownerDocument.documentElement;
            } else {
                boundariesNode = boundariesElement;
            }

            var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

            // In case of HTML, we need a different computation
            if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
                var _getWindowSizes = getWindowSizes(popper.ownerDocument),
                    height = _getWindowSizes.height,
                    width = _getWindowSizes.width;

                boundaries.top += offsets.top - offsets.marginTop;
                boundaries.bottom = height + offsets.top;
                boundaries.left += offsets.left - offsets.marginLeft;
                boundaries.right = width + offsets.left;
            } else {
                // for all the other DOM elements, this one is good
                boundaries = offsets;
            }
        }

        // Add paddings
        padding = padding || 0;
        var isPaddingNumber = typeof padding === 'number';
        boundaries.left += isPaddingNumber ? padding : padding.left || 0;
        boundaries.top += isPaddingNumber ? padding : padding.top || 0;
        boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
        boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

        return boundaries;
    }

    function getArea(_ref) {
        var width = _ref.width,
            height = _ref.height;

        return width * height;
    }

    /**
     * Utility used to transform the `auto` placement to the placement with more
     * available space.
     * @method
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
        var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

        if (placement.indexOf('auto') === -1) {
            return placement;
        }

        var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

        var rects = {
            top: {
                width: boundaries.width,
                height: refRect.top - boundaries.top
            },
            right: {
                width: boundaries.right - refRect.right,
                height: boundaries.height
            },
            bottom: {
                width: boundaries.width,
                height: boundaries.bottom - refRect.bottom
            },
            left: {
                width: refRect.left - boundaries.left,
                height: boundaries.height
            }
        };

        var sortedAreas = Object.keys(rects).map(function (key) {
            return _extends({
                key: key
            }, rects[key], {
                area: getArea(rects[key])
            });
        }).sort(function (a, b) {
            return b.area - a.area;
        });

        var filteredAreas = sortedAreas.filter(function (_ref2) {
            var width = _ref2.width,
                height = _ref2.height;
            return width >= popper.clientWidth && height >= popper.clientHeight;
        });

        var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

        var variation = placement.split('-')[1];

        return computedPlacement + (variation ? '-' + variation : '');
    }

    /**
     * Get offsets to the reference element
     * @method
     * @memberof Popper.Utils
     * @param {Object} state
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @param {Element} fixedPosition - is in fixed position mode
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    function getReferenceOffsets(state, popper, reference) {
        var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
        return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
    }

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
        var window = element.ownerDocument.defaultView;
        var styles = window.getComputedStyle(element);
        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
        var result = {
            width: element.offsetWidth + y,
            height: element.offsetHeight + x
        };
        return result;
    }

    /**
     * Get the opposite placement of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
        var hash = {left: 'right', right: 'left', bottom: 'top', top: 'bottom'};
        return placement.replace(/left|right|bottom|top/g, function (matched) {
            return hash[matched];
        });
    }

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper.Utils
     * @param {Object} position - CSS position the Popper will get applied
     * @param {HTMLElement} popper - the popper element
     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
     * @param {String} placement - one of the valid placement options
     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
        placement = placement.split('-')[0];

        // Get popper node sizes
        var popperRect = getOuterSizes(popper);

        // Add position, width and height to our offsets object
        var popperOffsets = {
            width: popperRect.width,
            height: popperRect.height
        };

        // depending by the popper placement we have to compute its offsets slightly differently
        var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
        var mainSide = isHoriz ? 'top' : 'left';
        var secondarySide = isHoriz ? 'left' : 'top';
        var measurement = isHoriz ? 'height' : 'width';
        var secondaryMeasurement = !isHoriz ? 'height' : 'width';

        popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
        if (placement === secondarySide) {
            popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
        } else {
            popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
        }

        return popperOffsets;
    }

    /**
     * Mimics the `find` method of Array
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function find(arr, check) {
        // use native find if supported
        if (Array.prototype.find) {
            return arr.find(check);
        }

        // use `filter` to obtain the same behavior of `find`
        return arr.filter(check)[0];
    }

    /**
     * Return the index of the matching object
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function findIndex(arr, prop, value) {
        // use native findIndex if supported
        if (Array.prototype.findIndex) {
            return arr.findIndex(function (cur) {
                return cur[prop] === value;
            });
        }

        // use `find` + `indexOf` if `findIndex` isn't supported
        var match = find(arr, function (obj) {
            return obj[prop] === value;
        });
        return arr.indexOf(match);
    }

    /**
     * Loop trough the list of modifiers and run them in order,
     * each of them will then edit the data object.
     * @method
     * @memberof Popper.Utils
     * @param {dataObject} data
     * @param {Array} modifiers
     * @param {String} ends - Optional modifier name used as stopper
     * @returns {dataObject}
     */
    function runModifiers(modifiers, data, ends) {
        var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

        modifiersToRun.forEach(function (modifier) {
            if (modifier['function']) {
                // eslint-disable-line dot-notation
                console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
            }
            var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
            if (modifier.enabled && isFunction(fn)) {
                // Add properties to offsets to make them a complete clientRect object
                // we do this before each modifier to make sure the previous one doesn't
                // mess with these values
                data.offsets.popper = getClientRect(data.offsets.popper);
                data.offsets.reference = getClientRect(data.offsets.reference);

                data = fn(data, modifier);
            }
        });

        return data;
    }

    /**
     * Updates the position of the popper, computing the new offsets and applying
     * the new style.<br />
     * Prefer `scheduleUpdate` over `update` because of performance reasons.
     * @method
     * @memberof Popper
     */
    function update() {
        // if popper is destroyed, don't perform any further update
        if (this.state.isDestroyed) {
            return;
        }

        var data = {
            instance: this,
            styles: {},
            arrowStyles: {},
            attributes: {},
            flipped: false,
            offsets: {}
        };

        // compute reference element offsets
        data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

        // compute auto placement, store placement inside the data object,
        // modifiers will be able to edit `placement` if needed
        // and refer to originalPlacement to know the original value
        data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

        // store the computed placement inside `originalPlacement`
        data.originalPlacement = data.placement;

        data.positionFixed = this.options.positionFixed;

        // compute the popper offsets
        data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

        data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

        // run the modifiers
        data = runModifiers(this.modifiers, data);

        // the first `update` will call `onCreate` callback
        // the other ones will call `onUpdate` callback
        if (!this.state.isCreated) {
            this.state.isCreated = true;
            this.options.onCreate(data);
        } else {
            this.options.onUpdate(data);
        }
    }

    /**
     * Helper used to know if the given modifier is enabled.
     * @method
     * @memberof Popper.Utils
     * @returns {Boolean}
     */
    function isModifierEnabled(modifiers, modifierName) {
        return modifiers.some(function (_ref) {
            var name = _ref.name,
                enabled = _ref.enabled;
            return enabled && name === modifierName;
        });
    }

    /**
     * Get the prefixed supported property name
     * @method
     * @memberof Popper.Utils
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
     */
    function getSupportedPropertyName(property) {
        var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
        var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

        for (var i = 0; i < prefixes.length; i++) {
            var prefix = prefixes[i];
            var toCheck = prefix ? '' + prefix + upperProp : property;
            if (typeof document.body.style[toCheck] !== 'undefined') {
                return toCheck;
            }
        }
        return null;
    }

    /**
     * Destroys the popper.
     * @method
     * @memberof Popper
     */
    function destroy() {
        this.state.isDestroyed = true;

        // touch DOM only if `applyStyle` modifier is enabled
        if (isModifierEnabled(this.modifiers, 'applyStyle')) {
            this.popper.removeAttribute('x-placement');
            this.popper.style.position = '';
            this.popper.style.top = '';
            this.popper.style.left = '';
            this.popper.style.right = '';
            this.popper.style.bottom = '';
            this.popper.style.willChange = '';
            this.popper.style[getSupportedPropertyName('transform')] = '';
        }

        this.disableEventListeners();

        // remove the popper if user explicity asked for the deletion on destroy
        // do not use `remove` because IE11 doesn't support it
        if (this.options.removeOnDestroy) {
            this.popper.parentNode.removeChild(this.popper);
        }
        return this;
    }

    /**
     * Get the window associated with the element
     * @argument {Element} element
     * @returns {Window}
     */
    function getWindow(element) {
        var ownerDocument = element.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView : window;
    }

    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
        var isBody = scrollParent.nodeName === 'BODY';
        var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
        target.addEventListener(event, callback, {passive: true});

        if (!isBody) {
            attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
        }
        scrollParents.push(target);
    }

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function setupEventListeners(reference, options, state, updateBound) {
        // Resize event listener on window
        state.updateBound = updateBound;
        getWindow(reference).addEventListener('resize', state.updateBound, {passive: true});

        // Scroll event listener on scroll parents
        var scrollElement = getScrollParent(reference);
        attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
        state.scrollElement = scrollElement;
        state.eventsEnabled = true;

        return state;
    }

    /**
     * It will add resize/scroll events and start recalculating
     * position of the popper element when they are triggered.
     * @method
     * @memberof Popper
     */
    function enableEventListeners() {
        if (!this.state.eventsEnabled) {
            this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
        }
    }

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function removeEventListeners(reference, state) {
        // Remove resize event listener on window
        getWindow(reference).removeEventListener('resize', state.updateBound);

        // Remove scroll event listener on scroll parents
        state.scrollParents.forEach(function (target) {
            target.removeEventListener('scroll', state.updateBound);
        });

        // Reset state
        state.updateBound = null;
        state.scrollParents = [];
        state.scrollElement = null;
        state.eventsEnabled = false;
        return state;
    }

    /**
     * It will remove resize/scroll events and won't recalculate popper position
     * when they are triggered. It also won't trigger `onUpdate` callback anymore,
     * unless you call `update` method manually.
     * @method
     * @memberof Popper
     */
    function disableEventListeners() {
        if (this.state.eventsEnabled) {
            cancelAnimationFrame(this.scheduleUpdate);
            this.state = removeEventListeners(this.reference, this.state);
        }
    }

    /**
     * Tells if a given input is a number
     * @method
     * @memberof Popper.Utils
     * @param {*} input to check
     * @return {Boolean}
     */
    function isNumeric(n) {
        return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Set the style to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setStyles(element, styles) {
        Object.keys(styles).forEach(function (prop) {
            var unit = '';
            // add unit if the value is numeric and is one of the following
            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
                unit = 'px';
            }
            element.style[prop] = styles[prop] + unit;
        });
    }

    /**
     * Set the attributes to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the attributes to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setAttributes(element, attributes) {
        Object.keys(attributes).forEach(function (prop) {
            var value = attributes[prop];
            if (value !== false) {
                element.setAttribute(prop, attributes[prop]);
            } else {
                element.removeAttribute(prop);
            }
        });
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} data.styles - List of style properties - values to apply to popper element
     * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The same data object
     */
    function applyStyle(data) {
        // any property present in `data.styles` will be applied to the popper,
        // in this way we can make the 3rd party modifiers add custom styles to it
        // Be aware, modifiers could override the properties defined in the previous
        // lines of this modifier!
        setStyles(data.instance.popper, data.styles);

        // any property present in `data.attributes` will be applied to the popper,
        // they will be set as HTML attributes of the element
        setAttributes(data.instance.popper, data.attributes);

        // if arrowElement is defined and arrowStyles has some properties
        if (data.arrowElement && Object.keys(data.arrowStyles).length) {
            setStyles(data.arrowElement, data.arrowStyles);
        }

        return data;
    }

    /**
     * Set the x-placement attribute before everything else because it could be used
     * to add margins to the popper margins needs to be calculated to get the
     * correct popper offsets.
     * @method
     * @memberof Popper.modifiers
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper
     * @param {Object} options - Popper.js options
     */
    function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
        // compute reference element offsets
        var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

        // compute auto placement, store placement inside the data object,
        // modifiers will be able to edit `placement` if needed
        // and refer to originalPlacement to know the original value
        var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

        popper.setAttribute('x-placement', placement);

        // Apply `position` to popper before anything else because
        // without the position applied we can't guarantee correct computations
        setStyles(popper, {position: options.positionFixed ? 'fixed' : 'absolute'});

        return options;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeStyle(data, options) {
        var x = options.x,
            y = options.y;
        var popper = data.offsets.popper;

        // Remove this legacy support in Popper.js v2

        var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
            return modifier.name === 'applyStyle';
        }).gpuAcceleration;
        if (legacyGpuAccelerationOption !== undefined) {
            console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
        }
        var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

        var offsetParent = getOffsetParent(data.instance.popper);
        var offsetParentRect = getBoundingClientRect(offsetParent);

        // Styles
        var styles = {
            position: popper.position
        };

        // Avoid blurry text by using full pixel integers.
        // For pixel-perfect positioning, top/bottom prefers rounded
        // values, while left/right prefers floored values.
        var offsets = {
            left: Math.floor(popper.left),
            top: Math.round(popper.top),
            bottom: Math.round(popper.bottom),
            right: Math.floor(popper.right)
        };

        var sideA = x === 'bottom' ? 'top' : 'bottom';
        var sideB = y === 'right' ? 'left' : 'right';

        // if gpuAcceleration is set to `true` and transform is supported,
        //  we use `translate3d` to apply the position to the popper we
        // automatically use the supported prefixed version if needed
        var prefixedProperty = getSupportedPropertyName('transform');

        // now, let's make a step back and look at this code closely (wtf?)
        // If the content of the popper grows once it's been positioned, it
        // may happen that the popper gets misplaced because of the new content
        // overflowing its reference element
        // To avoid this problem, we provide two options (x and y), which allow
        // the consumer to define the offset origin.
        // If we position a popper on top of a reference element, we can set
        // `x` to `top` to make the popper grow towards its top instead of
        // its bottom.
        var left = void 0,
            top = void 0;
        if (sideA === 'bottom') {
            // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
            // and not the bottom of the html element
            if (offsetParent.nodeName === 'HTML') {
                top = -offsetParent.clientHeight + offsets.bottom;
            } else {
                top = -offsetParentRect.height + offsets.bottom;
            }
        } else {
            top = offsets.top;
        }
        if (sideB === 'right') {
            if (offsetParent.nodeName === 'HTML') {
                left = -offsetParent.clientWidth + offsets.right;
            } else {
                left = -offsetParentRect.width + offsets.right;
            }
        } else {
            left = offsets.left;
        }
        if (gpuAcceleration && prefixedProperty) {
            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
            styles[sideA] = 0;
            styles[sideB] = 0;
            styles.willChange = 'transform';
        } else {
            // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
            var invertTop = sideA === 'bottom' ? -1 : 1;
            var invertLeft = sideB === 'right' ? -1 : 1;
            styles[sideA] = top * invertTop;
            styles[sideB] = left * invertLeft;
            styles.willChange = sideA + ', ' + sideB;
        }

        // Attributes
        var attributes = {
            'x-placement': data.placement
        };

        // Update `data` attributes, styles and arrowStyles
        data.attributes = _extends({}, attributes, data.attributes);
        data.styles = _extends({}, styles, data.styles);
        data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

        return data;
    }

    /**
     * Helper used to know if the given modifier depends from another one.<br />
     * It checks if the needed modifier is listed and enabled.
     * @method
     * @memberof Popper.Utils
     * @param {Array} modifiers - list of modifiers
     * @param {String} requestingName - name of requesting modifier
     * @param {String} requestedName - name of requested modifier
     * @returns {Boolean}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
        var requesting = find(modifiers, function (_ref) {
            var name = _ref.name;
            return name === requestingName;
        });

        var isRequired = !!requesting && modifiers.some(function (modifier) {
            return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
        });

        if (!isRequired) {
            var _requesting = '`' + requestingName + '`';
            var requested = '`' + requestedName + '`';
            console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
        }
        return isRequired;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function arrow(data, options) {
        var _data$offsets$arrow;

        // arrow depends on keepTogether in order to work
        if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
            return data;
        }

        var arrowElement = options.element;

        // if arrowElement is a string, suppose it's a CSS selector
        if (typeof arrowElement === 'string') {
            arrowElement = data.instance.popper.querySelector(arrowElement);

            // if arrowElement is not found, don't run the modifier
            if (!arrowElement) {
                return data;
            }
        } else {
            // if the arrowElement isn't a query selector we must check that the
            // provided DOM node is child of its popper node
            if (!data.instance.popper.contains(arrowElement)) {
                console.warn('WARNING: `arrow.element` must be child of its popper element!');
                return data;
            }
        }

        var placement = data.placement.split('-')[0];
        var _data$offsets = data.offsets,
            popper = _data$offsets.popper,
            reference = _data$offsets.reference;

        var isVertical = ['left', 'right'].indexOf(placement) !== -1;

        var len = isVertical ? 'height' : 'width';
        var sideCapitalized = isVertical ? 'Top' : 'Left';
        var side = sideCapitalized.toLowerCase();
        var altSide = isVertical ? 'left' : 'top';
        var opSide = isVertical ? 'bottom' : 'right';
        var arrowElementSize = getOuterSizes(arrowElement)[len];

        //
        // extends keepTogether behavior making sure the popper and its
        // reference have enough pixels in conjunction
        //

        // top/left side
        if (reference[opSide] - arrowElementSize < popper[side]) {
            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
        }
        // bottom/right side
        if (reference[side] + arrowElementSize > popper[opSide]) {
            data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
        }
        data.offsets.popper = getClientRect(data.offsets.popper);

        // compute center of the popper
        var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

        // Compute the sideValue using the updated popper offsets
        // take popper margin in account because we don't have this info available
        var css = getStyleComputedProperty(data.instance.popper);
        var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
        var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
        var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

        // prevent arrowElement from being placed not contiguously to its popper
        sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

        data.arrowElement = arrowElement;
        data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

        return data;
    }

    /**
     * Get the opposite placement variation of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement variation
     * @returns {String} flipped placement variation
     */
    function getOppositeVariation(variation) {
        if (variation === 'end') {
            return 'start';
        } else if (variation === 'start') {
            return 'end';
        }
        return variation;
    }

    /**
     * List of accepted placements to use as values of the `placement` option.<br />
     * Valid placements are:
     * - `auto`
     * - `top`
     * - `right`
     * - `bottom`
     * - `left`
     *
     * Each placement can have a variation from this list:
     * - `-start`
     * - `-end`
     *
     * Variations are interpreted easily if you think of them as the left to right
     * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
     * is right.<br />
     * Vertically (`left` and `right`), `start` is top and `end` is bottom.
     *
     * Some valid examples are:
     * - `top-end` (on top of reference, right aligned)
     * - `right-start` (on right of reference, top aligned)
     * - `bottom` (on bottom, centered)
     * - `auto-end` (on the side with more space available, alignment depends by placement)
     *
     * @static
     * @type {Array}
     * @enum {String}
     * @readonly
     * @method placements
     * @memberof Popper
     */
    var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
    var validPlacements = placements.slice(3);

    /**
     * Given an initial placement, returns all the subsequent placements
     * clockwise (or counter-clockwise).
     *
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement - A valid placement (it accepts variations)
     * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
     * @returns {Array} placements including their variations
     */
    function clockwise(placement) {
        var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var index = validPlacements.indexOf(placement);
        var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
        return counter ? arr.reverse() : arr;
    }

    var BEHAVIORS = {
        FLIP: 'flip',
        CLOCKWISE: 'clockwise',
        COUNTERCLOCKWISE: 'counterclockwise'
    };

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function flip(data, options) {
        // if `inner` modifier is enabled, we can't use the `flip` modifier
        if (isModifierEnabled(data.instance.modifiers, 'inner')) {
            return data;
        }

        if (data.flipped && data.placement === data.originalPlacement) {
            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
            return data;
        }

        var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

        var placement = data.placement.split('-')[0];
        var placementOpposite = getOppositePlacement(placement);
        var variation = data.placement.split('-')[1] || '';

        var flipOrder = [];

        switch (options.behavior) {
            case BEHAVIORS.FLIP:
                flipOrder = [placement, placementOpposite];
                break;
            case BEHAVIORS.CLOCKWISE:
                flipOrder = clockwise(placement);
                break;
            case BEHAVIORS.COUNTERCLOCKWISE:
                flipOrder = clockwise(placement, true);
                break;
            default:
                flipOrder = options.behavior;
        }

        flipOrder.forEach(function (step, index) {
            if (placement !== step || flipOrder.length === index + 1) {
                return data;
            }

            placement = data.placement.split('-')[0];
            placementOpposite = getOppositePlacement(placement);

            var popperOffsets = data.offsets.popper;
            var refOffsets = data.offsets.reference;

            // using floor because the reference offsets may contain decimals we are not going to consider here
            var floor = Math.floor;
            var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

            var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
            var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
            var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
            var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

            var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

            // flip the variation if required
            var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
            var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

            if (overlapsRef || overflowsBoundaries || flippedVariation) {
                // this boolean to detect any flip loop
                data.flipped = true;

                if (overlapsRef || overflowsBoundaries) {
                    placement = flipOrder[index + 1];
                }

                if (flippedVariation) {
                    variation = getOppositeVariation(variation);
                }

                data.placement = placement + (variation ? '-' + variation : '');

                // this object contains `position`, we want to preserve it along with
                // any additional property we may add in the future
                data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

                data = runModifiers(data.instance.modifiers, data, 'flip');
            }
        });
        return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function keepTogether(data) {
        var _data$offsets = data.offsets,
            popper = _data$offsets.popper,
            reference = _data$offsets.reference;

        var placement = data.placement.split('-')[0];
        var floor = Math.floor;
        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
        var side = isVertical ? 'right' : 'bottom';
        var opSide = isVertical ? 'left' : 'top';
        var measurement = isVertical ? 'width' : 'height';

        if (popper[side] < floor(reference[opSide])) {
            data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
        }
        if (popper[opSide] > floor(reference[side])) {
            data.offsets.popper[opSide] = floor(reference[side]);
        }

        return data;
    }

    /**
     * Converts a string containing value + unit into a px value number
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} str - Value + unit string
     * @argument {String} measurement - `height` or `width`
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @returns {Number|String}
     * Value in pixels, or original string if no values were extracted
     */
    function toValue(str, measurement, popperOffsets, referenceOffsets) {
        // separate value from unit
        var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
        var value = +split[1];
        var unit = split[2];

        // If it's not a number it's an operator, I guess
        if (!value) {
            return str;
        }

        if (unit.indexOf('%') === 0) {
            var element = void 0;
            switch (unit) {
                case '%p':
                    element = popperOffsets;
                    break;
                case '%':
                case '%r':
                default:
                    element = referenceOffsets;
            }

            var rect = getClientRect(element);
            return rect[measurement] / 100 * value;
        } else if (unit === 'vh' || unit === 'vw') {
            // if is a vh or vw, we calculate the size based on the viewport
            var size = void 0;
            if (unit === 'vh') {
                size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
            } else {
                size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
            }
            return size / 100 * value;
        } else {
            // if is an explicit pixel unit, we get rid of the unit and keep the value
            // if is an implicit unit, it's px, and we return just the value
            return value;
        }
    }

    /**
     * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} offset
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @argument {String} basePlacement
     * @returns {Array} a two cells array with x and y offsets in numbers
     */
    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
        var offsets = [0, 0];

        // Use height if placement is left or right and index is 0 otherwise use width
        // in this way the first offset will use an axis and the second one
        // will use the other one
        var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

        // Split the offset string to obtain a list of values and operands
        // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
        var fragments = offset.split(/(\+|\-)/).map(function (frag) {
            return frag.trim();
        });

        // Detect if the offset string contains a pair of values or a single one
        // they could be separated by comma or space
        var divider = fragments.indexOf(find(fragments, function (frag) {
            return frag.search(/,|\s/) !== -1;
        }));

        if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
            console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
        }

        // If divider is found, we divide the list of values and operands to divide
        // them by ofset X and Y.
        var splitRegex = /\s*,\s*|\s+/;
        var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

        // Convert the values with units to absolute pixels to allow our computations
        ops = ops.map(function (op, index) {
            // Most of the units rely on the orientation of the popper
            var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
            var mergeWithPrevious = false;
            return op
            // This aggregates any `+` or `-` sign that aren't considered operators
            // e.g.: 10 + +5 => [10, +, +5]
                .reduce(function (a, b) {
                    if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
                        a[a.length - 1] = b;
                        mergeWithPrevious = true;
                        return a;
                    } else if (mergeWithPrevious) {
                        a[a.length - 1] += b;
                        mergeWithPrevious = false;
                        return a;
                    } else {
                        return a.concat(b);
                    }
                }, [])
                // Here we convert the string values into number values (in px)
                .map(function (str) {
                    return toValue(str, measurement, popperOffsets, referenceOffsets);
                });
        });

        // Loop trough the offsets arrays and execute the operations
        ops.forEach(function (op, index) {
            op.forEach(function (frag, index2) {
                if (isNumeric(frag)) {
                    offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
                }
            });
        });
        return offsets;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @argument {Number|String} options.offset=0
     * The offset value as described in the modifier description
     * @returns {Object} The data object, properly modified
     */
    function offset(data, _ref) {
        var offset = _ref.offset;
        var placement = data.placement,
            _data$offsets = data.offsets,
            popper = _data$offsets.popper,
            reference = _data$offsets.reference;

        var basePlacement = placement.split('-')[0];

        var offsets = void 0;
        if (isNumeric(+offset)) {
            offsets = [+offset, 0];
        } else {
            offsets = parseOffset(offset, popper, reference, basePlacement);
        }

        if (basePlacement === 'left') {
            popper.top += offsets[0];
            popper.left -= offsets[1];
        } else if (basePlacement === 'right') {
            popper.top += offsets[0];
            popper.left += offsets[1];
        } else if (basePlacement === 'top') {
            popper.left += offsets[0];
            popper.top -= offsets[1];
        } else if (basePlacement === 'bottom') {
            popper.left += offsets[0];
            popper.top += offsets[1];
        }

        data.popper = popper;
        return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function preventOverflow(data, options) {
        var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

        // If offsetParent is the reference element, we really want to
        // go one step up and use the next offsetParent as reference to
        // avoid to make this modifier completely useless and look like broken
        if (data.instance.reference === boundariesElement) {
            boundariesElement = getOffsetParent(boundariesElement);
        }

        // NOTE: DOM access here
        // resets the popper's position so that the document size can be calculated excluding
        // the size of the popper element itself
        var transformProp = getSupportedPropertyName('transform');
        var popperStyles = data.instance.popper.style; // assignment to help minification
        var top = popperStyles.top,
            left = popperStyles.left,
            transform = popperStyles[transformProp];

        popperStyles.top = '';
        popperStyles.left = '';
        popperStyles[transformProp] = '';

        var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

        // NOTE: DOM access here
        // restores the original style properties after the offsets have been computed
        popperStyles.top = top;
        popperStyles.left = left;
        popperStyles[transformProp] = transform;

        options.boundaries = boundaries;

        var order = options.priority;
        var popper = data.offsets.popper;

        var check = {
            primary: function primary(placement) {
                var value = popper[placement];
                if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
                    value = Math.max(popper[placement], boundaries[placement]);
                }
                return defineProperty({}, placement, value);
            },
            secondary: function secondary(placement) {
                var mainSide = placement === 'right' ? 'left' : 'top';
                var value = popper[mainSide];
                if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
                    value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
                }
                return defineProperty({}, mainSide, value);
            }
        };

        order.forEach(function (placement) {
            var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
            popper = _extends({}, popper, check[side](placement));
        });

        data.offsets.popper = popper;

        return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function shift(data) {
        var placement = data.placement;
        var basePlacement = placement.split('-')[0];
        var shiftvariation = placement.split('-')[1];

        // if shift shiftvariation is specified, run the modifier
        if (shiftvariation) {
            var _data$offsets = data.offsets,
                reference = _data$offsets.reference,
                popper = _data$offsets.popper;

            var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
            var side = isVertical ? 'left' : 'top';
            var measurement = isVertical ? 'width' : 'height';

            var shiftOffsets = {
                start: defineProperty({}, side, reference[side]),
                end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
            };

            data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
        }

        return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function hide(data) {
        if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
            return data;
        }

        var refRect = data.offsets.reference;
        var bound = find(data.instance.modifiers, function (modifier) {
            return modifier.name === 'preventOverflow';
        }).boundaries;

        if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
            // Avoid unnecessary DOM access if visibility hasn't changed
            if (data.hide === true) {
                return data;
            }

            data.hide = true;
            data.attributes['x-out-of-boundaries'] = '';
        } else {
            // Avoid unnecessary DOM access if visibility hasn't changed
            if (data.hide === false) {
                return data;
            }

            data.hide = false;
            data.attributes['x-out-of-boundaries'] = false;
        }

        return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function inner(data) {
        var placement = data.placement;
        var basePlacement = placement.split('-')[0];
        var _data$offsets = data.offsets,
            popper = _data$offsets.popper,
            reference = _data$offsets.reference;

        var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

        var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

        popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

        data.placement = getOppositePlacement(placement);
        data.offsets.popper = getClientRect(popper);

        return data;
    }

    /**
     * Modifier function, each modifier can have a function of this type assigned
     * to its `fn` property.<br />
     * These functions will be called on each update, this means that you must
     * make sure they are performant enough to avoid performance bottlenecks.
     *
     * @function ModifierFn
     * @argument {dataObject} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {dataObject} The data object, properly modified
     */

    /**
     * Modifiers are plugins used to alter the behavior of your poppers.<br />
     * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
     * needed by the library.
     *
     * Usually you don't want to override the `order`, `fn` and `onLoad` props.
     * All the other properties are configurations that could be tweaked.
     * @namespace modifiers
     */
    var modifiers = {
        /**
         * Modifier used to shift the popper on the start or end of its reference
         * element.<br />
         * It will read the variation of the `placement` property.<br />
         * It can be one either `-end` or `-start`.
         * @memberof modifiers
         * @inner
         */
        shift: {
            /** @prop {number} order=100 - Index used to define the order of execution */
            order: 100,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: shift
        },

        /**
         * The `offset` modifier can shift your popper on both its axis.
         *
         * It accepts the following units:
         * - `px` or unit-less, interpreted as pixels
         * - `%` or `%r`, percentage relative to the length of the reference element
         * - `%p`, percentage relative to the length of the popper element
         * - `vw`, CSS viewport width unit
         * - `vh`, CSS viewport height unit
         *
         * For length is intended the main axis relative to the placement of the popper.<br />
         * This means that if the placement is `top` or `bottom`, the length will be the
         * `width`. In case of `left` or `right`, it will be the `height`.
         *
         * You can provide a single value (as `Number` or `String`), or a pair of values
         * as `String` divided by a comma or one (or more) white spaces.<br />
         * The latter is a deprecated method because it leads to confusion and will be
         * removed in v2.<br />
         * Additionally, it accepts additions and subtractions between different units.
         * Note that multiplications and divisions aren't supported.
         *
         * Valid examples are:
         * ```
         * 10
         * '10%'
         * '10, 10'
         * '10%, 10'
         * '10 + 10%'
         * '10 - 5vh + 3%'
         * '-10px + 5vh, 5px - 6%'
         * ```
         * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
         * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
         * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
         *
         * @memberof modifiers
         * @inner
         */
        offset: {
            /** @prop {number} order=200 - Index used to define the order of execution */
            order: 200,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: offset,
            /** @prop {Number|String} offset=0
             * The offset value as described in the modifier description
             */
            offset: 0
        },

        /**
         * Modifier used to prevent the popper from being positioned outside the boundary.
         *
         * A scenario exists where the reference itself is not within the boundaries.<br />
         * We can say it has "escaped the boundaries" — or just "escaped".<br />
         * In this case we need to decide whether the popper should either:
         *
         * - detach from the reference and remain "trapped" in the boundaries, or
         * - if it should ignore the boundary and "escape with its reference"
         *
         * When `escapeWithReference` is set to`true` and reference is completely
         * outside its boundaries, the popper will overflow (or completely leave)
         * the boundaries in order to remain attached to the edge of the reference.
         *
         * @memberof modifiers
         * @inner
         */
        preventOverflow: {
            /** @prop {number} order=300 - Index used to define the order of execution */
            order: 300,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: preventOverflow,
            /**
             * @prop {Array} [priority=['left','right','top','bottom']]
             * Popper will try to prevent overflow following these priorities by default,
             * then, it could overflow on the left and on top of the `boundariesElement`
             */
            priority: ['left', 'right', 'top', 'bottom'],
            /**
             * @prop {number} padding=5
             * Amount of pixel used to define a minimum distance between the boundaries
             * and the popper. This makes sure the popper always has a little padding
             * between the edges of its container
             */
            padding: 5,
            /**
             * @prop {String|HTMLElement} boundariesElement='scrollParent'
             * Boundaries used by the modifier. Can be `scrollParent`, `window`,
             * `viewport` or any DOM element.
             */
            boundariesElement: 'scrollParent'
        },

        /**
         * Modifier used to make sure the reference and its popper stay near each other
         * without leaving any gap between the two. Especially useful when the arrow is
         * enabled and you want to ensure that it points to its reference element.
         * It cares only about the first axis. You can still have poppers with margin
         * between the popper and its reference element.
         * @memberof modifiers
         * @inner
         */
        keepTogether: {
            /** @prop {number} order=400 - Index used to define the order of execution */
            order: 400,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: keepTogether
        },

        /**
         * This modifier is used to move the `arrowElement` of the popper to make
         * sure it is positioned between the reference element and its popper element.
         * It will read the outer size of the `arrowElement` node to detect how many
         * pixels of conjunction are needed.
         *
         * It has no effect if no `arrowElement` is provided.
         * @memberof modifiers
         * @inner
         */
        arrow: {
            /** @prop {number} order=500 - Index used to define the order of execution */
            order: 500,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: arrow,
            /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
            element: '[x-arrow]'
        },

        /**
         * Modifier used to flip the popper's placement when it starts to overlap its
         * reference element.
         *
         * Requires the `preventOverflow` modifier before it in order to work.
         *
         * **NOTE:** this modifier will interrupt the current update cycle and will
         * restart it if it detects the need to flip the placement.
         * @memberof modifiers
         * @inner
         */
        flip: {
            /** @prop {number} order=600 - Index used to define the order of execution */
            order: 600,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: flip,
            /**
             * @prop {String|Array} behavior='flip'
             * The behavior used to change the popper's placement. It can be one of
             * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
             * placements (with optional variations)
             */
            behavior: 'flip',
            /**
             * @prop {number} padding=5
             * The popper will flip if it hits the edges of the `boundariesElement`
             */
            padding: 5,
            /**
             * @prop {String|HTMLElement} boundariesElement='viewport'
             * The element which will define the boundaries of the popper position.
             * The popper will never be placed outside of the defined boundaries
             * (except if `keepTogether` is enabled)
             */
            boundariesElement: 'viewport'
        },

        /**
         * Modifier used to make the popper flow toward the inner of the reference element.
         * By default, when this modifier is disabled, the popper will be placed outside
         * the reference element.
         * @memberof modifiers
         * @inner
         */
        inner: {
            /** @prop {number} order=700 - Index used to define the order of execution */
            order: 700,
            /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
            enabled: false,
            /** @prop {ModifierFn} */
            fn: inner
        },

        /**
         * Modifier used to hide the popper when its reference element is outside of the
         * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
         * be used to hide with a CSS selector the popper when its reference is
         * out of boundaries.
         *
         * Requires the `preventOverflow` modifier before it in order to work.
         * @memberof modifiers
         * @inner
         */
        hide: {
            /** @prop {number} order=800 - Index used to define the order of execution */
            order: 800,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: hide
        },

        /**
         * Computes the style that will be applied to the popper element to gets
         * properly positioned.
         *
         * Note that this modifier will not touch the DOM, it just prepares the styles
         * so that `applyStyle` modifier can apply it. This separation is useful
         * in case you need to replace `applyStyle` with a custom implementation.
         *
         * This modifier has `850` as `order` value to maintain backward compatibility
         * with previous versions of Popper.js. Expect the modifiers ordering method
         * to change in future major versions of the library.
         *
         * @memberof modifiers
         * @inner
         */
        computeStyle: {
            /** @prop {number} order=850 - Index used to define the order of execution */
            order: 850,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: computeStyle,
            /**
             * @prop {Boolean} gpuAcceleration=true
             * If true, it uses the CSS 3D transformation to position the popper.
             * Otherwise, it will use the `top` and `left` properties
             */
            gpuAcceleration: true,
            /**
             * @prop {string} [x='bottom']
             * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
             * Change this if your popper should grow in a direction different from `bottom`
             */
            x: 'bottom',
            /**
             * @prop {string} [x='left']
             * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
             * Change this if your popper should grow in a direction different from `right`
             */
            y: 'right'
        },

        /**
         * Applies the computed styles to the popper element.
         *
         * All the DOM manipulations are limited to this modifier. This is useful in case
         * you want to integrate Popper.js inside a framework or view library and you
         * want to delegate all the DOM manipulations to it.
         *
         * Note that if you disable this modifier, you must make sure the popper element
         * has its position set to `absolute` before Popper.js can do its work!
         *
         * Just disable this modifier and define your own to achieve the desired effect.
         *
         * @memberof modifiers
         * @inner
         */
        applyStyle: {
            /** @prop {number} order=900 - Index used to define the order of execution */
            order: 900,
            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
            enabled: true,
            /** @prop {ModifierFn} */
            fn: applyStyle,
            /** @prop {Function} */
            onLoad: applyStyleOnLoad,
            /**
             * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
             * @prop {Boolean} gpuAcceleration=true
             * If true, it uses the CSS 3D transformation to position the popper.
             * Otherwise, it will use the `top` and `left` properties
             */
            gpuAcceleration: undefined
        }
    };

    /**
     * The `dataObject` is an object containing all the information used by Popper.js.
     * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
     * @name dataObject
     * @property {Object} data.instance The Popper.js instance
     * @property {String} data.placement Placement applied to popper
     * @property {String} data.originalPlacement Placement originally defined on init
     * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
     * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
     * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
     * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.boundaries Offsets of the popper boundaries
     * @property {Object} data.offsets The measurements of popper, reference and arrow elements
     * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
     */

    /**
     * Default options provided to Popper.js constructor.<br />
     * These can be overridden using the `options` argument of Popper.js.<br />
     * To override an option, simply pass an object with the same
     * structure of the `options` object, as the 3rd argument. For example:
     * ```
     * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
     * ```
     * @type {Object}
     * @static
     * @memberof Popper
     */
    var Defaults = {
        /**
         * Popper's placement.
         * @prop {Popper.placements} placement='bottom'
         */
        placement: 'bottom',

        /**
         * Set this to true if you want popper to position it self in 'fixed' mode
         * @prop {Boolean} positionFixed=false
         */
        positionFixed: false,

        /**
         * Whether events (resize, scroll) are initially enabled.
         * @prop {Boolean} eventsEnabled=true
         */
        eventsEnabled: true,

        /**
         * Set to true if you want to automatically remove the popper when
         * you call the `destroy` method.
         * @prop {Boolean} removeOnDestroy=false
         */
        removeOnDestroy: false,

        /**
         * Callback called when the popper is created.<br />
         * By default, it is set to no-op.<br />
         * Access Popper.js instance with `data.instance`.
         * @prop {onCreate}
         */
        onCreate: function onCreate() {
        },

        /**
         * Callback called when the popper is updated. This callback is not called
         * on the initialization/creation of the popper, but only on subsequent
         * updates.<br />
         * By default, it is set to no-op.<br />
         * Access Popper.js instance with `data.instance`.
         * @prop {onUpdate}
         */
        onUpdate: function onUpdate() {
        },

        /**
         * List of modifiers used to modify the offsets before they are applied to the popper.
         * They provide most of the functionalities of Popper.js.
         * @prop {modifiers}
         */
        modifiers: modifiers
    };

    /**
     * @callback onCreate
     * @param {dataObject} data
     */

    /**
     * @callback onUpdate
     * @param {dataObject} data
     */

// Utils
// Methods
    var Popper = function () {
        /**
         * Creates a new Popper.js instance.
         * @class Popper
         * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
         * @param {HTMLElement} popper - The HTML element used as the popper
         * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
         * @return {Object} instance - The generated Popper.js instance
         */
        function Popper(reference, popper) {
            var _this = this;

            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            classCallCheck(this, Popper);

            this.scheduleUpdate = function () {
                return requestAnimationFrame(_this.update);
            };

            // make update() debounced, so that it only runs at most once-per-tick
            this.update = debounce(this.update.bind(this));

            // with {} we create a new object with the options inside it
            this.options = _extends({}, Popper.Defaults, options);

            // init state
            this.state = {
                isDestroyed: false,
                isCreated: false,
                scrollParents: []
            };

            // get reference and popper elements (allow jQuery wrappers)
            this.reference = reference && reference.jquery ? reference[0] : reference;
            this.popper = popper && popper.jquery ? popper[0] : popper;

            // Deep merge modifiers options
            this.options.modifiers = {};
            Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
                _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
            });

            // Refactoring modifiers' list (Object => Array)
            this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
                return _extends({
                    name: name
                }, _this.options.modifiers[name]);
            })
            // sort the modifiers by order
                .sort(function (a, b) {
                    return a.order - b.order;
                });

            // modifiers have the ability to execute arbitrary code when Popper.js get inited
            // such code is executed in the same order of its modifier
            // they could add new properties to their options configuration
            // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
            this.modifiers.forEach(function (modifierOptions) {
                if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
                    modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
                }
            });

            // fire the first update to position the popper in the right place
            this.update();

            var eventsEnabled = this.options.eventsEnabled;
            if (eventsEnabled) {
                // setup event listeners, they will take care of update the position in specific situations
                this.enableEventListeners();
            }

            this.state.eventsEnabled = eventsEnabled;
        }

        // We can't use class properties because they don't get listed in the
        // class prototype and break stuff like Sinon stubs


        createClass(Popper, [{
            key: 'update',
            value: function update$$1() {
                return update.call(this);
            }
        }, {
            key: 'destroy',
            value: function destroy$$1() {
                return destroy.call(this);
            }
        }, {
            key: 'enableEventListeners',
            value: function enableEventListeners$$1() {
                return enableEventListeners.call(this);
            }
        }, {
            key: 'disableEventListeners',
            value: function disableEventListeners$$1() {
                return disableEventListeners.call(this);
            }

            /**
             * Schedules an update. It will run on the next UI update available.
             * @method scheduleUpdate
             * @memberof Popper
             */


            /**
             * Collection of utilities useful when writing custom modifiers.
             * Starting from version 1.7, this method is available only if you
             * include `popper-utils.js` before `popper.js`.
             *
             * **DEPRECATION**: This way to access PopperUtils is deprecated
             * and will be removed in v2! Use the PopperUtils module directly instead.
             * Due to the high instability of the methods contained in Utils, we can't
             * guarantee them to follow semver. Use them at your own risk!
             * @static
             * @private
             * @type {Object}
             * @deprecated since version 1.8
             * @member Utils
             * @memberof Popper
             */

        }]);
        return Popper;
    }();

    /**
     * The `referenceObject` is an object that provides an interface compatible with Popper.js
     * and lets you use it as replacement of a real DOM node.<br />
     * You can use this method to position a popper relatively to a set of coordinates
     * in case you don't have a DOM node to use as reference.
     *
     * ```
     * new Popper(referenceObject, popperNode);
     * ```
     *
     * NB: This feature isn't supported in Internet Explorer 10.
     * @name referenceObject
     * @property {Function} data.getBoundingClientRect
     * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
     * @property {number} data.clientWidth
     * An ES6 getter that will return the width of the virtual reference element.
     * @property {number} data.clientHeight
     * An ES6 getter that will return the height of the virtual reference element.
     */


    Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
    Popper.placements = placements;
    Popper.Defaults = Defaults;

    return Popper;

})));

/*!
  * Bootstrap v4.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports, require("jquery"), require("popper.js")) : "function" == typeof define && define.amd ? define(["exports", "jquery", "popper.js"], e) : e(t.bootstrap = {}, t.jQuery, t.Popper)
}(this, function (t, e, h) {
    "use strict";

    function i(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function s(t, e, n) {
        return e && i(t.prototype, e), n && i(t, n), t
    }

    function l(r) {
        for (var t = 1; t < arguments.length; t++) {
            var o = null != arguments[t] ? arguments[t] : {}, e = Object.keys(o);
            "function" == typeof Object.getOwnPropertySymbols && (e = e.concat(Object.getOwnPropertySymbols(o).filter(function (t) {
                return Object.getOwnPropertyDescriptor(o, t).enumerable
            }))), e.forEach(function (t) {
                var e, n, i;
                e = r, i = o[n = t], n in e ? Object.defineProperty(e, n, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[n] = i
            })
        }
        return r
    }

    e = e && e.hasOwnProperty("default") ? e.default : e, h = h && h.hasOwnProperty("default") ? h.default : h;
    var r, n, o, a, c, u, f, d, g, _, m, p, v, y, E, C, T, b, S, I, A, D, w, N, O, k, P, j, H, L, R, x, W, U, q, F, K,
        M, Q, B, V, Y, z, J, Z, G, $, X, tt, et, nt, it, rt, ot, st, at, lt, ct, ht, ut, ft, dt, gt, _t, mt, pt, vt, yt,
        Et, Ct, Tt, bt, St, It, At, Dt, wt, Nt, Ot, kt, Pt, jt, Ht, Lt, Rt, xt, Wt, Ut, qt, Ft, Kt, Mt, Qt, Bt, Vt, Yt,
        zt, Jt, Zt, Gt, $t, Xt, te, ee, ne, ie, re, oe, se, ae, le, ce, he, ue, fe, de, ge, _e, me, pe, ve, ye, Ee, Ce,
        Te, be, Se, Ie, Ae, De, we, Ne, Oe, ke, Pe, je, He, Le, Re, xe, We, Ue, qe, Fe, Ke, Me, Qe, Be, Ve, Ye, ze, Je,
        Ze, Ge, $e, Xe, tn, en, nn, rn, on, sn, an, ln, cn, hn, un, fn, dn, gn, _n, mn, pn, vn, yn, En, Cn, Tn, bn, Sn,
        In, An, Dn, wn, Nn, On, kn, Pn, jn, Hn, Ln, Rn, xn, Wn, Un, qn, Fn = function (i) {
            var e = "transitionend";

            function t(t) {
                var e = this, n = !1;
                return i(this).one(l.TRANSITION_END, function () {
                    n = !0
                }), setTimeout(function () {
                    n || l.triggerTransitionEnd(e)
                }, t), this
            }

            var l = {
                TRANSITION_END: "bsTransitionEnd", getUID: function (t) {
                    for (; t += ~~(1e6 * Math.random()), document.getElementById(t);) ;
                    return t
                }, getSelectorFromElement: function (t) {
                    var e = t.getAttribute("data-target");
                    e && "#" !== e || (e = t.getAttribute("href") || "");
                    try {
                        return document.querySelector(e) ? e : null
                    } catch (t) {
                        return null
                    }
                }, getTransitionDurationFromElement: function (t) {
                    if (!t) return 0;
                    var e = i(t).css("transition-duration");
                    return parseFloat(e) ? (e = e.split(",")[0], 1e3 * parseFloat(e)) : 0
                }, reflow: function (t) {
                    return t.offsetHeight
                }, triggerTransitionEnd: function (t) {
                    i(t).trigger(e)
                }, supportsTransitionEnd: function () {
                    return Boolean(e)
                }, isElement: function (t) {
                    return (t[0] || t).nodeType
                }, typeCheckConfig: function (t, e, n) {
                    for (var i in n) if (Object.prototype.hasOwnProperty.call(n, i)) {
                        var r = n[i], o = e[i],
                            s = o && l.isElement(o) ? "element" : (a = o, {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase());
                        if (!new RegExp(r).test(s)) throw new Error(t.toUpperCase() + ': Option "' + i + '" provided type "' + s + '" but expected type "' + r + '".')
                    }
                    var a
                }
            };
            return i.fn.emulateTransitionEnd = t, i.event.special[l.TRANSITION_END] = {
                bindType: e,
                delegateType: e,
                handle: function (t) {
                    if (i(t.target).is(this)) return t.handleObj.handler.apply(this, arguments)
                }
            }, l
        }(e), Kn = (n = "alert", a = "." + (o = "bs.alert"), c = (r = e).fn[n], u = {
            CLOSE: "close" + a,
            CLOSED: "closed" + a,
            CLICK_DATA_API: "click" + a + ".data-api"
        }, f = "alert", d = "fade", g = "show", _ = function () {
            function i(t) {
                this._element = t
            }

            var t = i.prototype;
            return t.close = function (t) {
                var e = this._element;
                t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e)
            }, t.dispose = function () {
                r.removeData(this._element, o), this._element = null
            }, t._getRootElement = function (t) {
                var e = Fn.getSelectorFromElement(t), n = !1;
                return e && (n = document.querySelector(e)), n || (n = r(t).closest("." + f)[0]), n
            }, t._triggerCloseEvent = function (t) {
                var e = r.Event(u.CLOSE);
                return r(t).trigger(e), e
            }, t._removeElement = function (e) {
                var n = this;
                if (r(e).removeClass(g), r(e).hasClass(d)) {
                    var t = Fn.getTransitionDurationFromElement(e);
                    r(e).one(Fn.TRANSITION_END, function (t) {
                        return n._destroyElement(e, t)
                    }).emulateTransitionEnd(t)
                } else this._destroyElement(e)
            }, t._destroyElement = function (t) {
                r(t).detach().trigger(u.CLOSED).remove()
            }, i._jQueryInterface = function (n) {
                return this.each(function () {
                    var t = r(this), e = t.data(o);
                    e || (e = new i(this), t.data(o, e)), "close" === n && e[n](this)
                })
            }, i._handleDismiss = function (e) {
                return function (t) {
                    t && t.preventDefault(), e.close(this)
                }
            }, s(i, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }]), i
        }(), r(document).on(u.CLICK_DATA_API, '[data-dismiss="alert"]', _._handleDismiss(new _)), r.fn[n] = _._jQueryInterface, r.fn[n].Constructor = _, r.fn[n].noConflict = function () {
            return r.fn[n] = c, _._jQueryInterface
        }, _),
        Mn = (p = "button", y = "." + (v = "bs.button"), E = ".data-api", C = (m = e).fn[p], T = "active", b = "btn", I = '[data-toggle^="button"]', A = '[data-toggle="buttons"]', D = "input", w = ".active", N = ".btn", O = {
            CLICK_DATA_API: "click" + y + E,
            FOCUS_BLUR_DATA_API: (S = "focus") + y + E + " blur" + y + E
        }, k = function () {
            function n(t) {
                this._element = t
            }

            var t = n.prototype;
            return t.toggle = function () {
                var t = !0, e = !0, n = m(this._element).closest(A)[0];
                if (n) {
                    var i = this._element.querySelector(D);
                    if (i) {
                        if ("radio" === i.type) if (i.checked && this._element.classList.contains(T)) t = !1; else {
                            var r = n.querySelector(w);
                            r && m(r).removeClass(T)
                        }
                        if (t) {
                            if (i.hasAttribute("disabled") || n.hasAttribute("disabled") || i.classList.contains("disabled") || n.classList.contains("disabled")) return;
                            i.checked = !this._element.classList.contains(T), m(i).trigger("change")
                        }
                        i.focus(), e = !1
                    }
                }
                e && this._element.setAttribute("aria-pressed", !this._element.classList.contains(T)), t && m(this._element).toggleClass(T)
            }, t.dispose = function () {
                m.removeData(this._element, v), this._element = null
            }, n._jQueryInterface = function (e) {
                return this.each(function () {
                    var t = m(this).data(v);
                    t || (t = new n(this), m(this).data(v, t)), "toggle" === e && t[e]()
                })
            }, s(n, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }]), n
        }(), m(document).on(O.CLICK_DATA_API, I, function (t) {
            t.preventDefault();
            var e = t.target;
            m(e).hasClass(b) || (e = m(e).closest(N)), k._jQueryInterface.call(m(e), "toggle")
        }).on(O.FOCUS_BLUR_DATA_API, I, function (t) {
            var e = m(t.target).closest(N)[0];
            m(e).toggleClass(S, /^focus(in)?$/.test(t.type))
        }), m.fn[p] = k._jQueryInterface, m.fn[p].Constructor = k, m.fn[p].noConflict = function () {
            return m.fn[p] = C, k._jQueryInterface
        }, k), Qn = (j = "carousel", L = "." + (H = "bs.carousel"), R = ".data-api", x = (P = e).fn[j], W = {
            interval: 5e3,
            keyboard: !0,
            slide: !1,
            pause: "hover",
            wrap: !0
        }, U = {
            interval: "(number|boolean)",
            keyboard: "boolean",
            slide: "(boolean|string)",
            pause: "(string|boolean)",
            wrap: "boolean"
        }, q = "next", F = "prev", K = "left", M = "right", Q = {
            SLIDE: "slide" + L,
            SLID: "slid" + L,
            KEYDOWN: "keydown" + L,
            MOUSEENTER: "mouseenter" + L,
            MOUSELEAVE: "mouseleave" + L,
            TOUCHEND: "touchend" + L,
            LOAD_DATA_API: "load" + L + R,
            CLICK_DATA_API: "click" + L + R
        }, B = "carousel", V = "active", Y = "slide", z = "carousel-item-right", J = "carousel-item-left", Z = "carousel-item-next", G = "carousel-item-prev", $ = ".active", X = ".active.carousel-item", tt = ".carousel-item", et = ".carousel-item-next, .carousel-item-prev", nt = ".carousel-indicators", it = "[data-slide], [data-slide-to]", rt = '[data-ride="carousel"]', ot = function () {
            function o(t, e) {
                this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this._config = this._getConfig(e), this._element = P(t)[0], this._indicatorsElement = this._element.querySelector(nt), this._addEventListeners()
            }

            var t = o.prototype;
            return t.next = function () {
                this._isSliding || this._slide(q)
            }, t.nextWhenVisible = function () {
                !document.hidden && P(this._element).is(":visible") && "hidden" !== P(this._element).css("visibility") && this.next()
            }, t.prev = function () {
                this._isSliding || this._slide(F)
            }, t.pause = function (t) {
                t || (this._isPaused = !0), this._element.querySelector(et) && (Fn.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
            }, t.cycle = function (t) {
                t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
            }, t.to = function (t) {
                var e = this;
                this._activeElement = this._element.querySelector(X);
                var n = this._getItemIndex(this._activeElement);
                if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding) P(this._element).one(Q.SLID, function () {
                    return e.to(t)
                }); else {
                    if (n === t) return this.pause(), void this.cycle();
                    var i = n < t ? q : F;
                    this._slide(i, this._items[t])
                }
            }, t.dispose = function () {
                P(this._element).off(L), P.removeData(this._element, H), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null
            }, t._getConfig = function (t) {
                return t = l({}, W, t), Fn.typeCheckConfig(j, t, U), t
            }, t._addEventListeners = function () {
                var e = this;
                this._config.keyboard && P(this._element).on(Q.KEYDOWN, function (t) {
                    return e._keydown(t)
                }), "hover" === this._config.pause && (P(this._element).on(Q.MOUSEENTER, function (t) {
                    return e.pause(t)
                }).on(Q.MOUSELEAVE, function (t) {
                    return e.cycle(t)
                }), "ontouchstart" in document.documentElement && P(this._element).on(Q.TOUCHEND, function () {
                    e.pause(), e.touchTimeout && clearTimeout(e.touchTimeout), e.touchTimeout = setTimeout(function (t) {
                        return e.cycle(t)
                    }, 500 + e._config.interval)
                }))
            }, t._keydown = function (t) {
                if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) {
                    case 37:
                        t.preventDefault(), this.prev();
                        break;
                    case 39:
                        t.preventDefault(), this.next()
                }
            }, t._getItemIndex = function (t) {
                return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(tt)) : [], this._items.indexOf(t)
            }, t._getItemByDirection = function (t, e) {
                var n = t === q, i = t === F, r = this._getItemIndex(e), o = this._items.length - 1;
                if ((i && 0 === r || n && r === o) && !this._config.wrap) return e;
                var s = (r + (t === F ? -1 : 1)) % this._items.length;
                return -1 === s ? this._items[this._items.length - 1] : this._items[s]
            }, t._triggerSlideEvent = function (t, e) {
                var n = this._getItemIndex(t), i = this._getItemIndex(this._element.querySelector(X)),
                    r = P.Event(Q.SLIDE, {relatedTarget: t, direction: e, from: i, to: n});
                return P(this._element).trigger(r), r
            }, t._setActiveIndicatorElement = function (t) {
                if (this._indicatorsElement) {
                    var e = [].slice.call(this._indicatorsElement.querySelectorAll($));
                    P(e).removeClass(V);
                    var n = this._indicatorsElement.children[this._getItemIndex(t)];
                    n && P(n).addClass(V)
                }
            }, t._slide = function (t, e) {
                var n, i, r, o = this, s = this._element.querySelector(X), a = this._getItemIndex(s),
                    l = e || s && this._getItemByDirection(t, s), c = this._getItemIndex(l), h = Boolean(this._interval);
                if (t === q ? (n = J, i = Z, r = K) : (n = z, i = G, r = M), l && P(l).hasClass(V)) this._isSliding = !1; else if (!this._triggerSlideEvent(l, r).isDefaultPrevented() && s && l) {
                    this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(l);
                    var u = P.Event(Q.SLID, {relatedTarget: l, direction: r, from: a, to: c});
                    if (P(this._element).hasClass(Y)) {
                        P(l).addClass(i), Fn.reflow(l), P(s).addClass(n), P(l).addClass(n);
                        var f = Fn.getTransitionDurationFromElement(s);
                        P(s).one(Fn.TRANSITION_END, function () {
                            P(l).removeClass(n + " " + i).addClass(V), P(s).removeClass(V + " " + i + " " + n), o._isSliding = !1, setTimeout(function () {
                                return P(o._element).trigger(u)
                            }, 0)
                        }).emulateTransitionEnd(f)
                    } else P(s).removeClass(V), P(l).addClass(V), this._isSliding = !1, P(this._element).trigger(u);
                    h && this.cycle()
                }
            }, o._jQueryInterface = function (i) {
                return this.each(function () {
                    var t = P(this).data(H), e = l({}, W, P(this).data());
                    "object" == typeof i && (e = l({}, e, i));
                    var n = "string" == typeof i ? i : e.slide;
                    if (t || (t = new o(this, e), P(this).data(H, t)), "number" == typeof i) t.to(i); else if ("string" == typeof n) {
                        if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
                        t[n]()
                    } else e.interval && (t.pause(), t.cycle())
                })
            }, o._dataApiClickHandler = function (t) {
                var e = Fn.getSelectorFromElement(this);
                if (e) {
                    var n = P(e)[0];
                    if (n && P(n).hasClass(B)) {
                        var i = l({}, P(n).data(), P(this).data()), r = this.getAttribute("data-slide-to");
                        r && (i.interval = !1), o._jQueryInterface.call(P(n), i), r && P(n).data(H).to(r), t.preventDefault()
                    }
                }
            }, s(o, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }, {
                key: "Default", get: function () {
                    return W
                }
            }]), o
        }(), P(document).on(Q.CLICK_DATA_API, it, ot._dataApiClickHandler), P(window).on(Q.LOAD_DATA_API, function () {
            for (var t = [].slice.call(document.querySelectorAll(rt)), e = 0, n = t.length; e < n; e++) {
                var i = P(t[e]);
                ot._jQueryInterface.call(i, i.data())
            }
        }), P.fn[j] = ot._jQueryInterface, P.fn[j].Constructor = ot, P.fn[j].noConflict = function () {
            return P.fn[j] = x, ot._jQueryInterface
        }, ot), Bn = (at = "collapse", ct = "." + (lt = "bs.collapse"), ht = (st = e).fn[at], ut = {
            toggle: !0,
            parent: ""
        }, ft = {toggle: "boolean", parent: "(string|element)"}, dt = {
            SHOW: "show" + ct,
            SHOWN: "shown" + ct,
            HIDE: "hide" + ct,
            HIDDEN: "hidden" + ct,
            CLICK_DATA_API: "click" + ct + ".data-api"
        }, gt = "show", _t = "collapse", mt = "collapsing", pt = "collapsed", vt = "width", yt = "height", Et = ".show, .collapsing", Ct = '[data-toggle="collapse"]', Tt = function () {
            function a(e, t) {
                this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = st.makeArray(document.querySelectorAll('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'));
                for (var n = [].slice.call(document.querySelectorAll(Ct)), i = 0, r = n.length; i < r; i++) {
                    var o = n[i], s = Fn.getSelectorFromElement(o),
                        a = [].slice.call(document.querySelectorAll(s)).filter(function (t) {
                            return t === e
                        });
                    null !== s && 0 < a.length && (this._selector = s, this._triggerArray.push(o))
                }
                this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle()
            }

            var t = a.prototype;
            return t.toggle = function () {
                st(this._element).hasClass(gt) ? this.hide() : this.show()
            }, t.show = function () {
                var t, e, n = this;
                if (!this._isTransitioning && !st(this._element).hasClass(gt) && (this._parent && 0 === (t = [].slice.call(this._parent.querySelectorAll(Et)).filter(function (t) {
                    return t.getAttribute("data-parent") === n._config.parent
                })).length && (t = null), !(t && (e = st(t).not(this._selector).data(lt)) && e._isTransitioning))) {
                    var i = st.Event(dt.SHOW);
                    if (st(this._element).trigger(i), !i.isDefaultPrevented()) {
                        t && (a._jQueryInterface.call(st(t).not(this._selector), "hide"), e || st(t).data(lt, null));
                        var r = this._getDimension();
                        st(this._element).removeClass(_t).addClass(mt), this._element.style[r] = 0, this._triggerArray.length && st(this._triggerArray).removeClass(pt).attr("aria-expanded", !0), this.setTransitioning(!0);
                        var o = "scroll" + (r[0].toUpperCase() + r.slice(1)),
                            s = Fn.getTransitionDurationFromElement(this._element);
                        st(this._element).one(Fn.TRANSITION_END, function () {
                            st(n._element).removeClass(mt).addClass(_t).addClass(gt), n._element.style[r] = "", n.setTransitioning(!1), st(n._element).trigger(dt.SHOWN)
                        }).emulateTransitionEnd(s), this._element.style[r] = this._element[o] + "px"
                    }
                }
            }, t.hide = function () {
                var t = this;
                if (!this._isTransitioning && st(this._element).hasClass(gt)) {
                    var e = st.Event(dt.HIDE);
                    if (st(this._element).trigger(e), !e.isDefaultPrevented()) {
                        var n = this._getDimension();
                        this._element.style[n] = this._element.getBoundingClientRect()[n] + "px", Fn.reflow(this._element), st(this._element).addClass(mt).removeClass(_t).removeClass(gt);
                        var i = this._triggerArray.length;
                        if (0 < i) for (var r = 0; r < i; r++) {
                            var o = this._triggerArray[r], s = Fn.getSelectorFromElement(o);
                            if (null !== s) st([].slice.call(document.querySelectorAll(s))).hasClass(gt) || st(o).addClass(pt).attr("aria-expanded", !1)
                        }
                        this.setTransitioning(!0);
                        this._element.style[n] = "";
                        var a = Fn.getTransitionDurationFromElement(this._element);
                        st(this._element).one(Fn.TRANSITION_END, function () {
                            t.setTransitioning(!1), st(t._element).removeClass(mt).addClass(_t).trigger(dt.HIDDEN)
                        }).emulateTransitionEnd(a)
                    }
                }
            }, t.setTransitioning = function (t) {
                this._isTransitioning = t
            }, t.dispose = function () {
                st.removeData(this._element, lt), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null
            }, t._getConfig = function (t) {
                return (t = l({}, ut, t)).toggle = Boolean(t.toggle), Fn.typeCheckConfig(at, t, ft), t
            }, t._getDimension = function () {
                return st(this._element).hasClass(vt) ? vt : yt
            }, t._getParent = function () {
                var n = this, t = null;
                Fn.isElement(this._config.parent) ? (t = this._config.parent, "undefined" != typeof this._config.parent.jquery && (t = this._config.parent[0])) : t = document.querySelector(this._config.parent);
                var e = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]',
                    i = [].slice.call(t.querySelectorAll(e));
                return st(i).each(function (t, e) {
                    n._addAriaAndCollapsedClass(a._getTargetFromElement(e), [e])
                }), t
            }, t._addAriaAndCollapsedClass = function (t, e) {
                if (t) {
                    var n = st(t).hasClass(gt);
                    e.length && st(e).toggleClass(pt, !n).attr("aria-expanded", n)
                }
            }, a._getTargetFromElement = function (t) {
                var e = Fn.getSelectorFromElement(t);
                return e ? document.querySelector(e) : null
            }, a._jQueryInterface = function (i) {
                return this.each(function () {
                    var t = st(this), e = t.data(lt), n = l({}, ut, t.data(), "object" == typeof i && i ? i : {});
                    if (!e && n.toggle && /show|hide/.test(i) && (n.toggle = !1), e || (e = new a(this, n), t.data(lt, e)), "string" == typeof i) {
                        if ("undefined" == typeof e[i]) throw new TypeError('No method named "' + i + '"');
                        e[i]()
                    }
                })
            }, s(a, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }, {
                key: "Default", get: function () {
                    return ut
                }
            }]), a
        }(), st(document).on(dt.CLICK_DATA_API, Ct, function (t) {
            "A" === t.currentTarget.tagName && t.preventDefault();
            var n = st(this), e = Fn.getSelectorFromElement(this), i = [].slice.call(document.querySelectorAll(e));
            st(i).each(function () {
                var t = st(this), e = t.data(lt) ? "toggle" : n.data();
                Tt._jQueryInterface.call(t, e)
            })
        }), st.fn[at] = Tt._jQueryInterface, st.fn[at].Constructor = Tt, st.fn[at].noConflict = function () {
            return st.fn[at] = ht, Tt._jQueryInterface
        }, Tt),
        Vn = (St = "dropdown", At = "." + (It = "bs.dropdown"), Dt = ".data-api", wt = (bt = e).fn[St], Nt = new RegExp("38|40|27"), Ot = {
            HIDE: "hide" + At,
            HIDDEN: "hidden" + At,
            SHOW: "show" + At,
            SHOWN: "shown" + At,
            CLICK: "click" + At,
            CLICK_DATA_API: "click" + At + Dt,
            KEYDOWN_DATA_API: "keydown" + At + Dt,
            KEYUP_DATA_API: "keyup" + At + Dt
        }, kt = "disabled", Pt = "show", jt = "dropup", Ht = "dropright", Lt = "dropleft", Rt = "dropdown-menu-right", xt = "position-static", Wt = '[data-toggle="dropdown"]', Ut = ".dropdown form", qt = ".dropdown-menu", Ft = ".navbar-nav", Kt = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", Mt = "top-start", Qt = "top-end", Bt = "bottom-start", Vt = "bottom-end", Yt = "right-start", zt = "left-start", Jt = {
            offset: 0,
            flip: !0,
            boundary: "scrollParent",
            reference: "toggle",
            display: "dynamic"
        }, Zt = {
            offset: "(number|string|function)",
            flip: "boolean",
            boundary: "(string|element)",
            reference: "(string|element)",
            display: "string"
        }, Gt = function () {
            function c(t, e) {
                this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners()
            }

            var t = c.prototype;
            return t.toggle = function () {
                if (!this._element.disabled && !bt(this._element).hasClass(kt)) {
                    var t = c._getParentFromElement(this._element), e = bt(this._menu).hasClass(Pt);
                    if (c._clearMenus(), !e) {
                        var n = {relatedTarget: this._element}, i = bt.Event(Ot.SHOW, n);
                        if (bt(t).trigger(i), !i.isDefaultPrevented()) {
                            if (!this._inNavbar) {
                                if ("undefined" == typeof h) throw new TypeError("Bootstrap dropdown require Popper.js (https://popper.js.org)");
                                var r = this._element;
                                "parent" === this._config.reference ? r = t : Fn.isElement(this._config.reference) && (r = this._config.reference, "undefined" != typeof this._config.reference.jquery && (r = this._config.reference[0])), "scrollParent" !== this._config.boundary && bt(t).addClass(xt), this._popper = new h(r, this._menu, this._getPopperConfig())
                            }
                            "ontouchstart" in document.documentElement && 0 === bt(t).closest(Ft).length && bt(document.body).children().on("mouseover", null, bt.noop), this._element.focus(), this._element.setAttribute("aria-expanded", !0), bt(this._menu).toggleClass(Pt), bt(t).toggleClass(Pt).trigger(bt.Event(Ot.SHOWN, n))
                        }
                    }
                }
            }, t.dispose = function () {
                bt.removeData(this._element, It), bt(this._element).off(At), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null)
            }, t.update = function () {
                this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate()
            }, t._addEventListeners = function () {
                var e = this;
                bt(this._element).on(Ot.CLICK, function (t) {
                    t.preventDefault(), t.stopPropagation(), e.toggle()
                })
            }, t._getConfig = function (t) {
                return t = l({}, this.constructor.Default, bt(this._element).data(), t), Fn.typeCheckConfig(St, t, this.constructor.DefaultType), t
            }, t._getMenuElement = function () {
                if (!this._menu) {
                    var t = c._getParentFromElement(this._element);
                    t && (this._menu = t.querySelector(qt))
                }
                return this._menu
            }, t._getPlacement = function () {
                var t = bt(this._element.parentNode), e = Bt;
                return t.hasClass(jt) ? (e = Mt, bt(this._menu).hasClass(Rt) && (e = Qt)) : t.hasClass(Ht) ? e = Yt : t.hasClass(Lt) ? e = zt : bt(this._menu).hasClass(Rt) && (e = Vt), e
            }, t._detectNavbar = function () {
                return 0 < bt(this._element).closest(".navbar").length
            }, t._getPopperConfig = function () {
                var e = this, t = {};
                "function" == typeof this._config.offset ? t.fn = function (t) {
                    return t.offsets = l({}, t.offsets, e._config.offset(t.offsets) || {}), t
                } : t.offset = this._config.offset;
                var n = {
                    placement: this._getPlacement(),
                    modifiers: {
                        offset: t,
                        flip: {enabled: this._config.flip},
                        preventOverflow: {boundariesElement: this._config.boundary}
                    }
                };
                return "static" === this._config.display && (n.modifiers.applyStyle = {enabled: !1}), n
            }, c._jQueryInterface = function (e) {
                return this.each(function () {
                    var t = bt(this).data(It);
                    if (t || (t = new c(this, "object" == typeof e ? e : null), bt(this).data(It, t)), "string" == typeof e) {
                        if ("undefined" == typeof t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e]()
                    }
                })
            }, c._clearMenus = function (t) {
                if (!t || 3 !== t.which && ("keyup" !== t.type || 9 === t.which)) for (var e = [].slice.call(document.querySelectorAll(Wt)), n = 0, i = e.length; n < i; n++) {
                    var r = c._getParentFromElement(e[n]), o = bt(e[n]).data(It), s = {relatedTarget: e[n]};
                    if (t && "click" === t.type && (s.clickEvent = t), o) {
                        var a = o._menu;
                        if (bt(r).hasClass(Pt) && !(t && ("click" === t.type && /input|textarea/i.test(t.target.tagName) || "keyup" === t.type && 9 === t.which) && bt.contains(r, t.target))) {
                            var l = bt.Event(Ot.HIDE, s);
                            bt(r).trigger(l), l.isDefaultPrevented() || ("ontouchstart" in document.documentElement && bt(document.body).children().off("mouseover", null, bt.noop), e[n].setAttribute("aria-expanded", "false"), bt(a).removeClass(Pt), bt(r).removeClass(Pt).trigger(bt.Event(Ot.HIDDEN, s)))
                        }
                    }
                }
            }, c._getParentFromElement = function (t) {
                var e, n = Fn.getSelectorFromElement(t);
                return n && (e = document.querySelector(n)), e || t.parentNode
            }, c._dataApiKeydownHandler = function (t) {
                if ((/input|textarea/i.test(t.target.tagName) ? !(32 === t.which || 27 !== t.which && (40 !== t.which && 38 !== t.which || bt(t.target).closest(qt).length)) : Nt.test(t.which)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !bt(this).hasClass(kt))) {
                    var e = c._getParentFromElement(this), n = bt(e).hasClass(Pt);
                    if ((n || 27 === t.which && 32 === t.which) && (!n || 27 !== t.which && 32 !== t.which)) {
                        var i = [].slice.call(e.querySelectorAll(Kt));
                        if (0 !== i.length) {
                            var r = i.indexOf(t.target);
                            38 === t.which && 0 < r && r--, 40 === t.which && r < i.length - 1 && r++, r < 0 && (r = 0), i[r].focus()
                        }
                    } else {
                        if (27 === t.which) {
                            var o = e.querySelector(Wt);
                            bt(o).trigger("focus")
                        }
                        bt(this).trigger("click")
                    }
                }
            }, s(c, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }, {
                key: "Default", get: function () {
                    return Jt
                }
            }, {
                key: "DefaultType", get: function () {
                    return Zt
                }
            }]), c
        }(), bt(document).on(Ot.KEYDOWN_DATA_API, Wt, Gt._dataApiKeydownHandler).on(Ot.KEYDOWN_DATA_API, qt, Gt._dataApiKeydownHandler).on(Ot.CLICK_DATA_API + " " + Ot.KEYUP_DATA_API, Gt._clearMenus).on(Ot.CLICK_DATA_API, Wt, function (t) {
            t.preventDefault(), t.stopPropagation(), Gt._jQueryInterface.call(bt(this), "toggle")
        }).on(Ot.CLICK_DATA_API, Ut, function (t) {
            t.stopPropagation()
        }), bt.fn[St] = Gt._jQueryInterface, bt.fn[St].Constructor = Gt, bt.fn[St].noConflict = function () {
            return bt.fn[St] = wt, Gt._jQueryInterface
        }, Gt), Yn = (Xt = "modal", ee = "." + (te = "bs.modal"), ne = ($t = e).fn[Xt], ie = {
            backdrop: !0,
            keyboard: !0,
            focus: !0,
            show: !0
        }, re = {
            backdrop: "(boolean|string)",
            keyboard: "boolean",
            focus: "boolean",
            show: "boolean"
        }, oe = {
            HIDE: "hide" + ee,
            HIDDEN: "hidden" + ee,
            SHOW: "show" + ee,
            SHOWN: "shown" + ee,
            FOCUSIN: "focusin" + ee,
            RESIZE: "resize" + ee,
            CLICK_DISMISS: "click.dismiss" + ee,
            KEYDOWN_DISMISS: "keydown.dismiss" + ee,
            MOUSEUP_DISMISS: "mouseup.dismiss" + ee,
            MOUSEDOWN_DISMISS: "mousedown.dismiss" + ee,
            CLICK_DATA_API: "click" + ee + ".data-api"
        }, se = "modal-scrollbar-measure", ae = "modal-backdrop", le = "modal-open", ce = "fade", he = "show", ue = ".modal-dialog", fe = '[data-toggle="modal"]', de = '[data-dismiss="modal"]', ge = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", _e = ".sticky-top", me = function () {
            function r(t, e) {
                this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(ue), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._scrollbarWidth = 0
            }

            var t = r.prototype;
            return t.toggle = function (t) {
                return this._isShown ? this.hide() : this.show(t)
            }, t.show = function (t) {
                var e = this;
                if (!this._isTransitioning && !this._isShown) {
                    $t(this._element).hasClass(ce) && (this._isTransitioning = !0);
                    var n = $t.Event(oe.SHOW, {relatedTarget: t});
                    $t(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), $t(document.body).addClass(le), this._setEscapeEvent(), this._setResizeEvent(), $t(this._element).on(oe.CLICK_DISMISS, de, function (t) {
                        return e.hide(t)
                    }), $t(this._dialog).on(oe.MOUSEDOWN_DISMISS, function () {
                        $t(e._element).one(oe.MOUSEUP_DISMISS, function (t) {
                            $t(t.target).is(e._element) && (e._ignoreBackdropClick = !0)
                        })
                    }), this._showBackdrop(function () {
                        return e._showElement(t)
                    }))
                }
            }, t.hide = function (t) {
                var e = this;
                if (t && t.preventDefault(), !this._isTransitioning && this._isShown) {
                    var n = $t.Event(oe.HIDE);
                    if ($t(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) {
                        this._isShown = !1;
                        var i = $t(this._element).hasClass(ce);
                        if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), $t(document).off(oe.FOCUSIN), $t(this._element).removeClass(he), $t(this._element).off(oe.CLICK_DISMISS), $t(this._dialog).off(oe.MOUSEDOWN_DISMISS), i) {
                            var r = Fn.getTransitionDurationFromElement(this._element);
                            $t(this._element).one(Fn.TRANSITION_END, function (t) {
                                return e._hideModal(t)
                            }).emulateTransitionEnd(r)
                        } else this._hideModal()
                    }
                }
            }, t.dispose = function () {
                $t.removeData(this._element, te), $t(window, document, this._element, this._backdrop).off(ee), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._scrollbarWidth = null
            }, t.handleUpdate = function () {
                this._adjustDialog()
            }, t._getConfig = function (t) {
                return t = l({}, ie, t), Fn.typeCheckConfig(Xt, t, re), t
            }, t._showElement = function (t) {
                var e = this, n = $t(this._element).hasClass(ce);
                this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.scrollTop = 0, n && Fn.reflow(this._element), $t(this._element).addClass(he), this._config.focus && this._enforceFocus();
                var i = $t.Event(oe.SHOWN, {relatedTarget: t}), r = function () {
                    e._config.focus && e._element.focus(), e._isTransitioning = !1, $t(e._element).trigger(i)
                };
                if (n) {
                    var o = Fn.getTransitionDurationFromElement(this._element);
                    $t(this._dialog).one(Fn.TRANSITION_END, r).emulateTransitionEnd(o)
                } else r()
            }, t._enforceFocus = function () {
                var e = this;
                $t(document).off(oe.FOCUSIN).on(oe.FOCUSIN, function (t) {
                    document !== t.target && e._element !== t.target && 0 === $t(e._element).has(t.target).length && e._element.focus()
                })
            }, t._setEscapeEvent = function () {
                var e = this;
                this._isShown && this._config.keyboard ? $t(this._element).on(oe.KEYDOWN_DISMISS, function (t) {
                    27 === t.which && (t.preventDefault(), e.hide())
                }) : this._isShown || $t(this._element).off(oe.KEYDOWN_DISMISS)
            }, t._setResizeEvent = function () {
                var e = this;
                this._isShown ? $t(window).on(oe.RESIZE, function (t) {
                    return e.handleUpdate(t)
                }) : $t(window).off(oe.RESIZE)
            }, t._hideModal = function () {
                var t = this;
                this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._isTransitioning = !1, this._showBackdrop(function () {
                    $t(document.body).removeClass(le), t._resetAdjustments(), t._resetScrollbar(), $t(t._element).trigger(oe.HIDDEN)
                })
            }, t._removeBackdrop = function () {
                this._backdrop && ($t(this._backdrop).remove(), this._backdrop = null)
            }, t._showBackdrop = function (t) {
                var e = this, n = $t(this._element).hasClass(ce) ? ce : "";
                if (this._isShown && this._config.backdrop) {
                    if (this._backdrop = document.createElement("div"), this._backdrop.className = ae, n && this._backdrop.classList.add(n), $t(this._backdrop).appendTo(document.body), $t(this._element).on(oe.CLICK_DISMISS, function (t) {
                        e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && ("static" === e._config.backdrop ? e._element.focus() : e.hide())
                    }), n && Fn.reflow(this._backdrop), $t(this._backdrop).addClass(he), !t) return;
                    if (!n) return void t();
                    var i = Fn.getTransitionDurationFromElement(this._backdrop);
                    $t(this._backdrop).one(Fn.TRANSITION_END, t).emulateTransitionEnd(i)
                } else if (!this._isShown && this._backdrop) {
                    $t(this._backdrop).removeClass(he);
                    var r = function () {
                        e._removeBackdrop(), t && t()
                    };
                    if ($t(this._element).hasClass(ce)) {
                        var o = Fn.getTransitionDurationFromElement(this._backdrop);
                        $t(this._backdrop).one(Fn.TRANSITION_END, r).emulateTransitionEnd(o)
                    } else r()
                } else t && t()
            }, t._adjustDialog = function () {
                var t = this._element.scrollHeight > document.documentElement.clientHeight;
                !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + "px")
            }, t._resetAdjustments = function () {
                this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
            }, t._checkScrollbar = function () {
                var t = document.body.getBoundingClientRect();
                this._isBodyOverflowing = t.left + t.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth()
            }, t._setScrollbar = function () {
                var r = this;
                if (this._isBodyOverflowing) {
                    var t = [].slice.call(document.querySelectorAll(ge)), e = [].slice.call(document.querySelectorAll(_e));
                    $t(t).each(function (t, e) {
                        var n = e.style.paddingRight, i = $t(e).css("padding-right");
                        $t(e).data("padding-right", n).css("padding-right", parseFloat(i) + r._scrollbarWidth + "px")
                    }), $t(e).each(function (t, e) {
                        var n = e.style.marginRight, i = $t(e).css("margin-right");
                        $t(e).data("margin-right", n).css("margin-right", parseFloat(i) - r._scrollbarWidth + "px")
                    });
                    var n = document.body.style.paddingRight, i = $t(document.body).css("padding-right");
                    $t(document.body).data("padding-right", n).css("padding-right", parseFloat(i) + this._scrollbarWidth + "px")
                }
            }, t._resetScrollbar = function () {
                var t = [].slice.call(document.querySelectorAll(ge));
                $t(t).each(function (t, e) {
                    var n = $t(e).data("padding-right");
                    $t(e).removeData("padding-right"), e.style.paddingRight = n || ""
                });
                var e = [].slice.call(document.querySelectorAll("" + _e));
                $t(e).each(function (t, e) {
                    var n = $t(e).data("margin-right");
                    "undefined" != typeof n && $t(e).css("margin-right", n).removeData("margin-right")
                });
                var n = $t(document.body).data("padding-right");
                $t(document.body).removeData("padding-right"), document.body.style.paddingRight = n || ""
            }, t._getScrollbarWidth = function () {
                var t = document.createElement("div");
                t.className = se, document.body.appendChild(t);
                var e = t.getBoundingClientRect().width - t.clientWidth;
                return document.body.removeChild(t), e
            }, r._jQueryInterface = function (n, i) {
                return this.each(function () {
                    var t = $t(this).data(te), e = l({}, ie, $t(this).data(), "object" == typeof n && n ? n : {});
                    if (t || (t = new r(this, e), $t(this).data(te, t)), "string" == typeof n) {
                        if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
                        t[n](i)
                    } else e.show && t.show(i)
                })
            }, s(r, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }, {
                key: "Default", get: function () {
                    return ie
                }
            }]), r
        }(), $t(document).on(oe.CLICK_DATA_API, fe, function (t) {
            var e, n = this, i = Fn.getSelectorFromElement(this);
            i && (e = document.querySelector(i));
            var r = $t(e).data(te) ? "toggle" : l({}, $t(e).data(), $t(this).data());
            "A" !== this.tagName && "AREA" !== this.tagName || t.preventDefault();
            var o = $t(e).one(oe.SHOW, function (t) {
                t.isDefaultPrevented() || o.one(oe.HIDDEN, function () {
                    $t(n).is(":visible") && n.focus()
                })
            });
            me._jQueryInterface.call($t(e), r, this)
        }), $t.fn[Xt] = me._jQueryInterface, $t.fn[Xt].Constructor = me, $t.fn[Xt].noConflict = function () {
            return $t.fn[Xt] = ne, me._jQueryInterface
        }, me),
        zn = (ve = "tooltip", Ee = "." + (ye = "bs.tooltip"), Ce = (pe = e).fn[ve], Te = "bs-tooltip", be = new RegExp("(^|\\s)" + Te + "\\S+", "g"), Ae = {
            animation: !0,
            template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: !(Ie = {AUTO: "auto", TOP: "top", RIGHT: "right", BOTTOM: "bottom", LEFT: "left"}),
            selector: !(Se = {
                animation: "boolean",
                template: "string",
                title: "(string|element|function)",
                trigger: "string",
                delay: "(number|object)",
                html: "boolean",
                selector: "(string|boolean)",
                placement: "(string|function)",
                offset: "(number|string)",
                container: "(string|element|boolean)",
                fallbackPlacement: "(string|array)",
                boundary: "(string|element)"
            }),
            placement: "top",
            offset: 0,
            container: !1,
            fallbackPlacement: "flip",
            boundary: "scrollParent"
        }, we = "out", Ne = {
            HIDE: "hide" + Ee,
            HIDDEN: "hidden" + Ee,
            SHOW: (De = "show") + Ee,
            SHOWN: "shown" + Ee,
            INSERTED: "inserted" + Ee,
            CLICK: "click" + Ee,
            FOCUSIN: "focusin" + Ee,
            FOCUSOUT: "focusout" + Ee,
            MOUSEENTER: "mouseenter" + Ee,
            MOUSELEAVE: "mouseleave" + Ee
        }, Oe = "fade", ke = "show", Pe = ".tooltip-inner", je = ".arrow", He = "hover", Le = "focus", Re = "click", xe = "manual", We = function () {
            function i(t, e) {
                if ("undefined" == typeof h) throw new TypeError("Bootstrap tooltips require Popper.js (https://popper.js.org)");
                this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners()
            }

            var t = i.prototype;
            return t.enable = function () {
                this._isEnabled = !0
            }, t.disable = function () {
                this._isEnabled = !1
            }, t.toggleEnabled = function () {
                this._isEnabled = !this._isEnabled
            }, t.toggle = function (t) {
                if (this._isEnabled) if (t) {
                    var e = this.constructor.DATA_KEY, n = pe(t.currentTarget).data(e);
                    n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), pe(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n)
                } else {
                    if (pe(this.getTipElement()).hasClass(ke)) return void this._leave(null, this);
                    this._enter(null, this)
                }
            }, t.dispose = function () {
                clearTimeout(this._timeout), pe.removeData(this.element, this.constructor.DATA_KEY), pe(this.element).off(this.constructor.EVENT_KEY), pe(this.element).closest(".modal").off("hide.bs.modal"), this.tip && pe(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null
            }, t.show = function () {
                var e = this;
                if ("none" === pe(this.element).css("display")) throw new Error("Please use show on visible elements");
                var t = pe.Event(this.constructor.Event.SHOW);
                if (this.isWithContent() && this._isEnabled) {
                    pe(this.element).trigger(t);
                    var n = pe.contains(this.element.ownerDocument.documentElement, this.element);
                    if (t.isDefaultPrevented() || !n) return;
                    var i = this.getTipElement(), r = Fn.getUID(this.constructor.NAME);
                    i.setAttribute("id", r), this.element.setAttribute("aria-describedby", r), this.setContent(), this.config.animation && pe(i).addClass(Oe);
                    var o = "function" == typeof this.config.placement ? this.config.placement.call(this, i, this.element) : this.config.placement,
                        s = this._getAttachment(o);
                    this.addAttachmentClass(s);
                    var a = !1 === this.config.container ? document.body : pe(document).find(this.config.container);
                    pe(i).data(this.constructor.DATA_KEY, this), pe.contains(this.element.ownerDocument.documentElement, this.tip) || pe(i).appendTo(a), pe(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new h(this.element, i, {
                        placement: s,
                        modifiers: {
                            offset: {offset: this.config.offset},
                            flip: {behavior: this.config.fallbackPlacement},
                            arrow: {element: je},
                            preventOverflow: {boundariesElement: this.config.boundary}
                        },
                        onCreate: function (t) {
                            t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t)
                        },
                        onUpdate: function (t) {
                            e._handlePopperPlacementChange(t)
                        }
                    }), pe(i).addClass(ke), "ontouchstart" in document.documentElement && pe(document.body).children().on("mouseover", null, pe.noop);
                    var l = function () {
                        e.config.animation && e._fixTransition();
                        var t = e._hoverState;
                        e._hoverState = null, pe(e.element).trigger(e.constructor.Event.SHOWN), t === we && e._leave(null, e)
                    };
                    if (pe(this.tip).hasClass(Oe)) {
                        var c = Fn.getTransitionDurationFromElement(this.tip);
                        pe(this.tip).one(Fn.TRANSITION_END, l).emulateTransitionEnd(c)
                    } else l()
                }
            }, t.hide = function (t) {
                var e = this, n = this.getTipElement(), i = pe.Event(this.constructor.Event.HIDE), r = function () {
                    e._hoverState !== De && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute("aria-describedby"), pe(e.element).trigger(e.constructor.Event.HIDDEN), null !== e._popper && e._popper.destroy(), t && t()
                };
                if (pe(this.element).trigger(i), !i.isDefaultPrevented()) {
                    if (pe(n).removeClass(ke), "ontouchstart" in document.documentElement && pe(document.body).children().off("mouseover", null, pe.noop), this._activeTrigger[Re] = !1, this._activeTrigger[Le] = !1, this._activeTrigger[He] = !1, pe(this.tip).hasClass(Oe)) {
                        var o = Fn.getTransitionDurationFromElement(n);
                        pe(n).one(Fn.TRANSITION_END, r).emulateTransitionEnd(o)
                    } else r();
                    this._hoverState = ""
                }
            }, t.update = function () {
                null !== this._popper && this._popper.scheduleUpdate()
            }, t.isWithContent = function () {
                return Boolean(this.getTitle())
            }, t.addAttachmentClass = function (t) {
                pe(this.getTipElement()).addClass(Te + "-" + t)
            }, t.getTipElement = function () {
                return this.tip = this.tip || pe(this.config.template)[0], this.tip
            }, t.setContent = function () {
                var t = this.getTipElement();
                this.setElementContent(pe(t.querySelectorAll(Pe)), this.getTitle()), pe(t).removeClass(Oe + " " + ke)
            }, t.setElementContent = function (t, e) {
                var n = this.config.html;
                "object" == typeof e && (e.nodeType || e.jquery) ? n ? pe(e).parent().is(t) || t.empty().append(e) : t.text(pe(e).text()) : t[n ? "html" : "text"](e)
            }, t.getTitle = function () {
                var t = this.element.getAttribute("data-original-title");
                return t || (t = "function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), t
            }, t._getAttachment = function (t) {
                return Ie[t.toUpperCase()]
            }, t._setListeners = function () {
                var i = this;
                this.config.trigger.split(" ").forEach(function (t) {
                    if ("click" === t) pe(i.element).on(i.constructor.Event.CLICK, i.config.selector, function (t) {
                        return i.toggle(t)
                    }); else if (t !== xe) {
                        var e = t === He ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN,
                            n = t === He ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT;
                        pe(i.element).on(e, i.config.selector, function (t) {
                            return i._enter(t)
                        }).on(n, i.config.selector, function (t) {
                            return i._leave(t)
                        })
                    }
                    pe(i.element).closest(".modal").on("hide.bs.modal", function () {
                        return i.hide()
                    })
                }), this.config.selector ? this.config = l({}, this.config, {
                    trigger: "manual",
                    selector: ""
                }) : this._fixTitle()
            }, t._fixTitle = function () {
                var t = typeof this.element.getAttribute("data-original-title");
                (this.element.getAttribute("title") || "string" !== t) && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), this.element.setAttribute("title", ""))
            }, t._enter = function (t, e) {
                var n = this.constructor.DATA_KEY;
                (e = e || pe(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), pe(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusin" === t.type ? Le : He] = !0), pe(e.getTipElement()).hasClass(ke) || e._hoverState === De ? e._hoverState = De : (clearTimeout(e._timeout), e._hoverState = De, e.config.delay && e.config.delay.show ? e._timeout = setTimeout(function () {
                    e._hoverState === De && e.show()
                }, e.config.delay.show) : e.show())
            }, t._leave = function (t, e) {
                var n = this.constructor.DATA_KEY;
                (e = e || pe(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), pe(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusout" === t.type ? Le : He] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = we, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(function () {
                    e._hoverState === we && e.hide()
                }, e.config.delay.hide) : e.hide())
            }, t._isWithActiveTrigger = function () {
                for (var t in this._activeTrigger) if (this._activeTrigger[t]) return !0;
                return !1
            }, t._getConfig = function (t) {
                return "number" == typeof(t = l({}, this.constructor.Default, pe(this.element).data(), "object" == typeof t && t ? t : {})).delay && (t.delay = {
                    show: t.delay,
                    hide: t.delay
                }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), Fn.typeCheckConfig(ve, t, this.constructor.DefaultType), t
            }, t._getDelegateConfig = function () {
                var t = {};
                if (this.config) for (var e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);
                return t
            }, t._cleanTipClass = function () {
                var t = pe(this.getTipElement()), e = t.attr("class").match(be);
                null !== e && e.length && t.removeClass(e.join(""))
            }, t._handlePopperPlacementChange = function (t) {
                var e = t.instance;
                this.tip = e.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement))
            }, t._fixTransition = function () {
                var t = this.getTipElement(), e = this.config.animation;
                null === t.getAttribute("x-placement") && (pe(t).removeClass(Oe), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e)
            }, i._jQueryInterface = function (n) {
                return this.each(function () {
                    var t = pe(this).data(ye), e = "object" == typeof n && n;
                    if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), pe(this).data(ye, t)), "string" == typeof n)) {
                        if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
                        t[n]()
                    }
                })
            }, s(i, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }, {
                key: "Default", get: function () {
                    return Ae
                }
            }, {
                key: "NAME", get: function () {
                    return ve
                }
            }, {
                key: "DATA_KEY", get: function () {
                    return ye
                }
            }, {
                key: "Event", get: function () {
                    return Ne
                }
            }, {
                key: "EVENT_KEY", get: function () {
                    return Ee
                }
            }, {
                key: "DefaultType", get: function () {
                    return Se
                }
            }]), i
        }(), pe.fn[ve] = We._jQueryInterface, pe.fn[ve].Constructor = We, pe.fn[ve].noConflict = function () {
            return pe.fn[ve] = Ce, We._jQueryInterface
        }, We),
        Jn = (qe = "popover", Ke = "." + (Fe = "bs.popover"), Me = (Ue = e).fn[qe], Qe = "bs-popover", Be = new RegExp("(^|\\s)" + Qe + "\\S+", "g"), Ve = l({}, zn.Default, {
            placement: "right",
            trigger: "click",
            content: "",
            template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }), Ye = l({}, zn.DefaultType, {content: "(string|element|function)"}), ze = "fade", Ze = ".popover-header", Ge = ".popover-body", $e = {
            HIDE: "hide" + Ke,
            HIDDEN: "hidden" + Ke,
            SHOW: (Je = "show") + Ke,
            SHOWN: "shown" + Ke,
            INSERTED: "inserted" + Ke,
            CLICK: "click" + Ke,
            FOCUSIN: "focusin" + Ke,
            FOCUSOUT: "focusout" + Ke,
            MOUSEENTER: "mouseenter" + Ke,
            MOUSELEAVE: "mouseleave" + Ke
        }, Xe = function (t) {
            var e, n;

            function i() {
                return t.apply(this, arguments) || this
            }

            n = t, (e = i).prototype = Object.create(n.prototype), (e.prototype.constructor = e).__proto__ = n;
            var r = i.prototype;
            return r.isWithContent = function () {
                return this.getTitle() || this._getContent()
            }, r.addAttachmentClass = function (t) {
                Ue(this.getTipElement()).addClass(Qe + "-" + t)
            }, r.getTipElement = function () {
                return this.tip = this.tip || Ue(this.config.template)[0], this.tip
            }, r.setContent = function () {
                var t = Ue(this.getTipElement());
                this.setElementContent(t.find(Ze), this.getTitle());
                var e = this._getContent();
                "function" == typeof e && (e = e.call(this.element)), this.setElementContent(t.find(Ge), e), t.removeClass(ze + " " + Je)
            }, r._getContent = function () {
                return this.element.getAttribute("data-content") || this.config.content
            }, r._cleanTipClass = function () {
                var t = Ue(this.getTipElement()), e = t.attr("class").match(Be);
                null !== e && 0 < e.length && t.removeClass(e.join(""))
            }, i._jQueryInterface = function (n) {
                return this.each(function () {
                    var t = Ue(this).data(Fe), e = "object" == typeof n ? n : null;
                    if ((t || !/destroy|hide/.test(n)) && (t || (t = new i(this, e), Ue(this).data(Fe, t)), "string" == typeof n)) {
                        if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
                        t[n]()
                    }
                })
            }, s(i, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }, {
                key: "Default", get: function () {
                    return Ve
                }
            }, {
                key: "NAME", get: function () {
                    return qe
                }
            }, {
                key: "DATA_KEY", get: function () {
                    return Fe
                }
            }, {
                key: "Event", get: function () {
                    return $e
                }
            }, {
                key: "EVENT_KEY", get: function () {
                    return Ke
                }
            }, {
                key: "DefaultType", get: function () {
                    return Ye
                }
            }]), i
        }(zn), Ue.fn[qe] = Xe._jQueryInterface, Ue.fn[qe].Constructor = Xe, Ue.fn[qe].noConflict = function () {
            return Ue.fn[qe] = Me, Xe._jQueryInterface
        }, Xe), Zn = (en = "scrollspy", rn = "." + (nn = "bs.scrollspy"), on = (tn = e).fn[en], sn = {
            offset: 10,
            method: "auto",
            target: ""
        }, an = {offset: "number", method: "string", target: "(string|element)"}, ln = {
            ACTIVATE: "activate" + rn,
            SCROLL: "scroll" + rn,
            LOAD_DATA_API: "load" + rn + ".data-api"
        }, cn = "dropdown-item", hn = "active", un = '[data-spy="scroll"]', fn = ".active", dn = ".nav, .list-group", gn = ".nav-link", _n = ".nav-item", mn = ".list-group-item", pn = ".dropdown", vn = ".dropdown-item", yn = ".dropdown-toggle", En = "offset", Cn = "position", Tn = function () {
            function n(t, e) {
                var n = this;
                this._element = t, this._scrollElement = "BODY" === t.tagName ? window : t, this._config = this._getConfig(e), this._selector = this._config.target + " " + gn + "," + this._config.target + " " + mn + "," + this._config.target + " " + vn, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, tn(this._scrollElement).on(ln.SCROLL, function (t) {
                    return n._process(t)
                }), this.refresh(), this._process()
            }

            var t = n.prototype;
            return t.refresh = function () {
                var e = this, t = this._scrollElement === this._scrollElement.window ? En : Cn,
                    r = "auto" === this._config.method ? t : this._config.method, o = r === Cn ? this._getScrollTop() : 0;
                this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map(function (t) {
                    var e, n = Fn.getSelectorFromElement(t);
                    if (n && (e = document.querySelector(n)), e) {
                        var i = e.getBoundingClientRect();
                        if (i.width || i.height) return [tn(e)[r]().top + o, n]
                    }
                    return null
                }).filter(function (t) {
                    return t
                }).sort(function (t, e) {
                    return t[0] - e[0]
                }).forEach(function (t) {
                    e._offsets.push(t[0]), e._targets.push(t[1])
                })
            }, t.dispose = function () {
                tn.removeData(this._element, nn), tn(this._scrollElement).off(rn), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null
            }, t._getConfig = function (t) {
                if ("string" != typeof(t = l({}, sn, "object" == typeof t && t ? t : {})).target) {
                    var e = tn(t.target).attr("id");
                    e || (e = Fn.getUID(en), tn(t.target).attr("id", e)), t.target = "#" + e
                }
                return Fn.typeCheckConfig(en, t, an), t
            }, t._getScrollTop = function () {
                return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
            }, t._getScrollHeight = function () {
                return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
            }, t._getOffsetHeight = function () {
                return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
            }, t._process = function () {
                var t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(),
                    n = this._config.offset + e - this._getOffsetHeight();
                if (this._scrollHeight !== e && this.refresh(), n <= t) {
                    var i = this._targets[this._targets.length - 1];
                    this._activeTarget !== i && this._activate(i)
                } else {
                    if (this._activeTarget && t < this._offsets[0] && 0 < this._offsets[0]) return this._activeTarget = null, void this._clear();
                    for (var r = this._offsets.length; r--;) {
                        this._activeTarget !== this._targets[r] && t >= this._offsets[r] && ("undefined" == typeof this._offsets[r + 1] || t < this._offsets[r + 1]) && this._activate(this._targets[r])
                    }
                }
            }, t._activate = function (e) {
                this._activeTarget = e, this._clear();
                var t = this._selector.split(",");
                t = t.map(function (t) {
                    return t + '[data-target="' + e + '"],' + t + '[href="' + e + '"]'
                });
                var n = tn([].slice.call(document.querySelectorAll(t.join(","))));
                n.hasClass(cn) ? (n.closest(pn).find(yn).addClass(hn), n.addClass(hn)) : (n.addClass(hn), n.parents(dn).prev(gn + ", " + mn).addClass(hn), n.parents(dn).prev(_n).children(gn).addClass(hn)), tn(this._scrollElement).trigger(ln.ACTIVATE, {relatedTarget: e})
            }, t._clear = function () {
                var t = [].slice.call(document.querySelectorAll(this._selector));
                tn(t).filter(fn).removeClass(hn)
            }, n._jQueryInterface = function (e) {
                return this.each(function () {
                    var t = tn(this).data(nn);
                    if (t || (t = new n(this, "object" == typeof e && e), tn(this).data(nn, t)), "string" == typeof e) {
                        if ("undefined" == typeof t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e]()
                    }
                })
            }, s(n, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }, {
                key: "Default", get: function () {
                    return sn
                }
            }]), n
        }(), tn(window).on(ln.LOAD_DATA_API, function () {
            for (var t = [].slice.call(document.querySelectorAll(un)), e = t.length; e--;) {
                var n = tn(t[e]);
                Tn._jQueryInterface.call(n, n.data())
            }
        }), tn.fn[en] = Tn._jQueryInterface, tn.fn[en].Constructor = Tn, tn.fn[en].noConflict = function () {
            return tn.fn[en] = on, Tn._jQueryInterface
        }, Tn), Gn = (In = "." + (Sn = "bs.tab"), An = (bn = e).fn.tab, Dn = {
            HIDE: "hide" + In,
            HIDDEN: "hidden" + In,
            SHOW: "show" + In,
            SHOWN: "shown" + In,
            CLICK_DATA_API: "click" + In + ".data-api"
        }, wn = "dropdown-menu", Nn = "active", On = "disabled", kn = "fade", Pn = "show", jn = ".dropdown", Hn = ".nav, .list-group", Ln = ".active", Rn = "> li > .active", xn = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]', Wn = ".dropdown-toggle", Un = "> .dropdown-menu .active", qn = function () {
            function i(t) {
                this._element = t
            }

            var t = i.prototype;
            return t.show = function () {
                var n = this;
                if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && bn(this._element).hasClass(Nn) || bn(this._element).hasClass(On))) {
                    var t, i, e = bn(this._element).closest(Hn)[0], r = Fn.getSelectorFromElement(this._element);
                    if (e) {
                        var o = "UL" === e.nodeName ? Rn : Ln;
                        i = (i = bn.makeArray(bn(e).find(o)))[i.length - 1]
                    }
                    var s = bn.Event(Dn.HIDE, {relatedTarget: this._element}), a = bn.Event(Dn.SHOW, {relatedTarget: i});
                    if (i && bn(i).trigger(s), bn(this._element).trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) {
                        r && (t = document.querySelector(r)), this._activate(this._element, e);
                        var l = function () {
                            var t = bn.Event(Dn.HIDDEN, {relatedTarget: n._element}),
                                e = bn.Event(Dn.SHOWN, {relatedTarget: i});
                            bn(i).trigger(t), bn(n._element).trigger(e)
                        };
                        t ? this._activate(t, t.parentNode, l) : l()
                    }
                }
            }, t.dispose = function () {
                bn.removeData(this._element, Sn), this._element = null
            }, t._activate = function (t, e, n) {
                var i = this, r = ("UL" === e.nodeName ? bn(e).find(Rn) : bn(e).children(Ln))[0],
                    o = n && r && bn(r).hasClass(kn), s = function () {
                        return i._transitionComplete(t, r, n)
                    };
                if (r && o) {
                    var a = Fn.getTransitionDurationFromElement(r);
                    bn(r).one(Fn.TRANSITION_END, s).emulateTransitionEnd(a)
                } else s()
            }, t._transitionComplete = function (t, e, n) {
                if (e) {
                    bn(e).removeClass(Pn + " " + Nn);
                    var i = bn(e.parentNode).find(Un)[0];
                    i && bn(i).removeClass(Nn), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1)
                }
                if (bn(t).addClass(Nn), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), Fn.reflow(t), bn(t).addClass(Pn), t.parentNode && bn(t.parentNode).hasClass(wn)) {
                    var r = bn(t).closest(jn)[0];
                    if (r) {
                        var o = [].slice.call(r.querySelectorAll(Wn));
                        bn(o).addClass(Nn)
                    }
                    t.setAttribute("aria-expanded", !0)
                }
                n && n()
            }, i._jQueryInterface = function (n) {
                return this.each(function () {
                    var t = bn(this), e = t.data(Sn);
                    if (e || (e = new i(this), t.data(Sn, e)), "string" == typeof n) {
                        if ("undefined" == typeof e[n]) throw new TypeError('No method named "' + n + '"');
                        e[n]()
                    }
                })
            }, s(i, null, [{
                key: "VERSION", get: function () {
                    return "4.1.3"
                }
            }]), i
        }(), bn(document).on(Dn.CLICK_DATA_API, xn, function (t) {
            t.preventDefault(), qn._jQueryInterface.call(bn(this), "show")
        }), bn.fn.tab = qn._jQueryInterface, bn.fn.tab.Constructor = qn, bn.fn.tab.noConflict = function () {
            return bn.fn.tab = An, qn._jQueryInterface
        }, qn);
    !function (t) {
        if ("undefined" == typeof t) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
        var e = t.fn.jquery.split(" ")[0].split(".");
        if (e[0] < 2 && e[1] < 9 || 1 === e[0] && 9 === e[1] && e[2] < 1 || 4 <= e[0]) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")
    }(e), t.Util = Fn, t.Alert = Kn, t.Button = Mn, t.Carousel = Qn, t.Collapse = Bn, t.Dropdown = Vn, t.Modal = Yn, t.Popover = Jn, t.Scrollspy = Zn, t.Tab = Gn, t.Tooltip = zn, Object.defineProperty(t, "__esModule", {value: !0})
});

/*!
 * JavaScript Cookie v2.2.0
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
    var registeredInModuleLoader = false;
    if (typeof define === 'function' && define.amd) {
        define(factory);
        registeredInModuleLoader = true;
    }
    if (typeof exports === 'object') {
        module.exports = factory();
        registeredInModuleLoader = true;
    }
    if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();
        api.noConflict = function () {
            window.Cookies = OldCookies;
            return api;
        };
    }
}(function () {
    function extend() {
        var i = 0;
        var result = {};
        for (; i < arguments.length; i++) {
            var attributes = arguments[i];
            for (var key in attributes) {
                result[key] = attributes[key];
            }
        }
        return result;
    }

    function init(converter) {
        function api(key, value, attributes) {
            var result;
            if (typeof document === 'undefined') {
                return;
            }

            // Write

            if (arguments.length > 1) {
                attributes = extend({
                    path: '/'
                }, api.defaults, attributes);

                if (typeof attributes.expires === 'number') {
                    var expires = new Date();
                    expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
                    attributes.expires = expires;
                }

                // We're using "expires" because "max-age" is not supported by IE
                attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

                try {
                    result = JSON.stringify(value);
                    if (/^[\{\[]/.test(result)) {
                        value = result;
                    }
                } catch (e) {
                }

                if (!converter.write) {
                    value = encodeURIComponent(String(value))
                        .replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
                } else {
                    value = converter.write(value, key);
                }

                key = encodeURIComponent(String(key));
                key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
                key = key.replace(/[\(\)]/g, escape);

                var stringifiedAttributes = '';

                for (var attributeName in attributes) {
                    if (!attributes[attributeName]) {
                        continue;
                    }
                    stringifiedAttributes += '; ' + attributeName;
                    if (attributes[attributeName] === true) {
                        continue;
                    }
                    stringifiedAttributes += '=' + attributes[attributeName];
                }
                return (document.cookie = key + '=' + value + stringifiedAttributes);
            }

            // Read

            if (!key) {
                result = {};
            }

            // To prevent the for loop in the first place assign an empty array
            // in case there are no cookies at all. Also prevents odd result when
            // calling "get()"
            var cookies = document.cookie ? document.cookie.split('; ') : [];
            var rdecode = /(%[0-9A-Z]{2})+/g;
            var i = 0;

            for (; i < cookies.length; i++) {
                var parts = cookies[i].split('=');
                var cookie = parts.slice(1).join('=');

                if (!this.json && cookie.charAt(0) === '"') {
                    cookie = cookie.slice(1, -1);
                }

                try {
                    var name = parts[0].replace(rdecode, decodeURIComponent);
                    cookie = converter.read ?
                        converter.read(cookie, name) : converter(cookie, name) ||
                        cookie.replace(rdecode, decodeURIComponent);

                    if (this.json) {
                        try {
                            cookie = JSON.parse(cookie);
                        } catch (e) {
                        }
                    }

                    if (key === name) {
                        result = cookie;
                        break;
                    }

                    if (!key) {
                        result[name] = cookie;
                    }
                } catch (e) {
                }
            }

            return result;
        }

        api.set = api;
        api.get = function (key) {
            return api.call(api, key);
        };
        api.getJSON = function () {
            return api.apply({
                json: true
            }, [].slice.call(arguments));
        };
        api.defaults = {};

        api.remove = function (key, attributes) {
            api(key, '', extend(attributes, {
                expires: -1
            }));
        };

        api.withConverter = init;

        return api;
    }

    return init(function () {
    });
}));

!function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.moment = t()
}(this, function () {
    "use strict";
    var e, i;

    function c() {
        return e.apply(null, arguments)
    }

    function o(e) {
        return e instanceof Array || "[object Array]" === Object.prototype.toString.call(e)
    }

    function u(e) {
        return null != e && "[object Object]" === Object.prototype.toString.call(e)
    }

    function l(e) {
        return void 0 === e
    }

    function d(e) {
        return "number" == typeof e || "[object Number]" === Object.prototype.toString.call(e)
    }

    function h(e) {
        return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e)
    }

    function f(e, t) {
        var n, s = [];
        for (n = 0; n < e.length; ++n) s.push(t(e[n], n));
        return s
    }

    function m(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }

    function _(e, t) {
        for (var n in t) m(t, n) && (e[n] = t[n]);
        return m(t, "toString") && (e.toString = t.toString), m(t, "valueOf") && (e.valueOf = t.valueOf), e
    }

    function y(e, t, n, s) {
        return Ot(e, t, n, s, !0).utc()
    }

    function g(e) {
        return null == e._pf && (e._pf = {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: !1,
            weekdayMismatch: !1
        }), e._pf
    }

    function p(e) {
        if (null == e._isValid) {
            var t = g(e), n = i.call(t.parsedDateParts, function (e) {
                    return null != e
                }),
                s = !isNaN(e._d.getTime()) && t.overflow < 0 && !t.empty && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n);
            if (e._strict && (s = s && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour), null != Object.isFrozen && Object.isFrozen(e)) return s;
            e._isValid = s
        }
        return e._isValid
    }

    function v(e) {
        var t = y(NaN);
        return null != e ? _(g(t), e) : g(t).userInvalidated = !0, t
    }

    i = Array.prototype.some ? Array.prototype.some : function (e) {
        for (var t = Object(this), n = t.length >>> 0, s = 0; s < n; s++) if (s in t && e.call(this, t[s], s, t)) return !0;
        return !1
    };
    var r = c.momentProperties = [];

    function w(e, t) {
        var n, s, i;
        if (l(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), l(t._i) || (e._i = t._i), l(t._f) || (e._f = t._f), l(t._l) || (e._l = t._l), l(t._strict) || (e._strict = t._strict), l(t._tzm) || (e._tzm = t._tzm), l(t._isUTC) || (e._isUTC = t._isUTC), l(t._offset) || (e._offset = t._offset), l(t._pf) || (e._pf = g(t)), l(t._locale) || (e._locale = t._locale), 0 < r.length) for (n = 0; n < r.length; n++) l(i = t[s = r[n]]) || (e[s] = i);
        return e
    }

    var t = !1;

    function M(e) {
        w(this, e), this._d = new Date(null != e._d ? e._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === t && (t = !0, c.updateOffset(this), t = !1)
    }

    function S(e) {
        return e instanceof M || null != e && null != e._isAMomentObject
    }

    function D(e) {
        return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
    }

    function k(e) {
        var t = +e, n = 0;
        return 0 !== t && isFinite(t) && (n = D(t)), n
    }

    function a(e, t, n) {
        var s, i = Math.min(e.length, t.length), r = Math.abs(e.length - t.length), a = 0;
        for (s = 0; s < i; s++) (n && e[s] !== t[s] || !n && k(e[s]) !== k(t[s])) && a++;
        return a + r
    }

    function Y(e) {
        !1 === c.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e)
    }

    function n(i, r) {
        var a = !0;
        return _(function () {
            if (null != c.deprecationHandler && c.deprecationHandler(null, i), a) {
                for (var e, t = [], n = 0; n < arguments.length; n++) {
                    if (e = "", "object" == typeof arguments[n]) {
                        for (var s in e += "\n[" + n + "] ", arguments[0]) e += s + ": " + arguments[0][s] + ", ";
                        e = e.slice(0, -2)
                    } else e = arguments[n];
                    t.push(e)
                }
                Y(i + "\nArguments: " + Array.prototype.slice.call(t).join("") + "\n" + (new Error).stack), a = !1
            }
            return r.apply(this, arguments)
        }, r)
    }

    var s, O = {};

    function T(e, t) {
        null != c.deprecationHandler && c.deprecationHandler(e, t), O[e] || (Y(t), O[e] = !0)
    }

    function x(e) {
        return e instanceof Function || "[object Function]" === Object.prototype.toString.call(e)
    }

    function b(e, t) {
        var n, s = _({}, e);
        for (n in t) m(t, n) && (u(e[n]) && u(t[n]) ? (s[n] = {}, _(s[n], e[n]), _(s[n], t[n])) : null != t[n] ? s[n] = t[n] : delete s[n]);
        for (n in e) m(e, n) && !m(t, n) && u(e[n]) && (s[n] = _({}, s[n]));
        return s
    }

    function P(e) {
        null != e && this.set(e)
    }

    c.suppressDeprecationWarnings = !1, c.deprecationHandler = null, s = Object.keys ? Object.keys : function (e) {
        var t, n = [];
        for (t in e) m(e, t) && n.push(t);
        return n
    };
    var W = {};

    function H(e, t) {
        var n = e.toLowerCase();
        W[n] = W[n + "s"] = W[t] = e
    }

    function R(e) {
        return "string" == typeof e ? W[e] || W[e.toLowerCase()] : void 0
    }

    function C(e) {
        var t, n, s = {};
        for (n in e) m(e, n) && (t = R(n)) && (s[t] = e[n]);
        return s
    }

    var F = {};

    function L(e, t) {
        F[e] = t
    }

    function U(e, t, n) {
        var s = "" + Math.abs(e), i = t - s.length;
        return (0 <= e ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + s
    }

    var N = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        G = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, V = {}, E = {};

    function I(e, t, n, s) {
        var i = s;
        "string" == typeof s && (i = function () {
            return this[s]()
        }), e && (E[e] = i), t && (E[t[0]] = function () {
            return U(i.apply(this, arguments), t[1], t[2])
        }), n && (E[n] = function () {
            return this.localeData().ordinal(i.apply(this, arguments), e)
        })
    }

    function A(e, t) {
        return e.isValid() ? (t = j(t, e.localeData()), V[t] = V[t] || function (s) {
            var e, i, t, r = s.match(N);
            for (e = 0, i = r.length; e < i; e++) E[r[e]] ? r[e] = E[r[e]] : r[e] = (t = r[e]).match(/\[[\s\S]/) ? t.replace(/^\[|\]$/g, "") : t.replace(/\\/g, "");
            return function (e) {
                var t, n = "";
                for (t = 0; t < i; t++) n += x(r[t]) ? r[t].call(e, s) : r[t];
                return n
            }
        }(t), V[t](e)) : e.localeData().invalidDate()
    }

    function j(e, t) {
        var n = 5;

        function s(e) {
            return t.longDateFormat(e) || e
        }

        for (G.lastIndex = 0; 0 <= n && G.test(e);) e = e.replace(G, s), G.lastIndex = 0, n -= 1;
        return e
    }

    var Z = /\d/, z = /\d\d/, $ = /\d{3}/, q = /\d{4}/, J = /[+-]?\d{6}/, B = /\d\d?/, Q = /\d\d\d\d?/,
        X = /\d\d\d\d\d\d?/, K = /\d{1,3}/, ee = /\d{1,4}/, te = /[+-]?\d{1,6}/, ne = /\d+/, se = /[+-]?\d+/,
        ie = /Z|[+-]\d\d:?\d\d/gi, re = /Z|[+-]\d\d(?::?\d\d)?/gi,
        ae = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        oe = {};

    function ue(e, n, s) {
        oe[e] = x(n) ? n : function (e, t) {
            return e && s ? s : n
        }
    }

    function le(e, t) {
        return m(oe, e) ? oe[e](t._strict, t._locale) : new RegExp(de(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (e, t, n, s, i) {
            return t || n || s || i
        })))
    }

    function de(e) {
        return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
    }

    var he = {};

    function ce(e, n) {
        var t, s = n;
        for ("string" == typeof e && (e = [e]), d(n) && (s = function (e, t) {
            t[n] = k(e)
        }), t = 0; t < e.length; t++) he[e[t]] = s
    }

    function fe(e, i) {
        ce(e, function (e, t, n, s) {
            n._w = n._w || {}, i(e, n._w, n, s)
        })
    }

    var me = 0, _e = 1, ye = 2, ge = 3, pe = 4, ve = 5, we = 6, Me = 7, Se = 8;

    function De(e) {
        return ke(e) ? 366 : 365
    }

    function ke(e) {
        return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
    }

    I("Y", 0, 0, function () {
        var e = this.year();
        return e <= 9999 ? "" + e : "+" + e
    }), I(0, ["YY", 2], 0, function () {
        return this.year() % 100
    }), I(0, ["YYYY", 4], 0, "year"), I(0, ["YYYYY", 5], 0, "year"), I(0, ["YYYYYY", 6, !0], 0, "year"), H("year", "y"), L("year", 1), ue("Y", se), ue("YY", B, z), ue("YYYY", ee, q), ue("YYYYY", te, J), ue("YYYYYY", te, J), ce(["YYYYY", "YYYYYY"], me), ce("YYYY", function (e, t) {
        t[me] = 2 === e.length ? c.parseTwoDigitYear(e) : k(e)
    }), ce("YY", function (e, t) {
        t[me] = c.parseTwoDigitYear(e)
    }), ce("Y", function (e, t) {
        t[me] = parseInt(e, 10)
    }), c.parseTwoDigitYear = function (e) {
        return k(e) + (68 < k(e) ? 1900 : 2e3)
    };
    var Ye, Oe = Te("FullYear", !0);

    function Te(t, n) {
        return function (e) {
            return null != e ? (be(this, t, e), c.updateOffset(this, n), this) : xe(this, t)
        }
    }

    function xe(e, t) {
        return e.isValid() ? e._d["get" + (e._isUTC ? "UTC" : "") + t]() : NaN
    }

    function be(e, t, n) {
        e.isValid() && !isNaN(n) && ("FullYear" === t && ke(e.year()) && 1 === e.month() && 29 === e.date() ? e._d["set" + (e._isUTC ? "UTC" : "") + t](n, e.month(), Pe(n, e.month())) : e._d["set" + (e._isUTC ? "UTC" : "") + t](n))
    }

    function Pe(e, t) {
        if (isNaN(e) || isNaN(t)) return NaN;
        var n, s = (t % (n = 12) + n) % n;
        return e += (t - s) / 12, 1 === s ? ke(e) ? 29 : 28 : 31 - s % 7 % 2
    }

    Ye = Array.prototype.indexOf ? Array.prototype.indexOf : function (e) {
        var t;
        for (t = 0; t < this.length; ++t) if (this[t] === e) return t;
        return -1
    }, I("M", ["MM", 2], "Mo", function () {
        return this.month() + 1
    }), I("MMM", 0, 0, function (e) {
        return this.localeData().monthsShort(this, e)
    }), I("MMMM", 0, 0, function (e) {
        return this.localeData().months(this, e)
    }), H("month", "M"), L("month", 8), ue("M", B), ue("MM", B, z), ue("MMM", function (e, t) {
        return t.monthsShortRegex(e)
    }), ue("MMMM", function (e, t) {
        return t.monthsRegex(e)
    }), ce(["M", "MM"], function (e, t) {
        t[_e] = k(e) - 1
    }), ce(["MMM", "MMMM"], function (e, t, n, s) {
        var i = n._locale.monthsParse(e, s, n._strict);
        null != i ? t[_e] = i : g(n).invalidMonth = e
    });
    var We = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        He = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
    var Re = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");

    function Ce(e, t) {
        var n;
        if (!e.isValid()) return e;
        if ("string" == typeof t) if (/^\d+$/.test(t)) t = k(t); else if (!d(t = e.localeData().monthsParse(t))) return e;
        return n = Math.min(e.date(), Pe(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n), e
    }

    function Fe(e) {
        return null != e ? (Ce(this, e), c.updateOffset(this, !0), this) : xe(this, "Month")
    }

    var Le = ae;
    var Ue = ae;

    function Ne() {
        function e(e, t) {
            return t.length - e.length
        }

        var t, n, s = [], i = [], r = [];
        for (t = 0; t < 12; t++) n = y([2e3, t]), s.push(this.monthsShort(n, "")), i.push(this.months(n, "")), r.push(this.months(n, "")), r.push(this.monthsShort(n, ""));
        for (s.sort(e), i.sort(e), r.sort(e), t = 0; t < 12; t++) s[t] = de(s[t]), i[t] = de(i[t]);
        for (t = 0; t < 24; t++) r[t] = de(r[t]);
        this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i")
    }

    function Ge(e) {
        var t = new Date(Date.UTC.apply(null, arguments));
        return e < 100 && 0 <= e && isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e), t
    }

    function Ve(e, t, n) {
        var s = 7 + t - n;
        return -((7 + Ge(e, 0, s).getUTCDay() - t) % 7) + s - 1
    }

    function Ee(e, t, n, s, i) {
        var r, a, o = 1 + 7 * (t - 1) + (7 + n - s) % 7 + Ve(e, s, i);
        return o <= 0 ? a = De(r = e - 1) + o : o > De(e) ? (r = e + 1, a = o - De(e)) : (r = e, a = o), {
            year: r,
            dayOfYear: a
        }
    }

    function Ie(e, t, n) {
        var s, i, r = Ve(e.year(), t, n), a = Math.floor((e.dayOfYear() - r - 1) / 7) + 1;
        return a < 1 ? s = a + Ae(i = e.year() - 1, t, n) : a > Ae(e.year(), t, n) ? (s = a - Ae(e.year(), t, n), i = e.year() + 1) : (i = e.year(), s = a), {
            week: s,
            year: i
        }
    }

    function Ae(e, t, n) {
        var s = Ve(e, t, n), i = Ve(e + 1, t, n);
        return (De(e) - s + i) / 7
    }

    I("w", ["ww", 2], "wo", "week"), I("W", ["WW", 2], "Wo", "isoWeek"), H("week", "w"), H("isoWeek", "W"), L("week", 5), L("isoWeek", 5), ue("w", B), ue("ww", B, z), ue("W", B), ue("WW", B, z), fe(["w", "ww", "W", "WW"], function (e, t, n, s) {
        t[s.substr(0, 1)] = k(e)
    });
    I("d", 0, "do", "day"), I("dd", 0, 0, function (e) {
        return this.localeData().weekdaysMin(this, e)
    }), I("ddd", 0, 0, function (e) {
        return this.localeData().weekdaysShort(this, e)
    }), I("dddd", 0, 0, function (e) {
        return this.localeData().weekdays(this, e)
    }), I("e", 0, 0, "weekday"), I("E", 0, 0, "isoWeekday"), H("day", "d"), H("weekday", "e"), H("isoWeekday", "E"), L("day", 11), L("weekday", 11), L("isoWeekday", 11), ue("d", B), ue("e", B), ue("E", B), ue("dd", function (e, t) {
        return t.weekdaysMinRegex(e)
    }), ue("ddd", function (e, t) {
        return t.weekdaysShortRegex(e)
    }), ue("dddd", function (e, t) {
        return t.weekdaysRegex(e)
    }), fe(["dd", "ddd", "dddd"], function (e, t, n, s) {
        var i = n._locale.weekdaysParse(e, s, n._strict);
        null != i ? t.d = i : g(n).invalidWeekday = e
    }), fe(["d", "e", "E"], function (e, t, n, s) {
        t[s] = k(e)
    });
    var je = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    var Ze = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    var ze = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    var $e = ae;
    var qe = ae;
    var Je = ae;

    function Be() {
        function e(e, t) {
            return t.length - e.length
        }

        var t, n, s, i, r, a = [], o = [], u = [], l = [];
        for (t = 0; t < 7; t++) n = y([2e3, 1]).day(t), s = this.weekdaysMin(n, ""), i = this.weekdaysShort(n, ""), r = this.weekdays(n, ""), a.push(s), o.push(i), u.push(r), l.push(s), l.push(i), l.push(r);
        for (a.sort(e), o.sort(e), u.sort(e), l.sort(e), t = 0; t < 7; t++) o[t] = de(o[t]), u[t] = de(u[t]), l[t] = de(l[t]);
        this._weekdaysRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + a.join("|") + ")", "i")
    }

    function Qe() {
        return this.hours() % 12 || 12
    }

    function Xe(e, t) {
        I(e, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), t)
        })
    }

    function Ke(e, t) {
        return t._meridiemParse
    }

    I("H", ["HH", 2], 0, "hour"), I("h", ["hh", 2], 0, Qe), I("k", ["kk", 2], 0, function () {
        return this.hours() || 24
    }), I("hmm", 0, 0, function () {
        return "" + Qe.apply(this) + U(this.minutes(), 2)
    }), I("hmmss", 0, 0, function () {
        return "" + Qe.apply(this) + U(this.minutes(), 2) + U(this.seconds(), 2)
    }), I("Hmm", 0, 0, function () {
        return "" + this.hours() + U(this.minutes(), 2)
    }), I("Hmmss", 0, 0, function () {
        return "" + this.hours() + U(this.minutes(), 2) + U(this.seconds(), 2)
    }), Xe("a", !0), Xe("A", !1), H("hour", "h"), L("hour", 13), ue("a", Ke), ue("A", Ke), ue("H", B), ue("h", B), ue("k", B), ue("HH", B, z), ue("hh", B, z), ue("kk", B, z), ue("hmm", Q), ue("hmmss", X), ue("Hmm", Q), ue("Hmmss", X), ce(["H", "HH"], ge), ce(["k", "kk"], function (e, t, n) {
        var s = k(e);
        t[ge] = 24 === s ? 0 : s
    }), ce(["a", "A"], function (e, t, n) {
        n._isPm = n._locale.isPM(e), n._meridiem = e
    }), ce(["h", "hh"], function (e, t, n) {
        t[ge] = k(e), g(n).bigHour = !0
    }), ce("hmm", function (e, t, n) {
        var s = e.length - 2;
        t[ge] = k(e.substr(0, s)), t[pe] = k(e.substr(s)), g(n).bigHour = !0
    }), ce("hmmss", function (e, t, n) {
        var s = e.length - 4, i = e.length - 2;
        t[ge] = k(e.substr(0, s)), t[pe] = k(e.substr(s, 2)), t[ve] = k(e.substr(i)), g(n).bigHour = !0
    }), ce("Hmm", function (e, t, n) {
        var s = e.length - 2;
        t[ge] = k(e.substr(0, s)), t[pe] = k(e.substr(s))
    }), ce("Hmmss", function (e, t, n) {
        var s = e.length - 4, i = e.length - 2;
        t[ge] = k(e.substr(0, s)), t[pe] = k(e.substr(s, 2)), t[ve] = k(e.substr(i))
    });
    var et, tt = Te("Hours", !0), nt = {
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY h:mm A",
            LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        invalidDate: "Invalid date",
        ordinal: "%d",
        dayOfMonthOrdinalParse: /\d{1,2}/,
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        months: He,
        monthsShort: Re,
        week: {dow: 0, doy: 6},
        weekdays: je,
        weekdaysMin: ze,
        weekdaysShort: Ze,
        meridiemParse: /[ap]\.?m?\.?/i
    }, st = {}, it = {};

    function rt(e) {
        return e ? e.toLowerCase().replace("_", "-") : e
    }

    function at(e) {
        var t = null;
        if (!st[e] && "undefined" != typeof module && module && module.exports) try {
            t = et._abbr, require("./locale/" + e), ot(t)
        } catch (e) {
        }
        return st[e]
    }

    function ot(e, t) {
        var n;
        return e && ((n = l(t) ? lt(e) : ut(e, t)) ? et = n : "undefined" != typeof console && console.warn && console.warn("Locale " + e + " not found. Did you forget to load it?")), et._abbr
    }

    function ut(e, t) {
        if (null !== t) {
            var n, s = nt;
            if (t.abbr = e, null != st[e]) T("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), s = st[e]._config; else if (null != t.parentLocale) if (null != st[t.parentLocale]) s = st[t.parentLocale]._config; else {
                if (null == (n = at(t.parentLocale))) return it[t.parentLocale] || (it[t.parentLocale] = []), it[t.parentLocale].push({
                    name: e,
                    config: t
                }), null;
                s = n._config
            }
            return st[e] = new P(b(s, t)), it[e] && it[e].forEach(function (e) {
                ut(e.name, e.config)
            }), ot(e), st[e]
        }
        return delete st[e], null
    }

    function lt(e) {
        var t;
        if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e) return et;
        if (!o(e)) {
            if (t = at(e)) return t;
            e = [e]
        }
        return function (e) {
            for (var t, n, s, i, r = 0; r < e.length;) {
                for (t = (i = rt(e[r]).split("-")).length, n = (n = rt(e[r + 1])) ? n.split("-") : null; 0 < t;) {
                    if (s = at(i.slice(0, t).join("-"))) return s;
                    if (n && n.length >= t && a(i, n, !0) >= t - 1) break;
                    t--
                }
                r++
            }
            return et
        }(e)
    }

    function dt(e) {
        var t, n = e._a;
        return n && -2 === g(e).overflow && (t = n[_e] < 0 || 11 < n[_e] ? _e : n[ye] < 1 || n[ye] > Pe(n[me], n[_e]) ? ye : n[ge] < 0 || 24 < n[ge] || 24 === n[ge] && (0 !== n[pe] || 0 !== n[ve] || 0 !== n[we]) ? ge : n[pe] < 0 || 59 < n[pe] ? pe : n[ve] < 0 || 59 < n[ve] ? ve : n[we] < 0 || 999 < n[we] ? we : -1, g(e)._overflowDayOfYear && (t < me || ye < t) && (t = ye), g(e)._overflowWeeks && -1 === t && (t = Me), g(e)._overflowWeekday && -1 === t && (t = Se), g(e).overflow = t), e
    }

    function ht(e, t, n) {
        return null != e ? e : null != t ? t : n
    }

    function ct(e) {
        var t, n, s, i, r, a = [];
        if (!e._d) {
            var o, u;
            for (o = e, u = new Date(c.now()), s = o._useUTC ? [u.getUTCFullYear(), u.getUTCMonth(), u.getUTCDate()] : [u.getFullYear(), u.getMonth(), u.getDate()], e._w && null == e._a[ye] && null == e._a[_e] && function (e) {
                var t, n, s, i, r, a, o, u;
                if (null != (t = e._w).GG || null != t.W || null != t.E) r = 1, a = 4, n = ht(t.GG, e._a[me], Ie(Tt(), 1, 4).year), s = ht(t.W, 1), ((i = ht(t.E, 1)) < 1 || 7 < i) && (u = !0); else {
                    r = e._locale._week.dow, a = e._locale._week.doy;
                    var l = Ie(Tt(), r, a);
                    n = ht(t.gg, e._a[me], l.year), s = ht(t.w, l.week), null != t.d ? ((i = t.d) < 0 || 6 < i) && (u = !0) : null != t.e ? (i = t.e + r, (t.e < 0 || 6 < t.e) && (u = !0)) : i = r
                }
                s < 1 || s > Ae(n, r, a) ? g(e)._overflowWeeks = !0 : null != u ? g(e)._overflowWeekday = !0 : (o = Ee(n, s, i, r, a), e._a[me] = o.year, e._dayOfYear = o.dayOfYear)
            }(e), null != e._dayOfYear && (r = ht(e._a[me], s[me]), (e._dayOfYear > De(r) || 0 === e._dayOfYear) && (g(e)._overflowDayOfYear = !0), n = Ge(r, 0, e._dayOfYear), e._a[_e] = n.getUTCMonth(), e._a[ye] = n.getUTCDate()), t = 0; t < 3 && null == e._a[t]; ++t) e._a[t] = a[t] = s[t];
            for (; t < 7; t++) e._a[t] = a[t] = null == e._a[t] ? 2 === t ? 1 : 0 : e._a[t];
            24 === e._a[ge] && 0 === e._a[pe] && 0 === e._a[ve] && 0 === e._a[we] && (e._nextDay = !0, e._a[ge] = 0), e._d = (e._useUTC ? Ge : function (e, t, n, s, i, r, a) {
                var o = new Date(e, t, n, s, i, r, a);
                return e < 100 && 0 <= e && isFinite(o.getFullYear()) && o.setFullYear(e), o
            }).apply(null, a), i = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), null != e._tzm && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[ge] = 24), e._w && void 0 !== e._w.d && e._w.d !== i && (g(e).weekdayMismatch = !0)
        }
    }

    var ft = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        mt = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        _t = /Z|[+-]\d\d(?::?\d\d)?/,
        yt = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/]],
        gt = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]],
        pt = /^\/?Date\((\-?\d+)/i;

    function vt(e) {
        var t, n, s, i, r, a, o = e._i, u = ft.exec(o) || mt.exec(o);
        if (u) {
            for (g(e).iso = !0, t = 0, n = yt.length; t < n; t++) if (yt[t][1].exec(u[1])) {
                i = yt[t][0], s = !1 !== yt[t][2];
                break
            }
            if (null == i) return void(e._isValid = !1);
            if (u[3]) {
                for (t = 0, n = gt.length; t < n; t++) if (gt[t][1].exec(u[3])) {
                    r = (u[2] || " ") + gt[t][0];
                    break
                }
                if (null == r) return void(e._isValid = !1)
            }
            if (!s && null != r) return void(e._isValid = !1);
            if (u[4]) {
                if (!_t.exec(u[4])) return void(e._isValid = !1);
                a = "Z"
            }
            e._f = i + (r || "") + (a || ""), kt(e)
        } else e._isValid = !1
    }

    var wt = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function Mt(e, t, n, s, i, r) {
        var a = [function (e) {
            var t = parseInt(e, 10);
            {
                if (t <= 49) return 2e3 + t;
                if (t <= 999) return 1900 + t
            }
            return t
        }(e), Re.indexOf(t), parseInt(n, 10), parseInt(s, 10), parseInt(i, 10)];
        return r && a.push(parseInt(r, 10)), a
    }

    var St = {UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480};

    function Dt(e) {
        var t, n, s,
            i = wt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
        if (i) {
            var r = Mt(i[4], i[3], i[2], i[5], i[6], i[7]);
            if (t = i[1], n = r, s = e, t && Ze.indexOf(t) !== new Date(n[0], n[1], n[2]).getDay() && (g(s).weekdayMismatch = !0, !(s._isValid = !1))) return;
            e._a = r, e._tzm = function (e, t, n) {
                if (e) return St[e];
                if (t) return 0;
                var s = parseInt(n, 10), i = s % 100;
                return (s - i) / 100 * 60 + i
            }(i[8], i[9], i[10]), e._d = Ge.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), g(e).rfc2822 = !0
        } else e._isValid = !1
    }

    function kt(e) {
        if (e._f !== c.ISO_8601) if (e._f !== c.RFC_2822) {
            e._a = [], g(e).empty = !0;
            var t, n, s, i, r, a, o, u, l = "" + e._i, d = l.length, h = 0;
            for (s = j(e._f, e._locale).match(N) || [], t = 0; t < s.length; t++) i = s[t], (n = (l.match(le(i, e)) || [])[0]) && (0 < (r = l.substr(0, l.indexOf(n))).length && g(e).unusedInput.push(r), l = l.slice(l.indexOf(n) + n.length), h += n.length), E[i] ? (n ? g(e).empty = !1 : g(e).unusedTokens.push(i), a = i, u = e, null != (o = n) && m(he, a) && he[a](o, u._a, u, a)) : e._strict && !n && g(e).unusedTokens.push(i);
            g(e).charsLeftOver = d - h, 0 < l.length && g(e).unusedInput.push(l), e._a[ge] <= 12 && !0 === g(e).bigHour && 0 < e._a[ge] && (g(e).bigHour = void 0), g(e).parsedDateParts = e._a.slice(0), g(e).meridiem = e._meridiem, e._a[ge] = function (e, t, n) {
                var s;
                if (null == n) return t;
                return null != e.meridiemHour ? e.meridiemHour(t, n) : (null != e.isPM && ((s = e.isPM(n)) && t < 12 && (t += 12), s || 12 !== t || (t = 0)), t)
            }(e._locale, e._a[ge], e._meridiem), ct(e), dt(e)
        } else Dt(e); else vt(e)
    }

    function Yt(e) {
        var t, n, s, i, r = e._i, a = e._f;
        return e._locale = e._locale || lt(e._l), null === r || void 0 === a && "" === r ? v({nullInput: !0}) : ("string" == typeof r && (e._i = r = e._locale.preparse(r)), S(r) ? new M(dt(r)) : (h(r) ? e._d = r : o(a) ? function (e) {
            var t, n, s, i, r;
            if (0 === e._f.length) return g(e).invalidFormat = !0, e._d = new Date(NaN);
            for (i = 0; i < e._f.length; i++) r = 0, t = w({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[i], kt(t), p(t) && (r += g(t).charsLeftOver, r += 10 * g(t).unusedTokens.length, g(t).score = r, (null == s || r < s) && (s = r, n = t));
            _(e, n || t)
        }(e) : a ? kt(e) : l(n = (t = e)._i) ? t._d = new Date(c.now()) : h(n) ? t._d = new Date(n.valueOf()) : "string" == typeof n ? (s = t, null === (i = pt.exec(s._i)) ? (vt(s), !1 === s._isValid && (delete s._isValid, Dt(s), !1 === s._isValid && (delete s._isValid, c.createFromInputFallback(s)))) : s._d = new Date(+i[1])) : o(n) ? (t._a = f(n.slice(0), function (e) {
            return parseInt(e, 10)
        }), ct(t)) : u(n) ? function (e) {
            if (!e._d) {
                var t = C(e._i);
                e._a = f([t.year, t.month, t.day || t.date, t.hour, t.minute, t.second, t.millisecond], function (e) {
                    return e && parseInt(e, 10)
                }), ct(e)
            }
        }(t) : d(n) ? t._d = new Date(n) : c.createFromInputFallback(t), p(e) || (e._d = null), e))
    }

    function Ot(e, t, n, s, i) {
        var r, a = {};
        return !0 !== n && !1 !== n || (s = n, n = void 0), (u(e) && function (e) {
            if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e).length;
            var t;
            for (t in e) if (e.hasOwnProperty(t)) return !1;
            return !0
        }(e) || o(e) && 0 === e.length) && (e = void 0), a._isAMomentObject = !0, a._useUTC = a._isUTC = i, a._l = n, a._i = e, a._f = t, a._strict = s, (r = new M(dt(Yt(a))))._nextDay && (r.add(1, "d"), r._nextDay = void 0), r
    }

    function Tt(e, t, n, s) {
        return Ot(e, t, n, s, !1)
    }

    c.createFromInputFallback = n("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (e) {
        e._d = new Date(e._i + (e._useUTC ? " UTC" : ""))
    }), c.ISO_8601 = function () {
    }, c.RFC_2822 = function () {
    };
    var xt = n("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
            var e = Tt.apply(null, arguments);
            return this.isValid() && e.isValid() ? e < this ? this : e : v()
        }),
        bt = n("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
            var e = Tt.apply(null, arguments);
            return this.isValid() && e.isValid() ? this < e ? this : e : v()
        });

    function Pt(e, t) {
        var n, s;
        if (1 === t.length && o(t[0]) && (t = t[0]), !t.length) return Tt();
        for (n = t[0], s = 1; s < t.length; ++s) t[s].isValid() && !t[s][e](n) || (n = t[s]);
        return n
    }

    var Wt = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

    function Ht(e) {
        var t = C(e), n = t.year || 0, s = t.quarter || 0, i = t.month || 0, r = t.week || 0, a = t.day || 0,
            o = t.hour || 0, u = t.minute || 0, l = t.second || 0, d = t.millisecond || 0;
        this._isValid = function (e) {
            for (var t in e) if (-1 === Ye.call(Wt, t) || null != e[t] && isNaN(e[t])) return !1;
            for (var n = !1, s = 0; s < Wt.length; ++s) if (e[Wt[s]]) {
                if (n) return !1;
                parseFloat(e[Wt[s]]) !== k(e[Wt[s]]) && (n = !0)
            }
            return !0
        }(t), this._milliseconds = +d + 1e3 * l + 6e4 * u + 1e3 * o * 60 * 60, this._days = +a + 7 * r, this._months = +i + 3 * s + 12 * n, this._data = {}, this._locale = lt(), this._bubble()
    }

    function Rt(e) {
        return e instanceof Ht
    }

    function Ct(e) {
        return e < 0 ? -1 * Math.round(-1 * e) : Math.round(e)
    }

    function Ft(e, n) {
        I(e, 0, 0, function () {
            var e = this.utcOffset(), t = "+";
            return e < 0 && (e = -e, t = "-"), t + U(~~(e / 60), 2) + n + U(~~e % 60, 2)
        })
    }

    Ft("Z", ":"), Ft("ZZ", ""), ue("Z", re), ue("ZZ", re), ce(["Z", "ZZ"], function (e, t, n) {
        n._useUTC = !0, n._tzm = Ut(re, e)
    });
    var Lt = /([\+\-]|\d\d)/gi;

    function Ut(e, t) {
        var n = (t || "").match(e);
        if (null === n) return null;
        var s = ((n[n.length - 1] || []) + "").match(Lt) || ["-", 0, 0], i = 60 * s[1] + k(s[2]);
        return 0 === i ? 0 : "+" === s[0] ? i : -i
    }

    function Nt(e, t) {
        var n, s;
        return t._isUTC ? (n = t.clone(), s = (S(e) || h(e) ? e.valueOf() : Tt(e).valueOf()) - n.valueOf(), n._d.setTime(n._d.valueOf() + s), c.updateOffset(n, !1), n) : Tt(e).local()
    }

    function Gt(e) {
        return 15 * -Math.round(e._d.getTimezoneOffset() / 15)
    }

    function Vt() {
        return !!this.isValid() && (this._isUTC && 0 === this._offset)
    }

    c.updateOffset = function () {
    };
    var Et = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
        It = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function At(e, t) {
        var n, s, i, r = e, a = null;
        return Rt(e) ? r = {
            ms: e._milliseconds,
            d: e._days,
            M: e._months
        } : d(e) ? (r = {}, t ? r[t] = e : r.milliseconds = e) : (a = Et.exec(e)) ? (n = "-" === a[1] ? -1 : 1, r = {
            y: 0,
            d: k(a[ye]) * n,
            h: k(a[ge]) * n,
            m: k(a[pe]) * n,
            s: k(a[ve]) * n,
            ms: k(Ct(1e3 * a[we])) * n
        }) : (a = It.exec(e)) ? (n = "-" === a[1] ? -1 : (a[1], 1), r = {
            y: jt(a[2], n),
            M: jt(a[3], n),
            w: jt(a[4], n),
            d: jt(a[5], n),
            h: jt(a[6], n),
            m: jt(a[7], n),
            s: jt(a[8], n)
        }) : null == r ? r = {} : "object" == typeof r && ("from" in r || "to" in r) && (i = function (e, t) {
            var n;
            if (!e.isValid() || !t.isValid()) return {milliseconds: 0, months: 0};
            t = Nt(t, e), e.isBefore(t) ? n = Zt(e, t) : ((n = Zt(t, e)).milliseconds = -n.milliseconds, n.months = -n.months);
            return n
        }(Tt(r.from), Tt(r.to)), (r = {}).ms = i.milliseconds, r.M = i.months), s = new Ht(r), Rt(e) && m(e, "_locale") && (s._locale = e._locale), s
    }

    function jt(e, t) {
        var n = e && parseFloat(e.replace(",", "."));
        return (isNaN(n) ? 0 : n) * t
    }

    function Zt(e, t) {
        var n = {milliseconds: 0, months: 0};
        return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n
    }

    function zt(s, i) {
        return function (e, t) {
            var n;
            return null === t || isNaN(+t) || (T(i, "moment()." + i + "(period, number) is deprecated. Please use moment()." + i + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), n = e, e = t, t = n), $t(this, At(e = "string" == typeof e ? +e : e, t), s), this
        }
    }

    function $t(e, t, n, s) {
        var i = t._milliseconds, r = Ct(t._days), a = Ct(t._months);
        e.isValid() && (s = null == s || s, a && Ce(e, xe(e, "Month") + a * n), r && be(e, "Date", xe(e, "Date") + r * n), i && e._d.setTime(e._d.valueOf() + i * n), s && c.updateOffset(e, r || a))
    }

    At.fn = Ht.prototype, At.invalid = function () {
        return At(NaN)
    };
    var qt = zt(1, "add"), Jt = zt(-1, "subtract");

    function Bt(e, t) {
        var n = 12 * (t.year() - e.year()) + (t.month() - e.month()), s = e.clone().add(n, "months");
        return -(n + (t - s < 0 ? (t - s) / (s - e.clone().add(n - 1, "months")) : (t - s) / (e.clone().add(n + 1, "months") - s))) || 0
    }

    function Qt(e) {
        var t;
        return void 0 === e ? this._locale._abbr : (null != (t = lt(e)) && (this._locale = t), this)
    }

    c.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", c.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    var Xt = n("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (e) {
        return void 0 === e ? this.localeData() : this.locale(e)
    });

    function Kt() {
        return this._locale
    }

    function en(e, t) {
        I(0, [e, e.length], 0, t)
    }

    function tn(e, t, n, s, i) {
        var r;
        return null == e ? Ie(this, s, i).year : ((r = Ae(e, s, i)) < t && (t = r), function (e, t, n, s, i) {
            var r = Ee(e, t, n, s, i), a = Ge(r.year, 0, r.dayOfYear);
            return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this
        }.call(this, e, t, n, s, i))
    }

    I(0, ["gg", 2], 0, function () {
        return this.weekYear() % 100
    }), I(0, ["GG", 2], 0, function () {
        return this.isoWeekYear() % 100
    }), en("gggg", "weekYear"), en("ggggg", "weekYear"), en("GGGG", "isoWeekYear"), en("GGGGG", "isoWeekYear"), H("weekYear", "gg"), H("isoWeekYear", "GG"), L("weekYear", 1), L("isoWeekYear", 1), ue("G", se), ue("g", se), ue("GG", B, z), ue("gg", B, z), ue("GGGG", ee, q), ue("gggg", ee, q), ue("GGGGG", te, J), ue("ggggg", te, J), fe(["gggg", "ggggg", "GGGG", "GGGGG"], function (e, t, n, s) {
        t[s.substr(0, 2)] = k(e)
    }), fe(["gg", "GG"], function (e, t, n, s) {
        t[s] = c.parseTwoDigitYear(e)
    }), I("Q", 0, "Qo", "quarter"), H("quarter", "Q"), L("quarter", 7), ue("Q", Z), ce("Q", function (e, t) {
        t[_e] = 3 * (k(e) - 1)
    }), I("D", ["DD", 2], "Do", "date"), H("date", "D"), L("date", 9), ue("D", B), ue("DD", B, z), ue("Do", function (e, t) {
        return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient
    }), ce(["D", "DD"], ye), ce("Do", function (e, t) {
        t[ye] = k(e.match(B)[0])
    });
    var nn = Te("Date", !0);
    I("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), H("dayOfYear", "DDD"), L("dayOfYear", 4), ue("DDD", K), ue("DDDD", $), ce(["DDD", "DDDD"], function (e, t, n) {
        n._dayOfYear = k(e)
    }), I("m", ["mm", 2], 0, "minute"), H("minute", "m"), L("minute", 14), ue("m", B), ue("mm", B, z), ce(["m", "mm"], pe);
    var sn = Te("Minutes", !1);
    I("s", ["ss", 2], 0, "second"), H("second", "s"), L("second", 15), ue("s", B), ue("ss", B, z), ce(["s", "ss"], ve);
    var rn, an = Te("Seconds", !1);
    for (I("S", 0, 0, function () {
        return ~~(this.millisecond() / 100)
    }), I(0, ["SS", 2], 0, function () {
        return ~~(this.millisecond() / 10)
    }), I(0, ["SSS", 3], 0, "millisecond"), I(0, ["SSSS", 4], 0, function () {
        return 10 * this.millisecond()
    }), I(0, ["SSSSS", 5], 0, function () {
        return 100 * this.millisecond()
    }), I(0, ["SSSSSS", 6], 0, function () {
        return 1e3 * this.millisecond()
    }), I(0, ["SSSSSSS", 7], 0, function () {
        return 1e4 * this.millisecond()
    }), I(0, ["SSSSSSSS", 8], 0, function () {
        return 1e5 * this.millisecond()
    }), I(0, ["SSSSSSSSS", 9], 0, function () {
        return 1e6 * this.millisecond()
    }), H("millisecond", "ms"), L("millisecond", 16), ue("S", K, Z), ue("SS", K, z), ue("SSS", K, $), rn = "SSSS"; rn.length <= 9; rn += "S") ue(rn, ne);

    function on(e, t) {
        t[we] = k(1e3 * ("0." + e))
    }

    for (rn = "S"; rn.length <= 9; rn += "S") ce(rn, on);
    var un = Te("Milliseconds", !1);
    I("z", 0, 0, "zoneAbbr"), I("zz", 0, 0, "zoneName");
    var ln = M.prototype;

    function dn(e) {
        return e
    }

    ln.add = qt, ln.calendar = function (e, t) {
        var n = e || Tt(), s = Nt(n, this).startOf("day"), i = c.calendarFormat(this, s) || "sameElse",
            r = t && (x(t[i]) ? t[i].call(this, n) : t[i]);
        return this.format(r || this.localeData().calendar(i, this, Tt(n)))
    }, ln.clone = function () {
        return new M(this)
    }, ln.diff = function (e, t, n) {
        var s, i, r;
        if (!this.isValid()) return NaN;
        if (!(s = Nt(e, this)).isValid()) return NaN;
        switch (i = 6e4 * (s.utcOffset() - this.utcOffset()), t = R(t)) {
            case"year":
                r = Bt(this, s) / 12;
                break;
            case"month":
                r = Bt(this, s);
                break;
            case"quarter":
                r = Bt(this, s) / 3;
                break;
            case"second":
                r = (this - s) / 1e3;
                break;
            case"minute":
                r = (this - s) / 6e4;
                break;
            case"hour":
                r = (this - s) / 36e5;
                break;
            case"day":
                r = (this - s - i) / 864e5;
                break;
            case"week":
                r = (this - s - i) / 6048e5;
                break;
            default:
                r = this - s
        }
        return n ? r : D(r)
    }, ln.endOf = function (e) {
        return void 0 === (e = R(e)) || "millisecond" === e ? this : ("date" === e && (e = "day"), this.startOf(e).add(1, "isoWeek" === e ? "week" : e).subtract(1, "ms"))
    }, ln.format = function (e) {
        e || (e = this.isUtc() ? c.defaultFormatUtc : c.defaultFormat);
        var t = A(this, e);
        return this.localeData().postformat(t)
    }, ln.from = function (e, t) {
        return this.isValid() && (S(e) && e.isValid() || Tt(e).isValid()) ? At({
            to: this,
            from: e
        }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
    }, ln.fromNow = function (e) {
        return this.from(Tt(), e)
    }, ln.to = function (e, t) {
        return this.isValid() && (S(e) && e.isValid() || Tt(e).isValid()) ? At({
            from: this,
            to: e
        }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
    }, ln.toNow = function (e) {
        return this.to(Tt(), e)
    }, ln.get = function (e) {
        return x(this[e = R(e)]) ? this[e]() : this
    }, ln.invalidAt = function () {
        return g(this).overflow
    }, ln.isAfter = function (e, t) {
        var n = S(e) ? e : Tt(e);
        return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = R(l(t) ? "millisecond" : t)) ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf())
    }, ln.isBefore = function (e, t) {
        var n = S(e) ? e : Tt(e);
        return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = R(l(t) ? "millisecond" : t)) ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf())
    }, ln.isBetween = function (e, t, n, s) {
        return ("(" === (s = s || "()")[0] ? this.isAfter(e, n) : !this.isBefore(e, n)) && (")" === s[1] ? this.isBefore(t, n) : !this.isAfter(t, n))
    }, ln.isSame = function (e, t) {
        var n, s = S(e) ? e : Tt(e);
        return !(!this.isValid() || !s.isValid()) && ("millisecond" === (t = R(t || "millisecond")) ? this.valueOf() === s.valueOf() : (n = s.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf()))
    }, ln.isSameOrAfter = function (e, t) {
        return this.isSame(e, t) || this.isAfter(e, t)
    }, ln.isSameOrBefore = function (e, t) {
        return this.isSame(e, t) || this.isBefore(e, t)
    }, ln.isValid = function () {
        return p(this)
    }, ln.lang = Xt, ln.locale = Qt, ln.localeData = Kt, ln.max = bt, ln.min = xt, ln.parsingFlags = function () {
        return _({}, g(this))
    }, ln.set = function (e, t) {
        if ("object" == typeof e) for (var n = function (e) {
            var t = [];
            for (var n in e) t.push({unit: n, priority: F[n]});
            return t.sort(function (e, t) {
                return e.priority - t.priority
            }), t
        }(e = C(e)), s = 0; s < n.length; s++) this[n[s].unit](e[n[s].unit]); else if (x(this[e = R(e)])) return this[e](t);
        return this
    }, ln.startOf = function (e) {
        switch (e = R(e)) {
            case"year":
                this.month(0);
            case"quarter":
            case"month":
                this.date(1);
            case"week":
            case"isoWeek":
            case"day":
            case"date":
                this.hours(0);
            case"hour":
                this.minutes(0);
            case"minute":
                this.seconds(0);
            case"second":
                this.milliseconds(0)
        }
        return "week" === e && this.weekday(0), "isoWeek" === e && this.isoWeekday(1), "quarter" === e && this.month(3 * Math.floor(this.month() / 3)), this
    }, ln.subtract = Jt, ln.toArray = function () {
        var e = this;
        return [e.year(), e.month(), e.date(), e.hour(), e.minute(), e.second(), e.millisecond()]
    }, ln.toObject = function () {
        var e = this;
        return {
            years: e.year(),
            months: e.month(),
            date: e.date(),
            hours: e.hours(),
            minutes: e.minutes(),
            seconds: e.seconds(),
            milliseconds: e.milliseconds()
        }
    }, ln.toDate = function () {
        return new Date(this.valueOf())
    }, ln.toISOString = function (e) {
        if (!this.isValid()) return null;
        var t = !0 !== e, n = t ? this.clone().utc() : this;
        return n.year() < 0 || 9999 < n.year() ? A(n, t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : x(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", A(n, "Z")) : A(n, t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
    }, ln.inspect = function () {
        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
        var e = "moment", t = "";
        this.isLocal() || (e = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", t = "Z");
        var n = "[" + e + '("]', s = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", i = t + '[")]';
        return this.format(n + s + "-MM-DD[T]HH:mm:ss.SSS" + i)
    }, ln.toJSON = function () {
        return this.isValid() ? this.toISOString() : null
    }, ln.toString = function () {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
    }, ln.unix = function () {
        return Math.floor(this.valueOf() / 1e3)
    }, ln.valueOf = function () {
        return this._d.valueOf() - 6e4 * (this._offset || 0)
    }, ln.creationData = function () {
        return {input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict}
    }, ln.year = Oe, ln.isLeapYear = function () {
        return ke(this.year())
    }, ln.weekYear = function (e) {
        return tn.call(this, e, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
    }, ln.isoWeekYear = function (e) {
        return tn.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
    }, ln.quarter = ln.quarters = function (e) {
        return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3)
    }, ln.month = Fe, ln.daysInMonth = function () {
        return Pe(this.year(), this.month())
    }, ln.week = ln.weeks = function (e) {
        var t = this.localeData().week(this);
        return null == e ? t : this.add(7 * (e - t), "d")
    }, ln.isoWeek = ln.isoWeeks = function (e) {
        var t = Ie(this, 1, 4).week;
        return null == e ? t : this.add(7 * (e - t), "d")
    }, ln.weeksInYear = function () {
        var e = this.localeData()._week;
        return Ae(this.year(), e.dow, e.doy)
    }, ln.isoWeeksInYear = function () {
        return Ae(this.year(), 1, 4)
    }, ln.date = nn, ln.day = ln.days = function (e) {
        if (!this.isValid()) return null != e ? this : NaN;
        var t, n, s = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        return null != e ? (t = e, n = this.localeData(), e = "string" != typeof t ? t : isNaN(t) ? "number" == typeof(t = n.weekdaysParse(t)) ? t : null : parseInt(t, 10), this.add(e - s, "d")) : s
    }, ln.weekday = function (e) {
        if (!this.isValid()) return null != e ? this : NaN;
        var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return null == e ? t : this.add(e - t, "d")
    }, ln.isoWeekday = function (e) {
        if (!this.isValid()) return null != e ? this : NaN;
        if (null != e) {
            var t = (n = e, s = this.localeData(), "string" == typeof n ? s.weekdaysParse(n) % 7 || 7 : isNaN(n) ? null : n);
            return this.day(this.day() % 7 ? t : t - 7)
        }
        return this.day() || 7;
        var n, s
    }, ln.dayOfYear = function (e) {
        var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return null == e ? t : this.add(e - t, "d")
    }, ln.hour = ln.hours = tt, ln.minute = ln.minutes = sn, ln.second = ln.seconds = an, ln.millisecond = ln.milliseconds = un, ln.utcOffset = function (e, t, n) {
        var s, i = this._offset || 0;
        if (!this.isValid()) return null != e ? this : NaN;
        if (null != e) {
            if ("string" == typeof e) {
                if (null === (e = Ut(re, e))) return this
            } else Math.abs(e) < 16 && !n && (e *= 60);
            return !this._isUTC && t && (s = Gt(this)), this._offset = e, this._isUTC = !0, null != s && this.add(s, "m"), i !== e && (!t || this._changeInProgress ? $t(this, At(e - i, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, c.updateOffset(this, !0), this._changeInProgress = null)), this
        }
        return this._isUTC ? i : Gt(this)
    }, ln.utc = function (e) {
        return this.utcOffset(0, e)
    }, ln.local = function (e) {
        return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Gt(this), "m")), this
    }, ln.parseZone = function () {
        if (null != this._tzm) this.utcOffset(this._tzm, !1, !0); else if ("string" == typeof this._i) {
            var e = Ut(ie, this._i);
            null != e ? this.utcOffset(e) : this.utcOffset(0, !0)
        }
        return this
    }, ln.hasAlignedHourOffset = function (e) {
        return !!this.isValid() && (e = e ? Tt(e).utcOffset() : 0, (this.utcOffset() - e) % 60 == 0)
    }, ln.isDST = function () {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
    }, ln.isLocal = function () {
        return !!this.isValid() && !this._isUTC
    }, ln.isUtcOffset = function () {
        return !!this.isValid() && this._isUTC
    }, ln.isUtc = Vt, ln.isUTC = Vt, ln.zoneAbbr = function () {
        return this._isUTC ? "UTC" : ""
    }, ln.zoneName = function () {
        return this._isUTC ? "Coordinated Universal Time" : ""
    }, ln.dates = n("dates accessor is deprecated. Use date instead.", nn), ln.months = n("months accessor is deprecated. Use month instead", Fe), ln.years = n("years accessor is deprecated. Use year instead", Oe), ln.zone = n("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (e, t) {
        return null != e ? ("string" != typeof e && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset()
    }), ln.isDSTShifted = n("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () {
        if (!l(this._isDSTShifted)) return this._isDSTShifted;
        var e = {};
        if (w(e, this), (e = Yt(e))._a) {
            var t = e._isUTC ? y(e._a) : Tt(e._a);
            this._isDSTShifted = this.isValid() && 0 < a(e._a, t.toArray())
        } else this._isDSTShifted = !1;
        return this._isDSTShifted
    });
    var hn = P.prototype;

    function cn(e, t, n, s) {
        var i = lt(), r = y().set(s, t);
        return i[n](r, e)
    }

    function fn(e, t, n) {
        if (d(e) && (t = e, e = void 0), e = e || "", null != t) return cn(e, t, n, "month");
        var s, i = [];
        for (s = 0; s < 12; s++) i[s] = cn(e, s, n, "month");
        return i
    }

    function mn(e, t, n, s) {
        "boolean" == typeof e ? d(t) && (n = t, t = void 0) : (t = e, e = !1, d(n = t) && (n = t, t = void 0)), t = t || "";
        var i, r = lt(), a = e ? r._week.dow : 0;
        if (null != n) return cn(t, (n + a) % 7, s, "day");
        var o = [];
        for (i = 0; i < 7; i++) o[i] = cn(t, (i + a) % 7, s, "day");
        return o
    }

    hn.calendar = function (e, t, n) {
        var s = this._calendar[e] || this._calendar.sameElse;
        return x(s) ? s.call(t, n) : s
    }, hn.longDateFormat = function (e) {
        var t = this._longDateFormat[e], n = this._longDateFormat[e.toUpperCase()];
        return t || !n ? t : (this._longDateFormat[e] = n.replace(/MMMM|MM|DD|dddd/g, function (e) {
            return e.slice(1)
        }), this._longDateFormat[e])
    }, hn.invalidDate = function () {
        return this._invalidDate
    }, hn.ordinal = function (e) {
        return this._ordinal.replace("%d", e)
    }, hn.preparse = dn, hn.postformat = dn, hn.relativeTime = function (e, t, n, s) {
        var i = this._relativeTime[n];
        return x(i) ? i(e, t, n, s) : i.replace(/%d/i, e)
    }, hn.pastFuture = function (e, t) {
        var n = this._relativeTime[0 < e ? "future" : "past"];
        return x(n) ? n(t) : n.replace(/%s/i, t)
    }, hn.set = function (e) {
        var t, n;
        for (n in e) x(t = e[n]) ? this[n] = t : this["_" + n] = t;
        this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
    }, hn.months = function (e, t) {
        return e ? o(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || We).test(t) ? "format" : "standalone"][e.month()] : o(this._months) ? this._months : this._months.standalone
    }, hn.monthsShort = function (e, t) {
        return e ? o(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[We.test(t) ? "format" : "standalone"][e.month()] : o(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
    }, hn.monthsParse = function (e, t, n) {
        var s, i, r;
        if (this._monthsParseExact) return function (e, t, n) {
            var s, i, r, a = e.toLocaleLowerCase();
            if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s) r = y([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[s] = this.months(r, "").toLocaleLowerCase();
            return n ? "MMM" === t ? -1 !== (i = Ye.call(this._shortMonthsParse, a)) ? i : null : -1 !== (i = Ye.call(this._longMonthsParse, a)) ? i : null : "MMM" === t ? -1 !== (i = Ye.call(this._shortMonthsParse, a)) ? i : -1 !== (i = Ye.call(this._longMonthsParse, a)) ? i : null : -1 !== (i = Ye.call(this._longMonthsParse, a)) ? i : -1 !== (i = Ye.call(this._shortMonthsParse, a)) ? i : null
        }.call(this, e, t, n);
        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) {
            if (i = y([2e3, s]), n && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[s] || (r = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[s] = new RegExp(r.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[s].test(e)) return s;
            if (n && "MMM" === t && this._shortMonthsParse[s].test(e)) return s;
            if (!n && this._monthsParse[s].test(e)) return s
        }
    }, hn.monthsRegex = function (e) {
        return this._monthsParseExact ? (m(this, "_monthsRegex") || Ne.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (m(this, "_monthsRegex") || (this._monthsRegex = Ue), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex)
    }, hn.monthsShortRegex = function (e) {
        return this._monthsParseExact ? (m(this, "_monthsRegex") || Ne.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (m(this, "_monthsShortRegex") || (this._monthsShortRegex = Le), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex)
    }, hn.week = function (e) {
        return Ie(e, this._week.dow, this._week.doy).week
    }, hn.firstDayOfYear = function () {
        return this._week.doy
    }, hn.firstDayOfWeek = function () {
        return this._week.dow
    }, hn.weekdays = function (e, t) {
        return e ? o(this._weekdays) ? this._weekdays[e.day()] : this._weekdays[this._weekdays.isFormat.test(t) ? "format" : "standalone"][e.day()] : o(this._weekdays) ? this._weekdays : this._weekdays.standalone
    }, hn.weekdaysMin = function (e) {
        return e ? this._weekdaysMin[e.day()] : this._weekdaysMin
    }, hn.weekdaysShort = function (e) {
        return e ? this._weekdaysShort[e.day()] : this._weekdaysShort
    }, hn.weekdaysParse = function (e, t, n) {
        var s, i, r;
        if (this._weekdaysParseExact) return function (e, t, n) {
            var s, i, r, a = e.toLocaleLowerCase();
            if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s) r = y([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(r, "").toLocaleLowerCase();
            return n ? "dddd" === t ? -1 !== (i = Ye.call(this._weekdaysParse, a)) ? i : null : "ddd" === t ? -1 !== (i = Ye.call(this._shortWeekdaysParse, a)) ? i : null : -1 !== (i = Ye.call(this._minWeekdaysParse, a)) ? i : null : "dddd" === t ? -1 !== (i = Ye.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ye.call(this._shortWeekdaysParse, a)) ? i : -1 !== (i = Ye.call(this._minWeekdaysParse, a)) ? i : null : "ddd" === t ? -1 !== (i = Ye.call(this._shortWeekdaysParse, a)) ? i : -1 !== (i = Ye.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ye.call(this._minWeekdaysParse, a)) ? i : null : -1 !== (i = Ye.call(this._minWeekdaysParse, a)) ? i : -1 !== (i = Ye.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ye.call(this._shortWeekdaysParse, a)) ? i : null
        }.call(this, e, t, n);
        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) {
            if (i = y([2e3, 1]).day(s), n && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp("^" + this.weekdays(i, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[s] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[s] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[s] || (r = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[s] = new RegExp(r.replace(".", ""), "i")), n && "dddd" === t && this._fullWeekdaysParse[s].test(e)) return s;
            if (n && "ddd" === t && this._shortWeekdaysParse[s].test(e)) return s;
            if (n && "dd" === t && this._minWeekdaysParse[s].test(e)) return s;
            if (!n && this._weekdaysParse[s].test(e)) return s
        }
    }, hn.weekdaysRegex = function (e) {
        return this._weekdaysParseExact ? (m(this, "_weekdaysRegex") || Be.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (m(this, "_weekdaysRegex") || (this._weekdaysRegex = $e), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex)
    }, hn.weekdaysShortRegex = function (e) {
        return this._weekdaysParseExact ? (m(this, "_weekdaysRegex") || Be.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (m(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = qe), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
    }, hn.weekdaysMinRegex = function (e) {
        return this._weekdaysParseExact ? (m(this, "_weekdaysRegex") || Be.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (m(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Je), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
    }, hn.isPM = function (e) {
        return "p" === (e + "").toLowerCase().charAt(0)
    }, hn.meridiem = function (e, t, n) {
        return 11 < e ? n ? "pm" : "PM" : n ? "am" : "AM"
    }, ot("en", {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function (e) {
            var t = e % 10;
            return e + (1 === k(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
        }
    }), c.lang = n("moment.lang is deprecated. Use moment.locale instead.", ot), c.langData = n("moment.langData is deprecated. Use moment.localeData instead.", lt);
    var _n = Math.abs;

    function yn(e, t, n, s) {
        var i = At(t, n);
        return e._milliseconds += s * i._milliseconds, e._days += s * i._days, e._months += s * i._months, e._bubble()
    }

    function gn(e) {
        return e < 0 ? Math.floor(e) : Math.ceil(e)
    }

    function pn(e) {
        return 4800 * e / 146097
    }

    function vn(e) {
        return 146097 * e / 4800
    }

    function wn(e) {
        return function () {
            return this.as(e)
        }
    }

    var Mn = wn("ms"), Sn = wn("s"), Dn = wn("m"), kn = wn("h"), Yn = wn("d"), On = wn("w"), Tn = wn("M"), xn = wn("y");

    function bn(e) {
        return function () {
            return this.isValid() ? this._data[e] : NaN
        }
    }

    var Pn = bn("milliseconds"), Wn = bn("seconds"), Hn = bn("minutes"), Rn = bn("hours"), Cn = bn("days"),
        Fn = bn("months"), Ln = bn("years");
    var Un = Math.round, Nn = {ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11};
    var Gn = Math.abs;

    function Vn(e) {
        return (0 < e) - (e < 0) || +e
    }

    function En() {
        if (!this.isValid()) return this.localeData().invalidDate();
        var e, t, n = Gn(this._milliseconds) / 1e3, s = Gn(this._days), i = Gn(this._months);
        t = D((e = D(n / 60)) / 60), n %= 60, e %= 60;
        var r = D(i / 12), a = i %= 12, o = s, u = t, l = e, d = n ? n.toFixed(3).replace(/\.?0+$/, "") : "",
            h = this.asSeconds();
        if (!h) return "P0D";
        var c = h < 0 ? "-" : "", f = Vn(this._months) !== Vn(h) ? "-" : "", m = Vn(this._days) !== Vn(h) ? "-" : "",
            _ = Vn(this._milliseconds) !== Vn(h) ? "-" : "";
        return c + "P" + (r ? f + r + "Y" : "") + (a ? f + a + "M" : "") + (o ? m + o + "D" : "") + (u || l || d ? "T" : "") + (u ? _ + u + "H" : "") + (l ? _ + l + "M" : "") + (d ? _ + d + "S" : "")
    }

    var In = Ht.prototype;
    return In.isValid = function () {
        return this._isValid
    }, In.abs = function () {
        var e = this._data;
        return this._milliseconds = _n(this._milliseconds), this._days = _n(this._days), this._months = _n(this._months), e.milliseconds = _n(e.milliseconds), e.seconds = _n(e.seconds), e.minutes = _n(e.minutes), e.hours = _n(e.hours), e.months = _n(e.months), e.years = _n(e.years), this
    }, In.add = function (e, t) {
        return yn(this, e, t, 1)
    }, In.subtract = function (e, t) {
        return yn(this, e, t, -1)
    }, In.as = function (e) {
        if (!this.isValid()) return NaN;
        var t, n, s = this._milliseconds;
        if ("month" === (e = R(e)) || "year" === e) return t = this._days + s / 864e5, n = this._months + pn(t), "month" === e ? n : n / 12;
        switch (t = this._days + Math.round(vn(this._months)), e) {
            case"week":
                return t / 7 + s / 6048e5;
            case"day":
                return t + s / 864e5;
            case"hour":
                return 24 * t + s / 36e5;
            case"minute":
                return 1440 * t + s / 6e4;
            case"second":
                return 86400 * t + s / 1e3;
            case"millisecond":
                return Math.floor(864e5 * t) + s;
            default:
                throw new Error("Unknown unit " + e)
        }
    }, In.asMilliseconds = Mn, In.asSeconds = Sn, In.asMinutes = Dn, In.asHours = kn, In.asDays = Yn, In.asWeeks = On, In.asMonths = Tn, In.asYears = xn, In.valueOf = function () {
        return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * k(this._months / 12) : NaN
    }, In._bubble = function () {
        var e, t, n, s, i, r = this._milliseconds, a = this._days, o = this._months, u = this._data;
        return 0 <= r && 0 <= a && 0 <= o || r <= 0 && a <= 0 && o <= 0 || (r += 864e5 * gn(vn(o) + a), o = a = 0), u.milliseconds = r % 1e3, e = D(r / 1e3), u.seconds = e % 60, t = D(e / 60), u.minutes = t % 60, n = D(t / 60), u.hours = n % 24, o += i = D(pn(a += D(n / 24))), a -= gn(vn(i)), s = D(o / 12), o %= 12, u.days = a, u.months = o, u.years = s, this
    }, In.clone = function () {
        return At(this)
    }, In.get = function (e) {
        return e = R(e), this.isValid() ? this[e + "s"]() : NaN
    }, In.milliseconds = Pn, In.seconds = Wn, In.minutes = Hn, In.hours = Rn, In.days = Cn, In.weeks = function () {
        return D(this.days() / 7)
    }, In.months = Fn, In.years = Ln, In.humanize = function (e) {
        if (!this.isValid()) return this.localeData().invalidDate();
        var t, n, s, i, r, a, o, u, l, d, h, c = this.localeData(),
            f = (n = !e, s = c, i = At(t = this).abs(), r = Un(i.as("s")), a = Un(i.as("m")), o = Un(i.as("h")), u = Un(i.as("d")), l = Un(i.as("M")), d = Un(i.as("y")), (h = r <= Nn.ss && ["s", r] || r < Nn.s && ["ss", r] || a <= 1 && ["m"] || a < Nn.m && ["mm", a] || o <= 1 && ["h"] || o < Nn.h && ["hh", o] || u <= 1 && ["d"] || u < Nn.d && ["dd", u] || l <= 1 && ["M"] || l < Nn.M && ["MM", l] || d <= 1 && ["y"] || ["yy", d])[2] = n, h[3] = 0 < +t, h[4] = s, function (e, t, n, s, i) {
                return i.relativeTime(t || 1, !!n, e, s)
            }.apply(null, h));
        return e && (f = c.pastFuture(+this, f)), c.postformat(f)
    }, In.toISOString = En, In.toString = En, In.toJSON = En, In.locale = Qt, In.localeData = Kt, In.toIsoString = n("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", En), In.lang = Xt, I("X", 0, 0, "unix"), I("x", 0, 0, "valueOf"), ue("x", se), ue("X", /[+-]?\d+(\.\d{1,3})?/), ce("X", function (e, t, n) {
        n._d = new Date(1e3 * parseFloat(e, 10))
    }), ce("x", function (e, t, n) {
        n._d = new Date(k(e))
    }), c.version = "2.22.2", e = Tt, c.fn = ln, c.min = function () {
        return Pt("isBefore", [].slice.call(arguments, 0))
    }, c.max = function () {
        return Pt("isAfter", [].slice.call(arguments, 0))
    }, c.now = function () {
        return Date.now ? Date.now() : +new Date
    }, c.utc = y, c.unix = function (e) {
        return Tt(1e3 * e)
    }, c.months = function (e, t) {
        return fn(e, t, "months")
    }, c.isDate = h, c.locale = ot, c.invalid = v, c.duration = At, c.isMoment = S, c.weekdays = function (e, t, n) {
        return mn(e, t, n, "weekdays")
    }, c.parseZone = function () {
        return Tt.apply(null, arguments).parseZone()
    }, c.localeData = lt, c.isDuration = Rt, c.monthsShort = function (e, t) {
        return fn(e, t, "monthsShort")
    }, c.weekdaysMin = function (e, t, n) {
        return mn(e, t, n, "weekdaysMin")
    }, c.defineLocale = ut, c.updateLocale = function (e, t) {
        if (null != t) {
            var n, s, i = nt;
            null != (s = at(e)) && (i = s._config), (n = new P(t = b(i, t))).parentLocale = st[e], st[e] = n, ot(e)
        } else null != st[e] && (null != st[e].parentLocale ? st[e] = st[e].parentLocale : null != st[e] && delete st[e]);
        return st[e]
    }, c.locales = function () {
        return s(st)
    }, c.weekdaysShort = function (e, t, n) {
        return mn(e, t, n, "weekdaysShort")
    }, c.normalizeUnits = R, c.relativeTimeRounding = function (e) {
        return void 0 === e ? Un : "function" == typeof e && (Un = e, !0)
    }, c.relativeTimeThreshold = function (e, t) {
        return void 0 !== Nn[e] && (void 0 === t ? Nn[e] : (Nn[e] = t, "s" === e && (Nn.ss = t - 1), !0))
    }, c.calendarFormat = function (e, t) {
        var n = e.diff(t, "days", !0);
        return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
    }, c.prototype = ln, c.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "YYYY-[W]WW",
        MONTH: "YYYY-MM"
    }, c
});
/*
 Copyright (C) Federico Zivolo 2018
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */
(function (a, b) {
    'object' == typeof exports && 'undefined' != typeof module ? module.exports = b(require('popper.js')) : 'function' == typeof define && define.amd ? define(['popper.js'], b) : a.Tooltip = b(a.Popper)
})(this, function (a) {
    'use strict';

    function b(a) {
        return a && '[object Function]' === {}.toString.call(a)
    }

    a = a && a.hasOwnProperty('default') ? a['default'] : a;
    var c = function (a, b) {
        if (!(a instanceof b)) throw new TypeError('Cannot call a class as a function')
    }, d = function () {
        function a(a, b) {
            for (var c, d = 0; d < b.length; d++) c = b[d], c.enumerable = c.enumerable || !1, c.configurable = !0, 'value' in c && (c.writable = !0), Object.defineProperty(a, c.key, c)
        }

        return function (b, c, d) {
            return c && a(b.prototype, c), d && a(b, d), b
        }
    }(), e = Object.assign || function (a) {
        for (var b, c = 1; c < arguments.length; c++) for (var d in b = arguments[c], b) Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d]);
        return a
    }, f = {
        container: !1,
        delay: 0,
        html: !1,
        placement: 'top',
        title: '',
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        offset: 0,
        arrowSelector: '.tooltip-arrow, .tooltip__arrow',
        innerSelector: '.tooltip-inner, .tooltip__inner'
    }, g = function () {
        function g(a, b) {
            c(this, g), h.call(this), b = e({}, f, b), a.jquery && (a = a[0]), this.reference = a, this.options = b;
            var d = 'string' == typeof b.trigger ? b.trigger.split(' ').filter(function (a) {
                return -1 !== ['click', 'hover', 'focus'].indexOf(a)
            }) : [];
            this._isOpen = !1, this._popperOptions = {}, this._setEventListeners(a, d, b)
        }

        return d(g, [{
            key: '_create', value: function (a, b, c, d) {
                var e = window.document.createElement('div');
                e.innerHTML = b.trim();
                var f = e.childNodes[0];
                f.id = 'tooltip_' + Math.random().toString(36).substr(2, 10), f.setAttribute('aria-hidden', 'false');
                var g = e.querySelector(this.options.innerSelector);
                return this._addTitleContent(a, c, d, g), f
            }
        }, {
            key: '_addTitleContent', value: function (a, c, d, e) {
                if (1 === c.nodeType || 11 === c.nodeType) d && e.appendChild(c); else if (b(c)) {
                    var f = c.call(a);
                    d ? e.innerHTML = f : e.textContent = f
                } else d ? e.innerHTML = c : e.textContent = c
            }
        }, {
            key: '_show', value: function (b, c) {
                if (this._isOpen && !this._isOpening) return this;
                if (this._isOpen = !0, this._tooltipNode) return this._tooltipNode.style.visibility = 'visible', this._tooltipNode.setAttribute('aria-hidden', 'false'), this.popperInstance.update(), this;
                var d = b.getAttribute('title') || c.title;
                if (!d) return this;
                var f = this._create(b, c.template, d, c.html);
                b.setAttribute('aria-describedby', f.id);
                var g = this._findContainer(c.container, b);
                return this._append(f, g), this._popperOptions = e({}, c.popperOptions, {placement: c.placement}), this._popperOptions.modifiers = e({}, this._popperOptions.modifiers, {
                    arrow: {element: this.options.arrowSelector},
                    offset: {offset: c.offset}
                }), c.boundariesElement && (this._popperOptions.modifiers.preventOverflow = {boundariesElement: c.boundariesElement}), this.popperInstance = new a(b, f, this._popperOptions), this._tooltipNode = f, this
            }
        }, {
            key: '_hide', value: function () {
                return this._isOpen ? (this._isOpen = !1, this._tooltipNode.style.visibility = 'hidden', this._tooltipNode.setAttribute('aria-hidden', 'true'), this) : this
            }
        }, {
            key: '_dispose', value: function () {
                var a = this;
                return this._events.forEach(function (b) {
                    var c = b.func, d = b.event;
                    a.reference.removeEventListener(d, c)
                }), this._events = [], this._tooltipNode && (this._hide(), this.popperInstance.destroy(), !this.popperInstance.options.removeOnDestroy && (this._tooltipNode.parentNode.removeChild(this._tooltipNode), this._tooltipNode = null)), this
            }
        }, {
            key: '_findContainer', value: function (a, b) {
                return 'string' == typeof a ? a = window.document.querySelector(a) : !1 === a && (a = b.parentNode), a
            }
        }, {
            key: '_append', value: function (a, b) {
                b.appendChild(a)
            }
        }, {
            key: '_setEventListeners', value: function (a, b, c) {
                var d = this, e = [], f = [];
                b.forEach(function (a) {
                    'hover' === a ? (e.push('mouseenter'), f.push('mouseleave')) : 'focus' === a ? (e.push('focus'), f.push('blur')) : 'click' === a ? (e.push('click'), f.push('click')) : void 0
                }), e.forEach(function (b) {
                    var e = function (b) {
                        !0 === d._isOpening || (b.usedByTooltip = !0, d._scheduleShow(a, c.delay, c, b))
                    };
                    d._events.push({event: b, func: e}), a.addEventListener(b, e)
                }), f.forEach(function (b) {
                    var f = function (b) {
                        !0 === b.usedByTooltip || d._scheduleHide(a, c.delay, c, b)
                    };
                    d._events.push({
                        event: b,
                        func: f
                    }), a.addEventListener(b, f), 'click' === b && c.closeOnClickOutside && document.addEventListener('mousedown', function (b) {
                        if (d._isOpening) {
                            var c = d.popperInstance.popper;
                            a.contains(b.target) || c.contains(b.target) || f(b)
                        }
                    }, !0)
                })
            }
        }, {
            key: '_scheduleShow', value: function (a, b, c) {
                var d = this;
                this._isOpening = !0;
                var e = b && b.show || b || 0;
                this._showTimeout = window.setTimeout(function () {
                    return d._show(a, c)
                }, e)
            }
        }, {
            key: '_scheduleHide', value: function (a, b, c, d) {
                var e = this;
                this._isOpening = !1;
                var f = b && b.hide || b || 0;
                window.setTimeout(function () {
                    if ((window.clearTimeout(e._showTimeout), !1 !== e._isOpen) && document.body.contains(e._tooltipNode)) {
                        if ('mouseleave' === d.type) {
                            var f = e._setTooltipNodeEvent(d, a, b, c);
                            if (f) return
                        }
                        e._hide(a, c)
                    }
                }, f)
            }
        }, {
            key: '_updateTitleContent', value: function (a) {
                if ('undefined' == typeof this._tooltipNode) return void('undefined' != typeof this.options.title && (this.options.title = a));
                var b = this._tooltipNode.parentNode.querySelector(this.options.innerSelector);
                this._clearTitleContent(b, this.options.html, this.reference.getAttribute('title') || this.options.title), this._addTitleContent(this.reference, a, this.options.html, b), this.options.title = a, this.popperInstance.update()
            }
        }, {
            key: '_clearTitleContent', value: function (a, b, c) {
                1 === c.nodeType || 11 === c.nodeType ? b && a.removeChild(c) : b ? a.innerHTML = '' : a.textContent = ''
            }
        }]), g
    }(), h = function () {
        var a = this;
        this.show = function () {
            return a._show(a.reference, a.options)
        }, this.hide = function () {
            return a._hide()
        }, this.dispose = function () {
            return a._dispose()
        }, this.toggle = function () {
            return a._isOpen ? a.hide() : a.show()
        }, this.updateTitleContent = function (b) {
            return a._updateTitleContent(b)
        }, this._events = [], this._setTooltipNodeEvent = function (b, c, d, e) {
            var f = b.relatedreference || b.toElement || b.relatedTarget;
            return !!a._tooltipNode.contains(f) && (a._tooltipNode.addEventListener(b.type, function d(f) {
                var g = f.relatedreference || f.toElement || f.relatedTarget;
                a._tooltipNode.removeEventListener(b.type, d), c.contains(g) || a._scheduleHide(c, e.delay, e, f)
            }), !0)
        }
    };
    return g
});


/*!
 * perfect-scrollbar v1.4.0
 * (c) 2018 Hyunje Jun
 * @license MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global.PerfectScrollbar = factory());
}(this, (function () {
    'use strict';

    function get(element) {
        return getComputedStyle(element);
    }

    function set(element, obj) {
        for (var key in obj) {
            var val = obj[key];
            if (typeof val === 'number') {
                val = val + "px";
            }
            element.style[key] = val;
        }
        return element;
    }

    function div(className) {
        var div = document.createElement('div');
        div.className = className;
        return div;
    }

    var elMatches =
        typeof Element !== 'undefined' &&
        (Element.prototype.matches ||
            Element.prototype.webkitMatchesSelector ||
            Element.prototype.mozMatchesSelector ||
            Element.prototype.msMatchesSelector);

    function matches(element, query) {
        if (!elMatches) {
            throw new Error('No element matching method supported');
        }

        return elMatches.call(element, query);
    }

    function remove(element) {
        if (element.remove) {
            element.remove();
        } else {
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
        }
    }

    function queryChildren(element, selector) {
        return Array.prototype.filter.call(element.children, function (child) {
                return matches(child, selector);
            }
        );
    }

    var cls = {
        main: 'ps',
        element: {
            thumb: function (x) {
                return ("ps__thumb-" + x);
            },
            rail: function (x) {
                return ("ps__rail-" + x);
            },
            consuming: 'ps__child--consume',
        },
        state: {
            focus: 'ps--focus',
            clicking: 'ps--clicking',
            active: function (x) {
                return ("ps--active-" + x);
            },
            scrolling: function (x) {
                return ("ps--scrolling-" + x);
            },
        },
    };

    /*
 * Helper methods
 */
    var scrollingClassTimeout = {x: null, y: null};

    function addScrollingClass(i, x) {
        var classList = i.element.classList;
        var className = cls.state.scrolling(x);

        if (classList.contains(className)) {
            clearTimeout(scrollingClassTimeout[x]);
        } else {
            classList.add(className);
        }
    }

    function removeScrollingClass(i, x) {
        scrollingClassTimeout[x] = setTimeout(
            function () {
                return i.isAlive && i.element.classList.remove(cls.state.scrolling(x));
            },
            i.settings.scrollingThreshold
        );
    }

    function setScrollingClassInstantly(i, x) {
        addScrollingClass(i, x);
        removeScrollingClass(i, x);
    }

    var EventElement = function EventElement(element) {
        this.element = element;
        this.handlers = {};
    };

    var prototypeAccessors = {isEmpty: {configurable: true}};

    EventElement.prototype.bind = function bind(eventName, handler) {
        if (typeof this.handlers[eventName] === 'undefined') {
            this.handlers[eventName] = [];
        }
        this.handlers[eventName].push(handler);
        this.element.addEventListener(eventName, handler, false);
    };

    EventElement.prototype.unbind = function unbind(eventName, target) {
        var this$1 = this;

        this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {
            if (target && handler !== target) {
                return true;
            }
            this$1.element.removeEventListener(eventName, handler, false);
            return false;
        });
    };

    EventElement.prototype.unbindAll = function unbindAll() {
        var this$1 = this;

        for (var name in this$1.handlers) {
            this$1.unbind(name);
        }
    };

    prototypeAccessors.isEmpty.get = function () {
        var this$1 = this;

        return Object.keys(this.handlers).every(
            function (key) {
                return this$1.handlers[key].length === 0;
            }
        );
    };

    Object.defineProperties(EventElement.prototype, prototypeAccessors);

    var EventManager = function EventManager() {
        this.eventElements = [];
    };

    EventManager.prototype.eventElement = function eventElement(element) {
        var ee = this.eventElements.filter(function (ee) {
            return ee.element === element;
        })[0];
        if (!ee) {
            ee = new EventElement(element);
            this.eventElements.push(ee);
        }
        return ee;
    };

    EventManager.prototype.bind = function bind(element, eventName, handler) {
        this.eventElement(element).bind(eventName, handler);
    };

    EventManager.prototype.unbind = function unbind(element, eventName, handler) {
        var ee = this.eventElement(element);
        ee.unbind(eventName, handler);

        if (ee.isEmpty) {
            // remove
            this.eventElements.splice(this.eventElements.indexOf(ee), 1);
        }
    };

    EventManager.prototype.unbindAll = function unbindAll() {
        this.eventElements.forEach(function (e) {
            return e.unbindAll();
        });
        this.eventElements = [];
    };

    EventManager.prototype.once = function once(element, eventName, handler) {
        var ee = this.eventElement(element);
        var onceHandler = function (evt) {
            ee.unbind(eventName, onceHandler);
            handler(evt);
        };
        ee.bind(eventName, onceHandler);
    };

    function createEvent(name) {
        if (typeof window.CustomEvent === 'function') {
            return new CustomEvent(name);
        } else {
            var evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(name, false, false, undefined);
            return evt;
        }
    }

    var processScrollDiff = function (
        i,
        axis,
        diff,
        useScrollingClass,
        forceFireReachEvent
    ) {
        if (useScrollingClass === void 0) useScrollingClass = true;
        if (forceFireReachEvent === void 0) forceFireReachEvent = false;

        var fields;
        if (axis === 'top') {
            fields = [
                'contentHeight',
                'containerHeight',
                'scrollTop',
                'y',
                'up',
                'down'];
        } else if (axis === 'left') {
            fields = [
                'contentWidth',
                'containerWidth',
                'scrollLeft',
                'x',
                'left',
                'right'];
        } else {
            throw new Error('A proper axis should be provided');
        }

        processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
    };

    function processScrollDiff$1(
        i,
        diff,
        ref,
        useScrollingClass,
        forceFireReachEvent
    ) {
        var contentHeight = ref[0];
        var containerHeight = ref[1];
        var scrollTop = ref[2];
        var y = ref[3];
        var up = ref[4];
        var down = ref[5];
        if (useScrollingClass === void 0) useScrollingClass = true;
        if (forceFireReachEvent === void 0) forceFireReachEvent = false;

        var element = i.element;

        // reset reach
        i.reach[y] = null;

        // 1 for subpixel rounding
        if (element[scrollTop] < 1) {
            i.reach[y] = 'start';
        }

        // 1 for subpixel rounding
        if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
            i.reach[y] = 'end';
        }

        if (diff) {
            element.dispatchEvent(createEvent(("ps-scroll-" + y)));

            if (diff < 0) {
                element.dispatchEvent(createEvent(("ps-scroll-" + up)));
            } else if (diff > 0) {
                element.dispatchEvent(createEvent(("ps-scroll-" + down)));
            }

            if (useScrollingClass) {
                setScrollingClassInstantly(i, y);
            }
        }

        if (i.reach[y] && (diff || forceFireReachEvent)) {
            element.dispatchEvent(createEvent(("ps-" + y + "-reach-" + (i.reach[y]))));
        }
    }

    function toInt(x) {
        return parseInt(x, 10) || 0;
    }

    function isEditable(el) {
        return (
            matches(el, 'input,[contenteditable]') ||
            matches(el, 'select,[contenteditable]') ||
            matches(el, 'textarea,[contenteditable]') ||
            matches(el, 'button,[contenteditable]')
        );
    }

    function outerWidth(element) {
        var styles = get(element);
        return (
            toInt(styles.width) +
            toInt(styles.paddingLeft) +
            toInt(styles.paddingRight) +
            toInt(styles.borderLeftWidth) +
            toInt(styles.borderRightWidth)
        );
    }

    var env = {
        isWebKit:
        typeof document !== 'undefined' &&
        'WebkitAppearance' in document.documentElement.style,
        supportsTouch:
        typeof window !== 'undefined' &&
        ('ontouchstart' in window ||
            (window.DocumentTouch && document instanceof window.DocumentTouch)),
        supportsIePointer:
        typeof navigator !== 'undefined' && navigator.msMaxTouchPoints,
        isChrome:
        typeof navigator !== 'undefined' &&
        /Chrome/i.test(navigator && navigator.userAgent),
    };

    var updateGeometry = function (i) {
        var element = i.element;
        var roundedScrollTop = Math.floor(element.scrollTop);

        i.containerWidth = element.clientWidth;
        i.containerHeight = element.clientHeight;
        i.contentWidth = element.scrollWidth;
        i.contentHeight = element.scrollHeight;

        if (!element.contains(i.scrollbarXRail)) {
            // clean up and append
            queryChildren(element, cls.element.rail('x')).forEach(function (el) {
                    return remove(el);
                }
            );
            element.appendChild(i.scrollbarXRail);
        }
        if (!element.contains(i.scrollbarYRail)) {
            // clean up and append
            queryChildren(element, cls.element.rail('y')).forEach(function (el) {
                    return remove(el);
                }
            );
            element.appendChild(i.scrollbarYRail);
        }

        if (
            !i.settings.suppressScrollX &&
            i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth
        ) {
            i.scrollbarXActive = true;
            i.railXWidth = i.containerWidth - i.railXMarginWidth;
            i.railXRatio = i.containerWidth / i.railXWidth;
            i.scrollbarXWidth = getThumbSize(
                i,
                toInt(i.railXWidth * i.containerWidth / i.contentWidth)
            );
            i.scrollbarXLeft = toInt(
                (i.negativeScrollAdjustment + element.scrollLeft) *
                (i.railXWidth - i.scrollbarXWidth) /
                (i.contentWidth - i.containerWidth)
            );
        } else {
            i.scrollbarXActive = false;
        }

        if (
            !i.settings.suppressScrollY &&
            i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight
        ) {
            i.scrollbarYActive = true;
            i.railYHeight = i.containerHeight - i.railYMarginHeight;
            i.railYRatio = i.containerHeight / i.railYHeight;
            i.scrollbarYHeight = getThumbSize(
                i,
                toInt(i.railYHeight * i.containerHeight / i.contentHeight)
            );
            i.scrollbarYTop = toInt(
                roundedScrollTop *
                (i.railYHeight - i.scrollbarYHeight) /
                (i.contentHeight - i.containerHeight)
            );
        } else {
            i.scrollbarYActive = false;
        }

        if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
            i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
        }
        if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
            i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
        }

        updateCss(element, i);

        if (i.scrollbarXActive) {
            element.classList.add(cls.state.active('x'));
        } else {
            element.classList.remove(cls.state.active('x'));
            i.scrollbarXWidth = 0;
            i.scrollbarXLeft = 0;
            element.scrollLeft = 0;
        }
        if (i.scrollbarYActive) {
            element.classList.add(cls.state.active('y'));
        } else {
            element.classList.remove(cls.state.active('y'));
            i.scrollbarYHeight = 0;
            i.scrollbarYTop = 0;
            element.scrollTop = 0;
        }
    };

    function getThumbSize(i, thumbSize) {
        if (i.settings.minScrollbarLength) {
            thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
        }
        if (i.settings.maxScrollbarLength) {
            thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
        }
        return thumbSize;
    }

    function updateCss(element, i) {
        var xRailOffset = {width: i.railXWidth};
        var roundedScrollTop = Math.floor(element.scrollTop);

        if (i.isRtl) {
            xRailOffset.left =
                i.negativeScrollAdjustment +
                element.scrollLeft +
                i.containerWidth -
                i.contentWidth;
        } else {
            xRailOffset.left = element.scrollLeft;
        }
        if (i.isScrollbarXUsingBottom) {
            xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
        } else {
            xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
        }
        set(i.scrollbarXRail, xRailOffset);

        var yRailOffset = {top: roundedScrollTop, height: i.railYHeight};
        if (i.isScrollbarYUsingRight) {
            if (i.isRtl) {
                yRailOffset.right =
                    i.contentWidth -
                    (i.negativeScrollAdjustment + element.scrollLeft) -
                    i.scrollbarYRight -
                    i.scrollbarYOuterWidth;
            } else {
                yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
            }
        } else {
            if (i.isRtl) {
                yRailOffset.left =
                    i.negativeScrollAdjustment +
                    element.scrollLeft +
                    i.containerWidth * 2 -
                    i.contentWidth -
                    i.scrollbarYLeft -
                    i.scrollbarYOuterWidth;
            } else {
                yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
            }
        }
        set(i.scrollbarYRail, yRailOffset);

        set(i.scrollbarX, {
            left: i.scrollbarXLeft,
            width: i.scrollbarXWidth - i.railBorderXWidth,
        });
        set(i.scrollbarY, {
            top: i.scrollbarYTop,
            height: i.scrollbarYHeight - i.railBorderYWidth,
        });
    }

    var clickRail = function (i) {
        i.event.bind(i.scrollbarY, 'mousedown', function (e) {
            return e.stopPropagation();
        });
        i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {
            var positionTop =
                e.pageY -
                window.pageYOffset -
                i.scrollbarYRail.getBoundingClientRect().top;
            var direction = positionTop > i.scrollbarYTop ? 1 : -1;

            i.element.scrollTop += direction * i.containerHeight;
            updateGeometry(i);

            e.stopPropagation();
        });

        i.event.bind(i.scrollbarX, 'mousedown', function (e) {
            return e.stopPropagation();
        });
        i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {
            var positionLeft =
                e.pageX -
                window.pageXOffset -
                i.scrollbarXRail.getBoundingClientRect().left;
            var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;

            i.element.scrollLeft += direction * i.containerWidth;
            updateGeometry(i);

            e.stopPropagation();
        });
    };

    var dragThumb = function (i) {
        bindMouseScrollHandler(i, [
            'containerWidth',
            'contentWidth',
            'pageX',
            'railXWidth',
            'scrollbarX',
            'scrollbarXWidth',
            'scrollLeft',
            'x',
            'scrollbarXRail']);
        bindMouseScrollHandler(i, [
            'containerHeight',
            'contentHeight',
            'pageY',
            'railYHeight',
            'scrollbarY',
            'scrollbarYHeight',
            'scrollTop',
            'y',
            'scrollbarYRail']);
    };

    function bindMouseScrollHandler(
        i,
        ref
    ) {
        var containerHeight = ref[0];
        var contentHeight = ref[1];
        var pageY = ref[2];
        var railYHeight = ref[3];
        var scrollbarY = ref[4];
        var scrollbarYHeight = ref[5];
        var scrollTop = ref[6];
        var y = ref[7];
        var scrollbarYRail = ref[8];

        var element = i.element;

        var startingScrollTop = null;
        var startingMousePageY = null;
        var scrollBy = null;

        function mouseMoveHandler(e) {
            element[scrollTop] =
                startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
            addScrollingClass(i, y);
            updateGeometry(i);

            e.stopPropagation();
            e.preventDefault();
        }

        function mouseUpHandler() {
            removeScrollingClass(i, y);
            i[scrollbarYRail].classList.remove(cls.state.clicking);
            i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
        }

        i.event.bind(i[scrollbarY], 'mousedown', function (e) {
            startingScrollTop = element[scrollTop];
            startingMousePageY = e[pageY];
            scrollBy =
                (i[contentHeight] - i[containerHeight]) /
                (i[railYHeight] - i[scrollbarYHeight]);

            i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
            i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

            i[scrollbarYRail].classList.add(cls.state.clicking);

            e.stopPropagation();
            e.preventDefault();
        });
    }

    var keyboard = function (i) {
        var element = i.element;

        var elementHovered = function () {
            return matches(element, ':hover');
        };
        var scrollbarFocused = function () {
            return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus');
        };

        function shouldPreventDefault(deltaX, deltaY) {
            var scrollTop = Math.floor(element.scrollTop);
            if (deltaX === 0) {
                if (!i.scrollbarYActive) {
                    return false;
                }
                if (
                    (scrollTop === 0 && deltaY > 0) ||
                    (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)
                ) {
                    return !i.settings.wheelPropagation;
                }
            }

            var scrollLeft = element.scrollLeft;
            if (deltaY === 0) {
                if (!i.scrollbarXActive) {
                    return false;
                }
                if (
                    (scrollLeft === 0 && deltaX < 0) ||
                    (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)
                ) {
                    return !i.settings.wheelPropagation;
                }
            }
            return true;
        }

        i.event.bind(i.ownerDocument, 'keydown', function (e) {
            if (
                (e.isDefaultPrevented && e.isDefaultPrevented()) ||
                e.defaultPrevented
            ) {
                return;
            }

            if (!elementHovered() && !scrollbarFocused()) {
                return;
            }

            var activeElement = document.activeElement
                ? document.activeElement
                : i.ownerDocument.activeElement;
            if (activeElement) {
                if (activeElement.tagName === 'IFRAME') {
                    activeElement = activeElement.contentDocument.activeElement;
                } else {
                    // go deeper if element is a webcomponent
                    while (activeElement.shadowRoot) {
                        activeElement = activeElement.shadowRoot.activeElement;
                    }
                }
                if (isEditable(activeElement)) {
                    return;
                }
            }

            var deltaX = 0;
            var deltaY = 0;

            switch (e.which) {
                case 37: // left
                    if (e.metaKey) {
                        deltaX = -i.contentWidth;
                    } else if (e.altKey) {
                        deltaX = -i.containerWidth;
                    } else {
                        deltaX = -30;
                    }
                    break;
                case 38: // up
                    if (e.metaKey) {
                        deltaY = i.contentHeight;
                    } else if (e.altKey) {
                        deltaY = i.containerHeight;
                    } else {
                        deltaY = 30;
                    }
                    break;
                case 39: // right
                    if (e.metaKey) {
                        deltaX = i.contentWidth;
                    } else if (e.altKey) {
                        deltaX = i.containerWidth;
                    } else {
                        deltaX = 30;
                    }
                    break;
                case 40: // down
                    if (e.metaKey) {
                        deltaY = -i.contentHeight;
                    } else if (e.altKey) {
                        deltaY = -i.containerHeight;
                    } else {
                        deltaY = -30;
                    }
                    break;
                case 32: // space bar
                    if (e.shiftKey) {
                        deltaY = i.containerHeight;
                    } else {
                        deltaY = -i.containerHeight;
                    }
                    break;
                case 33: // page up
                    deltaY = i.containerHeight;
                    break;
                case 34: // page down
                    deltaY = -i.containerHeight;
                    break;
                case 36: // home
                    deltaY = i.contentHeight;
                    break;
                case 35: // end
                    deltaY = -i.contentHeight;
                    break;
                default:
                    return;
            }

            if (i.settings.suppressScrollX && deltaX !== 0) {
                return;
            }
            if (i.settings.suppressScrollY && deltaY !== 0) {
                return;
            }

            element.scrollTop -= deltaY;
            element.scrollLeft += deltaX;
            updateGeometry(i);

            if (shouldPreventDefault(deltaX, deltaY)) {
                e.preventDefault();
            }
        });
    };

    var wheel = function (i) {
        var element = i.element;

        function shouldPreventDefault(deltaX, deltaY) {
            var roundedScrollTop = Math.floor(element.scrollTop);
            var isTop = element.scrollTop === 0;
            var isBottom =
                roundedScrollTop + element.offsetHeight === element.scrollHeight;
            var isLeft = element.scrollLeft === 0;
            var isRight =
                element.scrollLeft + element.offsetWidth === element.scrollWidth;

            var hitsBound;

            // pick axis with primary direction
            if (Math.abs(deltaY) > Math.abs(deltaX)) {
                hitsBound = isTop || isBottom;
            } else {
                hitsBound = isLeft || isRight;
            }

            return hitsBound ? !i.settings.wheelPropagation : true;
        }

        function getDeltaFromEvent(e) {
            var deltaX = e.deltaX;
            var deltaY = -1 * e.deltaY;

            if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {
                // OS X Safari
                deltaX = -1 * e.wheelDeltaX / 6;
                deltaY = e.wheelDeltaY / 6;
            }

            if (e.deltaMode && e.deltaMode === 1) {
                // Firefox in deltaMode 1: Line scrolling
                deltaX *= 10;
                deltaY *= 10;
            }

            if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {
                // IE in some mouse drivers
                deltaX = 0;
                deltaY = e.wheelDelta;
            }

            if (e.shiftKey) {
                // reverse axis with shift key
                return [-deltaY, -deltaX];
            }
            return [deltaX, deltaY];
        }

        function shouldBeConsumedByChild(target, deltaX, deltaY) {
            // FIXME: this is a workaround for <select> issue in FF and IE #571
            if (!env.isWebKit && element.querySelector('select:focus')) {
                return true;
            }

            if (!element.contains(target)) {
                return false;
            }

            var cursor = target;

            while (cursor && cursor !== element) {
                if (cursor.classList.contains(cls.element.consuming)) {
                    return true;
                }

                var style = get(cursor);
                var overflow = [style.overflow, style.overflowX, style.overflowY].join(
                    ''
                );

                // if scrollable
                if (overflow.match(/(scroll|auto)/)) {
                    var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
                    if (maxScrollTop > 0) {
                        if (
                            !(cursor.scrollTop === 0 && deltaY > 0) &&
                            !(cursor.scrollTop === maxScrollTop && deltaY < 0)
                        ) {
                            return true;
                        }
                    }
                    var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
                    if (maxScrollLeft > 0) {
                        if (
                            !(cursor.scrollLeft === 0 && deltaX < 0) &&
                            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)
                        ) {
                            return true;
                        }
                    }
                }

                cursor = cursor.parentNode;
            }

            return false;
        }

        function mousewheelHandler(e) {
            var ref = getDeltaFromEvent(e);
            var deltaX = ref[0];
            var deltaY = ref[1];

            if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
                return;
            }

            var shouldPrevent = false;
            if (!i.settings.useBothWheelAxes) {
                // deltaX will only be used for horizontal scrolling and deltaY will
                // only be used for vertical scrolling - this is the default
                element.scrollTop -= deltaY * i.settings.wheelSpeed;
                element.scrollLeft += deltaX * i.settings.wheelSpeed;
            } else if (i.scrollbarYActive && !i.scrollbarXActive) {
                // only vertical scrollbar is active and useBothWheelAxes option is
                // active, so let's scroll vertical bar using both mouse wheel axes
                if (deltaY) {
                    element.scrollTop -= deltaY * i.settings.wheelSpeed;
                } else {
                    element.scrollTop += deltaX * i.settings.wheelSpeed;
                }
                shouldPrevent = true;
            } else if (i.scrollbarXActive && !i.scrollbarYActive) {
                // useBothWheelAxes and only horizontal bar is active, so use both
                // wheel axes for horizontal bar
                if (deltaX) {
                    element.scrollLeft += deltaX * i.settings.wheelSpeed;
                } else {
                    element.scrollLeft -= deltaY * i.settings.wheelSpeed;
                }
                shouldPrevent = true;
            }

            updateGeometry(i);

            shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
            if (shouldPrevent && !e.ctrlKey) {
                e.stopPropagation();
                e.preventDefault();
            }
        }

        if (typeof window.onwheel !== 'undefined') {
            i.event.bind(element, 'wheel', mousewheelHandler);
        } else if (typeof window.onmousewheel !== 'undefined') {
            i.event.bind(element, 'mousewheel', mousewheelHandler);
        }
    };

    var touch = function (i) {
        if (!env.supportsTouch && !env.supportsIePointer) {
            return;
        }

        var element = i.element;

        function shouldPrevent(deltaX, deltaY) {
            var scrollTop = Math.floor(element.scrollTop);
            var scrollLeft = element.scrollLeft;
            var magnitudeX = Math.abs(deltaX);
            var magnitudeY = Math.abs(deltaY);

            if (magnitudeY > magnitudeX) {
                // user is perhaps trying to swipe up/down the page

                if (
                    (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight) ||
                    (deltaY > 0 && scrollTop === 0)
                ) {
                    // set prevent for mobile Chrome refresh
                    return window.scrollY === 0 && deltaY > 0 && env.isChrome;
                }
            } else if (magnitudeX > magnitudeY) {
                // user is perhaps trying to swipe left/right across the page

                if (
                    (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth) ||
                    (deltaX > 0 && scrollLeft === 0)
                ) {
                    return true;
                }
            }

            return true;
        }

        function applyTouchMove(differenceX, differenceY) {
            element.scrollTop -= differenceY;
            element.scrollLeft -= differenceX;

            updateGeometry(i);
        }

        var startOffset = {};
        var startTime = 0;
        var speed = {};
        var easingLoop = null;

        function getTouch(e) {
            if (e.targetTouches) {
                return e.targetTouches[0];
            } else {
                // Maybe IE pointer
                return e;
            }
        }

        function shouldHandle(e) {
            if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {
                return false;
            }
            if (e.targetTouches && e.targetTouches.length === 1) {
                return true;
            }
            if (
                e.pointerType &&
                e.pointerType !== 'mouse' &&
                e.pointerType !== e.MSPOINTER_TYPE_MOUSE
            ) {
                return true;
            }
            return false;
        }

        function touchStart(e) {
            if (!shouldHandle(e)) {
                return;
            }

            var touch = getTouch(e);

            startOffset.pageX = touch.pageX;
            startOffset.pageY = touch.pageY;

            startTime = new Date().getTime();

            if (easingLoop !== null) {
                clearInterval(easingLoop);
            }
        }

        function shouldBeConsumedByChild(target, deltaX, deltaY) {
            if (!element.contains(target)) {
                return false;
            }

            var cursor = target;

            while (cursor && cursor !== element) {
                if (cursor.classList.contains(cls.element.consuming)) {
                    return true;
                }

                var style = get(cursor);
                var overflow = [style.overflow, style.overflowX, style.overflowY].join(
                    ''
                );

                // if scrollable
                if (overflow.match(/(scroll|auto)/)) {
                    var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
                    if (maxScrollTop > 0) {
                        if (
                            !(cursor.scrollTop === 0 && deltaY > 0) &&
                            !(cursor.scrollTop === maxScrollTop && deltaY < 0)
                        ) {
                            return true;
                        }
                    }
                    var maxScrollLeft = cursor.scrollLeft - cursor.clientWidth;
                    if (maxScrollLeft > 0) {
                        if (
                            !(cursor.scrollLeft === 0 && deltaX < 0) &&
                            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)
                        ) {
                            return true;
                        }
                    }
                }

                cursor = cursor.parentNode;
            }

            return false;
        }

        function touchMove(e) {
            if (shouldHandle(e)) {
                var touch = getTouch(e);

                var currentOffset = {pageX: touch.pageX, pageY: touch.pageY};

                var differenceX = currentOffset.pageX - startOffset.pageX;
                var differenceY = currentOffset.pageY - startOffset.pageY;

                if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
                    return;
                }

                applyTouchMove(differenceX, differenceY);
                startOffset = currentOffset;

                var currentTime = new Date().getTime();

                var timeGap = currentTime - startTime;
                if (timeGap > 0) {
                    speed.x = differenceX / timeGap;
                    speed.y = differenceY / timeGap;
                    startTime = currentTime;
                }

                if (shouldPrevent(differenceX, differenceY)) {
                    e.preventDefault();
                }
            }
        }

        function touchEnd() {
            if (i.settings.swipeEasing) {
                clearInterval(easingLoop);
                easingLoop = setInterval(function () {
                    if (i.isInitialized) {
                        clearInterval(easingLoop);
                        return;
                    }

                    if (!speed.x && !speed.y) {
                        clearInterval(easingLoop);
                        return;
                    }

                    if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
                        clearInterval(easingLoop);
                        return;
                    }

                    applyTouchMove(speed.x * 30, speed.y * 30);

                    speed.x *= 0.8;
                    speed.y *= 0.8;
                }, 10);
            }
        }

        if (env.supportsTouch) {
            i.event.bind(element, 'touchstart', touchStart);
            i.event.bind(element, 'touchmove', touchMove);
            i.event.bind(element, 'touchend', touchEnd);
        } else if (env.supportsIePointer) {
            if (window.PointerEvent) {
                i.event.bind(element, 'pointerdown', touchStart);
                i.event.bind(element, 'pointermove', touchMove);
                i.event.bind(element, 'pointerup', touchEnd);
            } else if (window.MSPointerEvent) {
                i.event.bind(element, 'MSPointerDown', touchStart);
                i.event.bind(element, 'MSPointerMove', touchMove);
                i.event.bind(element, 'MSPointerUp', touchEnd);
            }
        }
    };

    var defaultSettings = function () {
        return ({
            handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],
            maxScrollbarLength: null,
            minScrollbarLength: null,
            scrollingThreshold: 1000,
            scrollXMarginOffset: 0,
            scrollYMarginOffset: 0,
            suppressScrollX: false,
            suppressScrollY: false,
            swipeEasing: true,
            useBothWheelAxes: false,
            wheelPropagation: true,
            wheelSpeed: 1,
        });
    };

    var handlers = {
        'click-rail': clickRail,
        'drag-thumb': dragThumb,
        keyboard: keyboard,
        wheel: wheel,
        touch: touch,
    };

    var PerfectScrollbar = function PerfectScrollbar(element, userSettings) {
        var this$1 = this;
        if (userSettings === void 0) userSettings = {};

        if (typeof element === 'string') {
            element = document.querySelector(element);
        }

        if (!element || !element.nodeName) {
            throw new Error('no element is specified to initialize PerfectScrollbar');
        }

        this.element = element;

        element.classList.add(cls.main);

        this.settings = defaultSettings();
        for (var key in userSettings) {
            this$1.settings[key] = userSettings[key];
        }

        this.containerWidth = null;
        this.containerHeight = null;
        this.contentWidth = null;
        this.contentHeight = null;

        var focus = function () {
            return element.classList.add(cls.state.focus);
        };
        var blur = function () {
            return element.classList.remove(cls.state.focus);
        };

        this.isRtl = get(element).direction === 'rtl';
        this.isNegativeScroll = (function () {
            var originalScrollLeft = element.scrollLeft;
            var result = null;
            element.scrollLeft = -1;
            result = element.scrollLeft < 0;
            element.scrollLeft = originalScrollLeft;
            return result;
        })();
        this.negativeScrollAdjustment = this.isNegativeScroll
            ? element.scrollWidth - element.clientWidth
            : 0;
        this.event = new EventManager();
        this.ownerDocument = element.ownerDocument || document;

        this.scrollbarXRail = div(cls.element.rail('x'));
        element.appendChild(this.scrollbarXRail);
        this.scrollbarX = div(cls.element.thumb('x'));
        this.scrollbarXRail.appendChild(this.scrollbarX);
        this.scrollbarX.setAttribute('tabindex', 0);
        this.event.bind(this.scrollbarX, 'focus', focus);
        this.event.bind(this.scrollbarX, 'blur', blur);
        this.scrollbarXActive = null;
        this.scrollbarXWidth = null;
        this.scrollbarXLeft = null;
        var railXStyle = get(this.scrollbarXRail);
        this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
        if (isNaN(this.scrollbarXBottom)) {
            this.isScrollbarXUsingBottom = false;
            this.scrollbarXTop = toInt(railXStyle.top);
        } else {
            this.isScrollbarXUsingBottom = true;
        }
        this.railBorderXWidth =
            toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
        // Set rail to display:block to calculate margins
        set(this.scrollbarXRail, {display: 'block'});
        this.railXMarginWidth =
            toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
        set(this.scrollbarXRail, {display: ''});
        this.railXWidth = null;
        this.railXRatio = null;

        this.scrollbarYRail = div(cls.element.rail('y'));
        element.appendChild(this.scrollbarYRail);
        this.scrollbarY = div(cls.element.thumb('y'));
        this.scrollbarYRail.appendChild(this.scrollbarY);
        this.scrollbarY.setAttribute('tabindex', 0);
        this.event.bind(this.scrollbarY, 'focus', focus);
        this.event.bind(this.scrollbarY, 'blur', blur);
        this.scrollbarYActive = null;
        this.scrollbarYHeight = null;
        this.scrollbarYTop = null;
        var railYStyle = get(this.scrollbarYRail);
        this.scrollbarYRight = parseInt(railYStyle.right, 10);
        if (isNaN(this.scrollbarYRight)) {
            this.isScrollbarYUsingRight = false;
            this.scrollbarYLeft = toInt(railYStyle.left);
        } else {
            this.isScrollbarYUsingRight = true;
        }
        this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
        this.railBorderYWidth =
            toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
        set(this.scrollbarYRail, {display: 'block'});
        this.railYMarginHeight =
            toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
        set(this.scrollbarYRail, {display: ''});
        this.railYHeight = null;
        this.railYRatio = null;

        this.reach = {
            x:
                element.scrollLeft <= 0
                    ? 'start'
                    : element.scrollLeft >= this.contentWidth - this.containerWidth
                    ? 'end'
                    : null,
            y:
                element.scrollTop <= 0
                    ? 'start'
                    : element.scrollTop >= this.contentHeight - this.containerHeight
                    ? 'end'
                    : null,
        };

        this.isAlive = true;

        this.settings.handlers.forEach(function (handlerName) {
            return handlers[handlerName](this$1);
        });

        this.lastScrollTop = Math.floor(element.scrollTop); // for onScroll only
        this.lastScrollLeft = element.scrollLeft; // for onScroll only
        this.event.bind(this.element, 'scroll', function (e) {
            return this$1.onScroll(e);
        });
        updateGeometry(this);
    };

    PerfectScrollbar.prototype.update = function update() {
        if (!this.isAlive) {
            return;
        }

        // Recalcuate negative scrollLeft adjustment
        this.negativeScrollAdjustment = this.isNegativeScroll
            ? this.element.scrollWidth - this.element.clientWidth
            : 0;

        // Recalculate rail margins
        set(this.scrollbarXRail, {display: 'block'});
        set(this.scrollbarYRail, {display: 'block'});
        this.railXMarginWidth =
            toInt(get(this.scrollbarXRail).marginLeft) +
            toInt(get(this.scrollbarXRail).marginRight);
        this.railYMarginHeight =
            toInt(get(this.scrollbarYRail).marginTop) +
            toInt(get(this.scrollbarYRail).marginBottom);

        // Hide scrollbars not to affect scrollWidth and scrollHeight
        set(this.scrollbarXRail, {display: 'none'});
        set(this.scrollbarYRail, {display: 'none'});

        updateGeometry(this);

        processScrollDiff(this, 'top', 0, false, true);
        processScrollDiff(this, 'left', 0, false, true);

        set(this.scrollbarXRail, {display: ''});
        set(this.scrollbarYRail, {display: ''});
    };

    PerfectScrollbar.prototype.onScroll = function onScroll(e) {
        if (!this.isAlive) {
            return;
        }

        updateGeometry(this);
        processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);
        processScrollDiff(
            this,
            'left',
            this.element.scrollLeft - this.lastScrollLeft
        );

        this.lastScrollTop = Math.floor(this.element.scrollTop);
        this.lastScrollLeft = this.element.scrollLeft;
    };

    PerfectScrollbar.prototype.destroy = function destroy() {
        if (!this.isAlive) {
            return;
        }

        this.event.unbindAll();
        remove(this.scrollbarX);
        remove(this.scrollbarY);
        remove(this.scrollbarXRail);
        remove(this.scrollbarYRail);
        this.removePsClasses();

        // unset elements
        this.element = null;
        this.scrollbarX = null;
        this.scrollbarY = null;
        this.scrollbarXRail = null;
        this.scrollbarYRail = null;

        this.isAlive = false;
    };

    PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
        this.element.className = this.element.className
            .split(' ')
            .filter(function (name) {
                return !name.match(/^ps([-_].+|)$/);
            })
            .join(' ');
    };

    return PerfectScrollbar;

})));

function _classCallCheck(t, i) {
    if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function")
}

var Sticky = function () {
    function t() {
        var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        _classCallCheck(this, t), this.selector = i, this.elements = [], this.version = "1.2.0", this.vp = this.getViewportSize(), this.body = document.querySelector("body"), this.options = {
            wrap: e.wrap || !1,
            marginTop: e.marginTop || 0,
            stickyFor: e.stickyFor || 0,
            stickyClass: e.stickyClass || null,
            stickyContainer: e.stickyContainer || "body"
        }, this.updateScrollTopPosition = this.updateScrollTopPosition.bind(this), this.updateScrollTopPosition(), window.addEventListener("load", this.updateScrollTopPosition), window.addEventListener("scroll", this.updateScrollTopPosition), this.run()
    }

    return t.prototype.run = function () {
        var t = this, i = setInterval(function () {
            if ("complete" === document.readyState) {
                clearInterval(i);
                var e = document.querySelectorAll(t.selector);
                t.forEach(e, function (i) {
                    return t.renderElement(i)
                })
            }
        }, 10)
    }, t.prototype.renderElement = function (t) {
        var i = this;
        t.sticky = {}, t.sticky.active = !1, t.sticky.marginTop = parseInt(t.getAttribute("data-margin-top")) || this.options.marginTop, t.sticky.stickyFor = parseInt(t.getAttribute("data-sticky-for")) || this.options.stickyFor, t.sticky.stickyClass = t.getAttribute("data-sticky-class") || this.options.stickyClass, t.sticky.wrap = !!t.hasAttribute("data-sticky-wrap") || this.options.wrap, t.sticky.stickyContainer = this.options.stickyContainer, t.sticky.container = this.getStickyContainer(t), t.sticky.container.rect = this.getRectangle(t.sticky.container), t.sticky.rect = this.getRectangle(t), "img" === t.tagName.toLowerCase() && (t.onload = function () {
            return t.sticky.rect = i.getRectangle(t)
        }), t.sticky.wrap && this.wrapElement(t), this.activate(t)
    }, t.prototype.wrapElement = function (t) {
        t.insertAdjacentHTML("beforebegin", "<span></span>"), t.previousSibling.appendChild(t)
    }, t.prototype.activate = function (t) {
        t.sticky.rect.top + t.sticky.rect.height < t.sticky.container.rect.top + t.sticky.container.rect.height && t.sticky.stickyFor < this.vp.width && !t.sticky.active && (t.sticky.active = !0), this.elements.indexOf(t) < 0 && this.elements.push(t), t.sticky.resizeEvent || (this.initResizeEvents(t), t.sticky.resizeEvent = !0), t.sticky.scrollEvent || (this.initScrollEvents(t), t.sticky.scrollEvent = !0), this.setPosition(t)
    }, t.prototype.initResizeEvents = function (t) {
        var i = this;
        t.sticky.resizeListener = function () {
            return i.onResizeEvents(t)
        }, window.addEventListener("resize", t.sticky.resizeListener)
    }, t.prototype.destroyResizeEvents = function (t) {
        window.removeEventListener("resize", t.sticky.resizeListener)
    }, t.prototype.onResizeEvents = function (t) {
        this.vp = this.getViewportSize(), t.sticky.rect = this.getRectangle(t), t.sticky.container.rect = this.getRectangle(t.sticky.container), t.sticky.rect.top + t.sticky.rect.height < t.sticky.container.rect.top + t.sticky.container.rect.height && t.sticky.stickyFor < this.vp.width && !t.sticky.active ? t.sticky.active = !0 : (t.sticky.rect.top + t.sticky.rect.height >= t.sticky.container.rect.top + t.sticky.container.rect.height || t.sticky.stickyFor >= this.vp.width && t.sticky.active) && (t.sticky.active = !1), this.setPosition(t)
    }, t.prototype.initScrollEvents = function (t) {
        var i = this;
        t.sticky.scrollListener = function () {
            return i.onScrollEvents(t)
        }, window.addEventListener("scroll", t.sticky.scrollListener)
    }, t.prototype.destroyScrollEvents = function (t) {
        window.removeEventListener("scroll", t.sticky.scrollListener)
    }, t.prototype.onScrollEvents = function (t) {
        t.sticky.active && this.setPosition(t)
    }, t.prototype.setPosition = function (t) {
        this.css(t, {
            position: "",
            width: "",
            top: "",
            left: ""
        }), this.vp.height < t.sticky.rect.height || !t.sticky.active || (t.sticky.rect.width || (t.sticky.rect = this.getRectangle(t)), t.sticky.wrap && this.css(t.parentNode, {
            display: "block",
            width: t.sticky.rect.width + "px",
            height: t.sticky.rect.height + "px"
        }), 0 === t.sticky.rect.top && t.sticky.container === this.body ? this.css(t, {
            position: "fixed",
            top: t.sticky.rect.top + "px",
            left: t.sticky.rect.left + "px",
            width: t.sticky.rect.width + "px"
        }) : this.scrollTop > t.sticky.rect.top - t.sticky.marginTop ? (this.css(t, {
            position: "fixed",
            width: t.sticky.rect.width + "px",
            left: t.sticky.rect.left + "px"
        }), this.scrollTop + t.sticky.rect.height + t.sticky.marginTop > t.sticky.container.rect.top + t.sticky.container.offsetHeight ? (t.sticky.stickyClass && t.classList.remove(t.sticky.stickyClass), this.css(t, {top: t.sticky.container.rect.top + t.sticky.container.offsetHeight - (this.scrollTop + t.sticky.rect.height) + "px"})) : (t.sticky.stickyClass && t.classList.add(t.sticky.stickyClass), this.css(t, {top: t.sticky.marginTop + "px"}))) : (t.sticky.stickyClass && t.classList.remove(t.sticky.stickyClass), this.css(t, {
            position: "",
            width: "",
            top: "",
            left: ""
        }), t.sticky.wrap && this.css(t.parentNode, {display: "", width: "", height: ""})))
    }, t.prototype.update = function () {
        var t = this;
        this.forEach(this.elements, function (i) {
            i.sticky.rect = t.getRectangle(i), i.sticky.container.rect = t.getRectangle(i.sticky.container), t.activate(i), t.setPosition(i)
        })
    }, t.prototype.destroy = function () {
        var t = this;
        this.forEach(this.elements, function (i) {
            t.destroyResizeEvents(i), t.destroyScrollEvents(i), delete i.sticky
        })
    }, t.prototype.getStickyContainer = function (t) {
        for (var i = t.parentNode; !i.hasAttribute("data-sticky-container") && !i.parentNode.querySelector(t.sticky.stickyContainer) && i !== this.body;) i = i.parentNode;
        return i
    }, t.prototype.getRectangle = function (t) {
        this.css(t, {position: "", width: "", top: "", left: ""});
        var i = Math.max(t.offsetWidth, t.clientWidth, t.scrollWidth),
            e = Math.max(t.offsetHeight, t.clientHeight, t.scrollHeight), s = 0, o = 0;
        do s += t.offsetTop || 0, o += t.offsetLeft || 0, t = t.offsetParent; while (t);
        return {top: s, left: o, width: i, height: e}
    }, t.prototype.getViewportSize = function () {
        return {
            width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
            height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
        }
    }, t.prototype.updateScrollTopPosition = function () {
        this.scrollTop = (window.pageYOffset || document.scrollTop) - (document.clientTop || 0) || 0
    }, t.prototype.forEach = function (t, i) {
        for (var e = 0, s = t.length; e < s; e++) i(t[e])
    }, t.prototype.css = function (t, i) {
        for (var e in i) i.hasOwnProperty(e) && (t.style[e] = i[e])
    }, t
}();
!function (t, i) {
    "undefined" != typeof exports ? module.exports = i : "function" == typeof define && define.amd ? define([], i) : t.Sticky = i
}(this, Sticky);
(function (factory) {

    if (typeof define === 'function' && define.amd) {

        // AMD. Register as an anonymous module.
        define([], factory);

    } else if (typeof exports === 'object') {

        // Node/CommonJS
        module.exports = factory();

    } else {

        // Browser globals
        window.wNumb = factory();
    }

}(function () {

    'use strict';

    var FormatOptions = [
        'decimals',
        'thousand',
        'mark',
        'prefix',
        'suffix',
        'encoder',
        'decoder',
        'negativeBefore',
        'negative',
        'edit',
        'undo'
    ];

// General

    // Reverse a string
    function strReverse(a) {
        return a.split('').reverse().join('');
    }

    // Check if a string starts with a specified prefix.
    function strStartsWith(input, match) {
        return input.substring(0, match.length) === match;
    }

    // Check is a string ends in a specified suffix.
    function strEndsWith(input, match) {
        return input.slice(-1 * match.length) === match;
    }

    // Throw an error if formatting options are incompatible.
    function throwEqualError(F, a, b) {
        if ((F[a] || F[b]) && (F[a] === F[b])) {
            throw new Error(a);
        }
    }

    // Check if a number is finite and not NaN
    function isValidNumber(input) {
        return typeof input === 'number' && isFinite(input);
    }

    // Provide rounding-accurate toFixed method.
    // Borrowed: http://stackoverflow.com/a/21323330/775265
    function toFixed(value, exp) {
        value = value.toString().split('e');
        value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp)));
        value = value.toString().split('e');
        return (+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp))).toFixed(exp);
    }


// Formatting

    // Accept a number as input, output formatted string.
    function formatTo(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {

        var originalInput = input, inputIsNegative, inputPieces, inputBase, inputDecimals = '', output = '';

        // Apply user encoder to the input.
        // Expected outcome: number.
        if (encoder) {
            input = encoder(input);
        }

        // Stop if no valid number was provided, the number is infinite or NaN.
        if (!isValidNumber(input)) {
            return false;
        }

        // Rounding away decimals might cause a value of -0
        // when using very small ranges. Remove those cases.
        if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {
            input = 0;
        }

        // Formatting is done on absolute numbers,
        // decorated by an optional negative symbol.
        if (input < 0) {
            inputIsNegative = true;
            input = Math.abs(input);
        }

        // Reduce the number of decimals to the specified option.
        if (decimals !== false) {
            input = toFixed(input, decimals);
        }

        // Transform the number into a string, so it can be split.
        input = input.toString();

        // Break the number on the decimal separator.
        if (input.indexOf('.') !== -1) {
            inputPieces = input.split('.');

            inputBase = inputPieces[0];

            if (mark) {
                inputDecimals = mark + inputPieces[1];
            }

        } else {

            // If it isn't split, the entire number will do.
            inputBase = input;
        }

        // Group numbers in sets of three.
        if (thousand) {
            inputBase = strReverse(inputBase).match(/.{1,3}/g);
            inputBase = strReverse(inputBase.join(strReverse(thousand)));
        }

        // If the number is negative, prefix with negation symbol.
        if (inputIsNegative && negativeBefore) {
            output += negativeBefore;
        }

        // Prefix the number
        if (prefix) {
            output += prefix;
        }

        // Normal negative option comes after the prefix. Defaults to '-'.
        if (inputIsNegative && negative) {
            output += negative;
        }

        // Append the actual number.
        output += inputBase;
        output += inputDecimals;

        // Apply the suffix.
        if (suffix) {
            output += suffix;
        }

        // Run the output through a user-specified post-formatter.
        if (edit) {
            output = edit(output, originalInput);
        }

        // All done.
        return output;
    }

    // Accept a sting as input, output decoded number.
    function formatFrom(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {

        var originalInput = input, inputIsNegative, output = '';

        // User defined pre-decoder. Result must be a non empty string.
        if (undo) {
            input = undo(input);
        }

        // Test the input. Can't be empty.
        if (!input || typeof input !== 'string') {
            return false;
        }

        // If the string starts with the negativeBefore value: remove it.
        // Remember is was there, the number is negative.
        if (negativeBefore && strStartsWith(input, negativeBefore)) {
            input = input.replace(negativeBefore, '');
            inputIsNegative = true;
        }

        // Repeat the same procedure for the prefix.
        if (prefix && strStartsWith(input, prefix)) {
            input = input.replace(prefix, '');
        }

        // And again for negative.
        if (negative && strStartsWith(input, negative)) {
            input = input.replace(negative, '');
            inputIsNegative = true;
        }

        // Remove the suffix.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice
        if (suffix && strEndsWith(input, suffix)) {
            input = input.slice(0, -1 * suffix.length);
        }

        // Remove the thousand grouping.
        if (thousand) {
            input = input.split(thousand).join('');
        }

        // Set the decimal separator back to period.
        if (mark) {
            input = input.replace(mark, '.');
        }

        // Prepend the negative symbol.
        if (inputIsNegative) {
            output += '-';
        }

        // Add the number
        output += input;

        // Trim all non-numeric characters (allow '.' and '-');
        output = output.replace(/[^0-9\.\-.]/g, '');

        // The value contains no parse-able number.
        if (output === '') {
            return false;
        }

        // Covert to number.
        output = Number(output);

        // Run the user-specified post-decoder.
        if (decoder) {
            output = decoder(output);
        }

        // Check is the output is valid, otherwise: return false.
        if (!isValidNumber(output)) {
            return false;
        }

        return output;
    }


// Framework

    // Validate formatting options
    function validate(inputOptions) {

        var i, optionName, optionValue,
            filteredOptions = {};

        if (inputOptions['suffix'] === undefined) {
            inputOptions['suffix'] = inputOptions['postfix'];
        }

        for (i = 0; i < FormatOptions.length; i += 1) {

            optionName = FormatOptions[i];
            optionValue = inputOptions[optionName];

            if (optionValue === undefined) {

                // Only default if negativeBefore isn't set.
                if (optionName === 'negative' && !filteredOptions.negativeBefore) {
                    filteredOptions[optionName] = '-';
                    // Don't set a default for mark when 'thousand' is set.
                } else if (optionName === 'mark' && filteredOptions.thousand !== '.') {
                    filteredOptions[optionName] = '.';
                } else {
                    filteredOptions[optionName] = false;
                }

                // Floating points in JS are stable up to 7 decimals.
            } else if (optionName === 'decimals') {
                if (optionValue >= 0 && optionValue < 8) {
                    filteredOptions[optionName] = optionValue;
                } else {
                    throw new Error(optionName);
                }

                // These options, when provided, must be functions.
            } else if (optionName === 'encoder' || optionName === 'decoder' || optionName === 'edit' || optionName === 'undo') {
                if (typeof optionValue === 'function') {
                    filteredOptions[optionName] = optionValue;
                } else {
                    throw new Error(optionName);
                }

                // Other options are strings.
            } else {

                if (typeof optionValue === 'string') {
                    filteredOptions[optionName] = optionValue;
                } else {
                    throw new Error(optionName);
                }
            }
        }

        // Some values can't be extracted from a
        // string if certain combinations are present.
        throwEqualError(filteredOptions, 'mark', 'thousand');
        throwEqualError(filteredOptions, 'prefix', 'negative');
        throwEqualError(filteredOptions, 'prefix', 'negativeBefore');

        return filteredOptions;
    }

    // Pass all options as function arguments
    function passAll(options, method, input) {
        var i, args = [];

        // Add all options in order of FormatOptions
        for (i = 0; i < FormatOptions.length; i += 1) {
            args.push(options[FormatOptions[i]]);
        }

        // Append the input, then call the method, presenting all
        // options as arguments.
        args.push(input);
        return method.apply('', args);
    }

    function wNumb(options) {

        if (!(this instanceof wNumb)) {
            return new wNumb(options);
        }

        if (typeof options !== "object") {
            return;
        }

        options = validate(options);

        // Call 'formatTo' with proper arguments.
        this.to = function (input) {
            return passAll(options, formatTo, input);
        };

        // Call 'formatFrom' with proper arguments.
        this.from = function (input) {
            return passAll(options, formatFrom, input);
        };
    }

    return wNumb;

}));

/*!
 * jQuery Form Plugin
 * version: 4.2.2
 * Requires jQuery v1.7.2 or later
 * Project repository: https://github.com/jquery-form/form

 * Copyright 2017 Kevin Morris
 * Copyright 2006 M. Alsup

 * Dual licensed under the LGPL-2.1+ or MIT licenses
 * https://github.com/jquery-form/form#license

 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 */
!function (e) {
    "function" == typeof define && define.amd ? define(["jquery"], e) : "object" == typeof module && module.exports ? module.exports = function (t, r) {
        return void 0 === r && (r = "undefined" != typeof window ? require("jquery") : require("jquery")(t)), e(r), r
    } : e(jQuery)
}(function (e) {
    "use strict";

    function t(t) {
        var r = t.data;
        t.isDefaultPrevented() || (t.preventDefault(), e(t.target).closest("form").ajaxSubmit(r))
    }

    function r(t) {
        var r = t.target, a = e(r);
        if (!a.is("[type=submit],[type=image]")) {
            var n = a.closest("[type=submit]");
            if (0 === n.length) return;
            r = n[0]
        }
        var i = r.form;
        if (i.clk = r, "image" === r.type) if (void 0 !== t.offsetX) i.clk_x = t.offsetX, i.clk_y = t.offsetY; else if ("function" == typeof e.fn.offset) {
            var o = a.offset();
            i.clk_x = t.pageX - o.left, i.clk_y = t.pageY - o.top
        } else i.clk_x = t.pageX - r.offsetLeft, i.clk_y = t.pageY - r.offsetTop;
        setTimeout(function () {
            i.clk = i.clk_x = i.clk_y = null
        }, 100)
    }

    function a() {
        if (e.fn.ajaxSubmit.debug) {
            var t = "[jquery.form] " + Array.prototype.join.call(arguments, "");
            window.console && window.console.log ? window.console.log(t) : window.opera && window.opera.postError && window.opera.postError(t)
        }
    }

    var n = /\r?\n/g, i = {};
    i.fileapi = void 0 !== e('<input type="file">').get(0).files, i.formdata = void 0 !== window.FormData;
    var o = !!e.fn.prop;
    e.fn.attr2 = function () {
        if (!o) return this.attr.apply(this, arguments);
        var e = this.prop.apply(this, arguments);
        return e && e.jquery || "string" == typeof e ? e : this.attr.apply(this, arguments)
    }, e.fn.ajaxSubmit = function (t, r, n, s) {
        function u(r) {
            var a, n, i = e.param(r, t.traditional).split("&"), o = i.length, s = [];
            for (a = 0; a < o; a++) i[a] = i[a].replace(/\+/g, " "), n = i[a].split("="), s.push([decodeURIComponent(n[0]), decodeURIComponent(n[1])]);
            return s
        }

        function c(r) {
            function n(e) {
                var t = null;
                try {
                    e.contentWindow && (t = e.contentWindow.document)
                } catch (e) {
                    a("cannot get iframe.contentWindow document: " + e)
                }
                if (t) return t;
                try {
                    t = e.contentDocument ? e.contentDocument : e.document
                } catch (r) {
                    a("cannot get iframe.contentDocument: " + r), t = e.document
                }
                return t
            }

            function i() {
                function t() {
                    try {
                        var e = n(v).readyState;
                        a("state = " + e), e && "uninitialized" === e.toLowerCase() && setTimeout(t, 50)
                    } catch (e) {
                        a("Server abort: ", e, " (", e.name, ")"), s(L), j && clearTimeout(j), j = void 0
                    }
                }

                var r = p.attr2("target"), i = p.attr2("action"),
                    o = p.attr("enctype") || p.attr("encoding") || "multipart/form-data";
                w.setAttribute("target", m), l && !/post/i.test(l) || w.setAttribute("method", "POST"), i !== f.url && w.setAttribute("action", f.url), f.skipEncodingOverride || l && !/post/i.test(l) || p.attr({
                    encoding: "multipart/form-data",
                    enctype: "multipart/form-data"
                }), f.timeout && (j = setTimeout(function () {
                    T = !0, s(A)
                }, f.timeout));
                var u = [];
                try {
                    if (f.extraData) for (var c in f.extraData) f.extraData.hasOwnProperty(c) && (e.isPlainObject(f.extraData[c]) && f.extraData[c].hasOwnProperty("name") && f.extraData[c].hasOwnProperty("value") ? u.push(e('<input type="hidden" name="' + f.extraData[c].name + '">', k).val(f.extraData[c].value).appendTo(w)[0]) : u.push(e('<input type="hidden" name="' + c + '">', k).val(f.extraData[c]).appendTo(w)[0]));
                    f.iframeTarget || h.appendTo(D), v.attachEvent ? v.attachEvent("onload", s) : v.addEventListener("load", s, !1), setTimeout(t, 15);
                    try {
                        w.submit()
                    } catch (e) {
                        document.createElement("form").submit.apply(w)
                    }
                } finally {
                    w.setAttribute("action", i), w.setAttribute("enctype", o), r ? w.setAttribute("target", r) : p.removeAttr("target"), e(u).remove()
                }
            }

            function s(t) {
                if (!x.aborted && !X) {
                    if ((O = n(v)) || (a("cannot access response document"), t = L), t === A && x) return x.abort("timeout"), void S.reject(x, "timeout");
                    if (t === L && x) return x.abort("server abort"), void S.reject(x, "error", "server abort");
                    if (O && O.location.href !== f.iframeSrc || T) {
                        v.detachEvent ? v.detachEvent("onload", s) : v.removeEventListener("load", s, !1);
                        var r, i = "success";
                        try {
                            if (T) throw"timeout";
                            var o = "xml" === f.dataType || O.XMLDocument || e.isXMLDoc(O);
                            if (a("isXml=" + o), !o && window.opera && (null === O.body || !O.body.innerHTML) && --C) return a("requeing onLoad callback, DOM not available"), void setTimeout(s, 250);
                            var u = O.body ? O.body : O.documentElement;
                            x.responseText = u ? u.innerHTML : null, x.responseXML = O.XMLDocument ? O.XMLDocument : O, o && (f.dataType = "xml"), x.getResponseHeader = function (e) {
                                return {"content-type": f.dataType}[e.toLowerCase()]
                            }, u && (x.status = Number(u.getAttribute("status")) || x.status, x.statusText = u.getAttribute("statusText") || x.statusText);
                            var c = (f.dataType || "").toLowerCase(), l = /(json|script|text)/.test(c);
                            if (l || f.textarea) {
                                var p = O.getElementsByTagName("textarea")[0];
                                if (p) x.responseText = p.value, x.status = Number(p.getAttribute("status")) || x.status, x.statusText = p.getAttribute("statusText") || x.statusText; else if (l) {
                                    var m = O.getElementsByTagName("pre")[0], g = O.getElementsByTagName("body")[0];
                                    m ? x.responseText = m.textContent ? m.textContent : m.innerText : g && (x.responseText = g.textContent ? g.textContent : g.innerText)
                                }
                            } else "xml" === c && !x.responseXML && x.responseText && (x.responseXML = q(x.responseText));
                            try {
                                M = N(x, c, f)
                            } catch (e) {
                                i = "parsererror", x.error = r = e || i
                            }
                        } catch (e) {
                            a("error caught: ", e), i = "error", x.error = r = e || i
                        }
                        x.aborted && (a("upload aborted"), i = null), x.status && (i = x.status >= 200 && x.status < 300 || 304 === x.status ? "success" : "error"), "success" === i ? (f.success && f.success.call(f.context, M, "success", x), S.resolve(x.responseText, "success", x), d && e.event.trigger("ajaxSuccess", [x, f])) : i && (void 0 === r && (r = x.statusText), f.error && f.error.call(f.context, x, i, r), S.reject(x, "error", r), d && e.event.trigger("ajaxError", [x, f, r])), d && e.event.trigger("ajaxComplete", [x, f]), d && !--e.active && e.event.trigger("ajaxStop"), f.complete && f.complete.call(f.context, x, i), X = !0, f.timeout && clearTimeout(j), setTimeout(function () {
                            f.iframeTarget ? h.attr("src", f.iframeSrc) : h.remove(), x.responseXML = null
                        }, 100)
                    }
                }
            }

            var u, c, f, d, m, h, v, x, y, b, T, j, w = p[0], S = e.Deferred();
            if (S.abort = function (e) {
                x.abort(e)
            }, r) for (c = 0; c < g.length; c++) u = e(g[c]), o ? u.prop("disabled", !1) : u.removeAttr("disabled");
            (f = e.extend(!0, {}, e.ajaxSettings, t)).context = f.context || f, m = "jqFormIO" + (new Date).getTime();
            var k = w.ownerDocument, D = p.closest("body");
            if (f.iframeTarget ? (b = (h = e(f.iframeTarget, k)).attr2("name")) ? m = b : h.attr2("name", m) : (h = e('<iframe name="' + m + '" src="' + f.iframeSrc + '" />', k)).css({
                position: "absolute",
                top: "-1000px",
                left: "-1000px"
            }), v = h[0], x = {
                aborted: 0,
                responseText: null,
                responseXML: null,
                status: 0,
                statusText: "n/a",
                getAllResponseHeaders: function () {
                },
                getResponseHeader: function () {
                },
                setRequestHeader: function () {
                },
                abort: function (t) {
                    var r = "timeout" === t ? "timeout" : "aborted";
                    a("aborting upload... " + r), this.aborted = 1;
                    try {
                        v.contentWindow.document.execCommand && v.contentWindow.document.execCommand("Stop")
                    } catch (e) {
                    }
                    h.attr("src", f.iframeSrc), x.error = r, f.error && f.error.call(f.context, x, r, t), d && e.event.trigger("ajaxError", [x, f, r]), f.complete && f.complete.call(f.context, x, r)
                }
            }, (d = f.global) && 0 == e.active++ && e.event.trigger("ajaxStart"), d && e.event.trigger("ajaxSend", [x, f]), f.beforeSend && !1 === f.beforeSend.call(f.context, x, f)) return f.global && e.active--, S.reject(), S;
            if (x.aborted) return S.reject(), S;
            (y = w.clk) && (b = y.name) && !y.disabled && (f.extraData = f.extraData || {}, f.extraData[b] = y.value, "image" === y.type && (f.extraData[b + ".x"] = w.clk_x, f.extraData[b + ".y"] = w.clk_y));
            var A = 1, L = 2, F = e("meta[name=csrf-token]").attr("content"),
                E = e("meta[name=csrf-param]").attr("content");
            E && F && (f.extraData = f.extraData || {}, f.extraData[E] = F), f.forceSync ? i() : setTimeout(i, 10);
            var M, O, X, C = 50, q = e.parseXML || function (e, t) {
                return window.ActiveXObject ? ((t = new ActiveXObject("Microsoft.XMLDOM")).async = "false", t.loadXML(e)) : t = (new DOMParser).parseFromString(e, "text/xml"), t && t.documentElement && "parsererror" !== t.documentElement.nodeName ? t : null
            }, _ = e.parseJSON || function (e) {
                return window.eval("(" + e + ")")
            }, N = function (t, r, a) {
                var n = t.getResponseHeader("content-type") || "", i = ("xml" === r || !r) && n.indexOf("xml") >= 0,
                    o = i ? t.responseXML : t.responseText;
                return i && "parsererror" === o.documentElement.nodeName && e.error && e.error("parsererror"), a && a.dataFilter && (o = a.dataFilter(o, r)), "string" == typeof o && (("json" === r || !r) && n.indexOf("json") >= 0 ? o = _(o) : ("script" === r || !r) && n.indexOf("javascript") >= 0 && e.globalEval(o)), o
            };
            return S
        }

        if (!this.length) return a("ajaxSubmit: skipping submit process - no element selected"), this;
        var l, f, d, p = this;
        "function" == typeof t ? t = {success: t} : "string" == typeof t || !1 === t && arguments.length > 0 ? (t = {
            url: t,
            data: r,
            dataType: n
        }, "function" == typeof s && (t.success = s)) : void 0 === t && (t = {}), l = t.method || t.type || this.attr2("method"), (d = (d = "string" == typeof(f = t.url || this.attr2("action")) ? e.trim(f) : "") || window.location.href || "") && (d = (d.match(/^([^#]+)/) || [])[1]), t = e.extend(!0, {
            url: d,
            success: e.ajaxSettings.success,
            type: l || e.ajaxSettings.type,
            iframeSrc: /^https/i.test(window.location.href || "") ? "javascript:false" : "about:blank"
        }, t);
        var m = {};
        if (this.trigger("form-pre-serialize", [this, t, m]), m.veto) return a("ajaxSubmit: submit vetoed via form-pre-serialize trigger"), this;
        if (t.beforeSerialize && !1 === t.beforeSerialize(this, t)) return a("ajaxSubmit: submit aborted via beforeSerialize callback"), this;
        var h = t.traditional;
        void 0 === h && (h = e.ajaxSettings.traditional);
        var v, g = [], x = this.formToArray(t.semantic, g, t.filtering);
        if (t.data) {
            var y = e.isFunction(t.data) ? t.data(x) : t.data;
            t.extraData = y, v = e.param(y, h)
        }
        if (t.beforeSubmit && !1 === t.beforeSubmit(x, this, t)) return a("ajaxSubmit: submit aborted via beforeSubmit callback"), this;
        if (this.trigger("form-submit-validate", [x, this, t, m]), m.veto) return a("ajaxSubmit: submit vetoed via form-submit-validate trigger"), this;
        var b = e.param(x, h);
        v && (b = b ? b + "&" + v : v), "GET" === t.type.toUpperCase() ? (t.url += (t.url.indexOf("?") >= 0 ? "&" : "?") + b, t.data = null) : t.data = b;
        var T = [];
        if (t.resetForm && T.push(function () {
            p.resetForm()
        }), t.clearForm && T.push(function () {
            p.clearForm(t.includeHidden)
        }), !t.dataType && t.target) {
            var j = t.success || function () {
            };
            T.push(function (r, a, n) {
                var i = arguments, o = t.replaceTarget ? "replaceWith" : "html";
                e(t.target)[o](r).each(function () {
                    j.apply(this, i)
                })
            })
        } else t.success && (e.isArray(t.success) ? e.merge(T, t.success) : T.push(t.success));
        if (t.success = function (e, r, a) {
            for (var n = t.context || this, i = 0, o = T.length; i < o; i++) T[i].apply(n, [e, r, a || p, p])
        }, t.error) {
            var w = t.error;
            t.error = function (e, r, a) {
                var n = t.context || this;
                w.apply(n, [e, r, a, p])
            }
        }
        if (t.complete) {
            var S = t.complete;
            t.complete = function (e, r) {
                var a = t.context || this;
                S.apply(a, [e, r, p])
            }
        }
        var k = e("input[type=file]:enabled", this).filter(function () {
                return "" !== e(this).val()
            }).length > 0, D = "multipart/form-data", A = p.attr("enctype") === D || p.attr("encoding") === D,
            L = i.fileapi && i.formdata;
        a("fileAPI :" + L);
        var F, E = (k || A) && !L;
        !1 !== t.iframe && (t.iframe || E) ? t.closeKeepAlive ? e.get(t.closeKeepAlive, function () {
            F = c(x)
        }) : F = c(x) : F = (k || A) && L ? function (r) {
            for (var a = new FormData, n = 0; n < r.length; n++) a.append(r[n].name, r[n].value);
            if (t.extraData) {
                var i = u(t.extraData);
                for (n = 0; n < i.length; n++) i[n] && a.append(i[n][0], i[n][1])
            }
            t.data = null;
            var o = e.extend(!0, {}, e.ajaxSettings, t, {
                contentType: !1,
                processData: !1,
                cache: !1,
                type: l || "POST"
            });
            t.uploadProgress && (o.xhr = function () {
                var r = e.ajaxSettings.xhr();
                return r.upload && r.upload.addEventListener("progress", function (e) {
                    var r = 0, a = e.loaded || e.position, n = e.total;
                    e.lengthComputable && (r = Math.ceil(a / n * 100)), t.uploadProgress(e, a, n, r)
                }, !1), r
            }), o.data = null;
            var s = o.beforeSend;
            return o.beforeSend = function (e, r) {
                t.formData ? r.data = t.formData : r.data = a, s && s.call(this, e, r)
            }, e.ajax(o)
        }(x) : e.ajax(t), p.removeData("jqxhr").data("jqxhr", F);
        for (var M = 0; M < g.length; M++) g[M] = null;
        return this.trigger("form-submit-notify", [this, t]), this
    }, e.fn.ajaxForm = function (n, i, o, s) {
        if (("string" == typeof n || !1 === n && arguments.length > 0) && (n = {
            url: n,
            data: i,
            dataType: o
        }, "function" == typeof s && (n.success = s)), n = n || {}, n.delegation = n.delegation && e.isFunction(e.fn.on), !n.delegation && 0 === this.length) {
            var u = {s: this.selector, c: this.context};
            return !e.isReady && u.s ? (a("DOM not ready, queuing ajaxForm"), e(function () {
                e(u.s, u.c).ajaxForm(n)
            }), this) : (a("terminating; zero elements found by selector" + (e.isReady ? "" : " (DOM not ready)")), this)
        }
        return n.delegation ? (e(document).off("submit.form-plugin", this.selector, t).off("click.form-plugin", this.selector, r).on("submit.form-plugin", this.selector, n, t).on("click.form-plugin", this.selector, n, r), this) : this.ajaxFormUnbind().on("submit.form-plugin", n, t).on("click.form-plugin", n, r)
    }, e.fn.ajaxFormUnbind = function () {
        return this.off("submit.form-plugin click.form-plugin")
    }, e.fn.formToArray = function (t, r, a) {
        var n = [];
        if (0 === this.length) return n;
        var o, s = this[0], u = this.attr("id"),
            c = t || void 0 === s.elements ? s.getElementsByTagName("*") : s.elements;
        if (c && (c = e.makeArray(c)), u && (t || /(Edge|Trident)\//.test(navigator.userAgent)) && (o = e(':input[form="' + u + '"]').get()).length && (c = (c || []).concat(o)), !c || !c.length) return n;
        e.isFunction(a) && (c = e.map(c, a));
        var l, f, d, p, m, h, v;
        for (l = 0, h = c.length; l < h; l++) if (m = c[l], (d = m.name) && !m.disabled) if (t && s.clk && "image" === m.type) s.clk === m && (n.push({
            name: d,
            value: e(m).val(),
            type: m.type
        }), n.push({name: d + ".x", value: s.clk_x}, {
            name: d + ".y",
            value: s.clk_y
        })); else if ((p = e.fieldValue(m, !0)) && p.constructor === Array) for (r && r.push(m), f = 0, v = p.length; f < v; f++) n.push({
            name: d,
            value: p[f]
        }); else if (i.fileapi && "file" === m.type) {
            r && r.push(m);
            var g = m.files;
            if (g.length) for (f = 0; f < g.length; f++) n.push({
                name: d,
                value: g[f],
                type: m.type
            }); else n.push({name: d, value: "", type: m.type})
        } else null !== p && void 0 !== p && (r && r.push(m), n.push({
            name: d,
            value: p,
            type: m.type,
            required: m.required
        }));
        if (!t && s.clk) {
            var x = e(s.clk), y = x[0];
            (d = y.name) && !y.disabled && "image" === y.type && (n.push({
                name: d,
                value: x.val()
            }), n.push({name: d + ".x", value: s.clk_x}, {name: d + ".y", value: s.clk_y}))
        }
        return n
    }, e.fn.formSerialize = function (t) {
        return e.param(this.formToArray(t))
    }, e.fn.fieldSerialize = function (t) {
        var r = [];
        return this.each(function () {
            var a = this.name;
            if (a) {
                var n = e.fieldValue(this, t);
                if (n && n.constructor === Array) for (var i = 0, o = n.length; i < o; i++) r.push({
                    name: a,
                    value: n[i]
                }); else null !== n && void 0 !== n && r.push({name: this.name, value: n})
            }
        }), e.param(r)
    }, e.fn.fieldValue = function (t) {
        for (var r = [], a = 0, n = this.length; a < n; a++) {
            var i = this[a], o = e.fieldValue(i, t);
            null === o || void 0 === o || o.constructor === Array && !o.length || (o.constructor === Array ? e.merge(r, o) : r.push(o))
        }
        return r
    }, e.fieldValue = function (t, r) {
        var a = t.name, i = t.type, o = t.tagName.toLowerCase();
        if (void 0 === r && (r = !0), r && (!a || t.disabled || "reset" === i || "button" === i || ("checkbox" === i || "radio" === i) && !t.checked || ("submit" === i || "image" === i) && t.form && t.form.clk !== t || "select" === o && -1 === t.selectedIndex)) return null;
        if ("select" === o) {
            var s = t.selectedIndex;
            if (s < 0) return null;
            for (var u = [], c = t.options, l = "select-one" === i, f = l ? s + 1 : c.length, d = l ? s : 0; d < f; d++) {
                var p = c[d];
                if (p.selected && !p.disabled) {
                    var m = p.value;
                    if (m || (m = p.attributes && p.attributes.value && !p.attributes.value.specified ? p.text : p.value), l) return m;
                    u.push(m)
                }
            }
            return u
        }
        return e(t).val().replace(n, "\r\n")
    }, e.fn.clearForm = function (t) {
        return this.each(function () {
            e("input,select,textarea", this).clearFields(t)
        })
    }, e.fn.clearFields = e.fn.clearInputs = function (t) {
        var r = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i;
        return this.each(function () {
            var a = this.type, n = this.tagName.toLowerCase();
            r.test(a) || "textarea" === n ? this.value = "" : "checkbox" === a || "radio" === a ? this.checked = !1 : "select" === n ? this.selectedIndex = -1 : "file" === a ? /MSIE/.test(navigator.userAgent) ? e(this).replaceWith(e(this).clone(!0)) : e(this).val("") : t && (!0 === t && /hidden/.test(a) || "string" == typeof t && e(this).is(t)) && (this.value = "")
        })
    }, e.fn.resetForm = function () {
        return this.each(function () {
            var t = e(this), r = this.tagName.toLowerCase();
            switch (r) {
                case"input":
                    this.checked = this.defaultChecked;
                case"textarea":
                    return this.value = this.defaultValue, !0;
                case"option":
                case"optgroup":
                    var a = t.parents("select");
                    return a.length && a[0].multiple ? "option" === r ? this.selected = this.defaultSelected : t.find("option").resetForm() : a.resetForm(), !0;
                case"select":
                    return t.find("option").each(function (e) {
                        if (this.selected = this.defaultSelected, this.defaultSelected && !t[0].multiple) return t[0].selectedIndex = e, !1
                    }), !0;
                case"label":
                    var n = e(t.attr("for")), i = t.find("input,select,textarea");
                    return n[0] && i.unshift(n[0]), i.resetForm(), !0;
                case"form":
                    return ("function" == typeof this.reset || "object" == typeof this.reset && !this.reset.nodeType) && this.reset(), !0;
                default:
                    return t.find("form,input,label,select,textarea").resetForm(), !0
            }
        })
    }, e.fn.enable = function (e) {
        return void 0 === e && (e = !0), this.each(function () {
            this.disabled = !e
        })
    }, e.fn.selected = function (t) {
        return void 0 === t && (t = !0), this.each(function () {
            var r = this.type;
            if ("checkbox" === r || "radio" === r) this.checked = t; else if ("option" === this.tagName.toLowerCase()) {
                var a = e(this).parent("select");
                t && a[0] && "select-one" === a[0].type && a.find("option").selected(!1), this.selected = t
            }
        })
    }, e.fn.ajaxSubmit.debug = !1
});


/*!
 * jQuery blockUI plugin
 * Version 2.70.0-2014.11.23
 * Requires jQuery v1.7 or later
 *
 * Examples at: http://malsup.com/jquery/block/
 * Copyright (c) 2007-2013 M. Alsup
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Thanks to Amir-Hossein Sobhi for some excellent contributions!
 */

;(function () {
    /*jshint eqeqeq:false curly:false latedef:false */
    "use strict";

    function setup($) {
        $.fn._fadeIn = $.fn.fadeIn;

        var noOp = $.noop || function () {
        };

        // this bit is to ensure we don't call setExpression when we shouldn't (with extra muscle to handle
        // confusing userAgent strings on Vista)
        var msie = /MSIE/.test(navigator.userAgent);
        var ie6 = /MSIE 6.0/.test(navigator.userAgent) && !/MSIE 8.0/.test(navigator.userAgent);
        var mode = document.documentMode || 0;
        var setExpr = $.isFunction(document.createElement('div').style.setExpression);

        // global $ methods for blocking/unblocking the entire page
        $.blockUI = function (opts) {
            install(window, opts);
        };
        $.unblockUI = function (opts) {
            remove(window, opts);
        };

        // convenience method for quick growl-like notifications  (http://www.google.com/search?q=growl)
        $.growlUI = function (title, message, timeout, onClose) {
            var $m = $('<div class="growlUI"></div>');
            if (title) $m.append('<h1>' + title + '</h1>');
            if (message) $m.append('<h2>' + message + '</h2>');
            if (timeout === undefined) timeout = 3000;

            // Added by konapun: Set timeout to 30 seconds if this growl is moused over, like normal toast notifications
            var callBlock = function (opts) {
                opts = opts || {};

                $.blockUI({
                    message: $m,
                    fadeIn: typeof opts.fadeIn !== 'undefined' ? opts.fadeIn : 700,
                    fadeOut: typeof opts.fadeOut !== 'undefined' ? opts.fadeOut : 1000,
                    timeout: typeof opts.timeout !== 'undefined' ? opts.timeout : timeout,
                    centerY: false,
                    showOverlay: false,
                    onUnblock: onClose,
                    css: $.blockUI.defaults.growlCSS
                });
            };

            callBlock();
            var nonmousedOpacity = $m.css('opacity');
            $m.mouseover(function () {
                callBlock({
                    fadeIn: 0,
                    timeout: 30000
                });

                var displayBlock = $('.blockMsg');
                displayBlock.stop(); // cancel fadeout if it has started
                displayBlock.fadeTo(300, 1); // make it easier to read the message by removing transparency
            }).mouseout(function () {
                $('.blockMsg').fadeOut(1000);
            });
            // End konapun additions
        };

        // plugin method for blocking element content
        $.fn.block = function (opts) {
            if (this[0] === window) {
                $.blockUI(opts);
                return this;
            }
            var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
            this.each(function () {
                var $el = $(this);
                if (fullOpts.ignoreIfBlocked && $el.data('blockUI.isBlocked'))
                    return;
                $el.unblock({fadeOut: 0});
            });

            return this.each(function () {
                if ($.css(this, 'position') == 'static') {
                    this.style.position = 'relative';
                    $(this).data('blockUI.static', true);
                }
                this.style.zoom = 1; // force 'hasLayout' in ie
                install(this, opts);
            });
        };

        // plugin method for unblocking element content
        $.fn.unblock = function (opts) {
            if (this[0] === window) {
                $.unblockUI(opts);
                return this;
            }
            return this.each(function () {
                remove(this, opts);
            });
        };

        $.blockUI.version = 2.70; // 2nd generation blocking at no extra cost!

        // override these in your code to change the default behavior and style
        $.blockUI.defaults = {
            // message displayed when blocking (use null for no message)
            message: '<h1>Please wait...</h1>',

            title: null,		// title string; only used when theme == true
            draggable: true,	// only used when theme == true (requires jquery-ui.js to be loaded)

            theme: false, // set to true to use with jQuery UI themes

            // styles for the message when blocking; if you wish to disable
            // these and use an external stylesheet then do this in your code:
            // $.blockUI.defaults.css = {};
            css: {
                padding: 0,
                margin: 0,
                width: '30%',
                top: '40%',
                left: '35%',
                textAlign: 'center',
                color: '#000',
                border: '3px solid #aaa',
                backgroundColor: '#fff',
                cursor: 'wait'
            },

            // minimal style set used when themes are used
            themedCSS: {
                width: '30%',
                top: '40%',
                left: '35%'
            },

            // styles for the overlay
            overlayCSS: {
                backgroundColor: '#000',
                opacity: 0.6,
                cursor: 'wait'
            },

            // style to replace wait cursor before unblocking to correct issue
            // of lingering wait cursor
            cursorReset: 'default',

            // styles applied when using $.growlUI
            growlCSS: {
                width: '350px',
                top: '10px',
                left: '',
                right: '10px',
                border: 'none',
                padding: '5px',
                opacity: 0.6,
                cursor: 'default',
                color: '#fff',
                backgroundColor: '#000',
                '-webkit-border-radius': '10px',
                '-moz-border-radius': '10px',
                'border-radius': '10px'
            },

            // IE issues: 'about:blank' fails on HTTPS and javascript:false is s-l-o-w
            // (hat tip to Jorge H. N. de Vasconcelos)
            /*jshint scripturl:true */
            iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank',

            // force usage of iframe in non-IE browsers (handy for blocking applets)
            forceIframe: false,

            // z-index for the blocking overlay
            baseZ: 1000,

            // set these to true to have the message automatically centered
            centerX: true, // <-- only effects element blocking (page block controlled via css above)
            centerY: true,

            // allow body element to be stetched in ie6; this makes blocking look better
            // on "short" pages.  disable if you wish to prevent changes to the body height
            allowBodyStretch: true,

            // enable if you want key and mouse events to be disabled for content that is blocked
            bindEvents: true,

            // be default blockUI will supress tab navigation from leaving blocking content
            // (if bindEvents is true)
            constrainTabKey: true,

            // fadeIn time in millis; set to 0 to disable fadeIn on block
            fadeIn: 200,

            // fadeOut time in millis; set to 0 to disable fadeOut on unblock
            fadeOut: 400,

            // time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock
            timeout: 0,

            // disable if you don't want to show the overlay
            showOverlay: true,

            // if true, focus will be placed in the first available input field when
            // page blocking
            focusInput: true,

            // elements that can receive focus
            focusableElements: ':input:enabled:visible',

            // suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity)
            // no longer needed in 2012
            // applyPlatformOpacityRules: true,

            // callback method invoked when fadeIn has completed and blocking message is visible
            onBlock: null,

            // callback method invoked when unblocking has completed; the callback is
            // passed the element that has been unblocked (which is the window object for page
            // blocks) and the options that were passed to the unblock call:
            //	onUnblock(element, options)
            onUnblock: null,

            // callback method invoked when the overlay area is clicked.
            // setting this will turn the cursor to a pointer, otherwise cursor defined in overlayCss will be used.
            onOverlayClick: null,

            // don't ask; if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493
            quirksmodeOffsetHack: 4,

            // class name of the message block
            blockMsgClass: 'blockMsg',

            // if it is already blocked, then ignore it (don't unblock and reblock)
            ignoreIfBlocked: false
        };

        // private data and functions follow...

        var pageBlock = null;
        var pageBlockEls = [];

        function install(el, opts) {
            var css, themedCSS;
            var full = (el == window);
            var msg = (opts && opts.message !== undefined ? opts.message : undefined);
            opts = $.extend({}, $.blockUI.defaults, opts || {});

            if (opts.ignoreIfBlocked && $(el).data('blockUI.isBlocked'))
                return;

            opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
            css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
            if (opts.onOverlayClick)
                opts.overlayCSS.cursor = 'pointer';

            themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
            msg = msg === undefined ? opts.message : msg;

            // remove the current block (if there is one)
            if (full && pageBlock)
                remove(window, {fadeOut: 0});

            // if an existing element is being used as the blocking content then we capture
            // its current place in the DOM (and current display style) so we can restore
            // it when we unblock
            if (msg && typeof msg != 'string' && (msg.parentNode || msg.jquery)) {
                var node = msg.jquery ? msg[0] : msg;
                var data = {};
                $(el).data('blockUI.history', data);
                data.el = node;
                data.parent = node.parentNode;
                data.display = node.style.display;
                data.position = node.style.position;
                if (data.parent)
                    data.parent.removeChild(node);
            }

            $(el).data('blockUI.onUnblock', opts.onUnblock);
            var z = opts.baseZ;

            // blockUI uses 3 layers for blocking, for simplicity they are all used on every platform;
            // layer1 is the iframe layer which is used to supress bleed through of underlying content
            // layer2 is the overlay layer which has opacity and a wait cursor (by default)
            // layer3 is the message content that is displayed while blocking
            var lyr1, lyr2, lyr3, s;
            if (msie || opts.forceIframe)
                lyr1 = $('<iframe class="blockUI" style="z-index:' + (z++) + ';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="' + opts.iframeSrc + '"></iframe>');
            else
                lyr1 = $('<div class="blockUI" style="display:none"></div>');

            if (opts.theme)
                lyr2 = $('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:' + (z++) + ';display:none"></div>');
            else
                lyr2 = $('<div class="blockUI blockOverlay" style="z-index:' + (z++) + ';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');

            if (opts.theme && full) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:fixed">';
                if (opts.title) {
                    s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || '&nbsp;') + '</div>';
                }
                s += '<div class="ui-widget-content ui-dialog-content"></div>';
                s += '</div>';
            }
            else if (opts.theme) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:absolute">';
                if (opts.title) {
                    s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || '&nbsp;') + '</div>';
                }
                s += '<div class="ui-widget-content ui-dialog-content"></div>';
                s += '</div>';
            }
            else if (full) {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:' + (z + 10) + ';display:none;position:fixed"></div>';
            }
            else {
                s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:' + (z + 10) + ';display:none;position:absolute"></div>';
            }
            lyr3 = $(s);

            // if we have a message, style it
            if (msg) {
                if (opts.theme) {
                    lyr3.css(themedCSS);
                    lyr3.addClass('ui-widget-content');
                }
                else
                    lyr3.css(css);
            }

            // style the overlay
            if (!opts.theme /*&& (!opts.applyPlatformOpacityRules)*/)
                lyr2.css(opts.overlayCSS);
            lyr2.css('position', full ? 'fixed' : 'absolute');

            // make iframe layer transparent in IE
            if (msie || opts.forceIframe)
                lyr1.css('opacity', 0.0);

            //$([lyr1[0],lyr2[0],lyr3[0]]).appendTo(full ? 'body' : el);
            var layers = [lyr1, lyr2, lyr3], $par = full ? $('body') : $(el);
            $.each(layers, function () {
                this.appendTo($par);
            });

            if (opts.theme && opts.draggable && $.fn.draggable) {
                lyr3.draggable({
                    handle: '.ui-dialog-titlebar',
                    cancel: 'li'
                });
            }

            // ie7 must use absolute positioning in quirks mode and to account for activex issues (when scrolling)
            var expr = setExpr && (!$.support.boxModel || $('object,embed', full ? null : el).length > 0);
            if (ie6 || expr) {
                // give body 100% height
                if (full && opts.allowBodyStretch && $.support.boxModel)
                    $('html,body').css('height', '100%');

                // fix ie6 issue when blocked element has a border width
                if ((ie6 || !$.support.boxModel) && !full) {
                    var t = sz(el, 'borderTopWidth'), l = sz(el, 'borderLeftWidth');
                    var fixT = t ? '(0 - ' + t + ')' : 0;
                    var fixL = l ? '(0 - ' + l + ')' : 0;
                }

                // simulate fixed position
                $.each(layers, function (i, o) {
                    var s = o[0].style;
                    s.position = 'absolute';
                    if (i < 2) {
                        if (full)
                            s.setExpression('height', 'Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:' + opts.quirksmodeOffsetHack + ') + "px"');
                        else
                            s.setExpression('height', 'this.parentNode.offsetHeight + "px"');
                        if (full)
                            s.setExpression('width', 'jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"');
                        else
                            s.setExpression('width', 'this.parentNode.offsetWidth + "px"');
                        if (fixL) s.setExpression('left', fixL);
                        if (fixT) s.setExpression('top', fixT);
                    }
                    else if (opts.centerY) {
                        if (full) s.setExpression('top', '(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
                        s.marginTop = 0;
                    }
                    else if (!opts.centerY && full) {
                        var top = (opts.css && opts.css.top) ? parseInt(opts.css.top, 10) : 0;
                        var expression = '((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + ' + top + ') + "px"';
                        s.setExpression('top', expression);
                    }
                });
            }

            // show the message
            if (msg) {
                if (opts.theme)
                    lyr3.find('.ui-widget-content').append(msg);
                else
                    lyr3.append(msg);
                if (msg.jquery || msg.nodeType)
                    $(msg).show();
            }

            if ((msie || opts.forceIframe) && opts.showOverlay)
                lyr1.show(); // opacity is zero
            if (opts.fadeIn) {
                var cb = opts.onBlock ? opts.onBlock : noOp;
                var cb1 = (opts.showOverlay && !msg) ? cb : noOp;
                var cb2 = msg ? cb : noOp;
                if (opts.showOverlay)
                    lyr2._fadeIn(opts.fadeIn, cb1);
                if (msg)
                    lyr3._fadeIn(opts.fadeIn, cb2);
            }
            else {
                if (opts.showOverlay)
                    lyr2.show();
                if (msg)
                    lyr3.show();
                if (opts.onBlock)
                    opts.onBlock.bind(lyr3)();
            }

            // bind key and mouse events
            bind(1, el, opts);

            if (full) {
                pageBlock = lyr3[0];
                pageBlockEls = $(opts.focusableElements, pageBlock);
                if (opts.focusInput)
                    setTimeout(focus, 20);
            }
            else
                center(lyr3[0], opts.centerX, opts.centerY);

            if (opts.timeout) {
                // auto-unblock
                var to = setTimeout(function () {
                    if (full)
                        $.unblockUI(opts);
                    else
                        $(el).unblock(opts);
                }, opts.timeout);
                $(el).data('blockUI.timeout', to);
            }
        }

        // remove the block
        function remove(el, opts) {
            var count;
            var full = (el == window);
            var $el = $(el);
            var data = $el.data('blockUI.history');
            var to = $el.data('blockUI.timeout');
            if (to) {
                clearTimeout(to);
                $el.removeData('blockUI.timeout');
            }
            opts = $.extend({}, $.blockUI.defaults, opts || {});
            bind(0, el, opts); // unbind events

            if (opts.onUnblock === null) {
                opts.onUnblock = $el.data('blockUI.onUnblock');
                $el.removeData('blockUI.onUnblock');
            }

            var els;
            if (full) // crazy selector to handle odd field errors in ie6/7
                els = $('body').children().filter('.blockUI').add('body > .blockUI');
            else
                els = $el.find('>.blockUI');

            // fix cursor issue
            if (opts.cursorReset) {
                if (els.length > 1)
                    els[1].style.cursor = opts.cursorReset;
                if (els.length > 2)
                    els[2].style.cursor = opts.cursorReset;
            }

            if (full)
                pageBlock = pageBlockEls = null;

            if (opts.fadeOut) {
                count = els.length;
                els.stop().fadeOut(opts.fadeOut, function () {
                    if (--count === 0)
                        reset(els, data, opts, el);
                });
            }
            else
                reset(els, data, opts, el);
        }

        // move blocking element back into the DOM where it started
        function reset(els, data, opts, el) {
            var $el = $(el);
            if ($el.data('blockUI.isBlocked'))
                return;

            els.each(function (i, o) {
                // remove via DOM calls so we don't lose event handlers
                if (this.parentNode)
                    this.parentNode.removeChild(this);
            });

            if (data && data.el) {
                data.el.style.display = data.display;
                data.el.style.position = data.position;
                data.el.style.cursor = 'default'; // #59
                if (data.parent)
                    data.parent.appendChild(data.el);
                $el.removeData('blockUI.history');
            }

            if ($el.data('blockUI.static')) {
                $el.css('position', 'static'); // #22
            }

            if (typeof opts.onUnblock == 'function')
                opts.onUnblock(el, opts);

            // fix issue in Safari 6 where block artifacts remain until reflow
            var body = $(document.body), w = body.width(), cssW = body[0].style.width;
            body.width(w - 1).width(w);
            body[0].style.width = cssW;
        }

        // bind/unbind the handler
        function bind(b, el, opts) {
            var full = el == window, $el = $(el);

            // don't bother unbinding if there is nothing to unbind
            if (!b && (full && !pageBlock || !full && !$el.data('blockUI.isBlocked')))
                return;

            $el.data('blockUI.isBlocked', b);

            // don't bind events when overlay is not in use or if bindEvents is false
            if (!full || !opts.bindEvents || (b && !opts.showOverlay))
                return;

            // bind anchors and inputs for mouse and key events
            var events = 'mousedown mouseup keydown keypress keyup touchstart touchend touchmove';
            if (b)
                $(document).bind(events, opts, handler);
            else
                $(document).unbind(events, handler);

            // former impl...
            //		var $e = $('a,:input');
            //		b ? $e.bind(events, opts, handler) : $e.unbind(events, handler);
        }

        // event handler to suppress keyboard/mouse events when blocking
        function handler(e) {
            // allow tab navigation (conditionally)
            if (e.type === 'keydown' && e.keyCode && e.keyCode == 9) {
                if (pageBlock && e.data.constrainTabKey) {
                    var els = pageBlockEls;
                    var fwd = !e.shiftKey && e.target === els[els.length - 1];
                    var back = e.shiftKey && e.target === els[0];
                    if (fwd || back) {
                        setTimeout(function () {
                            focus(back);
                        }, 10);
                        return false;
                    }
                }
            }
            var opts = e.data;
            var target = $(e.target);
            if (target.hasClass('blockOverlay') && opts.onOverlayClick)
                opts.onOverlayClick(e);

            // allow events within the message content
            if (target.parents('div.' + opts.blockMsgClass).length > 0)
                return true;

            // allow events for content that is not being blocked
            return target.parents().children().filter('div.blockUI').length === 0;
        }

        function focus(back) {
            if (!pageBlockEls)
                return;
            var e = pageBlockEls[back === true ? pageBlockEls.length - 1 : 0];
            if (e)
                e.focus();
        }

        function center(el, x, y) {
            var p = el.parentNode, s = el.style;
            var l = ((p.offsetWidth - el.offsetWidth) / 2) - sz(p, 'borderLeftWidth');
            var t = ((p.offsetHeight - el.offsetHeight) / 2) - sz(p, 'borderTopWidth');
            if (x) s.left = l > 0 ? (l + 'px') : '0';
            if (y) s.top = t > 0 ? (t + 'px') : '0';
        }

        function sz(el, p) {
            return parseInt($.css(el, p), 10) || 0;
        }

    }


    /*global define:true */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], setup);
    } else if (typeof exports === 'object') {
        // Node/CommonJS
        setup(require('jquery'));
    } else {
        // Browser globals
        setup(jQuery);
    }

})();

/*!
 * Datepicker for Bootstrap v1.8.0 (https://github.com/uxsolutions/bootstrap-datepicker)
 *
 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
 */

!function (a) {
    "function" == typeof define && define.amd ? define(["jquery"], a) : a("object" == typeof exports ? require("jquery") : jQuery)
}(function (a, b) {
    function c() {
        return new Date(Date.UTC.apply(Date, arguments))
    }

    function d() {
        var a = new Date;
        return c(a.getFullYear(), a.getMonth(), a.getDate())
    }

    function e(a, b) {
        return a.getUTCFullYear() === b.getUTCFullYear() && a.getUTCMonth() === b.getUTCMonth() && a.getUTCDate() === b.getUTCDate()
    }

    function f(c, d) {
        return function () {
            return d !== b && a.fn.datepicker.deprecated(d), this[c].apply(this, arguments)
        }
    }

    function g(a) {
        return a && !isNaN(a.getTime())
    }

    function h(b, c) {
        function d(a, b) {
            return b.toLowerCase()
        }

        var e, f = a(b).data(), g = {}, h = new RegExp("^" + c.toLowerCase() + "([A-Z])");
        c = new RegExp("^" + c.toLowerCase());
        for (var i in f) c.test(i) && (e = i.replace(h, d), g[e] = f[i]);
        return g
    }

    function i(b) {
        var c = {};
        if (q[b] || (b = b.split("-")[0], q[b])) {
            var d = q[b];
            return a.each(p, function (a, b) {
                b in d && (c[b] = d[b])
            }), c
        }
    }

    var j = function () {
        var b = {
            get: function (a) {
                return this.slice(a)[0]
            }, contains: function (a) {
                for (var b = a && a.valueOf(), c = 0, d = this.length; c < d; c++) if (0 <= this[c].valueOf() - b && this[c].valueOf() - b < 864e5) return c;
                return -1
            }, remove: function (a) {
                this.splice(a, 1)
            }, replace: function (b) {
                b && (a.isArray(b) || (b = [b]), this.clear(), this.push.apply(this, b))
            }, clear: function () {
                this.length = 0
            }, copy: function () {
                var a = new j;
                return a.replace(this), a
            }
        };
        return function () {
            var c = [];
            return c.push.apply(c, arguments), a.extend(c, b), c
        }
    }(), k = function (b, c) {
        a.data(b, "datepicker", this), this._process_options(c), this.dates = new j, this.viewDate = this.o.defaultViewDate, this.focusDate = null, this.element = a(b), this.isInput = this.element.is("input"), this.inputField = this.isInput ? this.element : this.element.find("input"), this.component = !!this.element.hasClass("date") && this.element.find(".add-on, .input-group-addon, .btn"), this.component && 0 === this.component.length && (this.component = !1), this.isInline = !this.component && this.element.is("div"), this.picker = a(r.template), this._check_template(this.o.templates.leftArrow) && this.picker.find(".prev").html(this.o.templates.leftArrow), this._check_template(this.o.templates.rightArrow) && this.picker.find(".next").html(this.o.templates.rightArrow), this._buildEvents(), this._attachEvents(), this.isInline ? this.picker.addClass("datepicker-inline").appendTo(this.element) : this.picker.addClass("datepicker-dropdown dropdown-menu"), this.o.rtl && this.picker.addClass("datepicker-rtl"), this.o.calendarWeeks && this.picker.find(".datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear").attr("colspan", function (a, b) {
            return Number(b) + 1
        }), this._process_options({
            startDate: this._o.startDate,
            endDate: this._o.endDate,
            daysOfWeekDisabled: this.o.daysOfWeekDisabled,
            daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
            datesDisabled: this.o.datesDisabled
        }), this._allow_update = !1, this.setViewMode(this.o.startView), this._allow_update = !0, this.fillDow(), this.fillMonths(), this.update(), this.isInline && this.show()
    };
    k.prototype = {
        constructor: k,
        _resolveViewName: function (b) {
            return a.each(r.viewModes, function (c, d) {
                if (b === c || a.inArray(b, d.names) !== -1) return b = c, !1
            }), b
        },
        _resolveDaysOfWeek: function (b) {
            return a.isArray(b) || (b = b.split(/[,\s]*/)), a.map(b, Number)
        },
        _check_template: function (c) {
            try {
                if (c === b || "" === c) return !1;
                if ((c.match(/[<>]/g) || []).length <= 0) return !0;
                var d = a(c);
                return d.length > 0
            } catch (a) {
                return !1
            }
        },
        _process_options: function (b) {
            this._o = a.extend({}, this._o, b);
            var e = this.o = a.extend({}, this._o), f = e.language;
            q[f] || (f = f.split("-")[0], q[f] || (f = o.language)), e.language = f, e.startView = this._resolveViewName(e.startView), e.minViewMode = this._resolveViewName(e.minViewMode), e.maxViewMode = this._resolveViewName(e.maxViewMode), e.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, e.startView)), e.multidate !== !0 && (e.multidate = Number(e.multidate) || !1, e.multidate !== !1 && (e.multidate = Math.max(0, e.multidate))), e.multidateSeparator = String(e.multidateSeparator), e.weekStart %= 7, e.weekEnd = (e.weekStart + 6) % 7;
            var g = r.parseFormat(e.format);
            e.startDate !== -(1 / 0) && (e.startDate ? e.startDate instanceof Date ? e.startDate = this._local_to_utc(this._zero_time(e.startDate)) : e.startDate = r.parseDate(e.startDate, g, e.language, e.assumeNearbyYear) : e.startDate = -(1 / 0)), e.endDate !== 1 / 0 && (e.endDate ? e.endDate instanceof Date ? e.endDate = this._local_to_utc(this._zero_time(e.endDate)) : e.endDate = r.parseDate(e.endDate, g, e.language, e.assumeNearbyYear) : e.endDate = 1 / 0), e.daysOfWeekDisabled = this._resolveDaysOfWeek(e.daysOfWeekDisabled || []), e.daysOfWeekHighlighted = this._resolveDaysOfWeek(e.daysOfWeekHighlighted || []), e.datesDisabled = e.datesDisabled || [], a.isArray(e.datesDisabled) || (e.datesDisabled = e.datesDisabled.split(",")), e.datesDisabled = a.map(e.datesDisabled, function (a) {
                return r.parseDate(a, g, e.language, e.assumeNearbyYear)
            });
            var h = String(e.orientation).toLowerCase().split(/\s+/g), i = e.orientation.toLowerCase();
            if (h = a.grep(h, function (a) {
                return /^auto|left|right|top|bottom$/.test(a)
            }), e.orientation = {x: "auto", y: "auto"}, i && "auto" !== i) if (1 === h.length) switch (h[0]) {
                case"top":
                case"bottom":
                    e.orientation.y = h[0];
                    break;
                case"left":
                case"right":
                    e.orientation.x = h[0]
            } else i = a.grep(h, function (a) {
                return /^left|right$/.test(a)
            }), e.orientation.x = i[0] || "auto", i = a.grep(h, function (a) {
                return /^top|bottom$/.test(a)
            }), e.orientation.y = i[0] || "auto"; else ;
            if (e.defaultViewDate instanceof Date || "string" == typeof e.defaultViewDate) e.defaultViewDate = r.parseDate(e.defaultViewDate, g, e.language, e.assumeNearbyYear); else if (e.defaultViewDate) {
                var j = e.defaultViewDate.year || (new Date).getFullYear(), k = e.defaultViewDate.month || 0,
                    l = e.defaultViewDate.day || 1;
                e.defaultViewDate = c(j, k, l)
            } else e.defaultViewDate = d()
        },
        _events: [],
        _secondaryEvents: [],
        _applyEvents: function (a) {
            for (var c, d, e, f = 0; f < a.length; f++) c = a[f][0], 2 === a[f].length ? (d = b, e = a[f][1]) : 3 === a[f].length && (d = a[f][1], e = a[f][2]), c.on(e, d)
        },
        _unapplyEvents: function (a) {
            for (var c, d, e, f = 0; f < a.length; f++) c = a[f][0], 2 === a[f].length ? (e = b, d = a[f][1]) : 3 === a[f].length && (e = a[f][1], d = a[f][2]), c.off(d, e)
        },
        _buildEvents: function () {
            var b = {
                keyup: a.proxy(function (b) {
                    a.inArray(b.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1 && this.update()
                }, this), keydown: a.proxy(this.keydown, this), paste: a.proxy(this.paste, this)
            };
            this.o.showOnFocus === !0 && (b.focus = a.proxy(this.show, this)), this.isInput ? this._events = [[this.element, b]] : this.component && this.inputField.length ? this._events = [[this.inputField, b], [this.component, {click: a.proxy(this.show, this)}]] : this._events = [[this.element, {
                click: a.proxy(this.show, this),
                keydown: a.proxy(this.keydown, this)
            }]], this._events.push([this.element, "*", {
                blur: a.proxy(function (a) {
                    this._focused_from = a.target
                }, this)
            }], [this.element, {
                blur: a.proxy(function (a) {
                    this._focused_from = a.target
                }, this)
            }]), this.o.immediateUpdates && this._events.push([this.element, {
                "changeYear changeMonth": a.proxy(function (a) {
                    this.update(a.date)
                }, this)
            }]), this._secondaryEvents = [[this.picker, {click: a.proxy(this.click, this)}], [this.picker, ".prev, .next", {click: a.proxy(this.navArrowsClick, this)}], [this.picker, ".day:not(.disabled)", {click: a.proxy(this.dayCellClick, this)}], [a(window), {resize: a.proxy(this.place, this)}], [a(document), {
                "mousedown touchstart": a.proxy(function (a) {
                    this.element.is(a.target) || this.element.find(a.target).length || this.picker.is(a.target) || this.picker.find(a.target).length || this.isInline || this.hide()
                }, this)
            }]]
        },
        _attachEvents: function () {
            this._detachEvents(), this._applyEvents(this._events)
        },
        _detachEvents: function () {
            this._unapplyEvents(this._events)
        },
        _attachSecondaryEvents: function () {
            this._detachSecondaryEvents(), this._applyEvents(this._secondaryEvents)
        },
        _detachSecondaryEvents: function () {
            this._unapplyEvents(this._secondaryEvents)
        },
        _trigger: function (b, c) {
            var d = c || this.dates.get(-1), e = this._utc_to_local(d);
            this.element.trigger({
                type: b,
                date: e,
                viewMode: this.viewMode,
                dates: a.map(this.dates, this._utc_to_local),
                format: a.proxy(function (a, b) {
                    0 === arguments.length ? (a = this.dates.length - 1, b = this.o.format) : "string" == typeof a && (b = a, a = this.dates.length - 1), b = b || this.o.format;
                    var c = this.dates.get(a);
                    return r.formatDate(c, b, this.o.language)
                }, this)
            })
        },
        show: function () {
            if (!(this.inputField.prop("disabled") || this.inputField.prop("readonly") && this.o.enableOnReadonly === !1)) return this.isInline || this.picker.appendTo(this.o.container), this.place(), this.picker.show(), this._attachSecondaryEvents(), this._trigger("show"), (window.navigator.msMaxTouchPoints || "ontouchstart" in document) && this.o.disableTouchKeyboard && a(this.element).blur(), this
        },
        hide: function () {
            return this.isInline || !this.picker.is(":visible") ? this : (this.focusDate = null, this.picker.hide().detach(), this._detachSecondaryEvents(), this.setViewMode(this.o.startView), this.o.forceParse && this.inputField.val() && this.setValue(), this._trigger("hide"), this)
        },
        destroy: function () {
            return this.hide(), this._detachEvents(), this._detachSecondaryEvents(), this.picker.remove(), delete this.element.data().datepicker, this.isInput || delete this.element.data().date, this
        },
        paste: function (b) {
            var c;
            if (b.originalEvent.clipboardData && b.originalEvent.clipboardData.types && a.inArray("text/plain", b.originalEvent.clipboardData.types) !== -1) c = b.originalEvent.clipboardData.getData("text/plain"); else {
                if (!window.clipboardData) return;
                c = window.clipboardData.getData("Text")
            }
            this.setDate(c), this.update(), b.preventDefault()
        },
        _utc_to_local: function (a) {
            if (!a) return a;
            var b = new Date(a.getTime() + 6e4 * a.getTimezoneOffset());
            return b.getTimezoneOffset() !== a.getTimezoneOffset() && (b = new Date(a.getTime() + 6e4 * b.getTimezoneOffset())), b
        },
        _local_to_utc: function (a) {
            return a && new Date(a.getTime() - 6e4 * a.getTimezoneOffset())
        },
        _zero_time: function (a) {
            return a && new Date(a.getFullYear(), a.getMonth(), a.getDate())
        },
        _zero_utc_time: function (a) {
            return a && c(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate())
        },
        getDates: function () {
            return a.map(this.dates, this._utc_to_local)
        },
        getUTCDates: function () {
            return a.map(this.dates, function (a) {
                return new Date(a)
            })
        },
        getDate: function () {
            return this._utc_to_local(this.getUTCDate())
        },
        getUTCDate: function () {
            var a = this.dates.get(-1);
            return a !== b ? new Date(a) : null
        },
        clearDates: function () {
            this.inputField.val(""), this.update(), this._trigger("changeDate"), this.o.autoclose && this.hide()
        },
        setDates: function () {
            var b = a.isArray(arguments[0]) ? arguments[0] : arguments;
            return this.update.apply(this, b), this._trigger("changeDate"), this.setValue(), this
        },
        setUTCDates: function () {
            var b = a.isArray(arguments[0]) ? arguments[0] : arguments;
            return this.setDates.apply(this, a.map(b, this._utc_to_local)), this
        },
        setDate: f("setDates"),
        setUTCDate: f("setUTCDates"),
        remove: f("destroy", "Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead"),
        setValue: function () {
            var a = this.getFormattedDate();
            return this.inputField.val(a), this
        },
        getFormattedDate: function (c) {
            c === b && (c = this.o.format);
            var d = this.o.language;
            return a.map(this.dates, function (a) {
                return r.formatDate(a, c, d)
            }).join(this.o.multidateSeparator)
        },
        getStartDate: function () {
            return this.o.startDate
        },
        setStartDate: function (a) {
            return this._process_options({startDate: a}), this.update(), this.updateNavArrows(), this
        },
        getEndDate: function () {
            return this.o.endDate
        },
        setEndDate: function (a) {
            return this._process_options({endDate: a}), this.update(), this.updateNavArrows(), this
        },
        setDaysOfWeekDisabled: function (a) {
            return this._process_options({daysOfWeekDisabled: a}), this.update(), this
        },
        setDaysOfWeekHighlighted: function (a) {
            return this._process_options({daysOfWeekHighlighted: a}), this.update(), this
        },
        setDatesDisabled: function (a) {
            return this._process_options({datesDisabled: a}), this.update(), this
        },
        place: function () {
            if (this.isInline) return this;
            var b = this.picker.outerWidth(), c = this.picker.outerHeight(), d = 10, e = a(this.o.container),
                f = e.width(), g = "body" === this.o.container ? a(document).scrollTop() : e.scrollTop(),
                h = e.offset(), i = [0];
            this.element.parents().each(function () {
                var b = a(this).css("z-index");
                "auto" !== b && 0 !== Number(b) && i.push(Number(b))
            });
            var j = Math.max.apply(Math, i) + this.o.zIndexOffset,
                k = this.component ? this.component.parent().offset() : this.element.offset(),
                l = this.component ? this.component.outerHeight(!0) : this.element.outerHeight(!1),
                m = this.component ? this.component.outerWidth(!0) : this.element.outerWidth(!1), n = k.left - h.left,
                o = k.top - h.top;
            "body" !== this.o.container && (o += g), this.picker.removeClass("datepicker-orient-top datepicker-orient-bottom datepicker-orient-right datepicker-orient-left"), "auto" !== this.o.orientation.x ? (this.picker.addClass("datepicker-orient-" + this.o.orientation.x), "right" === this.o.orientation.x && (n -= b - m)) : k.left < 0 ? (this.picker.addClass("datepicker-orient-left"), n -= k.left - d) : n + b > f ? (this.picker.addClass("datepicker-orient-right"), n += m - b) : this.o.rtl ? this.picker.addClass("datepicker-orient-right") : this.picker.addClass("datepicker-orient-left");
            var p, q = this.o.orientation.y;
            if ("auto" === q && (p = -g + o - c, q = p < 0 ? "bottom" : "top"), this.picker.addClass("datepicker-orient-" + q), "top" === q ? o -= c + parseInt(this.picker.css("padding-top")) : o += l, this.o.rtl) {
                var r = f - (n + m);
                this.picker.css({top: o, right: r, zIndex: j})
            } else this.picker.css({top: o, left: n, zIndex: j});
            return this
        },
        _allow_update: !0,
        update: function () {
            if (!this._allow_update) return this;
            var b = this.dates.copy(), c = [], d = !1;
            return arguments.length ? (a.each(arguments, a.proxy(function (a, b) {
                b instanceof Date && (b = this._local_to_utc(b)), c.push(b)
            }, this)), d = !0) : (c = this.isInput ? this.element.val() : this.element.data("date") || this.inputField.val(), c = c && this.o.multidate ? c.split(this.o.multidateSeparator) : [c], delete this.element.data().date), c = a.map(c, a.proxy(function (a) {
                return r.parseDate(a, this.o.format, this.o.language, this.o.assumeNearbyYear)
            }, this)), c = a.grep(c, a.proxy(function (a) {
                return !this.dateWithinRange(a) || !a
            }, this), !0), this.dates.replace(c), this.o.updateViewDate && (this.dates.length ? this.viewDate = new Date(this.dates.get(-1)) : this.viewDate < this.o.startDate ? this.viewDate = new Date(this.o.startDate) : this.viewDate > this.o.endDate ? this.viewDate = new Date(this.o.endDate) : this.viewDate = this.o.defaultViewDate), d ? (this.setValue(), this.element.change()) : this.dates.length && String(b) !== String(this.dates) && d && (this._trigger("changeDate"), this.element.change()), !this.dates.length && b.length && (this._trigger("clearDate"), this.element.change()), this.fill(), this
        },
        fillDow: function () {
            if (this.o.showWeekDays) {
                var b = this.o.weekStart, c = "<tr>";
                for (this.o.calendarWeeks && (c += '<th class="cw">&#160;</th>'); b < this.o.weekStart + 7;) c += '<th class="dow', a.inArray(b, this.o.daysOfWeekDisabled) !== -1 && (c += " disabled"), c += '">' + q[this.o.language].daysMin[b++ % 7] + "</th>";
                c += "</tr>", this.picker.find(".datepicker-days thead").append(c)
            }
        },
        fillMonths: function () {
            for (var a, b = this._utc_to_local(this.viewDate), c = "", d = 0; d < 12; d++) a = b && b.getMonth() === d ? " focused" : "", c += '<span class="month' + a + '">' + q[this.o.language].monthsShort[d] + "</span>";
            this.picker.find(".datepicker-months td").html(c)
        },
        setRange: function (b) {
            b && b.length ? this.range = a.map(b, function (a) {
                return a.valueOf()
            }) : delete this.range, this.fill()
        },
        getClassNames: function (b) {
            var c = [], f = this.viewDate.getUTCFullYear(), g = this.viewDate.getUTCMonth(), h = d();
            return b.getUTCFullYear() < f || b.getUTCFullYear() === f && b.getUTCMonth() < g ? c.push("old") : (b.getUTCFullYear() > f || b.getUTCFullYear() === f && b.getUTCMonth() > g) && c.push("new"), this.focusDate && b.valueOf() === this.focusDate.valueOf() && c.push("focused"), this.o.todayHighlight && e(b, h) && c.push("today"), this.dates.contains(b) !== -1 && c.push("active"), this.dateWithinRange(b) || c.push("disabled"), this.dateIsDisabled(b) && c.push("disabled", "disabled-date"), a.inArray(b.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1 && c.push("highlighted"), this.range && (b > this.range[0] && b < this.range[this.range.length - 1] && c.push("range"), a.inArray(b.valueOf(), this.range) !== -1 && c.push("selected"), b.valueOf() === this.range[0] && c.push("range-start"), b.valueOf() === this.range[this.range.length - 1] && c.push("range-end")), c
        },
        _fill_yearsView: function (c, d, e, f, g, h, i) {
            for (var j, k, l, m = "", n = e / 10, o = this.picker.find(c), p = Math.floor(f / e) * e, q = p + 9 * n, r = Math.floor(this.viewDate.getFullYear() / n) * n, s = a.map(this.dates, function (a) {
                return Math.floor(a.getUTCFullYear() / n) * n
            }), t = p - n; t <= q + n; t += n) j = [d], k = null, t === p - n ? j.push("old") : t === q + n && j.push("new"), a.inArray(t, s) !== -1 && j.push("active"), (t < g || t > h) && j.push("disabled"), t === r && j.push("focused"), i !== a.noop && (l = i(new Date(t, 0, 1)), l === b ? l = {} : "boolean" == typeof l ? l = {enabled: l} : "string" == typeof l && (l = {classes: l}), l.enabled === !1 && j.push("disabled"), l.classes && (j = j.concat(l.classes.split(/\s+/))), l.tooltip && (k = l.tooltip)), m += '<span class="' + j.join(" ") + '"' + (k ? ' title="' + k + '"' : "") + ">" + t + "</span>";
            o.find(".datepicker-switch").text(p + "-" + q), o.find("td").html(m)
        },
        fill: function () {
            var d, e, f = new Date(this.viewDate), g = f.getUTCFullYear(), h = f.getUTCMonth(),
                i = this.o.startDate !== -(1 / 0) ? this.o.startDate.getUTCFullYear() : -(1 / 0),
                j = this.o.startDate !== -(1 / 0) ? this.o.startDate.getUTCMonth() : -(1 / 0),
                k = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCFullYear() : 1 / 0,
                l = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCMonth() : 1 / 0,
                m = q[this.o.language].today || q.en.today || "", n = q[this.o.language].clear || q.en.clear || "",
                o = q[this.o.language].titleFormat || q.en.titleFormat;
            if (!isNaN(g) && !isNaN(h)) {
                this.picker.find(".datepicker-days .datepicker-switch").text(r.formatDate(f, o, this.o.language)), this.picker.find("tfoot .today").text(m).css("display", this.o.todayBtn === !0 || "linked" === this.o.todayBtn ? "table-cell" : "none"), this.picker.find("tfoot .clear").text(n).css("display", this.o.clearBtn === !0 ? "table-cell" : "none"), this.picker.find("thead .datepicker-title").text(this.o.title).css("display", "string" == typeof this.o.title && "" !== this.o.title ? "table-cell" : "none"), this.updateNavArrows(), this.fillMonths();
                var p = c(g, h, 0), s = p.getUTCDate();
                p.setUTCDate(s - (p.getUTCDay() - this.o.weekStart + 7) % 7);
                var t = new Date(p);
                p.getUTCFullYear() < 100 && t.setUTCFullYear(p.getUTCFullYear()), t.setUTCDate(t.getUTCDate() + 42), t = t.valueOf();
                for (var u, v, w = []; p.valueOf() < t;) {
                    if (u = p.getUTCDay(), u === this.o.weekStart && (w.push("<tr>"), this.o.calendarWeeks)) {
                        var x = new Date(+p + (this.o.weekStart - u - 7) % 7 * 864e5),
                            y = new Date(Number(x) + (11 - x.getUTCDay()) % 7 * 864e5),
                            z = new Date(Number(z = c(y.getUTCFullYear(), 0, 1)) + (11 - z.getUTCDay()) % 7 * 864e5),
                            A = (y - z) / 864e5 / 7 + 1;
                        w.push('<td class="cw">' + A + "</td>")
                    }
                    v = this.getClassNames(p), v.push("day");
                    var B = p.getUTCDate();
                    this.o.beforeShowDay !== a.noop && (e = this.o.beforeShowDay(this._utc_to_local(p)), e === b ? e = {} : "boolean" == typeof e ? e = {enabled: e} : "string" == typeof e && (e = {classes: e}), e.enabled === !1 && v.push("disabled"), e.classes && (v = v.concat(e.classes.split(/\s+/))), e.tooltip && (d = e.tooltip), e.content && (B = e.content)), v = a.isFunction(a.uniqueSort) ? a.uniqueSort(v) : a.unique(v), w.push('<td class="' + v.join(" ") + '"' + (d ? ' title="' + d + '"' : "") + ' data-date="' + p.getTime().toString() + '">' + B + "</td>"), d = null, u === this.o.weekEnd && w.push("</tr>"), p.setUTCDate(p.getUTCDate() + 1)
                }
                this.picker.find(".datepicker-days tbody").html(w.join(""));
                var C = q[this.o.language].monthsTitle || q.en.monthsTitle || "Months",
                    D = this.picker.find(".datepicker-months").find(".datepicker-switch").text(this.o.maxViewMode < 2 ? C : g).end().find("tbody span").removeClass("active");
                if (a.each(this.dates, function (a, b) {
                    b.getUTCFullYear() === g && D.eq(b.getUTCMonth()).addClass("active")
                }), (g < i || g > k) && D.addClass("disabled"), g === i && D.slice(0, j).addClass("disabled"), g === k && D.slice(l + 1).addClass("disabled"), this.o.beforeShowMonth !== a.noop) {
                    var E = this;
                    a.each(D, function (c, d) {
                        var e = new Date(g, c, 1), f = E.o.beforeShowMonth(e);
                        f === b ? f = {} : "boolean" == typeof f ? f = {enabled: f} : "string" == typeof f && (f = {classes: f}), f.enabled !== !1 || a(d).hasClass("disabled") || a(d).addClass("disabled"), f.classes && a(d).addClass(f.classes), f.tooltip && a(d).prop("title", f.tooltip)
                    })
                }
                this._fill_yearsView(".datepicker-years", "year", 10, g, i, k, this.o.beforeShowYear), this._fill_yearsView(".datepicker-decades", "decade", 100, g, i, k, this.o.beforeShowDecade), this._fill_yearsView(".datepicker-centuries", "century", 1e3, g, i, k, this.o.beforeShowCentury)
            }
        },
        updateNavArrows: function () {
            if (this._allow_update) {
                var a, b, c = new Date(this.viewDate), d = c.getUTCFullYear(), e = c.getUTCMonth(),
                    f = this.o.startDate !== -(1 / 0) ? this.o.startDate.getUTCFullYear() : -(1 / 0),
                    g = this.o.startDate !== -(1 / 0) ? this.o.startDate.getUTCMonth() : -(1 / 0),
                    h = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCFullYear() : 1 / 0,
                    i = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCMonth() : 1 / 0, j = 1;
                switch (this.viewMode) {
                    case 4:
                        j *= 10;
                    case 3:
                        j *= 10;
                    case 2:
                        j *= 10;
                    case 1:
                        a = Math.floor(d / j) * j < f, b = Math.floor(d / j) * j + j > h;
                        break;
                    case 0:
                        a = d <= f && e < g, b = d >= h && e > i
                }
                this.picker.find(".prev").toggleClass("disabled", a), this.picker.find(".next").toggleClass("disabled", b)
            }
        },
        click: function (b) {
            b.preventDefault(), b.stopPropagation();
            var e, f, g, h;
            e = a(b.target), e.hasClass("datepicker-switch") && this.viewMode !== this.o.maxViewMode && this.setViewMode(this.viewMode + 1), e.hasClass("today") && !e.hasClass("day") && (this.setViewMode(0), this._setDate(d(), "linked" === this.o.todayBtn ? null : "view")), e.hasClass("clear") && this.clearDates(), e.hasClass("disabled") || (e.hasClass("month") || e.hasClass("year") || e.hasClass("decade") || e.hasClass("century")) && (this.viewDate.setUTCDate(1), f = 1, 1 === this.viewMode ? (h = e.parent().find("span").index(e), g = this.viewDate.getUTCFullYear(), this.viewDate.setUTCMonth(h)) : (h = 0, g = Number(e.text()), this.viewDate.setUTCFullYear(g)), this._trigger(r.viewModes[this.viewMode - 1].e, this.viewDate), this.viewMode === this.o.minViewMode ? this._setDate(c(g, h, f)) : (this.setViewMode(this.viewMode - 1), this.fill())), this.picker.is(":visible") && this._focused_from && this._focused_from.focus(), delete this._focused_from
        },
        dayCellClick: function (b) {
            var c = a(b.currentTarget), d = c.data("date"), e = new Date(d);
            this.o.updateViewDate && (e.getUTCFullYear() !== this.viewDate.getUTCFullYear() && this._trigger("changeYear", this.viewDate), e.getUTCMonth() !== this.viewDate.getUTCMonth() && this._trigger("changeMonth", this.viewDate)), this._setDate(e)
        },
        navArrowsClick: function (b) {
            var c = a(b.currentTarget), d = c.hasClass("prev") ? -1 : 1;
            0 !== this.viewMode && (d *= 12 * r.viewModes[this.viewMode].navStep), this.viewDate = this.moveMonth(this.viewDate, d), this._trigger(r.viewModes[this.viewMode].e, this.viewDate), this.fill()
        },
        _toggle_multidate: function (a) {
            var b = this.dates.contains(a);
            if (a || this.dates.clear(), b !== -1 ? (this.o.multidate === !0 || this.o.multidate > 1 || this.o.toggleActive) && this.dates.remove(b) : this.o.multidate === !1 ? (this.dates.clear(), this.dates.push(a)) : this.dates.push(a), "number" == typeof this.o.multidate) for (; this.dates.length > this.o.multidate;) this.dates.remove(0)
        },
        _setDate: function (a, b) {
            b && "date" !== b || this._toggle_multidate(a && new Date(a)), (!b && this.o.updateViewDate || "view" === b) && (this.viewDate = a && new Date(a)), this.fill(), this.setValue(), b && "view" === b || this._trigger("changeDate"), this.inputField.trigger("change"), !this.o.autoclose || b && "date" !== b || this.hide()
        },
        moveDay: function (a, b) {
            var c = new Date(a);
            return c.setUTCDate(a.getUTCDate() + b), c
        },
        moveWeek: function (a, b) {
            return this.moveDay(a, 7 * b)
        },
        moveMonth: function (a, b) {
            if (!g(a)) return this.o.defaultViewDate;
            if (!b) return a;
            var c, d, e = new Date(a.valueOf()), f = e.getUTCDate(), h = e.getUTCMonth(), i = Math.abs(b);
            if (b = b > 0 ? 1 : -1, 1 === i) d = b === -1 ? function () {
                return e.getUTCMonth() === h
            } : function () {
                return e.getUTCMonth() !== c
            }, c = h + b, e.setUTCMonth(c), c = (c + 12) % 12; else {
                for (var j = 0; j < i; j++) e = this.moveMonth(e, b);
                c = e.getUTCMonth(), e.setUTCDate(f), d = function () {
                    return c !== e.getUTCMonth()
                }
            }
            for (; d();) e.setUTCDate(--f), e.setUTCMonth(c);
            return e
        },
        moveYear: function (a, b) {
            return this.moveMonth(a, 12 * b)
        },
        moveAvailableDate: function (a, b, c) {
            do {
                if (a = this[c](a, b), !this.dateWithinRange(a)) return !1;
                c = "moveDay"
            } while (this.dateIsDisabled(a));
            return a
        },
        weekOfDateIsDisabled: function (b) {
            return a.inArray(b.getUTCDay(), this.o.daysOfWeekDisabled) !== -1
        },
        dateIsDisabled: function (b) {
            return this.weekOfDateIsDisabled(b) || a.grep(this.o.datesDisabled, function (a) {
                return e(b, a)
            }).length > 0
        },
        dateWithinRange: function (a) {
            return a >= this.o.startDate && a <= this.o.endDate
        },
        keydown: function (a) {
            if (!this.picker.is(":visible")) return void(40 !== a.keyCode && 27 !== a.keyCode || (this.show(), a.stopPropagation()));
            var b, c, d = !1, e = this.focusDate || this.viewDate;
            switch (a.keyCode) {
                case 27:
                    this.focusDate ? (this.focusDate = null, this.viewDate = this.dates.get(-1) || this.viewDate, this.fill()) : this.hide(), a.preventDefault(), a.stopPropagation();
                    break;
                case 37:
                case 38:
                case 39:
                case 40:
                    if (!this.o.keyboardNavigation || 7 === this.o.daysOfWeekDisabled.length) break;
                    b = 37 === a.keyCode || 38 === a.keyCode ? -1 : 1, 0 === this.viewMode ? a.ctrlKey ? (c = this.moveAvailableDate(e, b, "moveYear"), c && this._trigger("changeYear", this.viewDate)) : a.shiftKey ? (c = this.moveAvailableDate(e, b, "moveMonth"), c && this._trigger("changeMonth", this.viewDate)) : 37 === a.keyCode || 39 === a.keyCode ? c = this.moveAvailableDate(e, b, "moveDay") : this.weekOfDateIsDisabled(e) || (c = this.moveAvailableDate(e, b, "moveWeek")) : 1 === this.viewMode ? (38 !== a.keyCode && 40 !== a.keyCode || (b *= 4), c = this.moveAvailableDate(e, b, "moveMonth")) : 2 === this.viewMode && (38 !== a.keyCode && 40 !== a.keyCode || (b *= 4), c = this.moveAvailableDate(e, b, "moveYear")), c && (this.focusDate = this.viewDate = c, this.setValue(), this.fill(), a.preventDefault());
                    break;
                case 13:
                    if (!this.o.forceParse) break;
                    e = this.focusDate || this.dates.get(-1) || this.viewDate, this.o.keyboardNavigation && (this._toggle_multidate(e), d = !0), this.focusDate = null, this.viewDate = this.dates.get(-1) || this.viewDate, this.setValue(), this.fill(), this.picker.is(":visible") && (a.preventDefault(), a.stopPropagation(), this.o.autoclose && this.hide());
                    break;
                case 9:
                    this.focusDate = null, this.viewDate = this.dates.get(-1) || this.viewDate, this.fill(), this.hide()
            }
            d && (this.dates.length ? this._trigger("changeDate") : this._trigger("clearDate"), this.inputField.trigger("change"))
        },
        setViewMode: function (a) {
            this.viewMode = a, this.picker.children("div").hide().filter(".datepicker-" + r.viewModes[this.viewMode].clsName).show(), this.updateNavArrows(), this._trigger("changeViewMode", new Date(this.viewDate))
        }
    };
    var l = function (b, c) {
        a.data(b, "datepicker", this), this.element = a(b), this.inputs = a.map(c.inputs, function (a) {
            return a.jquery ? a[0] : a
        }), delete c.inputs, this.keepEmptyValues = c.keepEmptyValues, delete c.keepEmptyValues, n.call(a(this.inputs), c).on("changeDate", a.proxy(this.dateUpdated, this)), this.pickers = a.map(this.inputs, function (b) {
            return a.data(b, "datepicker")
        }), this.updateDates()
    };
    l.prototype = {
        updateDates: function () {
            this.dates = a.map(this.pickers, function (a) {
                return a.getUTCDate()
            }), this.updateRanges()
        },
        updateRanges: function () {
            var b = a.map(this.dates, function (a) {
                return a.valueOf()
            });
            a.each(this.pickers, function (a, c) {
                c.setRange(b)
            })
        },
        clearDates: function () {
            a.each(this.pickers, function (a, b) {
                b.clearDates()
            })
        },
        dateUpdated: function (c) {
            if (!this.updating) {
                this.updating = !0;
                var d = a.data(c.target, "datepicker");
                if (d !== b) {
                    var e = d.getUTCDate(), f = this.keepEmptyValues, g = a.inArray(c.target, this.inputs), h = g - 1,
                        i = g + 1, j = this.inputs.length;
                    if (g !== -1) {
                        if (a.each(this.pickers, function (a, b) {
                            b.getUTCDate() || b !== d && f || b.setUTCDate(e)
                        }), e < this.dates[h]) for (; h >= 0 && e < this.dates[h];) this.pickers[h--].setUTCDate(e); else if (e > this.dates[i]) for (; i < j && e > this.dates[i];) this.pickers[i++].setUTCDate(e);
                        this.updateDates(), delete this.updating
                    }
                }
            }
        },
        destroy: function () {
            a.map(this.pickers, function (a) {
                a.destroy()
            }), a(this.inputs).off("changeDate", this.dateUpdated), delete this.element.data().datepicker
        },
        remove: f("destroy", "Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead")
    };
    var m = a.fn.datepicker, n = function (c) {
        var d = Array.apply(null, arguments);
        d.shift();
        var e;
        if (this.each(function () {
            var b = a(this), f = b.data("datepicker"), g = "object" == typeof c && c;
            if (!f) {
                var j = h(this, "date"), m = a.extend({}, o, j, g), n = i(m.language), p = a.extend({}, o, n, j, g);
                b.hasClass("input-daterange") || p.inputs ? (a.extend(p, {inputs: p.inputs || b.find("input").toArray()}), f = new l(this, p)) : f = new k(this, p), b.data("datepicker", f)
            }
            "string" == typeof c && "function" == typeof f[c] && (e = f[c].apply(f, d))
        }), e === b || e instanceof k || e instanceof l) return this;
        if (this.length > 1) throw new Error("Using only allowed for the collection of a single element (" + c + " function)");
        return e
    };
    a.fn.datepicker = n;
    var o = a.fn.datepicker.defaults = {
        assumeNearbyYear: !1,
        autoclose: !1,
        beforeShowDay: a.noop,
        beforeShowMonth: a.noop,
        beforeShowYear: a.noop,
        beforeShowDecade: a.noop,
        beforeShowCentury: a.noop,
        calendarWeeks: !1,
        clearBtn: !1,
        toggleActive: !1,
        daysOfWeekDisabled: [],
        daysOfWeekHighlighted: [],
        datesDisabled: [],
        endDate: 1 / 0,
        forceParse: !0,
        format: "mm/dd/yyyy",
        keepEmptyValues: !1,
        keyboardNavigation: !0,
        language: "en",
        minViewMode: 0,
        maxViewMode: 4,
        multidate: !1,
        multidateSeparator: ",",
        orientation: "auto",
        rtl: !1,
        startDate: -(1 / 0),
        startView: 0,
        todayBtn: !1,
        todayHighlight: !1,
        updateViewDate: !0,
        weekStart: 0,
        disableTouchKeyboard: !1,
        enableOnReadonly: !0,
        showOnFocus: !0,
        zIndexOffset: 10,
        container: "body",
        immediateUpdates: !1,
        title: "",
        templates: {leftArrow: "&#x00AB;", rightArrow: "&#x00BB;"},
        showWeekDays: !0
    }, p = a.fn.datepicker.locale_opts = ["format", "rtl", "weekStart"];
    a.fn.datepicker.Constructor = k;
    var q = a.fn.datepicker.dates = {
        en: {
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            today: "Today",
            clear: "Clear",
            titleFormat: "MM yyyy"
        }
    }, r = {
        viewModes: [{names: ["days", "month"], clsName: "days", e: "changeMonth"}, {
            names: ["months", "year"],
            clsName: "months",
            e: "changeYear",
            navStep: 1
        }, {
            names: ["years", "decade"],
            clsName: "years",
            e: "changeDecade",
            navStep: 10
        }, {
            names: ["decades", "century"],
            clsName: "decades",
            e: "changeCentury",
            navStep: 100
        }, {names: ["centuries", "millennium"], clsName: "centuries", e: "changeMillennium", navStep: 1e3}],
        validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
        nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
        parseFormat: function (a) {
            if ("function" == typeof a.toValue && "function" == typeof a.toDisplay) return a;
            var b = a.replace(this.validParts, "\0").split("\0"), c = a.match(this.validParts);
            if (!b || !b.length || !c || 0 === c.length) throw new Error("Invalid date format.");
            return {separators: b, parts: c}
        },
        parseDate: function (c, e, f, g) {
            function h(a, b) {
                return b === !0 && (b = 10), a < 100 && (a += 2e3, a > (new Date).getFullYear() + b && (a -= 100)), a
            }

            function i() {
                var a = this.slice(0, j[n].length), b = j[n].slice(0, a.length);
                return a.toLowerCase() === b.toLowerCase()
            }

            if (!c) return b;
            if (c instanceof Date) return c;
            if ("string" == typeof e && (e = r.parseFormat(e)), e.toValue) return e.toValue(c, e, f);
            var j, l, m, n, o, p = {d: "moveDay", m: "moveMonth", w: "moveWeek", y: "moveYear"},
                s = {yesterday: "-1d", today: "+0d", tomorrow: "+1d"};
            if (c in s && (c = s[c]), /^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(c)) {
                for (j = c.match(/([\-+]\d+)([dmwy])/gi), c = new Date, n = 0; n < j.length; n++) l = j[n].match(/([\-+]\d+)([dmwy])/i), m = Number(l[1]), o = p[l[2].toLowerCase()], c = k.prototype[o](c, m);
                return k.prototype._zero_utc_time(c)
            }
            j = c && c.match(this.nonpunctuation) || [];
            var t, u, v = {}, w = ["yyyy", "yy", "M", "MM", "m", "mm", "d", "dd"], x = {
                yyyy: function (a, b) {
                    return a.setUTCFullYear(g ? h(b, g) : b)
                }, m: function (a, b) {
                    if (isNaN(a)) return a;
                    for (b -= 1; b < 0;) b += 12;
                    for (b %= 12, a.setUTCMonth(b); a.getUTCMonth() !== b;) a.setUTCDate(a.getUTCDate() - 1);
                    return a
                }, d: function (a, b) {
                    return a.setUTCDate(b)
                }
            };
            x.yy = x.yyyy, x.M = x.MM = x.mm = x.m, x.dd = x.d, c = d();
            var y = e.parts.slice();
            if (j.length !== y.length && (y = a(y).filter(function (b, c) {
                return a.inArray(c, w) !== -1
            }).toArray()), j.length === y.length) {
                var z;
                for (n = 0, z = y.length; n < z; n++) {
                    if (t = parseInt(j[n], 10), l = y[n], isNaN(t)) switch (l) {
                        case"MM":
                            u = a(q[f].months).filter(i), t = a.inArray(u[0], q[f].months) + 1;
                            break;
                        case"M":
                            u = a(q[f].monthsShort).filter(i), t = a.inArray(u[0], q[f].monthsShort) + 1
                    }
                    v[l] = t
                }
                var A, B;
                for (n = 0; n < w.length; n++) B = w[n], B in v && !isNaN(v[B]) && (A = new Date(c), x[B](A, v[B]), isNaN(A) || (c = A))
            }
            return c
        },
        formatDate: function (b, c, d) {
            if (!b) return "";
            if ("string" == typeof c && (c = r.parseFormat(c)), c.toDisplay) return c.toDisplay(b, c, d);
            var e = {
                d: b.getUTCDate(),
                D: q[d].daysShort[b.getUTCDay()],
                DD: q[d].days[b.getUTCDay()],
                m: b.getUTCMonth() + 1,
                M: q[d].monthsShort[b.getUTCMonth()],
                MM: q[d].months[b.getUTCMonth()],
                yy: b.getUTCFullYear().toString().substring(2),
                yyyy: b.getUTCFullYear()
            };
            e.dd = (e.d < 10 ? "0" : "") + e.d, e.mm = (e.m < 10 ? "0" : "") + e.m, b = [];
            for (var f = a.extend([], c.separators), g = 0, h = c.parts.length; g <= h; g++) f.length && b.push(f.shift()), b.push(e[c.parts[g]]);
            return b.join("")
        },
        headTemplate: '<thead><tr><th colspan="7" class="datepicker-title"></th></tr><tr><th class="prev">' + o.templates.leftArrow + '</th><th colspan="5" class="datepicker-switch"></th><th class="next">' + o.templates.rightArrow + "</th></tr></thead>",
        contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
        footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'
    };
    r.template = '<div class="datepicker"><div class="datepicker-days"><table class="table-condensed">' + r.headTemplate + "<tbody></tbody>" + r.footTemplate + '</table></div><div class="datepicker-months"><table class="table-condensed">' + r.headTemplate + r.contTemplate + r.footTemplate + '</table></div><div class="datepicker-years"><table class="table-condensed">' + r.headTemplate + r.contTemplate + r.footTemplate + '</table></div><div class="datepicker-decades"><table class="table-condensed">' + r.headTemplate + r.contTemplate + r.footTemplate + '</table></div><div class="datepicker-centuries"><table class="table-condensed">' + r.headTemplate + r.contTemplate + r.footTemplate + "</table></div></div>", a.fn.datepicker.DPGlobal = r, a.fn.datepicker.noConflict = function () {
        return a.fn.datepicker = m, this
    }, a.fn.datepicker.version = "1.8.0", a.fn.datepicker.deprecated = function (a) {
        var b = window.console;
        b && b.warn && b.warn("DEPRECATED: " + a)
    }, a(document).on("focus.datepicker.data-api click.datepicker.data-api", '[data-provide="datepicker"]', function (b) {
        var c = a(this);
        c.data("datepicker") || (b.preventDefault(), n.call(c, "show"))
    }), a(function () {
        n.call(a('[data-provide="datepicker-inline"]'))
    })
});
"use strict";
$.fn.datepicker.defaults.zIndexOffset = 10;
(function (a) {
    if (typeof define === "function" && define.amd) {
        define(["jquery"], a)
    } else {
        if (typeof exports === "object") {
            a(require("jquery"))
        } else {
            a(jQuery)
        }
    }
}(function (d, f) {
    if (!("indexOf" in Array.prototype)) {
        Array.prototype.indexOf = function (k, j) {
            if (j === f) {
                j = 0
            }
            if (j < 0) {
                j += this.length
            }
            if (j < 0) {
                j = 0
            }
            for (var l = this.length; j < l; j++) {
                if (j in this && this[j] === k) {
                    return j
                }
            }
            return -1
        }
    }

    function a() {
        var q, k, p, l, j, n, m, o;
        k = (new Date()).toString();
        p = ((m = k.split("(")[1]) != null ? m.slice(0, -1) : 0) || k.split(" ");
        if (p instanceof Array) {
            n = [];
            for (var l = 0, j = p.length; l < j; l++) {
                o = p[l];
                if ((q = (m = o.match(/\b[A-Z]+\b/)) !== null) ? m[0] : 0) {
                    n.push(q)
                }
            }
            p = n.pop()
        }
        return p
    }

    function h() {
        return new Date(Date.UTC.apply(Date, arguments))
    }

    var g = function (k, j) {
        var m = this;
        this.element = d(k);
        this.container = j.container || "body";
        this.language = j.language || this.element.data("date-language") || "en";
        this.language = this.language in e ? this.language : this.language.split("-")[0];
        this.language = this.language in e ? this.language : "en";
        this.isRTL = e[this.language].rtl || false;
        this.formatType = j.formatType || this.element.data("format-type") || "standard";
        this.format = c.parseFormat(j.format || this.element.data("date-format") || e[this.language].format || c.getDefaultFormat(this.formatType, "input"), this.formatType);
        this.isInline = false;
        this.isVisible = false;
        this.isInput = this.element.is("input");
        this.fontAwesome = j.fontAwesome || this.element.data("font-awesome") || false;
        this.bootcssVer = j.bootcssVer || (this.isInput ? (this.element.is(".form-control") ? 3 : 2) : (this.bootcssVer = this.element.is(".input-group") ? 3 : 2));
        this.component = this.element.is(".date") ? (this.bootcssVer === 3 ? this.element.find(".input-group-addon .glyphicon-th, .input-group-addon .glyphicon-time, .input-group-addon .glyphicon-remove, .input-group-addon .glyphicon-calendar, .input-group-addon .fa-calendar, .input-group-addon .fa-clock-o").parent() : this.element.find(".add-on .icon-th, .add-on .icon-time, .add-on .icon-calendar, .add-on .fa-calendar, .add-on .fa-clock-o").parent()) : false;
        this.componentReset = this.element.is(".date") ? (this.bootcssVer === 3 ? this.element.find(".input-group-addon .glyphicon-remove, .input-group-addon .fa-times").parent() : this.element.find(".add-on .icon-remove, .add-on .fa-times").parent()) : false;
        this.hasInput = this.component && this.element.find("input").length;
        if (this.component && this.component.length === 0) {
            this.component = false
        }
        this.linkField = j.linkField || this.element.data("link-field") || false;
        this.linkFormat = c.parseFormat(j.linkFormat || this.element.data("link-format") || c.getDefaultFormat(this.formatType, "link"), this.formatType);
        this.minuteStep = j.minuteStep || this.element.data("minute-step") || 5;
        this.pickerPosition = j.pickerPosition || this.element.data("picker-position") || "bottom-right";
        this.showMeridian = j.showMeridian || this.element.data("show-meridian") || false;
        this.initialDate = j.initialDate || new Date();
        this.zIndex = j.zIndex || this.element.data("z-index") || f;
        this.title = typeof j.title === "undefined" ? false : j.title;
        this.timezone = j.timezone || a();
        this.icons = {
            leftArrow: this.fontAwesome ? "fa-arrow-left" : (this.bootcssVer === 3 ? "glyphicon-arrow-left" : "icon-arrow-left"),
            rightArrow: this.fontAwesome ? "fa-arrow-right" : (this.bootcssVer === 3 ? "glyphicon-arrow-right" : "icon-arrow-right")
        };
        this.icontype = this.fontAwesome ? "fa" : "glyphicon";
        this._attachEvents();
        this.clickedOutside = function (n) {
            if (d(n.target).closest(".datetimepicker").length === 0) {
                m.hide()
            }
        };
        this.formatViewType = "datetime";
        if ("formatViewType" in j) {
            this.formatViewType = j.formatViewType
        } else {
            if ("formatViewType" in this.element.data()) {
                this.formatViewType = this.element.data("formatViewType")
            }
        }
        this.minView = 0;
        if ("minView" in j) {
            this.minView = j.minView
        } else {
            if ("minView" in this.element.data()) {
                this.minView = this.element.data("min-view")
            }
        }
        this.minView = c.convertViewMode(this.minView);
        this.maxView = c.modes.length - 1;
        if ("maxView" in j) {
            this.maxView = j.maxView
        } else {
            if ("maxView" in this.element.data()) {
                this.maxView = this.element.data("max-view")
            }
        }
        this.maxView = c.convertViewMode(this.maxView);
        this.wheelViewModeNavigation = false;
        if ("wheelViewModeNavigation" in j) {
            this.wheelViewModeNavigation = j.wheelViewModeNavigation
        } else {
            if ("wheelViewModeNavigation" in this.element.data()) {
                this.wheelViewModeNavigation = this.element.data("view-mode-wheel-navigation")
            }
        }
        this.wheelViewModeNavigationInverseDirection = false;
        if ("wheelViewModeNavigationInverseDirection" in j) {
            this.wheelViewModeNavigationInverseDirection = j.wheelViewModeNavigationInverseDirection
        } else {
            if ("wheelViewModeNavigationInverseDirection" in this.element.data()) {
                this.wheelViewModeNavigationInverseDirection = this.element.data("view-mode-wheel-navigation-inverse-dir")
            }
        }
        this.wheelViewModeNavigationDelay = 100;
        if ("wheelViewModeNavigationDelay" in j) {
            this.wheelViewModeNavigationDelay = j.wheelViewModeNavigationDelay
        } else {
            if ("wheelViewModeNavigationDelay" in this.element.data()) {
                this.wheelViewModeNavigationDelay = this.element.data("view-mode-wheel-navigation-delay")
            }
        }
        this.startViewMode = 2;
        if ("startView" in j) {
            this.startViewMode = j.startView
        } else {
            if ("startView" in this.element.data()) {
                this.startViewMode = this.element.data("start-view")
            }
        }
        this.startViewMode = c.convertViewMode(this.startViewMode);
        this.viewMode = this.startViewMode;
        this.viewSelect = this.minView;
        if ("viewSelect" in j) {
            this.viewSelect = j.viewSelect
        } else {
            if ("viewSelect" in this.element.data()) {
                this.viewSelect = this.element.data("view-select")
            }
        }
        this.viewSelect = c.convertViewMode(this.viewSelect);
        this.forceParse = true;
        if ("forceParse" in j) {
            this.forceParse = j.forceParse
        } else {
            if ("dateForceParse" in this.element.data()) {
                this.forceParse = this.element.data("date-force-parse")
            }
        }
        var l = this.bootcssVer === 3 ? c.templateV3 : c.template;
        while (l.indexOf("{iconType}") !== -1) {
            l = l.replace("{iconType}", this.icontype)
        }
        while (l.indexOf("{leftArrow}") !== -1) {
            l = l.replace("{leftArrow}", this.icons.leftArrow)
        }
        while (l.indexOf("{rightArrow}") !== -1) {
            l = l.replace("{rightArrow}", this.icons.rightArrow)
        }
        this.picker = d(l).appendTo(this.isInline ? this.element : this.container).on({
            click: d.proxy(this.click, this),
            mousedown: d.proxy(this.mousedown, this)
        });
        if (this.wheelViewModeNavigation) {
            if (d.fn.mousewheel) {
                this.picker.on({mousewheel: d.proxy(this.mousewheel, this)})
            } else {
                console.log("Mouse Wheel event is not supported. Please include the jQuery Mouse Wheel plugin before enabling this option")
            }
        }
        if (this.isInline) {
            this.picker.addClass("datetimepicker-inline")
        } else {
            this.picker.addClass("datetimepicker-dropdown-" + this.pickerPosition + " dropdown-menu")
        }
        if (this.isRTL) {
            this.picker.addClass("datetimepicker-rtl");
            var i = this.bootcssVer === 3 ? ".prev span, .next span" : ".prev i, .next i";
            this.picker.find(i).toggleClass(this.icons.leftArrow + " " + this.icons.rightArrow)
        }
        d(document).on("mousedown touchend", this.clickedOutside);
        this.autoclose = false;
        if ("autoclose" in j) {
            this.autoclose = j.autoclose
        } else {
            if ("dateAutoclose" in this.element.data()) {
                this.autoclose = this.element.data("date-autoclose")
            }
        }
        this.keyboardNavigation = true;
        if ("keyboardNavigation" in j) {
            this.keyboardNavigation = j.keyboardNavigation
        } else {
            if ("dateKeyboardNavigation" in this.element.data()) {
                this.keyboardNavigation = this.element.data("date-keyboard-navigation")
            }
        }
        this.todayBtn = (j.todayBtn || this.element.data("date-today-btn") || false);
        this.clearBtn = (j.clearBtn || this.element.data("date-clear-btn") || false);
        this.todayHighlight = (j.todayHighlight || this.element.data("date-today-highlight") || false);
        this.weekStart = 0;
        if (typeof j.weekStart !== "undefined") {
            this.weekStart = j.weekStart
        } else {
            if (typeof this.element.data("date-weekstart") !== "undefined") {
                this.weekStart = this.element.data("date-weekstart")
            } else {
                if (typeof e[this.language].weekStart !== "undefined") {
                    this.weekStart = e[this.language].weekStart
                }
            }
        }
        this.weekStart = this.weekStart % 7;
        this.weekEnd = ((this.weekStart + 6) % 7);
        this.onRenderDay = function (n) {
            var p = (j.onRenderDay || function () {
                return []
            })(n);
            if (typeof p === "string") {
                p = [p]
            }
            var o = ["day"];
            return o.concat((p ? p : []))
        };
        this.onRenderHour = function (n) {
            var p = (j.onRenderHour || function () {
                return []
            })(n);
            var o = ["hour"];
            if (typeof p === "string") {
                p = [p]
            }
            return o.concat((p ? p : []))
        };
        this.onRenderMinute = function (n) {
            var p = (j.onRenderMinute || function () {
                return []
            })(n);
            var o = ["minute"];
            if (typeof p === "string") {
                p = [p]
            }
            if (n < this.startDate || n > this.endDate) {
                o.push("disabled")
            } else {
                if (Math.floor(this.date.getUTCMinutes() / this.minuteStep) === Math.floor(n.getUTCMinutes() / this.minuteStep)) {
                    o.push("active")
                }
            }
            return o.concat((p ? p : []))
        };
        this.onRenderYear = function (o) {
            var q = (j.onRenderYear || function () {
                return []
            })(o);
            var p = ["year"];
            if (typeof q === "string") {
                q = [q]
            }
            if (this.date.getUTCFullYear() === o.getUTCFullYear()) {
                p.push("active")
            }
            var n = o.getUTCFullYear();
            var r = this.endDate.getUTCFullYear();
            if (o < this.startDate || n > r) {
                p.push("disabled")
            }
            return p.concat((q ? q : []))
        };
        this.onRenderMonth = function (n) {
            var p = (j.onRenderMonth || function () {
                return []
            })(n);
            var o = ["month"];
            if (typeof p === "string") {
                p = [p]
            }
            return o.concat((p ? p : []))
        };
        this.startDate = new Date(-8639968443048000);
        this.endDate = new Date(8639968443048000);
        this.datesDisabled = [];
        this.daysOfWeekDisabled = [];
        this.setStartDate(j.startDate || this.element.data("date-startdate"));
        this.setEndDate(j.endDate || this.element.data("date-enddate"));
        this.setDatesDisabled(j.datesDisabled || this.element.data("date-dates-disabled"));
        this.setDaysOfWeekDisabled(j.daysOfWeekDisabled || this.element.data("date-days-of-week-disabled"));
        this.setMinutesDisabled(j.minutesDisabled || this.element.data("date-minute-disabled"));
        this.setHoursDisabled(j.hoursDisabled || this.element.data("date-hour-disabled"));
        this.fillDow();
        this.fillMonths();
        this.update();
        this.showMode();
        if (this.isInline) {
            this.show()
        }
    };
    g.prototype = {
        constructor: g, _events: [], _attachEvents: function () {
            this._detachEvents();
            if (this.isInput) {
                this._events = [[this.element, {
                    focus: d.proxy(this.show, this),
                    keyup: d.proxy(this.update, this),
                    keydown: d.proxy(this.keydown, this)
                }]]
            } else {
                if (this.component && this.hasInput) {
                    this._events = [[this.element.find("input"), {
                        focus: d.proxy(this.show, this),
                        keyup: d.proxy(this.update, this),
                        keydown: d.proxy(this.keydown, this)
                    }], [this.component, {click: d.proxy(this.show, this)}]];
                    if (this.componentReset) {
                        this._events.push([this.componentReset, {click: d.proxy(this.reset, this)}])
                    }
                } else {
                    if (this.element.is("div")) {
                        this.isInline = true
                    } else {
                        this._events = [[this.element, {click: d.proxy(this.show, this)}]]
                    }
                }
            }
            for (var j = 0, k, l; j < this._events.length; j++) {
                k = this._events[j][0];
                l = this._events[j][1];
                k.on(l)
            }
        }, _detachEvents: function () {
            for (var j = 0, k, l; j < this._events.length; j++) {
                k = this._events[j][0];
                l = this._events[j][1];
                k.off(l)
            }
            this._events = []
        }, show: function (i) {
            this.picker.show();
            this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
            if (this.forceParse) {
                this.update()
            }
            this.place();
            d(window).on("resize", d.proxy(this.place, this));
            if (i) {
                i.stopPropagation();
                i.preventDefault()
            }
            this.isVisible = true;
            this.element.trigger({type: "show", date: this.date})
        }, hide: function () {
            if (!this.isVisible) {
                return
            }
            if (this.isInline) {
                return
            }
            this.picker.hide();
            d(window).off("resize", this.place);
            this.viewMode = this.startViewMode;
            this.showMode();
            if (!this.isInput) {
                d(document).off("mousedown", this.hide)
            }
            if (this.forceParse && (this.isInput && this.element.val() || this.hasInput && this.element.find("input").val())) {
                this.setValue()
            }
            this.isVisible = false;
            this.element.trigger({type: "hide", date: this.date})
        }, remove: function () {
            this._detachEvents();
            d(document).off("mousedown", this.clickedOutside);
            this.picker.remove();
            delete this.picker;
            delete this.element.data().datetimepicker
        }, getDate: function () {
            var i = this.getUTCDate();
            if (i === null) {
                return null
            }
            return new Date(i.getTime() + (i.getTimezoneOffset() * 60000))
        }, getUTCDate: function () {
            return this.date
        }, getInitialDate: function () {
            return this.initialDate
        }, setInitialDate: function (i) {
            this.initialDate = i
        }, setDate: function (i) {
            this.setUTCDate(new Date(i.getTime() - (i.getTimezoneOffset() * 60000)))
        }, setUTCDate: function (i) {
            if (i >= this.startDate && i <= this.endDate) {
                this.date = i;
                this.setValue();
                this.viewDate = this.date;
                this.fill()
            } else {
                this.element.trigger({type: "outOfRange", date: i, startDate: this.startDate, endDate: this.endDate})
            }
        }, setFormat: function (j) {
            this.format = c.parseFormat(j, this.formatType);
            var i;
            if (this.isInput) {
                i = this.element
            } else {
                if (this.component) {
                    i = this.element.find("input")
                }
            }
            if (i && i.val()) {
                this.setValue()
            }
        }, setValue: function () {
            var i = this.getFormattedDate();
            if (!this.isInput) {
                if (this.component) {
                    this.element.find("input").val(i)
                }
                this.element.data("date", i)
            } else {
                this.element.val(i)
            }
            if (this.linkField) {
                d("#" + this.linkField).val(this.getFormattedDate(this.linkFormat))
            }
        }, getFormattedDate: function (i) {
            i = i || this.format;
            return c.formatDate(this.date, i, this.language, this.formatType, this.timezone)
        }, setStartDate: function (i) {
            this.startDate = i || this.startDate;
            if (this.startDate.valueOf() !== 8639968443048000) {
                this.startDate = c.parseDate(this.startDate, this.format, this.language, this.formatType, this.timezone)
            }
            this.update();
            this.updateNavArrows()
        }, setEndDate: function (i) {
            this.endDate = i || this.endDate;
            if (this.endDate.valueOf() !== 8639968443048000) {
                this.endDate = c.parseDate(this.endDate, this.format, this.language, this.formatType, this.timezone)
            }
            this.update();
            this.updateNavArrows()
        }, setDatesDisabled: function (j) {
            this.datesDisabled = j || [];
            if (!d.isArray(this.datesDisabled)) {
                this.datesDisabled = this.datesDisabled.split(/,\s*/)
            }
            var i = this;
            this.datesDisabled = d.map(this.datesDisabled, function (k) {
                return c.parseDate(k, i.format, i.language, i.formatType, i.timezone).toDateString()
            });
            this.update();
            this.updateNavArrows()
        }, setTitle: function (i, j) {
            return this.picker.find(i).find("th:eq(1)").text(this.title === false ? j : this.title)
        }, setDaysOfWeekDisabled: function (i) {
            this.daysOfWeekDisabled = i || [];
            if (!d.isArray(this.daysOfWeekDisabled)) {
                this.daysOfWeekDisabled = this.daysOfWeekDisabled.split(/,\s*/)
            }
            this.daysOfWeekDisabled = d.map(this.daysOfWeekDisabled, function (j) {
                return parseInt(j, 10)
            });
            this.update();
            this.updateNavArrows()
        }, setMinutesDisabled: function (i) {
            this.minutesDisabled = i || [];
            if (!d.isArray(this.minutesDisabled)) {
                this.minutesDisabled = this.minutesDisabled.split(/,\s*/)
            }
            this.minutesDisabled = d.map(this.minutesDisabled, function (j) {
                return parseInt(j, 10)
            });
            this.update();
            this.updateNavArrows()
        }, setHoursDisabled: function (i) {
            this.hoursDisabled = i || [];
            if (!d.isArray(this.hoursDisabled)) {
                this.hoursDisabled = this.hoursDisabled.split(/,\s*/)
            }
            this.hoursDisabled = d.map(this.hoursDisabled, function (j) {
                return parseInt(j, 10)
            });
            this.update();
            this.updateNavArrows()
        }, place: function () {
            if (this.isInline) {
                return
            }
            if (!this.zIndex) {
                var j = 0;
                d("div").each(function () {
                    var o = parseInt(d(this).css("zIndex"), 10);
                    if (o > j) {
                        j = o
                    }
                });
                this.zIndex = j + 10
            }
            var n, m, l, k;
            if (this.container instanceof d) {
                k = this.container.offset()
            } else {
                k = d(this.container).offset()
            }
            if (this.component) {
                n = this.component.offset();
                l = n.left;
                if (this.pickerPosition === "bottom-left" || this.pickerPosition === "top-left") {
                    l += this.component.outerWidth() - this.picker.outerWidth()
                }
            } else {
                n = this.element.offset();
                l = n.left;
                if (this.pickerPosition === "bottom-left" || this.pickerPosition === "top-left") {
                    l += this.element.outerWidth() - this.picker.outerWidth()
                }
            }
            var i = document.body.clientWidth || window.innerWidth;
            if (l + 220 > i) {
                l = i - 220
            }
            if (this.pickerPosition === "top-left" || this.pickerPosition === "top-right") {
                m = n.top - this.picker.outerHeight()
            } else {
                m = n.top + this.height
            }
            m = m - k.top;
            l = l - k.left;
            this.picker.css({top: m, left: l, zIndex: this.zIndex})
        }, hour_minute: "^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]", update: function () {
            var i, j = false;
            if (arguments && arguments.length && (typeof arguments[0] === "string" || arguments[0] instanceof Date)) {
                i = arguments[0];
                j = true
            } else {
                i = (this.isInput ? this.element.val() : this.element.find("input").val()) || this.element.data("date") || this.initialDate;
                if (typeof i === "string") {
                    i = i.replace(/^\s+|\s+$/g, "")
                }
            }
            if (!i) {
                i = new Date();
                j = false
            }
            if (typeof i === "string") {
                if (new RegExp(this.hour_minute).test(i) || new RegExp(this.hour_minute + ":[0-5][0-9]").test(i)) {
                    i = this.getDate()
                }
            }
            this.date = c.parseDate(i, this.format, this.language, this.formatType, this.timezone);
            if (j) {
                this.setValue()
            }
            if (this.date < this.startDate) {
                this.viewDate = new Date(this.startDate)
            } else {
                if (this.date > this.endDate) {
                    this.viewDate = new Date(this.endDate)
                } else {
                    this.viewDate = new Date(this.date)
                }
            }
            this.fill()
        }, fillDow: function () {
            var i = this.weekStart, j = "<tr>";
            while (i < this.weekStart + 7) {
                j += '<th class="dow">' + e[this.language].daysMin[(i++) % 7] + "</th>"
            }
            j += "</tr>";
            this.picker.find(".datetimepicker-days thead").append(j)
        }, fillMonths: function () {
            var l = "";
            var m = new Date(this.viewDate);
            for (var k = 0; k < 12; k++) {
                m.setUTCMonth(k);
                var j = this.onRenderMonth(m);
                l += '<span class="' + j.join(" ") + '">' + e[this.language].monthsShort[k] + "</span>"
            }
            this.picker.find(".datetimepicker-months td").html(l)
        }, fill: function () {
            if (!this.date || !this.viewDate) {
                return
            }
            var E = new Date(this.viewDate), t = E.getUTCFullYear(), G = E.getUTCMonth(), n = E.getUTCDate(),
                A = E.getUTCHours(), w = this.startDate.getUTCFullYear(), B = this.startDate.getUTCMonth(),
                p = this.endDate.getUTCFullYear(), x = this.endDate.getUTCMonth() + 1,
                q = (new h(this.date.getUTCFullYear(), this.date.getUTCMonth(), this.date.getUTCDate())).valueOf(),
                D = new Date();
            this.setTitle(".datetimepicker-days", e[this.language].months[G] + " " + t);
            if (this.formatViewType === "time") {
                var k = this.getFormattedDate();
                this.setTitle(".datetimepicker-hours", k);
                this.setTitle(".datetimepicker-minutes", k)
            } else {
                this.setTitle(".datetimepicker-hours", n + " " + e[this.language].months[G] + " " + t);
                this.setTitle(".datetimepicker-minutes", n + " " + e[this.language].months[G] + " " + t)
            }
            this.picker.find("tfoot th.today").text(e[this.language].today || e.en.today).toggle(this.todayBtn !== false);
            this.picker.find("tfoot th.clear").text(e[this.language].clear || e.en.clear).toggle(this.clearBtn !== false);
            this.updateNavArrows();
            this.fillMonths();
            var I = h(t, G - 1, 28, 0, 0, 0, 0), z = c.getDaysInMonth(I.getUTCFullYear(), I.getUTCMonth());
            I.setUTCDate(z);
            I.setUTCDate(z - (I.getUTCDay() - this.weekStart + 7) % 7);
            var j = new Date(I);
            j.setUTCDate(j.getUTCDate() + 42);
            j = j.valueOf();
            var r = [];
            var F;
            while (I.valueOf() < j) {
                if (I.getUTCDay() === this.weekStart) {
                    r.push("<tr>")
                }
                F = this.onRenderDay(I);
                if (I.getUTCFullYear() < t || (I.getUTCFullYear() === t && I.getUTCMonth() < G)) {
                    F.push("old")
                } else {
                    if (I.getUTCFullYear() > t || (I.getUTCFullYear() === t && I.getUTCMonth() > G)) {
                        F.push("new")
                    }
                }
                if (this.todayHighlight && I.getUTCFullYear() === D.getFullYear() && I.getUTCMonth() === D.getMonth() && I.getUTCDate() === D.getDate()) {
                    F.push("today")
                }
                if (I.valueOf() === q) {
                    F.push("active")
                }
                if ((I.valueOf() + 86400000) <= this.startDate || I.valueOf() > this.endDate || d.inArray(I.getUTCDay(), this.daysOfWeekDisabled) !== -1 || d.inArray(I.toDateString(), this.datesDisabled) !== -1) {
                    F.push("disabled")
                }
                r.push('<td class="' + F.join(" ") + '">' + I.getUTCDate() + "</td>");
                if (I.getUTCDay() === this.weekEnd) {
                    r.push("</tr>")
                }
                I.setUTCDate(I.getUTCDate() + 1)
            }
            this.picker.find(".datetimepicker-days tbody").empty().append(r.join(""));
            r = [];
            var u = "", C = "", s = "";
            var l = this.hoursDisabled || [];
            E = new Date(this.viewDate);
            for (var y = 0; y < 24; y++) {
                E.setUTCHours(y);
                F = this.onRenderHour(E);
                if (l.indexOf(y) !== -1) {
                    F.push("disabled")
                }
                var v = h(t, G, n, y);
                if ((v.valueOf() + 3600000) <= this.startDate || v.valueOf() > this.endDate) {
                    F.push("disabled")
                } else {
                    if (A === y) {
                        F.push("active")
                    }
                }
                if (this.showMeridian && e[this.language].meridiem.length === 2) {
                    C = (y < 12 ? e[this.language].meridiem[0] : e[this.language].meridiem[1]);
                    if (C !== s) {
                        if (s !== "") {
                            r.push("</fieldset>")
                        }
                        r.push('<fieldset class="hour"><legend>' + C.toUpperCase() + "</legend>")
                    }
                    s = C;
                    u = (y % 12 ? y % 12 : 12);
                    if (y < 12) {
                        F.push("hour_am")
                    } else {
                        F.push("hour_pm")
                    }
                    r.push('<span class="' + F.join(" ") + '">' + u + "</span>");
                    if (y === 23) {
                        r.push("</fieldset>")
                    }
                } else {
                    u = y + ":00";
                    r.push('<span class="' + F.join(" ") + '">' + u + "</span>")
                }
            }
            this.picker.find(".datetimepicker-hours td").html(r.join(""));
            r = [];
            u = "";
            C = "";
            s = "";
            var m = this.minutesDisabled || [];
            E = new Date(this.viewDate);
            for (var y = 0; y < 60; y += this.minuteStep) {
                if (m.indexOf(y) !== -1) {
                    continue
                }
                E.setUTCMinutes(y);
                E.setUTCSeconds(0);
                F = this.onRenderMinute(E);
                if (this.showMeridian && e[this.language].meridiem.length === 2) {
                    C = (A < 12 ? e[this.language].meridiem[0] : e[this.language].meridiem[1]);
                    if (C !== s) {
                        if (s !== "") {
                            r.push("</fieldset>")
                        }
                        r.push('<fieldset class="minute"><legend>' + C.toUpperCase() + "</legend>")
                    }
                    s = C;
                    u = (A % 12 ? A % 12 : 12);
                    r.push('<span class="' + F.join(" ") + '">' + u + ":" + (y < 10 ? "0" + y : y) + "</span>");
                    if (y === 59) {
                        r.push("</fieldset>")
                    }
                } else {
                    u = y + ":00";
                    r.push('<span class="' + F.join(" ") + '">' + A + ":" + (y < 10 ? "0" + y : y) + "</span>")
                }
            }
            this.picker.find(".datetimepicker-minutes td").html(r.join(""));
            var J = this.date.getUTCFullYear();
            var o = this.setTitle(".datetimepicker-months", t).end().find(".month").removeClass("active");
            if (J === t) {
                o.eq(this.date.getUTCMonth()).addClass("active")
            }
            if (t < w || t > p) {
                o.addClass("disabled")
            }
            if (t === w) {
                o.slice(0, B).addClass("disabled")
            }
            if (t === p) {
                o.slice(x).addClass("disabled")
            }
            r = "";
            t = parseInt(t / 10, 10) * 10;
            var H = this.setTitle(".datetimepicker-years", t + "-" + (t + 9)).end().find("td");
            t -= 1;
            E = new Date(this.viewDate);
            for (var y = -1; y < 11; y++) {
                E.setUTCFullYear(t);
                F = this.onRenderYear(E);
                if (y === -1 || y === 10) {
                    F.push(b)
                }
                r += '<span class="' + F.join(" ") + '">' + t + "</span>";
                t += 1
            }
            H.html(r);
            this.place()
        }, updateNavArrows: function () {
            var m = new Date(this.viewDate), k = m.getUTCFullYear(), l = m.getUTCMonth(), j = m.getUTCDate(),
                i = m.getUTCHours();
            switch (this.viewMode) {
                case 0:
                    if (k <= this.startDate.getUTCFullYear() && l <= this.startDate.getUTCMonth() && j <= this.startDate.getUTCDate() && i <= this.startDate.getUTCHours()) {
                        this.picker.find(".prev").css({visibility: "hidden"})
                    } else {
                        this.picker.find(".prev").css({visibility: "visible"})
                    }
                    if (k >= this.endDate.getUTCFullYear() && l >= this.endDate.getUTCMonth() && j >= this.endDate.getUTCDate() && i >= this.endDate.getUTCHours()) {
                        this.picker.find(".next").css({visibility: "hidden"})
                    } else {
                        this.picker.find(".next").css({visibility: "visible"})
                    }
                    break;
                case 1:
                    if (k <= this.startDate.getUTCFullYear() && l <= this.startDate.getUTCMonth() && j <= this.startDate.getUTCDate()) {
                        this.picker.find(".prev").css({visibility: "hidden"})
                    } else {
                        this.picker.find(".prev").css({visibility: "visible"})
                    }
                    if (k >= this.endDate.getUTCFullYear() && l >= this.endDate.getUTCMonth() && j >= this.endDate.getUTCDate()) {
                        this.picker.find(".next").css({visibility: "hidden"})
                    } else {
                        this.picker.find(".next").css({visibility: "visible"})
                    }
                    break;
                case 2:
                    if (k <= this.startDate.getUTCFullYear() && l <= this.startDate.getUTCMonth()) {
                        this.picker.find(".prev").css({visibility: "hidden"})
                    } else {
                        this.picker.find(".prev").css({visibility: "visible"})
                    }
                    if (k >= this.endDate.getUTCFullYear() && l >= this.endDate.getUTCMonth()) {
                        this.picker.find(".next").css({visibility: "hidden"})
                    } else {
                        this.picker.find(".next").css({visibility: "visible"})
                    }
                    break;
                case 3:
                case 4:
                    if (k <= this.startDate.getUTCFullYear()) {
                        this.picker.find(".prev").css({visibility: "hidden"})
                    } else {
                        this.picker.find(".prev").css({visibility: "visible"})
                    }
                    if (k >= this.endDate.getUTCFullYear()) {
                        this.picker.find(".next").css({visibility: "hidden"})
                    } else {
                        this.picker.find(".next").css({visibility: "visible"})
                    }
                    break
            }
        }, mousewheel: function (j) {
            j.preventDefault();
            j.stopPropagation();
            if (this.wheelPause) {
                return
            }
            this.wheelPause = true;
            var i = j.originalEvent;
            var l = i.wheelDelta;
            var k = l > 0 ? 1 : (l === 0) ? 0 : -1;
            if (this.wheelViewModeNavigationInverseDirection) {
                k = -k
            }
            this.showMode(k);
            setTimeout(d.proxy(function () {
                this.wheelPause = false
            }, this), this.wheelViewModeNavigationDelay)
        }, click: function (m) {
            m.stopPropagation();
            m.preventDefault();
            var n = d(m.target).closest("span, td, th, legend");
            if (n.is("." + this.icontype)) {
                n = d(n).parent().closest("span, td, th, legend")
            }
            if (n.length === 1) {
                if (n.is(".disabled")) {
                    this.element.trigger({
                        type: "outOfRange",
                        date: this.viewDate,
                        startDate: this.startDate,
                        endDate: this.endDate
                    });
                    return
                }
                switch (n[0].nodeName.toLowerCase()) {
                    case"th":
                        switch (n[0].className) {
                            case"switch":
                                this.showMode(1);
                                break;
                            case"prev":
                            case"next":
                                var i = c.modes[this.viewMode].navStep * (n[0].className === "prev" ? -1 : 1);
                                switch (this.viewMode) {
                                    case 0:
                                        this.viewDate = this.moveHour(this.viewDate, i);
                                        break;
                                    case 1:
                                        this.viewDate = this.moveDate(this.viewDate, i);
                                        break;
                                    case 2:
                                        this.viewDate = this.moveMonth(this.viewDate, i);
                                        break;
                                    case 3:
                                    case 4:
                                        this.viewDate = this.moveYear(this.viewDate, i);
                                        break
                                }
                                this.fill();
                                this.element.trigger({
                                    type: n[0].className + ":" + this.convertViewModeText(this.viewMode),
                                    date: this.viewDate,
                                    startDate: this.startDate,
                                    endDate: this.endDate
                                });
                                break;
                            case"clear":
                                this.reset();
                                if (this.autoclose) {
                                    this.hide()
                                }
                                break;
                            case"today":
                                var j = new Date();
                                j = h(j.getFullYear(), j.getMonth(), j.getDate(), j.getHours(), j.getMinutes(), j.getSeconds(), 0);
                                if (j < this.startDate) {
                                    j = this.startDate
                                } else {
                                    if (j > this.endDate) {
                                        j = this.endDate
                                    }
                                }
                                this.viewMode = this.startViewMode;
                                this.showMode(0);
                                this._setDate(j);
                                this.fill();
                                if (this.autoclose) {
                                    this.hide()
                                }
                                break
                        }
                        break;
                    case"span":
                        if (!n.is(".disabled")) {
                            var p = this.viewDate.getUTCFullYear(), o = this.viewDate.getUTCMonth(),
                                q = this.viewDate.getUTCDate(), r = this.viewDate.getUTCHours(),
                                k = this.viewDate.getUTCMinutes(), s = this.viewDate.getUTCSeconds();
                            if (n.is(".month")) {
                                this.viewDate.setUTCDate(1);
                                o = n.parent().find("span").index(n);
                                q = this.viewDate.getUTCDate();
                                this.viewDate.setUTCMonth(o);
                                this.element.trigger({type: "changeMonth", date: this.viewDate});
                                if (this.viewSelect >= 3) {
                                    this._setDate(h(p, o, q, r, k, s, 0))
                                }
                            } else {
                                if (n.is(".year")) {
                                    this.viewDate.setUTCDate(1);
                                    p = parseInt(n.text(), 10) || 0;
                                    this.viewDate.setUTCFullYear(p);
                                    this.element.trigger({type: "changeYear", date: this.viewDate});
                                    if (this.viewSelect >= 4) {
                                        this._setDate(h(p, o, q, r, k, s, 0))
                                    }
                                } else {
                                    if (n.is(".hour")) {
                                        r = parseInt(n.text(), 10) || 0;
                                        if (n.hasClass("hour_am") || n.hasClass("hour_pm")) {
                                            if (r === 12 && n.hasClass("hour_am")) {
                                                r = 0
                                            } else {
                                                if (r !== 12 && n.hasClass("hour_pm")) {
                                                    r += 12
                                                }
                                            }
                                        }
                                        this.viewDate.setUTCHours(r);
                                        this.element.trigger({type: "changeHour", date: this.viewDate});
                                        if (this.viewSelect >= 1) {
                                            this._setDate(h(p, o, q, r, k, s, 0))
                                        }
                                    } else {
                                        if (n.is(".minute")) {
                                            k = parseInt(n.text().substr(n.text().indexOf(":") + 1), 10) || 0;
                                            this.viewDate.setUTCMinutes(k);
                                            this.element.trigger({type: "changeMinute", date: this.viewDate});
                                            if (this.viewSelect >= 0) {
                                                this._setDate(h(p, o, q, r, k, s, 0))
                                            }
                                        }
                                    }
                                }
                            }
                            if (this.viewMode !== 0) {
                                var l = this.viewMode;
                                this.showMode(-1);
                                this.fill();
                                if (l === this.viewMode && this.autoclose) {
                                    this.hide()
                                }
                            } else {
                                this.fill();
                                if (this.autoclose) {
                                    this.hide()
                                }
                            }
                        }
                        break;
                    case"td":
                        if (n.is(".day") && !n.is(".disabled")) {
                            var q = parseInt(n.text(), 10) || 1;
                            var p = this.viewDate.getUTCFullYear(), o = this.viewDate.getUTCMonth(),
                                r = this.viewDate.getUTCHours(), k = this.viewDate.getUTCMinutes(),
                                s = this.viewDate.getUTCSeconds();
                            if (n.is(".old")) {
                                if (o === 0) {
                                    o = 11;
                                    p -= 1
                                } else {
                                    o -= 1
                                }
                            } else {
                                if (n.is(".new")) {
                                    if (o === 11) {
                                        o = 0;
                                        p += 1
                                    } else {
                                        o += 1
                                    }
                                }
                            }
                            this.viewDate.setUTCFullYear(p);
                            this.viewDate.setUTCMonth(o, q);
                            this.element.trigger({type: "changeDay", date: this.viewDate});
                            if (this.viewSelect >= 2) {
                                this._setDate(h(p, o, q, r, k, s, 0))
                            }
                        }
                        var l = this.viewMode;
                        this.showMode(-1);
                        this.fill();
                        if (l === this.viewMode && this.autoclose) {
                            this.hide()
                        }
                        break
                }
            }
        }, _setDate: function (i, k) {
            if (!k || k === "date") {
                this.date = i
            }
            if (!k || k === "view") {
                this.viewDate = i
            }
            this.fill();
            this.setValue();
            var j;
            if (this.isInput) {
                j = this.element
            } else {
                if (this.component) {
                    j = this.element.find("input")
                }
            }
            if (j) {
                j.change()
            }
            this.element.trigger({type: "changeDate", date: this.getDate()});
            if (i === null) {
                this.date = this.viewDate
            }
        }, moveMinute: function (j, i) {
            if (!i) {
                return j
            }
            var k = new Date(j.valueOf());
            k.setUTCMinutes(k.getUTCMinutes() + (i * this.minuteStep));
            return k
        }, moveHour: function (j, i) {
            if (!i) {
                return j
            }
            var k = new Date(j.valueOf());
            k.setUTCHours(k.getUTCHours() + i);
            return k
        }, moveDate: function (j, i) {
            if (!i) {
                return j
            }
            var k = new Date(j.valueOf());
            k.setUTCDate(k.getUTCDate() + i);
            return k
        }, moveMonth: function (j, k) {
            if (!k) {
                return j
            }
            var n = new Date(j.valueOf()), r = n.getUTCDate(), o = n.getUTCMonth(), m = Math.abs(k), q, p;
            k = k > 0 ? 1 : -1;
            if (m === 1) {
                p = k === -1 ? function () {
                    return n.getUTCMonth() === o
                } : function () {
                    return n.getUTCMonth() !== q
                };
                q = o + k;
                n.setUTCMonth(q);
                if (q < 0 || q > 11) {
                    q = (q + 12) % 12
                }
            } else {
                for (var l = 0; l < m; l++) {
                    n = this.moveMonth(n, k)
                }
                q = n.getUTCMonth();
                n.setUTCDate(r);
                p = function () {
                    return q !== n.getUTCMonth()
                }
            }
            while (p()) {
                n.setUTCDate(--r);
                n.setUTCMonth(q)
            }
            return n
        }, moveYear: function (j, i) {
            return this.moveMonth(j, i * 12)
        }, dateWithinRange: function (i) {
            return i >= this.startDate && i <= this.endDate
        }, keydown: function (o) {
            if (this.picker.is(":not(:visible)")) {
                if (o.keyCode === 27) {
                    this.show()
                }
                return
            }
            var k = false, j, i, n;
            switch (o.keyCode) {
                case 27:
                    this.hide();
                    o.preventDefault();
                    break;
                case 37:
                case 39:
                    if (!this.keyboardNavigation) {
                        break
                    }
                    j = o.keyCode === 37 ? -1 : 1;
                    var m = this.viewMode;
                    if (o.ctrlKey) {
                        m += 2
                    } else {
                        if (o.shiftKey) {
                            m += 1
                        }
                    }
                    if (m === 4) {
                        i = this.moveYear(this.date, j);
                        n = this.moveYear(this.viewDate, j)
                    } else {
                        if (m === 3) {
                            i = this.moveMonth(this.date, j);
                            n = this.moveMonth(this.viewDate, j)
                        } else {
                            if (m === 2) {
                                i = this.moveDate(this.date, j);
                                n = this.moveDate(this.viewDate, j)
                            } else {
                                if (m === 1) {
                                    i = this.moveHour(this.date, j);
                                    n = this.moveHour(this.viewDate, j)
                                } else {
                                    if (m === 0) {
                                        i = this.moveMinute(this.date, j);
                                        n = this.moveMinute(this.viewDate, j)
                                    }
                                }
                            }
                        }
                    }
                    if (this.dateWithinRange(i)) {
                        this.date = i;
                        this.viewDate = n;
                        this.setValue();
                        this.update();
                        o.preventDefault();
                        k = true
                    }
                    break;
                case 38:
                case 40:
                    if (!this.keyboardNavigation) {
                        break
                    }
                    j = o.keyCode === 38 ? -1 : 1;
                    m = this.viewMode;
                    if (o.ctrlKey) {
                        m += 2
                    } else {
                        if (o.shiftKey) {
                            m += 1
                        }
                    }
                    if (m === 4) {
                        i = this.moveYear(this.date, j);
                        n = this.moveYear(this.viewDate, j)
                    } else {
                        if (m === 3) {
                            i = this.moveMonth(this.date, j);
                            n = this.moveMonth(this.viewDate, j)
                        } else {
                            if (m === 2) {
                                i = this.moveDate(this.date, j * 7);
                                n = this.moveDate(this.viewDate, j * 7)
                            } else {
                                if (m === 1) {
                                    if (this.showMeridian) {
                                        i = this.moveHour(this.date, j * 6);
                                        n = this.moveHour(this.viewDate, j * 6)
                                    } else {
                                        i = this.moveHour(this.date, j * 4);
                                        n = this.moveHour(this.viewDate, j * 4)
                                    }
                                } else {
                                    if (m === 0) {
                                        i = this.moveMinute(this.date, j * 4);
                                        n = this.moveMinute(this.viewDate, j * 4)
                                    }
                                }
                            }
                        }
                    }
                    if (this.dateWithinRange(i)) {
                        this.date = i;
                        this.viewDate = n;
                        this.setValue();
                        this.update();
                        o.preventDefault();
                        k = true
                    }
                    break;
                case 13:
                    if (this.viewMode !== 0) {
                        var p = this.viewMode;
                        this.showMode(-1);
                        this.fill();
                        if (p === this.viewMode && this.autoclose) {
                            this.hide()
                        }
                    } else {
                        this.fill();
                        if (this.autoclose) {
                            this.hide()
                        }
                    }
                    o.preventDefault();
                    break;
                case 9:
                    this.hide();
                    break
            }
            if (k) {
                var l;
                if (this.isInput) {
                    l = this.element
                } else {
                    if (this.component) {
                        l = this.element.find("input")
                    }
                }
                if (l) {
                    l.change()
                }
                this.element.trigger({type: "changeDate", date: this.getDate()})
            }
        }, showMode: function (i) {
            if (i) {
                var j = Math.max(0, Math.min(c.modes.length - 1, this.viewMode + i));
                if (j >= this.minView && j <= this.maxView) {
                    this.element.trigger({
                        type: "changeMode",
                        date: this.viewDate,
                        oldViewMode: this.viewMode,
                        newViewMode: j
                    });
                    this.viewMode = j
                }
            }
            this.picker.find(">div").hide().filter(".datetimepicker-" + c.modes[this.viewMode].clsName).css("display", "block");
            this.updateNavArrows()
        }, reset: function () {
            this._setDate(null, "date")
        }, convertViewModeText: function (i) {
            switch (i) {
                case 4:
                    return "decade";
                case 3:
                    return "year";
                case 2:
                    return "month";
                case 1:
                    return "day";
                case 0:
                    return "hour"
            }
        }
    };
    var b = d.fn.datetimepicker;
    d.fn.datetimepicker = function (k) {
        var i = Array.apply(null, arguments);
        i.shift();
        var j;
        this.each(function () {
            var n = d(this), m = n.data("datetimepicker"), l = typeof k === "object" && k;
            if (!m) {
                n.data("datetimepicker", (m = new g(this, d.extend({}, d.fn.datetimepicker.defaults, l))))
            }
            if (typeof k === "string" && typeof m[k] === "function") {
                j = m[k].apply(m, i);
                if (j !== f) {
                    return false
                }
            }
        });
        if (j !== f) {
            return j
        } else {
            return this
        }
    };
    d.fn.datetimepicker.defaults = {};
    d.fn.datetimepicker.Constructor = g;
    var e = d.fn.datetimepicker.dates = {
        en: {
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
            daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
            daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            meridiem: ["am", "pm"],
            suffix: ["st", "nd", "rd", "th"],
            today: "Today",
            clear: "Clear"
        }
    };
    var c = {
        modes: [{clsName: "minutes", navFnc: "Hours", navStep: 1}, {
            clsName: "hours",
            navFnc: "Date",
            navStep: 1
        }, {clsName: "days", navFnc: "Month", navStep: 1}, {
            clsName: "months",
            navFnc: "FullYear",
            navStep: 1
        }, {clsName: "years", navFnc: "FullYear", navStep: 10}],
        isLeapYear: function (i) {
            return (((i % 4 === 0) && (i % 100 !== 0)) || (i % 400 === 0))
        },
        getDaysInMonth: function (i, j) {
            return [31, (c.isLeapYear(i) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][j]
        },
        getDefaultFormat: function (i, j) {
            if (i === "standard") {
                if (j === "input") {
                    return "yyyy-mm-dd hh:ii"
                } else {
                    return "yyyy-mm-dd hh:ii:ss"
                }
            } else {
                if (i === "php") {
                    if (j === "input") {
                        return "Y-m-d H:i"
                    } else {
                        return "Y-m-d H:i:s"
                    }
                } else {
                    throw new Error("Invalid format type.")
                }
            }
        },
        validParts: function (i) {
            if (i === "standard") {
                return /t|hh?|HH?|p|P|z|Z|ii?|ss?|dd?|DD?|mm?|MM?|yy(?:yy)?/g
            } else {
                if (i === "php") {
                    return /[dDjlNwzFmMnStyYaABgGhHis]/g
                } else {
                    throw new Error("Invalid format type.")
                }
            }
        },
        nonpunctuation: /[^ -\/:-@\[-`{-~\t\n\rTZ]+/g,
        parseFormat: function (l, j) {
            var i = l.replace(this.validParts(j), "\0").split("\0"), k = l.match(this.validParts(j));
            if (!i || !i.length || !k || k.length === 0) {
                throw new Error("Invalid date format.")
            }
            return {separators: i, parts: k}
        },
        parseDate: function (A, y, v, j, r) {
            if (A instanceof Date) {
                var u = new Date(A.valueOf() - A.getTimezoneOffset() * 60000);
                u.setMilliseconds(0);
                return u
            }
            if (/^\d{4}\-\d{1,2}\-\d{1,2}$/.test(A)) {
                y = this.parseFormat("yyyy-mm-dd", j)
            }
            if (/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}$/.test(A)) {
                y = this.parseFormat("yyyy-mm-dd hh:ii", j)
            }
            if (/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}\:\d{1,2}[Z]{0,1}$/.test(A)) {
                y = this.parseFormat("yyyy-mm-dd hh:ii:ss", j)
            }
            if (/^[-+]\d+[dmwy]([\s,]+[-+]\d+[dmwy])*$/.test(A)) {
                var l = /([-+]\d+)([dmwy])/, q = A.match(/([-+]\d+)([dmwy])/g), t, p;
                A = new Date();
                for (var x = 0; x < q.length; x++) {
                    t = l.exec(q[x]);
                    p = parseInt(t[1]);
                    switch (t[2]) {
                        case"d":
                            A.setUTCDate(A.getUTCDate() + p);
                            break;
                        case"m":
                            A = g.prototype.moveMonth.call(g.prototype, A, p);
                            break;
                        case"w":
                            A.setUTCDate(A.getUTCDate() + p * 7);
                            break;
                        case"y":
                            A = g.prototype.moveYear.call(g.prototype, A, p);
                            break
                    }
                }
                return h(A.getUTCFullYear(), A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), 0)
            }
            var q = A && A.toString().match(this.nonpunctuation) || [], A = new Date(0, 0, 0, 0, 0, 0, 0), m = {},
                z = ["hh", "h", "ii", "i", "ss", "s", "yyyy", "yy", "M", "MM", "m", "mm", "D", "DD", "d", "dd", "H", "HH", "p", "P", "z", "Z"],
                o = {
                    hh: function (s, i) {
                        return s.setUTCHours(i)
                    }, h: function (s, i) {
                        return s.setUTCHours(i)
                    }, HH: function (s, i) {
                        return s.setUTCHours(i === 12 ? 0 : i)
                    }, H: function (s, i) {
                        return s.setUTCHours(i === 12 ? 0 : i)
                    }, ii: function (s, i) {
                        return s.setUTCMinutes(i)
                    }, i: function (s, i) {
                        return s.setUTCMinutes(i)
                    }, ss: function (s, i) {
                        return s.setUTCSeconds(i)
                    }, s: function (s, i) {
                        return s.setUTCSeconds(i)
                    }, yyyy: function (s, i) {
                        return s.setUTCFullYear(i)
                    }, yy: function (s, i) {
                        return s.setUTCFullYear(2000 + i)
                    }, m: function (s, i) {
                        i -= 1;
                        while (i < 0) {
                            i += 12
                        }
                        i %= 12;
                        s.setUTCMonth(i);
                        while (s.getUTCMonth() !== i) {
                            if (isNaN(s.getUTCMonth())) {
                                return s
                            } else {
                                s.setUTCDate(s.getUTCDate() - 1)
                            }
                        }
                        return s
                    }, d: function (s, i) {
                        return s.setUTCDate(i)
                    }, p: function (s, i) {
                        return s.setUTCHours(i === 1 ? s.getUTCHours() + 12 : s.getUTCHours())
                    }, z: function () {
                        return r
                    }
                }, B, k, t;
            o.M = o.MM = o.mm = o.m;
            o.dd = o.d;
            o.P = o.p;
            o.Z = o.z;
            A = h(A.getFullYear(), A.getMonth(), A.getDate(), A.getHours(), A.getMinutes(), A.getSeconds());
            if (q.length === y.parts.length) {
                for (var x = 0, w = y.parts.length; x < w; x++) {
                    B = parseInt(q[x], 10);
                    t = y.parts[x];
                    if (isNaN(B)) {
                        switch (t) {
                            case"MM":
                                k = d(e[v].months).filter(function () {
                                    var i = this.slice(0, q[x].length), s = q[x].slice(0, i.length);
                                    return i === s
                                });
                                B = d.inArray(k[0], e[v].months) + 1;
                                break;
                            case"M":
                                k = d(e[v].monthsShort).filter(function () {
                                    var i = this.slice(0, q[x].length), s = q[x].slice(0, i.length);
                                    return i.toLowerCase() === s.toLowerCase()
                                });
                                B = d.inArray(k[0], e[v].monthsShort) + 1;
                                break;
                            case"p":
                            case"P":
                                B = d.inArray(q[x].toLowerCase(), e[v].meridiem);
                                break;
                            case"z":
                            case"Z":
                                r;
                                break
                        }
                    }
                    m[t] = B
                }
                for (var x = 0, n; x < z.length; x++) {
                    n = z[x];
                    if (n in m && !isNaN(m[n])) {
                        o[n](A, m[n])
                    }
                }
            }
            return A
        },
        formatDate: function (l, q, m, p, o) {
            if (l === null) {
                return ""
            }
            var k;
            if (p === "standard") {
                k = {
                    t: l.getTime(),
                    yy: l.getUTCFullYear().toString().substring(2),
                    yyyy: l.getUTCFullYear(),
                    m: l.getUTCMonth() + 1,
                    M: e[m].monthsShort[l.getUTCMonth()],
                    MM: e[m].months[l.getUTCMonth()],
                    d: l.getUTCDate(),
                    D: e[m].daysShort[l.getUTCDay()],
                    DD: e[m].days[l.getUTCDay()],
                    p: (e[m].meridiem.length === 2 ? e[m].meridiem[l.getUTCHours() < 12 ? 0 : 1] : ""),
                    h: l.getUTCHours(),
                    i: l.getUTCMinutes(),
                    s: l.getUTCSeconds(),
                    z: o
                };
                if (e[m].meridiem.length === 2) {
                    k.H = (k.h % 12 === 0 ? 12 : k.h % 12)
                } else {
                    k.H = k.h
                }
                k.HH = (k.H < 10 ? "0" : "") + k.H;
                k.P = k.p.toUpperCase();
                k.Z = k.z;
                k.hh = (k.h < 10 ? "0" : "") + k.h;
                k.ii = (k.i < 10 ? "0" : "") + k.i;
                k.ss = (k.s < 10 ? "0" : "") + k.s;
                k.dd = (k.d < 10 ? "0" : "") + k.d;
                k.mm = (k.m < 10 ? "0" : "") + k.m
            } else {
                if (p === "php") {
                    k = {
                        y: l.getUTCFullYear().toString().substring(2),
                        Y: l.getUTCFullYear(),
                        F: e[m].months[l.getUTCMonth()],
                        M: e[m].monthsShort[l.getUTCMonth()],
                        n: l.getUTCMonth() + 1,
                        t: c.getDaysInMonth(l.getUTCFullYear(), l.getUTCMonth()),
                        j: l.getUTCDate(),
                        l: e[m].days[l.getUTCDay()],
                        D: e[m].daysShort[l.getUTCDay()],
                        w: l.getUTCDay(),
                        N: (l.getUTCDay() === 0 ? 7 : l.getUTCDay()),
                        S: (l.getUTCDate() % 10 <= e[m].suffix.length ? e[m].suffix[l.getUTCDate() % 10 - 1] : ""),
                        a: (e[m].meridiem.length === 2 ? e[m].meridiem[l.getUTCHours() < 12 ? 0 : 1] : ""),
                        g: (l.getUTCHours() % 12 === 0 ? 12 : l.getUTCHours() % 12),
                        G: l.getUTCHours(),
                        i: l.getUTCMinutes(),
                        s: l.getUTCSeconds()
                    };
                    k.m = (k.n < 10 ? "0" : "") + k.n;
                    k.d = (k.j < 10 ? "0" : "") + k.j;
                    k.A = k.a.toString().toUpperCase();
                    k.h = (k.g < 10 ? "0" : "") + k.g;
                    k.H = (k.G < 10 ? "0" : "") + k.G;
                    k.i = (k.i < 10 ? "0" : "") + k.i;
                    k.s = (k.s < 10 ? "0" : "") + k.s
                } else {
                    throw new Error("Invalid format type.")
                }
            }
            var l = [], r = d.extend([], q.separators);
            for (var n = 0, j = q.parts.length; n < j; n++) {
                if (r.length) {
                    l.push(r.shift())
                }
                l.push(k[q.parts[n]])
            }
            if (r.length) {
                l.push(r.shift())
            }
            return l.join("")
        },
        convertViewMode: function (i) {
            switch (i) {
                case 4:
                case"decade":
                    i = 4;
                    break;
                case 3:
                case"year":
                    i = 3;
                    break;
                case 2:
                case"month":
                    i = 2;
                    break;
                case 1:
                case"day":
                    i = 1;
                    break;
                case 0:
                case"hour":
                    i = 0;
                    break
            }
            return i
        },
        headTemplate: '<thead><tr><th class="prev"><i class="{iconType} {leftArrow}"/></th><th colspan="5" class="switch"></th><th class="next"><i class="{iconType} {rightArrow}"/></th></tr></thead>',
        headTemplateV3: '<thead><tr><th class="prev"><span class="{iconType} {leftArrow}"></span> </th><th colspan="5" class="switch"></th><th class="next"><span class="{iconType} {rightArrow}"></span> </th></tr></thead>',
        contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
        footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'
    };
    c.template = '<div class="datetimepicker"><div class="datetimepicker-minutes"><table class=" table-condensed">' + c.headTemplate + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-hours"><table class=" table-condensed">' + c.headTemplate + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-days"><table class=" table-condensed">' + c.headTemplate + "<tbody></tbody>" + c.footTemplate + '</table></div><div class="datetimepicker-months"><table class="table-condensed">' + c.headTemplate + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-years"><table class="table-condensed">' + c.headTemplate + c.contTemplate + c.footTemplate + "</table></div></div>";
    c.templateV3 = '<div class="datetimepicker"><div class="datetimepicker-minutes"><table class=" table-condensed">' + c.headTemplateV3 + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-hours"><table class=" table-condensed">' + c.headTemplateV3 + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-days"><table class=" table-condensed">' + c.headTemplateV3 + "<tbody></tbody>" + c.footTemplate + '</table></div><div class="datetimepicker-months"><table class="table-condensed">' + c.headTemplateV3 + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-years"><table class="table-condensed">' + c.headTemplateV3 + c.contTemplate + c.footTemplate + "</table></div></div>";
    d.fn.datetimepicker.DPGlobal = c;
    d.fn.datetimepicker.noConflict = function () {
        d.fn.datetimepicker = b;
        return this
    };
    d(document).on("focus.datetimepicker.data-api click.datetimepicker.data-api", '[data-provide="datetimepicker"]', function (j) {
        var i = d(this);
        if (i.data("datetimepicker")) {
            return
        }
        j.preventDefault();
        i.datetimepicker("show")
    });
    d(function () {
        d('[data-provide="datetimepicker-inline"]').datetimepicker()
    })
}));
/*! bootstrap-timepicker v0.5.2
* http://jdewit.github.com/bootstrap-timepicker
* Copyright (c) 2016 Joris de Wit and bootstrap-timepicker contributors
* MIT License
*/
!function (a, b, c) {
    "use strict";
    var d = function (b, c) {
        this.widget = "", this.$element = a(b), this.defaultTime = c.defaultTime, this.disableFocus = c.disableFocus, this.disableMousewheel = c.disableMousewheel, this.isOpen = c.isOpen, this.minuteStep = c.minuteStep, this.modalBackdrop = c.modalBackdrop, this.orientation = c.orientation, this.secondStep = c.secondStep, this.snapToStep = c.snapToStep, this.showInputs = c.showInputs, this.showMeridian = c.showMeridian, this.showSeconds = c.showSeconds, this.template = c.template, this.appendWidgetTo = c.appendWidgetTo, this.showWidgetOnAddonClick = c.showWidgetOnAddonClick, this.icons = c.icons, this.maxHours = c.maxHours, this.explicitMode = c.explicitMode, this.handleDocumentClick = function (a) {
            var b = a.data.scope;
            b.$element.parent().find(a.target).length || b.$widget.is(a.target) || b.$widget.find(a.target).length || b.hideWidget()
        }, this._init()
    };
    d.prototype = {
        constructor: d, _init: function () {
            var b = this;
            this.showWidgetOnAddonClick && this.$element.parent().hasClass("input-group") && this.$element.parent().hasClass("bootstrap-timepicker") ? (this.$element.parent(".input-group.bootstrap-timepicker").find(".input-group-addon").on({"click.timepicker": a.proxy(this.showWidget, this)}), this.$element.on({
                "focus.timepicker": a.proxy(this.highlightUnit, this),
                "click.timepicker": a.proxy(this.highlightUnit, this),
                "keydown.timepicker": a.proxy(this.elementKeydown, this),
                "blur.timepicker": a.proxy(this.blurElement, this),
                "mousewheel.timepicker DOMMouseScroll.timepicker": a.proxy(this.mousewheel, this)
            })) : this.template ? this.$element.on({
                "focus.timepicker": a.proxy(this.showWidget, this),
                "click.timepicker": a.proxy(this.showWidget, this),
                "blur.timepicker": a.proxy(this.blurElement, this),
                "mousewheel.timepicker DOMMouseScroll.timepicker": a.proxy(this.mousewheel, this)
            }) : this.$element.on({
                "focus.timepicker": a.proxy(this.highlightUnit, this),
                "click.timepicker": a.proxy(this.highlightUnit, this),
                "keydown.timepicker": a.proxy(this.elementKeydown, this),
                "blur.timepicker": a.proxy(this.blurElement, this),
                "mousewheel.timepicker DOMMouseScroll.timepicker": a.proxy(this.mousewheel, this)
            }), this.template !== !1 ? this.$widget = a(this.getTemplate()).on("click", a.proxy(this.widgetClick, this)) : this.$widget = !1, this.showInputs && this.$widget !== !1 && this.$widget.find("input").each(function () {
                a(this).on({
                    "click.timepicker": function () {
                        a(this).select()
                    }, "keydown.timepicker": a.proxy(b.widgetKeydown, b), "keyup.timepicker": a.proxy(b.widgetKeyup, b)
                })
            }), this.setDefaultTime(this.defaultTime)
        }, blurElement: function () {
            this.highlightedUnit = null, this.updateFromElementVal()
        }, clear: function () {
            this.hour = "", this.minute = "", this.second = "", this.meridian = "", this.$element.val("")
        }, decrementHour: function () {
            if (this.showMeridian) if (1 === this.hour) this.hour = 12; else {
                if (12 === this.hour) return this.hour--, this.toggleMeridian();
                if (0 === this.hour) return this.hour = 11, this.toggleMeridian();
                this.hour--
            } else this.hour <= 0 ? this.hour = this.maxHours - 1 : this.hour--
        }, decrementMinute: function (a) {
            var b;
            b = a ? this.minute - a : this.minute - this.minuteStep, 0 > b ? (this.decrementHour(), this.minute = b + 60) : this.minute = b
        }, decrementSecond: function () {
            var a = this.second - this.secondStep;
            0 > a ? (this.decrementMinute(!0), this.second = a + 60) : this.second = a
        }, elementKeydown: function (a) {
            switch (a.which) {
                case 9:
                    if (a.shiftKey) {
                        if ("hour" === this.highlightedUnit) {
                            this.hideWidget();
                            break
                        }
                        this.highlightPrevUnit()
                    } else {
                        if (this.showMeridian && "meridian" === this.highlightedUnit || this.showSeconds && "second" === this.highlightedUnit || !this.showMeridian && !this.showSeconds && "minute" === this.highlightedUnit) {
                            this.hideWidget();
                            break
                        }
                        this.highlightNextUnit()
                    }
                    a.preventDefault(), this.updateFromElementVal();
                    break;
                case 27:
                    this.updateFromElementVal();
                    break;
                case 37:
                    a.preventDefault(), this.highlightPrevUnit(), this.updateFromElementVal();
                    break;
                case 38:
                    switch (a.preventDefault(), this.highlightedUnit) {
                        case"hour":
                            this.incrementHour(), this.highlightHour();
                            break;
                        case"minute":
                            this.incrementMinute(), this.highlightMinute();
                            break;
                        case"second":
                            this.incrementSecond(), this.highlightSecond();
                            break;
                        case"meridian":
                            this.toggleMeridian(), this.highlightMeridian()
                    }
                    this.update();
                    break;
                case 39:
                    a.preventDefault(), this.highlightNextUnit(), this.updateFromElementVal();
                    break;
                case 40:
                    switch (a.preventDefault(), this.highlightedUnit) {
                        case"hour":
                            this.decrementHour(), this.highlightHour();
                            break;
                        case"minute":
                            this.decrementMinute(), this.highlightMinute();
                            break;
                        case"second":
                            this.decrementSecond(), this.highlightSecond();
                            break;
                        case"meridian":
                            this.toggleMeridian(), this.highlightMeridian()
                    }
                    this.update()
            }
        }, getCursorPosition: function () {
            var a = this.$element.get(0);
            if ("selectionStart" in a) return a.selectionStart;
            if (c.selection) {
                a.focus();
                var b = c.selection.createRange(), d = c.selection.createRange().text.length;
                return b.moveStart("character", -a.value.length), b.text.length - d
            }
        }, getTemplate: function () {
            var a, b, c, d, e, f;
            switch (this.showInputs ? (b = '<input type="text" class="bootstrap-timepicker-hour" maxlength="2"/>', c = '<input type="text" class="bootstrap-timepicker-minute" maxlength="2"/>', d = '<input type="text" class="bootstrap-timepicker-second" maxlength="2"/>', e = '<input type="text" class="bootstrap-timepicker-meridian" maxlength="2"/>') : (b = '<span class="bootstrap-timepicker-hour"></span>', c = '<span class="bootstrap-timepicker-minute"></span>', d = '<span class="bootstrap-timepicker-second"></span>', e = '<span class="bootstrap-timepicker-meridian"></span>'), f = '<table><tr><td><a href="#" data-action="incrementHour"><span class="' + this.icons.up + '"></span></a></td><td class="separator">&nbsp;</td><td><a href="#" data-action="incrementMinute"><span class="' + this.icons.up + '"></span></a></td>' + (this.showSeconds ? '<td class="separator">&nbsp;</td><td><a href="#" data-action="incrementSecond"><span class="' + this.icons.up + '"></span></a></td>' : "") + (this.showMeridian ? '<td class="separator">&nbsp;</td><td class="meridian-column"><a href="#" data-action="toggleMeridian"><span class="' + this.icons.up + '"></span></a></td>' : "") + "</tr><tr><td>" + b + '</td> <td class="separator">:</td><td>' + c + "</td> " + (this.showSeconds ? '<td class="separator">:</td><td>' + d + "</td>" : "") + (this.showMeridian ? '<td class="separator">&nbsp;</td><td>' + e + "</td>" : "") + '</tr><tr><td><a href="#" data-action="decrementHour"><span class="' + this.icons.down + '"></span></a></td><td class="separator"></td><td><a href="#" data-action="decrementMinute"><span class="' + this.icons.down + '"></span></a></td>' + (this.showSeconds ? '<td class="separator">&nbsp;</td><td><a href="#" data-action="decrementSecond"><span class="' + this.icons.down + '"></span></a></td>' : "") + (this.showMeridian ? '<td class="separator">&nbsp;</td><td><a href="#" data-action="toggleMeridian"><span class="' + this.icons.down + '"></span></a></td>' : "") + "</tr></table>", this.template) {
                case"modal":
                    a = '<div class="bootstrap-timepicker-widget modal hide fade in" data-backdrop="' + (this.modalBackdrop ? "true" : "false") + '"><div class="modal-header"><a href="#" class="close" data-dismiss="modal">&times;</a><h3>Pick a Time</h3></div><div class="modal-content">' + f + '</div><div class="modal-footer"><a href="#" class="btn btn-primary" data-dismiss="modal">OK</a></div></div>';
                    break;
                case"dropdown":
                    a = '<div class="bootstrap-timepicker-widget dropdown-menu">' + f + "</div>"
            }
            return a
        }, getTime: function () {
            return "" === this.hour ? "" : this.hour + ":" + (1 === this.minute.toString().length ? "0" + this.minute : this.minute) + (this.showSeconds ? ":" + (1 === this.second.toString().length ? "0" + this.second : this.second) : "") + (this.showMeridian ? " " + this.meridian : "")
        }, hideWidget: function () {
            this.isOpen !== !1 && (this.$element.trigger({
                type: "hide.timepicker",
                time: {
                    value: this.getTime(),
                    hours: this.hour,
                    minutes: this.minute,
                    seconds: this.second,
                    meridian: this.meridian
                }
            }), "modal" === this.template && this.$widget.modal ? this.$widget.modal("hide") : this.$widget.removeClass("open"), a(c).off("mousedown.timepicker, touchend.timepicker", this.handleDocumentClick), this.isOpen = !1, this.$widget.detach())
        }, highlightUnit: function () {
            this.position = this.getCursorPosition(), this.position >= 0 && this.position <= 2 ? this.highlightHour() : this.position >= 3 && this.position <= 5 ? this.highlightMinute() : this.position >= 6 && this.position <= 8 ? this.showSeconds ? this.highlightSecond() : this.highlightMeridian() : this.position >= 9 && this.position <= 11 && this.highlightMeridian()
        }, highlightNextUnit: function () {
            switch (this.highlightedUnit) {
                case"hour":
                    this.highlightMinute();
                    break;
                case"minute":
                    this.showSeconds ? this.highlightSecond() : this.showMeridian ? this.highlightMeridian() : this.highlightHour();
                    break;
                case"second":
                    this.showMeridian ? this.highlightMeridian() : this.highlightHour();
                    break;
                case"meridian":
                    this.highlightHour()
            }
        }, highlightPrevUnit: function () {
            switch (this.highlightedUnit) {
                case"hour":
                    this.showMeridian ? this.highlightMeridian() : this.showSeconds ? this.highlightSecond() : this.highlightMinute();
                    break;
                case"minute":
                    this.highlightHour();
                    break;
                case"second":
                    this.highlightMinute();
                    break;
                case"meridian":
                    this.showSeconds ? this.highlightSecond() : this.highlightMinute()
            }
        }, highlightHour: function () {
            var a = this.$element.get(0), b = this;
            this.highlightedUnit = "hour", a.setSelectionRange && setTimeout(function () {
                b.hour < 10 ? a.setSelectionRange(0, 1) : a.setSelectionRange(0, 2)
            }, 0)
        }, highlightMinute: function () {
            var a = this.$element.get(0), b = this;
            this.highlightedUnit = "minute", a.setSelectionRange && setTimeout(function () {
                b.hour < 10 ? a.setSelectionRange(2, 4) : a.setSelectionRange(3, 5)
            }, 0)
        }, highlightSecond: function () {
            var a = this.$element.get(0), b = this;
            this.highlightedUnit = "second", a.setSelectionRange && setTimeout(function () {
                b.hour < 10 ? a.setSelectionRange(5, 7) : a.setSelectionRange(6, 8)
            }, 0)
        }, highlightMeridian: function () {
            var a = this.$element.get(0), b = this;
            this.highlightedUnit = "meridian", a.setSelectionRange && (this.showSeconds ? setTimeout(function () {
                b.hour < 10 ? a.setSelectionRange(8, 10) : a.setSelectionRange(9, 11)
            }, 0) : setTimeout(function () {
                b.hour < 10 ? a.setSelectionRange(5, 7) : a.setSelectionRange(6, 8)
            }, 0))
        }, incrementHour: function () {
            if (this.showMeridian) {
                if (11 === this.hour) return this.hour++, this.toggleMeridian();
                12 === this.hour && (this.hour = 0)
            }
            return this.hour === this.maxHours - 1 ? void(this.hour = 0) : void this.hour++
        }, incrementMinute: function (a) {
            var b;
            b = a ? this.minute + a : this.minute + this.minuteStep - this.minute % this.minuteStep, b > 59 ? (this.incrementHour(), this.minute = b - 60) : this.minute = b
        }, incrementSecond: function () {
            var a = this.second + this.secondStep - this.second % this.secondStep;
            a > 59 ? (this.incrementMinute(!0), this.second = a - 60) : this.second = a
        }, mousewheel: function (b) {
            if (!this.disableMousewheel) {
                b.preventDefault(), b.stopPropagation();
                var c = b.originalEvent.wheelDelta || -b.originalEvent.detail, d = null;
                switch ("mousewheel" === b.type ? d = -1 * b.originalEvent.wheelDelta : "DOMMouseScroll" === b.type && (d = 40 * b.originalEvent.detail), d && (b.preventDefault(), a(this).scrollTop(d + a(this).scrollTop())), this.highlightedUnit) {
                    case"minute":
                        c > 0 ? this.incrementMinute() : this.decrementMinute(), this.highlightMinute();
                        break;
                    case"second":
                        c > 0 ? this.incrementSecond() : this.decrementSecond(), this.highlightSecond();
                        break;
                    case"meridian":
                        this.toggleMeridian(), this.highlightMeridian();
                        break;
                    default:
                        c > 0 ? this.incrementHour() : this.decrementHour(), this.highlightHour()
                }
                return !1
            }
        }, changeToNearestStep: function (a, b) {
            return a % b === 0 ? a : Math.round(a % b / b) ? (a + (b - a % b)) % 60 : a - a % b
        }, place: function () {
            if (!this.isInline) {
                var c = this.$widget.outerWidth(), d = this.$widget.outerHeight(), e = 10, f = a(b).width(),
                    g = a(b).height(), h = a(b).scrollTop(), i = parseInt(this.$element.parents().filter(function () {
                        return "auto" !== a(this).css("z-index")
                    }).first().css("z-index"), 10) + 10,
                    j = this.component ? this.component.parent().offset() : this.$element.offset(),
                    k = this.component ? this.component.outerHeight(!0) : this.$element.outerHeight(!1),
                    l = this.component ? this.component.outerWidth(!0) : this.$element.outerWidth(!1), m = j.left,
                    n = j.top;
                this.$widget.removeClass("timepicker-orient-top timepicker-orient-bottom timepicker-orient-right timepicker-orient-left"), "auto" !== this.orientation.x ? (this.$widget.addClass("timepicker-orient-" + this.orientation.x), "right" === this.orientation.x && (m -= c - l)) : (this.$widget.addClass("timepicker-orient-left"), j.left < 0 ? m -= j.left - e : j.left + c > f && (m = f - c - e));
                var o, p, q = this.orientation.y;
                "auto" === q && (o = -h + j.top - d, p = h + g - (j.top + k + d), q = Math.max(o, p) === p ? "top" : "bottom"), this.$widget.addClass("timepicker-orient-" + q), "top" === q ? n += k : n -= d + parseInt(this.$widget.css("padding-top"), 10), this.$widget.css({
                    top: n,
                    left: m,
                    zIndex: i
                })
            }
        }, remove: function () {
            a("document").off(".timepicker"), this.$widget && this.$widget.remove(), delete this.$element.data().timepicker
        }, setDefaultTime: function (a) {
            if (this.$element.val()) this.updateFromElementVal(); else if ("current" === a) {
                var b = new Date, c = b.getHours(), d = b.getMinutes(), e = b.getSeconds(), f = "AM";
                0 !== e && (e = Math.ceil(b.getSeconds() / this.secondStep) * this.secondStep, 60 === e && (d += 1, e = 0)), 0 !== d && (d = Math.ceil(b.getMinutes() / this.minuteStep) * this.minuteStep, 60 === d && (c += 1, d = 0)), this.showMeridian && (0 === c ? c = 12 : c >= 12 ? (c > 12 && (c -= 12), f = "PM") : f = "AM"), this.hour = c, this.minute = d, this.second = e, this.meridian = f, this.update()
            } else a === !1 ? (this.hour = 0, this.minute = 0, this.second = 0, this.meridian = "AM") : this.setTime(a)
        }, setTime: function (a, b) {
            if (!a) return void this.clear();
            var c, d, e, f, g, h;
            if ("object" == typeof a && a.getMonth) e = a.getHours(), f = a.getMinutes(), g = a.getSeconds(), this.showMeridian && (h = "AM", e > 12 && (h = "PM", e %= 12), 12 === e && (h = "PM")); else {
                if (c = (/a/i.test(a) ? 1 : 0) + (/p/i.test(a) ? 2 : 0), c > 2) return void this.clear();
                if (d = a.replace(/[^0-9\:]/g, "").split(":"), e = d[0] ? d[0].toString() : d.toString(), this.explicitMode && e.length > 2 && e.length % 2 !== 0) return void this.clear();
                f = d[1] ? d[1].toString() : "", g = d[2] ? d[2].toString() : "", e.length > 4 && (g = e.slice(-2), e = e.slice(0, -2)), e.length > 2 && (f = e.slice(-2), e = e.slice(0, -2)), f.length > 2 && (g = f.slice(-2), f = f.slice(0, -2)), e = parseInt(e, 10), f = parseInt(f, 10), g = parseInt(g, 10), isNaN(e) && (e = 0), isNaN(f) && (f = 0), isNaN(g) && (g = 0), g > 59 && (g = 59), f > 59 && (f = 59), e >= this.maxHours && (e = this.maxHours - 1), this.showMeridian ? (e > 12 && (c = 2, e -= 12), c || (c = 1), 0 === e && (e = 12), h = 1 === c ? "AM" : "PM") : 12 > e && 2 === c ? e += 12 : e >= this.maxHours ? e = this.maxHours - 1 : (0 > e || 12 === e && 1 === c) && (e = 0)
            }
            this.hour = e, this.snapToStep ? (this.minute = this.changeToNearestStep(f, this.minuteStep), this.second = this.changeToNearestStep(g, this.secondStep)) : (this.minute = f, this.second = g), this.meridian = h, this.update(b)
        }, showWidget: function () {
            this.isOpen || this.$element.is(":disabled") || (this.$widget.appendTo(this.appendWidgetTo), a(c).on("mousedown.timepicker, touchend.timepicker", {scope: this}, this.handleDocumentClick), this.$element.trigger({
                type: "show.timepicker",
                time: {
                    value: this.getTime(),
                    hours: this.hour,
                    minutes: this.minute,
                    seconds: this.second,
                    meridian: this.meridian
                }
            }), this.place(), this.disableFocus && this.$element.blur(), "" === this.hour && (this.defaultTime ? this.setDefaultTime(this.defaultTime) : this.setTime("0:0:0")), "modal" === this.template && this.$widget.modal ? this.$widget.modal("show").on("hidden", a.proxy(this.hideWidget, this)) : this.isOpen === !1 && this.$widget.addClass("open"), this.isOpen = !0)
        }, toggleMeridian: function () {
            this.meridian = "AM" === this.meridian ? "PM" : "AM"
        }, update: function (a) {
            this.updateElement(), a || this.updateWidget(), this.$element.trigger({
                type: "changeTime.timepicker",
                time: {
                    value: this.getTime(),
                    hours: this.hour,
                    minutes: this.minute,
                    seconds: this.second,
                    meridian: this.meridian
                }
            })
        }, updateElement: function () {
            this.$element.val(this.getTime()).change()
        }, updateFromElementVal: function () {
            this.setTime(this.$element.val())
        }, updateWidget: function () {
            if (this.$widget !== !1) {
                var a = this.hour, b = 1 === this.minute.toString().length ? "0" + this.minute : this.minute,
                    c = 1 === this.second.toString().length ? "0" + this.second : this.second;
                this.showInputs ? (this.$widget.find("input.bootstrap-timepicker-hour").val(a), this.$widget.find("input.bootstrap-timepicker-minute").val(b), this.showSeconds && this.$widget.find("input.bootstrap-timepicker-second").val(c), this.showMeridian && this.$widget.find("input.bootstrap-timepicker-meridian").val(this.meridian)) : (this.$widget.find("span.bootstrap-timepicker-hour").text(a), this.$widget.find("span.bootstrap-timepicker-minute").text(b), this.showSeconds && this.$widget.find("span.bootstrap-timepicker-second").text(c), this.showMeridian && this.$widget.find("span.bootstrap-timepicker-meridian").text(this.meridian))
            }
        }, updateFromWidgetInputs: function () {
            if (this.$widget !== !1) {
                var a = this.$widget.find("input.bootstrap-timepicker-hour").val() + ":" + this.$widget.find("input.bootstrap-timepicker-minute").val() + (this.showSeconds ? ":" + this.$widget.find("input.bootstrap-timepicker-second").val() : "") + (this.showMeridian ? this.$widget.find("input.bootstrap-timepicker-meridian").val() : "");
                this.setTime(a, !0)
            }
        }, widgetClick: function (b) {
            b.stopPropagation(), b.preventDefault();
            var c = a(b.target), d = c.closest("a").data("action");
            d && this[d](), this.update(), c.is("input") && c.get(0).setSelectionRange(0, 2)
        }, widgetKeydown: function (b) {
            var c = a(b.target), d = c.attr("class").replace("bootstrap-timepicker-", "");
            switch (b.which) {
                case 9:
                    if (b.shiftKey) {
                        if ("hour" === d) return this.hideWidget()
                    } else if (this.showMeridian && "meridian" === d || this.showSeconds && "second" === d || !this.showMeridian && !this.showSeconds && "minute" === d) return this.hideWidget();
                    break;
                case 27:
                    this.hideWidget();
                    break;
                case 38:
                    switch (b.preventDefault(), d) {
                        case"hour":
                            this.incrementHour();
                            break;
                        case"minute":
                            this.incrementMinute();
                            break;
                        case"second":
                            this.incrementSecond();
                            break;
                        case"meridian":
                            this.toggleMeridian()
                    }
                    this.setTime(this.getTime()), c.get(0).setSelectionRange(0, 2);
                    break;
                case 40:
                    switch (b.preventDefault(), d) {
                        case"hour":
                            this.decrementHour();
                            break;
                        case"minute":
                            this.decrementMinute();
                            break;
                        case"second":
                            this.decrementSecond();
                            break;
                        case"meridian":
                            this.toggleMeridian()
                    }
                    this.setTime(this.getTime()), c.get(0).setSelectionRange(0, 2)
            }
        }, widgetKeyup: function (a) {
            (65 === a.which || 77 === a.which || 80 === a.which || 46 === a.which || 8 === a.which || a.which >= 48 && a.which <= 57 || a.which >= 96 && a.which <= 105) && this.updateFromWidgetInputs()
        }
    }, a.fn.timepicker = function (b) {
        var c = Array.apply(null, arguments);
        return c.shift(), this.each(function () {
            var e = a(this), f = e.data("timepicker"), g = "object" == typeof b && b;
            f || e.data("timepicker", f = new d(this, a.extend({}, a.fn.timepicker.defaults, g, a(this).data()))), "string" == typeof b && f[b].apply(f, c)
        })
    }, a.fn.timepicker.defaults = {
        defaultTime: "current",
        disableFocus: !1,
        disableMousewheel: !1,
        isOpen: !1,
        minuteStep: 15,
        modalBackdrop: !1,
        orientation: {x: "auto", y: "auto"},
        secondStep: 15,
        snapToStep: !1,
        showSeconds: !1,
        showInputs: !0,
        showMeridian: !0,
        template: "dropdown",
        appendWidgetTo: "body",
        showWidgetOnAddonClick: !0,
        icons: {up: "glyphicon glyphicon-chevron-up", down: "glyphicon glyphicon-chevron-down"},
        maxHours: 24,
        explicitMode: !1
    }, a.fn.timepicker.Constructor = d, a(c).on("focus.timepicker.data-api click.timepicker.data-api", '[data-provide="timepicker"]', function (b) {
        var c = a(this);
        c.data("timepicker") || (b.preventDefault(), c.timepicker())
    })
}(jQuery, window, document);
"use strict";
$.fn.timepicker.defaults = $.extend(true, {}, $.fn.timepicker.defaults, {
    icons: {
        up: 'la la-angle-up',
        down: 'la la-angle-down'
    }
});
/**
 * @version: 2.1.30
 * @author: Dan Grossman http://www.dangrossman.info/
 * @copyright: Copyright (c) 2012-2017 Dan Grossman. All rights reserved.
 * @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
 * @website: http://www.daterangepicker.com/
 */
// Follow the UMD template https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Make globaly available as well
        define(['moment', 'jquery'], function (moment, jquery) {
            if (!jquery.fn) jquery.fn = {}; // webpack server rendering
            return factory(moment, jquery);
        });
    } else if (typeof module === 'object' && module.exports) {
        // Node / Browserify
        //isomorphic issue
        var jQuery = (typeof window != 'undefined') ? window.jQuery : undefined;
        if (!jQuery) {
            jQuery = require('jquery');
            if (!jQuery.fn) jQuery.fn = {};
        }
        var moment = (typeof window != 'undefined' && typeof window.moment != 'undefined') ? window.moment : require('moment');
        module.exports = factory(moment, jQuery);
    } else {
        // Browser globals
        root.daterangepicker = factory(root.moment, root.jQuery);
    }
}(this, function (moment, $) {
    var DateRangePicker = function (element, options, cb) {

        //default settings for options
        this.parentEl = 'body';
        this.element = $(element);
        this.startDate = moment().startOf('day');
        this.endDate = moment().endOf('day');
        this.minDate = false;
        this.maxDate = false;
        this.dateLimit = false;
        this.autoApply = false;
        this.singleDatePicker = false;
        this.showDropdowns = false;
        this.showWeekNumbers = false;
        this.showISOWeekNumbers = false;
        this.showCustomRangeLabel = true;
        this.timePicker = false;
        this.timePicker24Hour = false;
        this.timePickerIncrement = 1;
        this.timePickerSeconds = false;
        this.linkedCalendars = true;
        this.autoUpdateInput = true;
        this.alwaysShowCalendars = false;
        this.ranges = {};

        this.opens = 'right';
        if (this.element.hasClass('pull-right'))
            this.opens = 'left';

        this.drops = 'down';
        if (this.element.hasClass('dropup'))
            this.drops = 'up';

        this.buttonClasses = 'btn btn-sm';
        this.applyClass = 'btn-success';
        this.cancelClass = 'btn-default';

        this.locale = {
            direction: 'ltr',
            format: moment.localeData().longDateFormat('L'),
            separator: ' - ',
            applyLabel: 'Apply',
            cancelLabel: 'Cancel',
            weekLabel: 'W',
            customRangeLabel: 'Custom Range',
            daysOfWeek: moment.weekdaysMin(),
            monthNames: moment.monthsShort(),
            firstDay: moment.localeData().firstDayOfWeek()
        };

        this.callback = function () {
        };

        //some state information
        this.isShowing = false;
        this.leftCalendar = {};
        this.rightCalendar = {};

        //custom options from user
        if (typeof options !== 'object' || options === null)
            options = {};

        //allow setting options with data attributes
        //data-api options will be overwritten with custom javascript options
        options = $.extend(this.element.data(), options);

        //html template for the picker UI
        if (typeof options.template !== 'string' && !(options.template instanceof $))
            options.template = '<div class="daterangepicker dropdown-menu">' +
                '<div class="calendar left">' +
                '<div class="daterangepicker_input">' +
                '<input class="input-mini form-control" type="text" name="daterangepicker_start" value="" />' +
                '<i class="fa fa-calendar glyphicon glyphicon-calendar"></i>' +
                '<div class="calendar-time">' +
                '<div></div>' +
                '<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
                '</div>' +
                '</div>' +
                '<div class="calendar-table"></div>' +
                '</div>' +
                '<div class="calendar right">' +
                '<div class="daterangepicker_input">' +
                '<input class="input-mini form-control" type="text" name="daterangepicker_end" value="" />' +
                '<i class="fa fa-calendar glyphicon glyphicon-calendar"></i>' +
                '<div class="calendar-time">' +
                '<div></div>' +
                '<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
                '</div>' +
                '</div>' +
                '<div class="calendar-table"></div>' +
                '</div>' +
                '<div class="ranges">' +
                '<div class="range_inputs">' +
                '<button class="applyBtn" disabled="disabled" type="button"></button> ' +
                '<button class="cancelBtn" type="button"></button>' +
                '</div>' +
                '</div>' +
                '</div>';

        this.parentEl = (options.parentEl && $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);
        this.container = $(options.template).appendTo(this.parentEl);

        //
        // handle all the possible options overriding defaults
        //

        if (typeof options.locale === 'object') {

            if (typeof options.locale.direction === 'string')
                this.locale.direction = options.locale.direction;

            if (typeof options.locale.format === 'string')
                this.locale.format = options.locale.format;

            if (typeof options.locale.separator === 'string')
                this.locale.separator = options.locale.separator;

            if (typeof options.locale.daysOfWeek === 'object')
                this.locale.daysOfWeek = options.locale.daysOfWeek.slice();

            if (typeof options.locale.monthNames === 'object')
                this.locale.monthNames = options.locale.monthNames.slice();

            if (typeof options.locale.firstDay === 'number')
                this.locale.firstDay = options.locale.firstDay;

            if (typeof options.locale.applyLabel === 'string')
                this.locale.applyLabel = options.locale.applyLabel;

            if (typeof options.locale.cancelLabel === 'string')
                this.locale.cancelLabel = options.locale.cancelLabel;

            if (typeof options.locale.weekLabel === 'string')
                this.locale.weekLabel = options.locale.weekLabel;

            if (typeof options.locale.customRangeLabel === 'string') {
                //Support unicode chars in the custom range name.
                var elem = document.createElement('textarea');
                elem.innerHTML = options.locale.customRangeLabel;
                var rangeHtml = elem.value;
                this.locale.customRangeLabel = rangeHtml;
            }
        }
        this.container.addClass(this.locale.direction);

        if (typeof options.startDate === 'string')
            this.startDate = moment(options.startDate, this.locale.format);

        if (typeof options.endDate === 'string')
            this.endDate = moment(options.endDate, this.locale.format);

        if (typeof options.minDate === 'string')
            this.minDate = moment(options.minDate, this.locale.format);

        if (typeof options.maxDate === 'string')
            this.maxDate = moment(options.maxDate, this.locale.format);

        if (typeof options.startDate === 'object')
            this.startDate = moment(options.startDate);

        if (typeof options.endDate === 'object')
            this.endDate = moment(options.endDate);

        if (typeof options.minDate === 'object')
            this.minDate = moment(options.minDate);

        if (typeof options.maxDate === 'object')
            this.maxDate = moment(options.maxDate);

        // sanity check for bad options
        if (this.minDate && this.startDate.isBefore(this.minDate))
            this.startDate = this.minDate.clone();

        // sanity check for bad options
        if (this.maxDate && this.endDate.isAfter(this.maxDate))
            this.endDate = this.maxDate.clone();

        if (typeof options.applyClass === 'string')
            this.applyClass = options.applyClass;

        if (typeof options.cancelClass === 'string')
            this.cancelClass = options.cancelClass;

        if (typeof options.dateLimit === 'object')
            this.dateLimit = options.dateLimit;

        if (typeof options.opens === 'string')
            this.opens = options.opens;

        if (typeof options.drops === 'string')
            this.drops = options.drops;

        if (typeof options.showWeekNumbers === 'boolean')
            this.showWeekNumbers = options.showWeekNumbers;

        if (typeof options.showISOWeekNumbers === 'boolean')
            this.showISOWeekNumbers = options.showISOWeekNumbers;

        if (typeof options.buttonClasses === 'string')
            this.buttonClasses = options.buttonClasses;

        if (typeof options.buttonClasses === 'object')
            this.buttonClasses = options.buttonClasses.join(' ');

        if (typeof options.showDropdowns === 'boolean')
            this.showDropdowns = options.showDropdowns;

        if (typeof options.showCustomRangeLabel === 'boolean')
            this.showCustomRangeLabel = options.showCustomRangeLabel;

        if (typeof options.singleDatePicker === 'boolean') {
            this.singleDatePicker = options.singleDatePicker;
            if (this.singleDatePicker)
                this.endDate = this.startDate.clone();
        }

        if (typeof options.timePicker === 'boolean')
            this.timePicker = options.timePicker;

        if (typeof options.timePickerSeconds === 'boolean')
            this.timePickerSeconds = options.timePickerSeconds;

        if (typeof options.timePickerIncrement === 'number')
            this.timePickerIncrement = options.timePickerIncrement;

        if (typeof options.timePicker24Hour === 'boolean')
            this.timePicker24Hour = options.timePicker24Hour;

        if (typeof options.autoApply === 'boolean')
            this.autoApply = options.autoApply;

        if (typeof options.autoUpdateInput === 'boolean')
            this.autoUpdateInput = options.autoUpdateInput;

        if (typeof options.linkedCalendars === 'boolean')
            this.linkedCalendars = options.linkedCalendars;

        if (typeof options.isInvalidDate === 'function')
            this.isInvalidDate = options.isInvalidDate;

        if (typeof options.isCustomDate === 'function')
            this.isCustomDate = options.isCustomDate;

        if (typeof options.alwaysShowCalendars === 'boolean')
            this.alwaysShowCalendars = options.alwaysShowCalendars;

        // update day names order to firstDay
        if (this.locale.firstDay != 0) {
            var iterator = this.locale.firstDay;
            while (iterator > 0) {
                this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
                iterator--;
            }
        }

        var start, end, range;

        //if no start/end dates set, check if an input element contains initial values
        if (typeof options.startDate === 'undefined' && typeof options.endDate === 'undefined') {
            if ($(this.element).is('input[type=text]')) {
                var val = $(this.element).val(),
                    split = val.split(this.locale.separator);

                start = end = null;

                if (split.length == 2) {
                    start = moment(split[0], this.locale.format);
                    end = moment(split[1], this.locale.format);
                } else if (this.singleDatePicker && val !== "") {
                    start = moment(val, this.locale.format);
                    end = moment(val, this.locale.format);
                }
                if (start !== null && end !== null) {
                    this.setStartDate(start);
                    this.setEndDate(end);
                }
            }
        }

        if (typeof options.ranges === 'object') {
            for (range in options.ranges) {

                if (typeof options.ranges[range][0] === 'string')
                    start = moment(options.ranges[range][0], this.locale.format);
                else
                    start = moment(options.ranges[range][0]);

                if (typeof options.ranges[range][1] === 'string')
                    end = moment(options.ranges[range][1], this.locale.format);
                else
                    end = moment(options.ranges[range][1]);

                // If the start or end date exceed those allowed by the minDate or dateLimit
                // options, shorten the range to the allowable period.
                if (this.minDate && start.isBefore(this.minDate))
                    start = this.minDate.clone();

                var maxDate = this.maxDate;
                if (this.dateLimit && maxDate && start.clone().add(this.dateLimit).isAfter(maxDate))
                    maxDate = start.clone().add(this.dateLimit);
                if (maxDate && end.isAfter(maxDate))
                    end = maxDate.clone();

                // If the end of the range is before the minimum or the start of the range is
                // after the maximum, don't display this range option at all.
                if ((this.minDate && end.isBefore(this.minDate, this.timepicker ? 'minute' : 'day'))
                    || (maxDate && start.isAfter(maxDate, this.timepicker ? 'minute' : 'day')))
                    continue;

                //Support unicode chars in the range names.
                var elem = document.createElement('textarea');
                elem.innerHTML = range;
                var rangeHtml = elem.value;

                this.ranges[rangeHtml] = [start, end];
            }

            var list = '<ul>';
            for (range in this.ranges) {
                list += '<li data-range-key="' + range + '">' + range + '</li>';
            }
            if (this.showCustomRangeLabel) {
                list += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + '</li>';
            }
            list += '</ul>';
            this.container.find('.ranges').prepend(list);
        }

        if (typeof cb === 'function') {
            this.callback = cb;
        }

        if (!this.timePicker) {
            this.startDate = this.startDate.startOf('day');
            this.endDate = this.endDate.endOf('day');
            this.container.find('.calendar-time').hide();
        }

        //can't be used together for now
        if (this.timePicker && this.autoApply)
            this.autoApply = false;

        if (this.autoApply && typeof options.ranges !== 'object') {
            this.container.find('.ranges').hide();
        } else if (this.autoApply) {
            this.container.find('.applyBtn, .cancelBtn').addClass('hide');
        }

        if (this.singleDatePicker) {
            this.container.addClass('single');
            this.container.find('.calendar.left').addClass('single');
            this.container.find('.calendar.left').show();
            this.container.find('.calendar.right').hide();
            this.container.find('.daterangepicker_input input, .daterangepicker_input > i').hide();
            if (this.timePicker) {
                this.container.find('.ranges ul').hide();
            } else {
                this.container.find('.ranges').hide();
            }
        }

        if ((typeof options.ranges === 'undefined' && !this.singleDatePicker) || this.alwaysShowCalendars) {
            this.container.addClass('show-calendar');
        }

        this.container.addClass('opens' + this.opens);

        //swap the position of the predefined ranges if opens right
        if (typeof options.ranges !== 'undefined' && this.opens == 'right') {
            this.container.find('.ranges').prependTo(this.container.find('.calendar.left').parent());
        }

        //apply CSS classes and labels to buttons
        this.container.find('.applyBtn, .cancelBtn').addClass(this.buttonClasses);
        if (this.applyClass.length)
            this.container.find('.applyBtn').addClass(this.applyClass);
        if (this.cancelClass.length)
            this.container.find('.cancelBtn').addClass(this.cancelClass);
        this.container.find('.applyBtn').html(this.locale.applyLabel);
        this.container.find('.cancelBtn').html(this.locale.cancelLabel);

        //
        // event listeners
        //

        this.container.find('.calendar')
            .on('click.daterangepicker', '.prev', $.proxy(this.clickPrev, this))
            .on('click.daterangepicker', '.next', $.proxy(this.clickNext, this))
            .on('mousedown.daterangepicker', 'td.available', $.proxy(this.clickDate, this))
            .on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate, this))
            .on('mouseleave.daterangepicker', 'td.available', $.proxy(this.updateFormInputs, this))
            .on('change.daterangepicker', 'select.yearselect', $.proxy(this.monthOrYearChanged, this))
            .on('change.daterangepicker', 'select.monthselect', $.proxy(this.monthOrYearChanged, this))
            .on('change.daterangepicker', 'select.hourselect,select.minuteselect,select.secondselect,select.ampmselect', $.proxy(this.timeChanged, this))
            .on('click.daterangepicker', '.daterangepicker_input input', $.proxy(this.showCalendars, this))
            .on('focus.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsFocused, this))
            .on('blur.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsBlurred, this))
            .on('change.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsChanged, this))
            .on('keydown.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsKeydown, this));

        this.container.find('.ranges')
            .on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply, this))
            .on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel, this))
            .on('click.daterangepicker', 'li', $.proxy(this.clickRange, this))
            .on('mouseenter.daterangepicker', 'li', $.proxy(this.hoverRange, this))
            .on('mouseleave.daterangepicker', 'li', $.proxy(this.updateFormInputs, this));

        if (this.element.is('input') || this.element.is('button')) {
            this.element.on({
                'click.daterangepicker': $.proxy(this.show, this),
                'focus.daterangepicker': $.proxy(this.show, this),
                'keyup.daterangepicker': $.proxy(this.elementChanged, this),
                'keydown.daterangepicker': $.proxy(this.keydown, this) //IE 11 compatibility
            });
        } else {
            this.element.on('click.daterangepicker', $.proxy(this.toggle, this));
            this.element.on('keydown.daterangepicker', $.proxy(this.toggle, this));
        }

        //
        // if attached to a text input, set the initial value
        //

        if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
            this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
            this.element.trigger('change');
        } else if (this.element.is('input') && this.autoUpdateInput) {
            this.element.val(this.startDate.format(this.locale.format));
            this.element.trigger('change');
        }

    };

    DateRangePicker.prototype = {

        constructor: DateRangePicker,

        setStartDate: function (startDate) {
            if (typeof startDate === 'string')
                this.startDate = moment(startDate, this.locale.format);

            if (typeof startDate === 'object')
                this.startDate = moment(startDate);

            if (!this.timePicker)
                this.startDate = this.startDate.startOf('day');

            if (this.timePicker && this.timePickerIncrement)
                this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

            if (this.minDate && this.startDate.isBefore(this.minDate)) {
                this.startDate = this.minDate.clone();
                if (this.timePicker && this.timePickerIncrement)
                    this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }

            if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
                this.startDate = this.maxDate.clone();
                if (this.timePicker && this.timePickerIncrement)
                    this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }

            if (!this.isShowing)
                this.updateElement();

            this.updateMonthsInView();
        },

        setEndDate: function (endDate) {
            if (typeof endDate === 'string')
                this.endDate = moment(endDate, this.locale.format);

            if (typeof endDate === 'object')
                this.endDate = moment(endDate);

            if (!this.timePicker)
                this.endDate = this.endDate.add(1, 'd').startOf('day').subtract(1, 'second');

            if (this.timePicker && this.timePickerIncrement)
                this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

            if (this.endDate.isBefore(this.startDate))
                this.endDate = this.startDate.clone();

            if (this.maxDate && this.endDate.isAfter(this.maxDate))
                this.endDate = this.maxDate.clone();

            if (this.dateLimit && this.startDate.clone().add(this.dateLimit).isBefore(this.endDate))
                this.endDate = this.startDate.clone().add(this.dateLimit);

            this.previousRightTime = this.endDate.clone();

            if (!this.isShowing)
                this.updateElement();

            this.updateMonthsInView();
        },

        isInvalidDate: function () {
            return false;
        },

        isCustomDate: function () {
            return false;
        },

        updateView: function () {
            if (this.timePicker) {
                this.renderTimePicker('left');
                this.renderTimePicker('right');
                if (!this.endDate) {
                    this.container.find('.right .calendar-time select').attr('disabled', 'disabled').addClass('disabled');
                } else {
                    this.container.find('.right .calendar-time select').removeAttr('disabled').removeClass('disabled');
                }
            }
            if (this.endDate) {
                this.container.find('input[name="daterangepicker_end"]').removeClass('active');
                this.container.find('input[name="daterangepicker_start"]').addClass('active');
            } else {
                this.container.find('input[name="daterangepicker_end"]').addClass('active');
                this.container.find('input[name="daterangepicker_start"]').removeClass('active');
            }
            this.updateMonthsInView();
            this.updateCalendars();
            this.updateFormInputs();
        },

        updateMonthsInView: function () {
            if (this.endDate) {

                //if both dates are visible already, do nothing
                if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&
                    (this.startDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.startDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
                    &&
                    (this.endDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.endDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
                ) {
                    return;
                }

                this.leftCalendar.month = this.startDate.clone().date(2);
                if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {
                    this.rightCalendar.month = this.endDate.clone().date(2);
                } else {
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }

            } else {
                if (this.leftCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM') && this.rightCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM')) {
                    this.leftCalendar.month = this.startDate.clone().date(2);
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }
            }
            if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
                this.rightCalendar.month = this.maxDate.clone().date(2);
                this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, 'month');
            }
        },

        updateCalendars: function () {

            if (this.timePicker) {
                var hour, minute, second;
                if (this.endDate) {
                    hour = parseInt(this.container.find('.left .hourselect').val(), 10);
                    minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
                    second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.left .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                } else {
                    hour = parseInt(this.container.find('.right .hourselect').val(), 10);
                    minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
                    second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.right .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                }
                this.leftCalendar.month.hour(hour).minute(minute).second(second);
                this.rightCalendar.month.hour(hour).minute(minute).second(second);
            }

            this.renderCalendar('left');
            this.renderCalendar('right');

            //highlight any predefined range matching the current start and end dates
            this.container.find('.ranges li').removeClass('active');
            if (this.endDate == null) return;

            this.calculateChosenLabel();
        },

        renderCalendar: function (side) {

            //
            // Build the matrix of dates that will populate the calendar
            //

            var calendar = side == 'left' ? this.leftCalendar : this.rightCalendar;
            var month = calendar.month.month();
            var year = calendar.month.year();
            var hour = calendar.month.hour();
            var minute = calendar.month.minute();
            var second = calendar.month.second();
            var daysInMonth = moment([year, month]).daysInMonth();
            var firstDay = moment([year, month, 1]);
            var lastDay = moment([year, month, daysInMonth]);
            var lastMonth = moment(firstDay).subtract(1, 'month').month();
            var lastYear = moment(firstDay).subtract(1, 'month').year();
            var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();
            var dayOfWeek = firstDay.day();

            //initialize a 6 rows x 7 columns array for the calendar
            var calendar = [];
            calendar.firstDay = firstDay;
            calendar.lastDay = lastDay;

            for (var i = 0; i < 6; i++) {
                calendar[i] = [];
            }

            //populate the calendar with date objects
            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
            if (startDay > daysInLastMonth)
                startDay -= 7;

            if (dayOfWeek == this.locale.firstDay)
                startDay = daysInLastMonth - 6;

            var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);

            var col, row;
            for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment(curDate).add(24, 'hour')) {
                if (i > 0 && col % 7 === 0) {
                    col = 0;
                    row++;
                }
                calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
                curDate.hour(12);

                if (this.minDate && calendar[row][col].format('YYYY-MM-DD') == this.minDate.format('YYYY-MM-DD') && calendar[row][col].isBefore(this.minDate) && side == 'left') {
                    calendar[row][col] = this.minDate.clone();
                }

                if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') == this.maxDate.format('YYYY-MM-DD') && calendar[row][col].isAfter(this.maxDate) && side == 'right') {
                    calendar[row][col] = this.maxDate.clone();
                }

            }

            //make the calendar object available to hoverDate/clickDate
            if (side == 'left') {
                this.leftCalendar.calendar = calendar;
            } else {
                this.rightCalendar.calendar = calendar;
            }

            //
            // Display the calendar
            //

            var minDate = side == 'left' ? this.minDate : this.startDate;
            var maxDate = this.maxDate;
            var selected = side == 'left' ? this.startDate : this.endDate;
            var arrow = this.locale.direction == 'ltr' ? {
                left: 'chevron-left',
                right: 'chevron-right'
            } : {left: 'chevron-right', right: 'chevron-left'};

            var html = '<table class="table-condensed">';
            html += '<thead>';
            html += '<tr>';

            // add empty cell for week number
            if (this.showWeekNumbers || this.showISOWeekNumbers)
                html += '<th></th>';

            if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == 'left')) {
                html += '<th class="prev available"><i class="fa fa-' + arrow.left + ' glyphicon glyphicon-' + arrow.left + '"></i></th>';
            } else {
                html += '<th></th>';
            }

            var dateHtml = this.locale.monthNames[calendar[1][1].month()] + calendar[1][1].format(" YYYY");

            if (this.showDropdowns) {
                var currentMonth = calendar[1][1].month();
                var currentYear = calendar[1][1].year();
                var maxYear = (maxDate && maxDate.year()) || (currentYear + 5);
                var minYear = (minDate && minDate.year()) || (currentYear - 50);
                var inMinYear = currentYear == minYear;
                var inMaxYear = currentYear == maxYear;

                var monthHtml = '<select class="monthselect">';
                for (var m = 0; m < 12; m++) {
                    if ((!inMinYear || m >= minDate.month()) && (!inMaxYear || m <= maxDate.month())) {
                        monthHtml += "<option value='" + m + "'" +
                            (m === currentMonth ? " selected='selected'" : "") +
                            ">" + this.locale.monthNames[m] + "</option>";
                    } else {
                        monthHtml += "<option value='" + m + "'" +
                            (m === currentMonth ? " selected='selected'" : "") +
                            " disabled='disabled'>" + this.locale.monthNames[m] + "</option>";
                    }
                }
                monthHtml += "</select>";

                var yearHtml = '<select class="yearselect">';
                for (var y = minYear; y <= maxYear; y++) {
                    yearHtml += '<option value="' + y + '"' +
                        (y === currentYear ? ' selected="selected"' : '') +
                        '>' + y + '</option>';
                }
                yearHtml += '</select>';

                dateHtml = monthHtml + yearHtml;
            }

            html += '<th colspan="5" class="month">' + dateHtml + '</th>';
            if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == 'right' || this.singleDatePicker)) {
                html += '<th class="next available"><i class="fa fa-' + arrow.right + ' glyphicon glyphicon-' + arrow.right + '"></i></th>';
            } else {
                html += '<th></th>';
            }

            html += '</tr>';
            html += '<tr>';

            // add week number label
            if (this.showWeekNumbers || this.showISOWeekNumbers)
                html += '<th class="week">' + this.locale.weekLabel + '</th>';

            $.each(this.locale.daysOfWeek, function (index, dayOfWeek) {
                html += '<th>' + dayOfWeek + '</th>';
            });

            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';

            //adjust maxDate to reflect the dateLimit setting in order to
            //grey out end dates beyond the dateLimit
            if (this.endDate == null && this.dateLimit) {
                var maxLimit = this.startDate.clone().add(this.dateLimit).endOf('day');
                if (!maxDate || maxLimit.isBefore(maxDate)) {
                    maxDate = maxLimit;
                }
            }

            for (var row = 0; row < 6; row++) {
                html += '<tr>';

                // add week number
                if (this.showWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].week() + '</td>';
                else if (this.showISOWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].isoWeek() + '</td>';

                for (var col = 0; col < 7; col++) {

                    var classes = [];

                    //highlight today's date
                    if (calendar[row][col].isSame(new Date(), "day"))
                        classes.push('today');

                    //highlight weekends
                    if (calendar[row][col].isoWeekday() > 5)
                        classes.push('weekend');

                    //grey out the dates in other months displayed at beginning and end of this calendar
                    if (calendar[row][col].month() != calendar[1][1].month())
                        classes.push('off');

                    //don't allow selection of dates before the minimum date
                    if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day'))
                        classes.push('off', 'disabled');

                    //don't allow selection of dates after the maximum date
                    if (maxDate && calendar[row][col].isAfter(maxDate, 'day'))
                        classes.push('off', 'disabled');

                    //don't allow selection of date if a custom function decides it's invalid
                    if (this.isInvalidDate(calendar[row][col]))
                        classes.push('off', 'disabled');

                    //highlight the currently selected start date
                    if (calendar[row][col].format('YYYY-MM-DD') == this.startDate.format('YYYY-MM-DD'))
                        classes.push('active', 'start-date');

                    //highlight the currently selected end date
                    if (this.endDate != null && calendar[row][col].format('YYYY-MM-DD') == this.endDate.format('YYYY-MM-DD'))
                        classes.push('active', 'end-date');

                    //highlight dates in-between the selected dates
                    if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate)
                        classes.push('in-range');

                    //apply custom classes for this date
                    var isCustom = this.isCustomDate(calendar[row][col]);
                    if (isCustom !== false) {
                        if (typeof isCustom === 'string')
                            classes.push(isCustom);
                        else
                            Array.prototype.push.apply(classes, isCustom);
                    }

                    var cname = '', disabled = false;
                    for (var i = 0; i < classes.length; i++) {
                        cname += classes[i] + ' ';
                        if (classes[i] == 'disabled')
                            disabled = true;
                    }
                    if (!disabled)
                        cname += 'available';

                    html += '<td class="' + cname.replace(/^\s+|\s+$/g, '') + '" data-title="' + 'r' + row + 'c' + col + '">' + calendar[row][col].date() + '</td>';

                }
                html += '</tr>';
            }

            html += '</tbody>';
            html += '</table>';

            this.container.find('.calendar.' + side + ' .calendar-table').html(html);

        },

        renderTimePicker: function (side) {

            // Don't bother updating the time picker if it's currently disabled
            // because an end date hasn't been clicked yet
            if (side == 'right' && !this.endDate) return;

            var html, selected, minDate, maxDate = this.maxDate;

            if (this.dateLimit && (!this.maxDate || this.startDate.clone().add(this.dateLimit).isAfter(this.maxDate)))
                maxDate = this.startDate.clone().add(this.dateLimit);

            if (side == 'left') {
                selected = this.startDate.clone();
                minDate = this.minDate;
            } else if (side == 'right') {
                selected = this.endDate.clone();
                minDate = this.startDate;

                //Preserve the time already selected
                var timeSelector = this.container.find('.calendar.right .calendar-time div');
                if (timeSelector.html() != '') {

                    selected.hour(timeSelector.find('.hourselect option:selected').val() || selected.hour());
                    selected.minute(timeSelector.find('.minuteselect option:selected').val() || selected.minute());
                    selected.second(timeSelector.find('.secondselect option:selected').val() || selected.second());

                    if (!this.timePicker24Hour) {
                        var ampm = timeSelector.find('.ampmselect option:selected').val();
                        if (ampm === 'PM' && selected.hour() < 12)
                            selected.hour(selected.hour() + 12);
                        if (ampm === 'AM' && selected.hour() === 12)
                            selected.hour(0);
                    }

                }

                if (selected.isBefore(this.startDate))
                    selected = this.startDate.clone();

                if (maxDate && selected.isAfter(maxDate))
                    selected = maxDate.clone();

            }

            //
            // hours
            //

            html = '<select class="hourselect">';

            var start = this.timePicker24Hour ? 0 : 1;
            var end = this.timePicker24Hour ? 23 : 12;

            for (var i = start; i <= end; i++) {
                var i_in_24 = i;
                if (!this.timePicker24Hour)
                    i_in_24 = selected.hour() >= 12 ? (i == 12 ? 12 : i + 12) : (i == 12 ? 0 : i);

                var time = selected.clone().hour(i_in_24);
                var disabled = false;
                if (minDate && time.minute(59).isBefore(minDate))
                    disabled = true;
                if (maxDate && time.minute(0).isAfter(maxDate))
                    disabled = true;

                if (i_in_24 == selected.hour() && !disabled) {
                    html += '<option value="' + i + '" selected="selected">' + i + '</option>';
                } else if (disabled) {
                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + i + '</option>';
                } else {
                    html += '<option value="' + i + '">' + i + '</option>';
                }
            }

            html += '</select> ';

            //
            // minutes
            //

            html += ': <select class="minuteselect">';

            for (var i = 0; i < 60; i += this.timePickerIncrement) {
                var padded = i < 10 ? '0' + i : i;
                var time = selected.clone().minute(i);

                var disabled = false;
                if (minDate && time.second(59).isBefore(minDate))
                    disabled = true;
                if (maxDate && time.second(0).isAfter(maxDate))
                    disabled = true;

                if (selected.minute() == i && !disabled) {
                    html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
                } else if (disabled) {
                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
                } else {
                    html += '<option value="' + i + '">' + padded + '</option>';
                }
            }

            html += '</select> ';

            //
            // seconds
            //

            if (this.timePickerSeconds) {
                html += ': <select class="secondselect">';

                for (var i = 0; i < 60; i++) {
                    var padded = i < 10 ? '0' + i : i;
                    var time = selected.clone().second(i);

                    var disabled = false;
                    if (minDate && time.isBefore(minDate))
                        disabled = true;
                    if (maxDate && time.isAfter(maxDate))
                        disabled = true;

                    if (selected.second() == i && !disabled) {
                        html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
                    } else if (disabled) {
                        html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
                    } else {
                        html += '<option value="' + i + '">' + padded + '</option>';
                    }
                }

                html += '</select> ';
            }

            //
            // AM/PM
            //

            if (!this.timePicker24Hour) {
                html += '<select class="ampmselect">';

                var am_html = '';
                var pm_html = '';

                if (minDate && selected.clone().hour(12).minute(0).second(0).isBefore(minDate))
                    am_html = ' disabled="disabled" class="disabled"';

                if (maxDate && selected.clone().hour(0).minute(0).second(0).isAfter(maxDate))
                    pm_html = ' disabled="disabled" class="disabled"';

                if (selected.hour() >= 12) {
                    html += '<option value="AM"' + am_html + '>AM</option><option value="PM" selected="selected"' + pm_html + '>PM</option>';
                } else {
                    html += '<option value="AM" selected="selected"' + am_html + '>AM</option><option value="PM"' + pm_html + '>PM</option>';
                }

                html += '</select>';
            }

            this.container.find('.calendar.' + side + ' .calendar-time div').html(html);

        },

        updateFormInputs: function () {

            //ignore mouse movements while an above-calendar text input has focus
            if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
                return;

            this.container.find('input[name=daterangepicker_start]').val(this.startDate.format(this.locale.format));
            if (this.endDate)
                this.container.find('input[name=daterangepicker_end]').val(this.endDate.format(this.locale.format));

            if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {
                this.container.find('button.applyBtn').removeAttr('disabled');
            } else {
                this.container.find('button.applyBtn').attr('disabled', 'disabled');
            }

        },

        move: function () {
            var parentOffset = {top: 0, left: 0},
                containerTop;
            var parentRightEdge = $(window).width();
            if (!this.parentEl.is('body')) {
                parentOffset = {
                    top: this.parentEl.offset().top - this.parentEl.scrollTop(),
                    left: this.parentEl.offset().left - this.parentEl.scrollLeft()
                };
                parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;
            }

            if (this.drops == 'up')
                containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
            else
                containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
            this.container[this.drops == 'up' ? 'addClass' : 'removeClass']('dropup');

            if (this.opens == 'left') {
                this.container.css({
                    top: containerTop,
                    right: parentRightEdge - this.element.offset().left - this.element.outerWidth(),
                    left: 'auto'
                });
                if (this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else if (this.opens == 'center') {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2
                    - this.container.outerWidth() / 2,
                    right: 'auto'
                });
                if (this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left - parentOffset.left,
                    right: 'auto'
                });
                if (this.container.offset().left + this.container.outerWidth() > $(window).width()) {
                    this.container.css({
                        left: 'auto',
                        right: 0
                    });
                }
            }
        },

        show: function (e) {
            if (this.isShowing) return;

            // Create a click proxy that is private to this instance of datepicker, for unbinding
            this._outsideClickProxy = $.proxy(function (e) {
                this.outsideClick(e);
            }, this);

            // Bind global datepicker mousedown for hiding and
            $(document)
                .on('mousedown.daterangepicker', this._outsideClickProxy)
                // also support mobile devices
                .on('touchend.daterangepicker', this._outsideClickProxy)
                // also explicitly play nice with Bootstrap dropdowns, which stopPropagation when clicking them
                .on('click.daterangepicker', '[data-toggle=dropdown]', this._outsideClickProxy)
                // and also close when focus changes to outside the picker (eg. tabbing between controls)
                .on('focusin.daterangepicker', this._outsideClickProxy);

            // Reposition the picker if the window is resized while it's open
            $(window).on('resize.daterangepicker', $.proxy(function (e) {
                this.move(e);
            }, this));

            this.oldStartDate = this.startDate.clone();
            this.oldEndDate = this.endDate.clone();
            this.previousRightTime = this.endDate.clone();

            this.updateView();
            this.container.show();
            this.move();
            this.element.trigger('show.daterangepicker', this);
            this.isShowing = true;
        },

        hide: function (e) {
            if (!this.isShowing) return;

            //incomplete date selection, revert to last values
            if (!this.endDate) {
                this.startDate = this.oldStartDate.clone();
                this.endDate = this.oldEndDate.clone();
            }

            //if a new date range was selected, invoke the user callback function
            if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate))
                this.callback(this.startDate, this.endDate, this.chosenLabel);

            //if picker is attached to a text input, update it
            this.updateElement();

            $(document).off('.daterangepicker');
            $(window).off('.daterangepicker');
            this.container.hide();
            this.element.trigger('hide.daterangepicker', this);
            this.isShowing = false;
        },

        toggle: function (e) {
            if (this.isShowing) {
                this.hide();
            } else {
                this.show();
            }
        },

        outsideClick: function (e) {
            var target = $(e.target);
            // if the page is clicked anywhere except within the daterangerpicker/button
            // itself then call this.hide()
            if (
                // ie modal dialog fix
                e.type == "focusin" ||
                target.closest(this.element).length ||
                target.closest(this.container).length ||
                target.closest('.calendar-table').length
            ) return;
            this.hide();
            this.element.trigger('outsideClick.daterangepicker', this);
        },

        showCalendars: function () {
            this.container.addClass('show-calendar');
            this.move();
            this.element.trigger('showCalendar.daterangepicker', this);
        },

        hideCalendars: function () {
            this.container.removeClass('show-calendar');
            this.element.trigger('hideCalendar.daterangepicker', this);
        },

        hoverRange: function (e) {

            //ignore mouse movements while an above-calendar text input has focus
            if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
                return;

            var label = e.target.getAttribute('data-range-key');

            if (label == this.locale.customRangeLabel) {
                this.updateView();
            } else {
                var dates = this.ranges[label];
                this.container.find('input[name=daterangepicker_start]').val(dates[0].format(this.locale.format));
                this.container.find('input[name=daterangepicker_end]').val(dates[1].format(this.locale.format));
            }

        },

        clickRange: function (e) {
            var label = e.target.getAttribute('data-range-key');
            this.chosenLabel = label;
            if (label == this.locale.customRangeLabel) {
                this.showCalendars();
            } else {
                var dates = this.ranges[label];
                this.startDate = dates[0];
                this.endDate = dates[1];

                if (!this.timePicker) {
                    this.startDate.startOf('day');
                    this.endDate.endOf('day');
                }

                if (!this.alwaysShowCalendars)
                    this.hideCalendars();
                this.clickApply();
            }
        },

        clickPrev: function (e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.subtract(1, 'month');
                if (this.linkedCalendars)
                    this.rightCalendar.month.subtract(1, 'month');
            } else {
                this.rightCalendar.month.subtract(1, 'month');
            }
            this.updateCalendars();
        },

        clickNext: function (e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.add(1, 'month');
            } else {
                this.rightCalendar.month.add(1, 'month');
                if (this.linkedCalendars)
                    this.leftCalendar.month.add(1, 'month');
            }
            this.updateCalendars();
        },

        hoverDate: function (e) {

            //ignore mouse movements while an above-calendar text input has focus
            //if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
            //    return;

            //ignore dates that can't be selected
            if (!$(e.target).hasClass('available')) return;

            //have the text inputs above calendars reflect the date being hovered over
            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');
            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

            if (this.endDate && !this.container.find('input[name=daterangepicker_start]').is(":focus")) {
                this.container.find('input[name=daterangepicker_start]').val(date.format(this.locale.format));
            } else if (!this.endDate && !this.container.find('input[name=daterangepicker_end]').is(":focus")) {
                this.container.find('input[name=daterangepicker_end]').val(date.format(this.locale.format));
            }

            //highlight the dates between the start date and the date being hovered as a potential end date
            var leftCalendar = this.leftCalendar;
            var rightCalendar = this.rightCalendar;
            var startDate = this.startDate;
            if (!this.endDate) {
                this.container.find('.calendar tbody td').each(function (index, el) {

                    //skip week numbers, only look at dates
                    if ($(el).hasClass('week')) return;

                    var title = $(el).attr('data-title');
                    var row = title.substr(1, 1);
                    var col = title.substr(3, 1);
                    var cal = $(el).parents('.calendar');
                    var dt = cal.hasClass('left') ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];

                    if ((dt.isAfter(startDate) && dt.isBefore(date)) || dt.isSame(date, 'day')) {
                        $(el).addClass('in-range');
                    } else {
                        $(el).removeClass('in-range');
                    }

                });
            }

        },

        clickDate: function (e) {

            if (!$(e.target).hasClass('available')) return;

            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');
            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

            //
            // this function needs to do a few things:
            // * alternate between selecting a start and end date for the range,
            // * if the time picker is enabled, apply the hour/minute/second from the select boxes to the clicked date
            // * if autoapply is enabled, and an end date was chosen, apply the selection
            // * if single date picker mode, and time picker isn't enabled, apply the selection immediately
            // * if one of the inputs above the calendars was focused, cancel that manual input
            //

            if (this.endDate || date.isBefore(this.startDate, 'day')) { //picking start
                if (this.timePicker) {
                    var hour = parseInt(this.container.find('.left .hourselect').val(), 10);
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.left .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                    var minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
                    var second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
                    date = date.clone().hour(hour).minute(minute).second(second);
                }
                this.endDate = null;
                this.setStartDate(date.clone());
            } else if (!this.endDate && date.isBefore(this.startDate)) {
                //special case: clicking the same date for start/end,
                //but the time of the end date is before the start date
                this.setEndDate(this.startDate.clone());
            } else { // picking end
                if (this.timePicker) {
                    var hour = parseInt(this.container.find('.right .hourselect').val(), 10);
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.right .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                    var minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
                    var second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
                    date = date.clone().hour(hour).minute(minute).second(second);
                }
                this.setEndDate(date.clone());
                if (this.autoApply) {
                    this.calculateChosenLabel();
                    this.clickApply();
                }
            }

            if (this.singleDatePicker) {
                this.setEndDate(this.startDate);
                if (!this.timePicker)
                    this.clickApply();
            }

            this.updateView();

            //This is to cancel the blur event handler if the mouse was in one of the inputs
            e.stopPropagation();

        },

        calculateChosenLabel: function () {
            var customRange = true;
            var i = 0;
            for (var range in this.ranges) {
                if (this.timePicker) {
                    var format = this.timePickerSeconds ? "YYYY-MM-DD hh:mm:ss" : "YYYY-MM-DD hh:mm";
                    //ignore times when comparing dates if time picker seconds is not enabled
                    if (this.startDate.format(format) == this.ranges[range][0].format(format) && this.endDate.format(format) == this.ranges[range][1].format(format)) {
                        customRange = false;
                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
                        break;
                    }
                } else {
                    //ignore times when comparing dates if time picker is not enabled
                    if (this.startDate.format('YYYY-MM-DD') == this.ranges[range][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') == this.ranges[range][1].format('YYYY-MM-DD')) {
                        customRange = false;
                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
                        break;
                    }
                }
                i++;
            }
            if (customRange) {
                if (this.showCustomRangeLabel) {
                    this.chosenLabel = this.container.find('.ranges li:last').addClass('active').html();
                } else {
                    this.chosenLabel = null;
                }
                this.showCalendars();
            }
        },

        clickApply: function (e) {
            this.hide();
            this.element.trigger('apply.daterangepicker', this);
        },

        clickCancel: function (e) {
            this.startDate = this.oldStartDate;
            this.endDate = this.oldEndDate;
            this.hide();
            this.element.trigger('cancel.daterangepicker', this);
        },

        monthOrYearChanged: function (e) {
            var isLeft = $(e.target).closest('.calendar').hasClass('left'),
                leftOrRight = isLeft ? 'left' : 'right',
                cal = this.container.find('.calendar.' + leftOrRight);

            // Month must be Number for new moment versions
            var month = parseInt(cal.find('.monthselect').val(), 10);
            var year = cal.find('.yearselect').val();

            if (!isLeft) {
                if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {
                    month = this.startDate.month();
                    year = this.startDate.year();
                }
            }

            if (this.minDate) {
                if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {
                    month = this.minDate.month();
                    year = this.minDate.year();
                }
            }

            if (this.maxDate) {
                if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {
                    month = this.maxDate.month();
                    year = this.maxDate.year();
                }
            }

            if (isLeft) {
                this.leftCalendar.month.month(month).year(year);
                if (this.linkedCalendars)
                    this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');
            } else {
                this.rightCalendar.month.month(month).year(year);
                if (this.linkedCalendars)
                    this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');
            }
            this.updateCalendars();
        },

        timeChanged: function (e) {

            var cal = $(e.target).closest('.calendar'),
                isLeft = cal.hasClass('left');

            var hour = parseInt(cal.find('.hourselect').val(), 10);
            var minute = parseInt(cal.find('.minuteselect').val(), 10);
            var second = this.timePickerSeconds ? parseInt(cal.find('.secondselect').val(), 10) : 0;

            if (!this.timePicker24Hour) {
                var ampm = cal.find('.ampmselect').val();
                if (ampm === 'PM' && hour < 12)
                    hour += 12;
                if (ampm === 'AM' && hour === 12)
                    hour = 0;
            }

            if (isLeft) {
                var start = this.startDate.clone();
                start.hour(hour);
                start.minute(minute);
                start.second(second);
                this.setStartDate(start);
                if (this.singleDatePicker) {
                    this.endDate = this.startDate.clone();
                } else if (this.endDate && this.endDate.format('YYYY-MM-DD') == start.format('YYYY-MM-DD') && this.endDate.isBefore(start)) {
                    this.setEndDate(start.clone());
                }
            } else if (this.endDate) {
                var end = this.endDate.clone();
                end.hour(hour);
                end.minute(minute);
                end.second(second);
                this.setEndDate(end);
            }

            //update the calendars so all clickable dates reflect the new time component
            this.updateCalendars();

            //update the form inputs above the calendars with the new time
            this.updateFormInputs();

            //re-render the time pickers because changing one selection can affect what's enabled in another
            this.renderTimePicker('left');
            this.renderTimePicker('right');

        },

        formInputsChanged: function (e) {
            var isRight = $(e.target).closest('.calendar').hasClass('right');
            var start = moment(this.container.find('input[name="daterangepicker_start"]').val(), this.locale.format);
            var end = moment(this.container.find('input[name="daterangepicker_end"]').val(), this.locale.format);

            if (start.isValid() && end.isValid()) {

                if (isRight && end.isBefore(start))
                    start = end.clone();

                this.setStartDate(start);
                this.setEndDate(end);

                if (isRight) {
                    this.container.find('input[name="daterangepicker_start"]').val(this.startDate.format(this.locale.format));
                } else {
                    this.container.find('input[name="daterangepicker_end"]').val(this.endDate.format(this.locale.format));
                }

            }

            this.updateView();
        },

        formInputsFocused: function (e) {

            // Highlight the focused input
            this.container.find('input[name="daterangepicker_start"], input[name="daterangepicker_end"]').removeClass('active');
            $(e.target).addClass('active');

            // Set the state such that if the user goes back to using a mouse,
            // the calendars are aware we're selecting the end of the range, not
            // the start. This allows someone to edit the end of a date range without
            // re-selecting the beginning, by clicking on the end date input then
            // using the calendar.
            var isRight = $(e.target).closest('.calendar').hasClass('right');
            if (isRight) {
                this.endDate = null;
                this.setStartDate(this.startDate.clone());
                this.updateView();
            }

        },

        formInputsBlurred: function (e) {

            // this function has one purpose right now: if you tab from the first
            // text input to the second in the UI, the endDate is nulled so that
            // you can click another, but if you tab out without clicking anything
            // or changing the input value, the old endDate should be retained

            if (!this.endDate) {
                var val = this.container.find('input[name="daterangepicker_end"]').val();
                var end = moment(val, this.locale.format);
                if (end.isValid()) {
                    this.setEndDate(end);
                    this.updateView();
                }
            }

        },

        formInputsKeydown: function (e) {
            // This function ensures that if the 'enter' key was pressed in the input, then the calendars
            // are updated with the startDate and endDate.
            // This behaviour is automatic in Chrome/Firefox/Edge but not in IE 11 hence why this exists.
            // Other browsers and versions of IE are untested and the behaviour is unknown.
            if (e.keyCode === 13) {
                // Prevent the calendar from being updated twice on Chrome/Firefox/Edge
                e.preventDefault();
                this.formInputsChanged(e);
            }
        },


        elementChanged: function () {
            if (!this.element.is('input')) return;
            if (!this.element.val().length) return;

            var dateString = this.element.val().split(this.locale.separator),
                start = null,
                end = null;

            if (dateString.length === 2) {
                start = moment(dateString[0], this.locale.format);
                end = moment(dateString[1], this.locale.format);
            }

            if (this.singleDatePicker || start === null || end === null) {
                start = moment(this.element.val(), this.locale.format);
                end = start;
            }

            if (!start.isValid() || !end.isValid()) return;

            this.setStartDate(start);
            this.setEndDate(end);
            this.updateView();
        },

        keydown: function (e) {
            //hide on tab or enter
            if ((e.keyCode === 9) || (e.keyCode === 13)) {
                this.hide();
            }

            //hide on esc and prevent propagation
            if (e.keyCode === 27) {
                e.preventDefault();
                e.stopPropagation();

                this.hide();
            }
        },

        updateElement: function () {
            if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
                this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
                this.element.trigger('change');
            } else if (this.element.is('input') && this.autoUpdateInput) {
                this.element.val(this.startDate.format(this.locale.format));
                this.element.trigger('change');
            }
        },

        remove: function () {
            this.container.remove();
            this.element.off('.daterangepicker');
            this.element.removeData();
        }

    };

    $.fn.daterangepicker = function (options, callback) {
        var implementOptions = $.extend(true, {}, $.fn.daterangepicker.defaultOptions, options);
        this.each(function () {
            var el = $(this);
            if (el.data('daterangepicker'))
                el.data('daterangepicker').remove();
            el.data('daterangepicker', new DateRangePicker(el, implementOptions, callback));
        });
        return this;
    };

    return DateRangePicker;

}));

/*
 *  Bootstrap TouchSpin - v3.1.1
 *  A mobile and touch friendly input spinner component for Bootstrap 3.
 *  http://www.virtuosoft.eu/code/bootstrap-touchspin/
 *
 *  Made by István Ujj-Mészáros
 *  Under Apache License v2.0 License
 */
(function ($) {
    'use strict';

    var _currentSpinnerId = 0;

    function _scopedEventName(name, id) {
        return name + '.touchspin_' + id;
    }

    function _scopeEventNames(names, id) {
        return $.map(names, function (name) {
            return _scopedEventName(name, id);
        });
    }

    $.fn.TouchSpin = function (options) {

        if (options === 'destroy') {
            this.each(function () {
                var originalinput = $(this),
                    originalinput_data = originalinput.data();
                $(document).off(_scopeEventNames([
                    'mouseup',
                    'touchend',
                    'touchcancel',
                    'mousemove',
                    'touchmove',
                    'scroll',
                    'scrollstart'], originalinput_data.spinnerid).join(' '));
            });
            return;
        }

        var defaults = {
            min: 0,
            max: 100,
            initval: '',
            replacementval: '',
            step: 1,
            decimals: 0,
            stepinterval: 100,
            forcestepdivisibility: 'round', // none | floor | round | ceil
            stepintervaldelay: 500,
            verticalbuttons: false,
            verticalupclass: 'glyphicon glyphicon-chevron-up',
            verticaldownclass: 'glyphicon glyphicon-chevron-down',
            prefix: '',
            postfix: '',
            prefix_extraclass: '',
            postfix_extraclass: '',
            booster: true,
            boostat: 10,
            maxboostedstep: false,
            mousewheel: true,
            buttondown_class: 'btn btn-default',
            buttonup_class: 'btn btn-default',
            buttondown_txt: '-',
            buttonup_txt: '+'
        };

        var attributeMap = {
            min: 'min',
            max: 'max',
            initval: 'init-val',
            replacementval: 'replacement-val',
            step: 'step',
            decimals: 'decimals',
            stepinterval: 'step-interval',
            verticalbuttons: 'vertical-buttons',
            verticalupclass: 'vertical-up-class',
            verticaldownclass: 'vertical-down-class',
            forcestepdivisibility: 'force-step-divisibility',
            stepintervaldelay: 'step-interval-delay',
            prefix: 'prefix',
            postfix: 'postfix',
            prefix_extraclass: 'prefix-extra-class',
            postfix_extraclass: 'postfix-extra-class',
            booster: 'booster',
            boostat: 'boostat',
            maxboostedstep: 'max-boosted-step',
            mousewheel: 'mouse-wheel',
            buttondown_class: 'button-down-class',
            buttonup_class: 'button-up-class',
            buttondown_txt: 'button-down-txt',
            buttonup_txt: 'button-up-txt'
        };

        return this.each(function () {

            var settings,
                originalinput = $(this),
                originalinput_data = originalinput.data(),
                container,
                elements,
                value,
                downSpinTimer,
                upSpinTimer,
                downDelayTimeout,
                upDelayTimeout,
                spincount = 0,
                spinning = false;

            init();


            function init() {
                if (originalinput.data('alreadyinitialized')) {
                    return;
                }

                originalinput.data('alreadyinitialized', true);
                _currentSpinnerId += 1;
                originalinput.data('spinnerid', _currentSpinnerId);


                if (!originalinput.is('input')) {
                    console.log('Must be an input.');
                    return;
                }

                _initSettings();
                _setInitval();
                _checkValue();
                _buildHtml();
                _initElements();
                _hideEmptyPrefixPostfix();
                _bindEvents();
                _bindEventsInterface();
                elements.input.css('display', 'block');
            }

            function _setInitval() {
                if (settings.initval !== '' && originalinput.val() === '') {
                    originalinput.val(settings.initval);
                }
            }

            function changeSettings(newsettings) {
                _updateSettings(newsettings);
                _checkValue();

                var value = elements.input.val();

                if (value !== '') {
                    value = Number(elements.input.val());
                    elements.input.val(value.toFixed(settings.decimals));
                }
            }

            function _initSettings() {
                settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);
            }

            function _parseAttributes() {
                var data = {};
                $.each(attributeMap, function (key, value) {
                    var attrName = 'bts-' + value + '';
                    if (originalinput.is('[data-' + attrName + ']')) {
                        data[key] = originalinput.data(attrName);
                    }
                });
                return data;
            }

            function _updateSettings(newsettings) {
                settings = $.extend({}, settings, newsettings);
            }

            function _buildHtml() {
                var initval = originalinput.val(),
                    parentelement = originalinput.parent();

                if (initval !== '') {
                    initval = Number(initval).toFixed(settings.decimals);
                }

                originalinput.data('initvalue', initval).val(initval);
                originalinput.addClass('form-control');

                if (parentelement.hasClass('input-group')) {
                    _advanceInputGroup(parentelement);
                }
                else {
                    _buildInputGroup();
                }
            }

            function _advanceInputGroup(parentelement) {
                parentelement.addClass('bootstrap-touchspin');

                var prev = originalinput.prev(),
                    next = originalinput.next();

                var downhtml,
                    uphtml,
                    prefixhtml = '<span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span>',
                    postfixhtml = '<span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span>';

                if (prev.hasClass('input-group-btn')) {
                    downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button>';
                    prev.append(downhtml);
                }
                else {
                    downhtml = '<span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span>';
                    $(downhtml).insertBefore(originalinput);
                }

                if (next.hasClass('input-group-btn')) {
                    uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button>';
                    next.prepend(uphtml);
                }
                else {
                    uphtml = '<span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span>';
                    $(uphtml).insertAfter(originalinput);
                }

                $(prefixhtml).insertBefore(originalinput);
                $(postfixhtml).insertAfter(originalinput);

                container = parentelement;
            }

            function _buildInputGroup() {
                var html;

                if (settings.verticalbuttons) {
                    html = '<div class="input-group bootstrap-touchspin"><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn-vertical"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-up" type="button"><i class="' + settings.verticalupclass + '"></i></button><button class="' + settings.buttonup_class + ' bootstrap-touchspin-down" type="button"><i class="' + settings.verticaldownclass + '"></i></button></span></div>';
                }
                else {
                    html = '<div class="input-group bootstrap-touchspin"><span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span></div>';
                }

                container = $(html).insertBefore(originalinput);

                $('.bootstrap-touchspin-prefix', container).after(originalinput);

                if (originalinput.hasClass('input-sm')) {
                    container.addClass('input-group-sm');
                }
                else if (originalinput.hasClass('input-lg')) {
                    container.addClass('input-group-lg');
                }
            }

            function _initElements() {
                elements = {
                    down: $('.bootstrap-touchspin-down', container),
                    up: $('.bootstrap-touchspin-up', container),
                    input: $('input', container),
                    prefix: $('.bootstrap-touchspin-prefix', container).addClass(settings.prefix_extraclass),
                    postfix: $('.bootstrap-touchspin-postfix', container).addClass(settings.postfix_extraclass)
                };
            }

            function _hideEmptyPrefixPostfix() {
                if (settings.prefix === '') {
                    elements.prefix.hide();
                }

                if (settings.postfix === '') {
                    elements.postfix.hide();
                }
            }

            function _bindEvents() {
                originalinput.on('keydown', function (ev) {
                    var code = ev.keyCode || ev.which;

                    if (code === 38) {
                        if (spinning !== 'up') {
                            upOnce();
                            startUpSpin();
                        }
                        ev.preventDefault();
                    }
                    else if (code === 40) {
                        if (spinning !== 'down') {
                            downOnce();
                            startDownSpin();
                        }
                        ev.preventDefault();
                    }
                });

                originalinput.on('keyup', function (ev) {
                    var code = ev.keyCode || ev.which;

                    if (code === 38) {
                        stopSpin();
                    }
                    else if (code === 40) {
                        stopSpin();
                    }
                });

                originalinput.on('blur', function () {
                    _checkValue();
                });

                elements.down.on('keydown', function (ev) {
                    var code = ev.keyCode || ev.which;

                    if (code === 32 || code === 13) {
                        if (spinning !== 'down') {
                            downOnce();
                            startDownSpin();
                        }
                        ev.preventDefault();
                    }
                });

                elements.down.on('keyup', function (ev) {
                    var code = ev.keyCode || ev.which;

                    if (code === 32 || code === 13) {
                        stopSpin();
                    }
                });

                elements.up.on('keydown', function (ev) {
                    var code = ev.keyCode || ev.which;

                    if (code === 32 || code === 13) {
                        if (spinning !== 'up') {
                            upOnce();
                            startUpSpin();
                        }
                        ev.preventDefault();
                    }
                });

                elements.up.on('keyup', function (ev) {
                    var code = ev.keyCode || ev.which;

                    if (code === 32 || code === 13) {
                        stopSpin();
                    }
                });

                elements.down.on('mousedown.touchspin', function (ev) {
                    elements.down.off('touchstart.touchspin');  // android 4 workaround

                    if (originalinput.is(':disabled')) {
                        return;
                    }

                    downOnce();
                    startDownSpin();

                    ev.preventDefault();
                    ev.stopPropagation();
                });

                elements.down.on('touchstart.touchspin', function (ev) {
                    elements.down.off('mousedown.touchspin');  // android 4 workaround

                    if (originalinput.is(':disabled')) {
                        return;
                    }

                    downOnce();
                    startDownSpin();

                    ev.preventDefault();
                    ev.stopPropagation();
                });

                elements.up.on('mousedown.touchspin', function (ev) {
                    elements.up.off('touchstart.touchspin');  // android 4 workaround

                    if (originalinput.is(':disabled')) {
                        return;
                    }

                    upOnce();
                    startUpSpin();

                    ev.preventDefault();
                    ev.stopPropagation();
                });

                elements.up.on('touchstart.touchspin', function (ev) {
                    elements.up.off('mousedown.touchspin');  // android 4 workaround

                    if (originalinput.is(':disabled')) {
                        return;
                    }

                    upOnce();
                    startUpSpin();

                    ev.preventDefault();
                    ev.stopPropagation();
                });

                elements.up.on('mouseout touchleave touchend touchcancel', function (ev) {
                    if (!spinning) {
                        return;
                    }

                    ev.stopPropagation();
                    stopSpin();
                });

                elements.down.on('mouseout touchleave touchend touchcancel', function (ev) {
                    if (!spinning) {
                        return;
                    }

                    ev.stopPropagation();
                    stopSpin();
                });

                elements.down.on('mousemove touchmove', function (ev) {
                    if (!spinning) {
                        return;
                    }

                    ev.stopPropagation();
                    ev.preventDefault();
                });

                elements.up.on('mousemove touchmove', function (ev) {
                    if (!spinning) {
                        return;
                    }

                    ev.stopPropagation();
                    ev.preventDefault();
                });

                $(document).on(_scopeEventNames(['mouseup', 'touchend', 'touchcancel'], _currentSpinnerId).join(' '), function (ev) {
                    if (!spinning) {
                        return;
                    }

                    ev.preventDefault();
                    stopSpin();
                });

                $(document).on(_scopeEventNames(['mousemove', 'touchmove', 'scroll', 'scrollstart'], _currentSpinnerId).join(' '), function (ev) {
                    if (!spinning) {
                        return;
                    }

                    ev.preventDefault();
                    stopSpin();
                });

                originalinput.on('mousewheel DOMMouseScroll', function (ev) {
                    if (!settings.mousewheel || !originalinput.is(':focus')) {
                        return;
                    }

                    var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;

                    ev.stopPropagation();
                    ev.preventDefault();

                    if (delta < 0) {
                        downOnce();
                    }
                    else {
                        upOnce();
                    }
                });
            }

            function _bindEventsInterface() {
                originalinput.on('touchspin.uponce', function () {
                    stopSpin();
                    upOnce();
                });

                originalinput.on('touchspin.downonce', function () {
                    stopSpin();
                    downOnce();
                });

                originalinput.on('touchspin.startupspin', function () {
                    startUpSpin();
                });

                originalinput.on('touchspin.startdownspin', function () {
                    startDownSpin();
                });

                originalinput.on('touchspin.stopspin', function () {
                    stopSpin();
                });

                originalinput.on('touchspin.updatesettings', function (e, newsettings) {
                    changeSettings(newsettings);
                });
            }

            function _forcestepdivisibility(value) {
                switch (settings.forcestepdivisibility) {
                    case 'round':
                        return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);
                    case 'floor':
                        return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);
                    case 'ceil':
                        return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);
                    default:
                        return value;
                }
            }

            function _checkValue() {
                var val, parsedval, returnval;

                val = originalinput.val();

                if (val === '') {
                    if (settings.replacementval !== '') {
                        originalinput.val(settings.replacementval);
                        originalinput.trigger('change');
                    }
                    return;
                }

                if (settings.decimals > 0 && val === '.') {
                    return;
                }

                parsedval = parseFloat(val);

                if (isNaN(parsedval)) {
                    if (settings.replacementval !== '') {
                        parsedval = settings.replacementval;
                    }
                    else {
                        parsedval = 0;
                    }
                }

                returnval = parsedval;

                if (parsedval.toString() !== val) {
                    returnval = parsedval;
                }

                if (parsedval < settings.min) {
                    returnval = settings.min;
                }

                if (parsedval > settings.max) {
                    returnval = settings.max;
                }

                returnval = _forcestepdivisibility(returnval);

                if (Number(val).toString() !== returnval.toString()) {
                    originalinput.val(returnval);
                    originalinput.trigger('change');
                }
            }

            function _getBoostedStep() {
                if (!settings.booster) {
                    return settings.step;
                }
                else {
                    var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;

                    if (settings.maxboostedstep) {
                        if (boosted > settings.maxboostedstep) {
                            boosted = settings.maxboostedstep;
                            value = Math.round((value / boosted)) * boosted;
                        }
                    }

                    return Math.max(settings.step, boosted);
                }
            }

            function upOnce() {
                _checkValue();

                value = parseFloat(elements.input.val());
                if (isNaN(value)) {
                    value = 0;
                }

                var initvalue = value,
                    boostedstep = _getBoostedStep();

                value = value + boostedstep;

                if (value > settings.max) {
                    value = settings.max;
                    originalinput.trigger('touchspin.on.max');
                    stopSpin();
                }

                elements.input.val(Number(value).toFixed(settings.decimals));

                if (initvalue !== value) {
                    originalinput.trigger('change');
                }
            }

            function downOnce() {
                _checkValue();

                value = parseFloat(elements.input.val());
                if (isNaN(value)) {
                    value = 0;
                }

                var initvalue = value,
                    boostedstep = _getBoostedStep();

                value = value - boostedstep;

                if (value < settings.min) {
                    value = settings.min;
                    originalinput.trigger('touchspin.on.min');
                    stopSpin();
                }

                elements.input.val(value.toFixed(settings.decimals));

                if (initvalue !== value) {
                    originalinput.trigger('change');
                }
            }

            function startDownSpin() {
                stopSpin();

                spincount = 0;
                spinning = 'down';

                originalinput.trigger('touchspin.on.startspin');
                originalinput.trigger('touchspin.on.startdownspin');

                downDelayTimeout = setTimeout(function () {
                    downSpinTimer = setInterval(function () {
                        spincount++;
                        downOnce();
                    }, settings.stepinterval);
                }, settings.stepintervaldelay);
            }

            function startUpSpin() {
                stopSpin();

                spincount = 0;
                spinning = 'up';

                originalinput.trigger('touchspin.on.startspin');
                originalinput.trigger('touchspin.on.startupspin');

                upDelayTimeout = setTimeout(function () {
                    upSpinTimer = setInterval(function () {
                        spincount++;
                        upOnce();
                    }, settings.stepinterval);
                }, settings.stepintervaldelay);
            }

            function stopSpin() {
                clearTimeout(downDelayTimeout);
                clearTimeout(upDelayTimeout);
                clearInterval(downSpinTimer);
                clearInterval(upSpinTimer);

                switch (spinning) {
                    case 'up':
                        originalinput.trigger('touchspin.on.stopupspin');
                        originalinput.trigger('touchspin.on.stopspin');
                        break;
                    case 'down':
                        originalinput.trigger('touchspin.on.stopdownspin');
                        originalinput.trigger('touchspin.on.stopspin');
                        break;
                }

                spincount = 0;
                spinning = false;
            }

        });

    };

})(jQuery);

(function ($) {
    'use strict';
    /**
     * We need an event when the elements are destroyed
     * because if an input is removed, we have to remove the
     * maxlength object associated (if any).
     * From:
     * http://stackoverflow.com/questions/2200494/jquery-trigger-event-when-an-element-is-removed-from-the-dom
     */
    if (!$.event.special.destroyed) {
        $.event.special.destroyed = {
            remove: function (o) {
                if (o.handler) {
                    o.handler();
                }
            }
        };
    }


    $.fn.extend({
        maxlength: function (options, callback) {
            var documentBody = $('body'),
                defaults = {
                    showOnReady: false, // true to always show when indicator is ready
                    alwaysShow: false, // if true the indicator it's always shown.
                    threshold: 10, // Represents how many chars left are needed to show up the counter
                    warningClass: 'label label-success',
                    limitReachedClass: 'label label-important label-danger',
                    separator: ' / ',
                    preText: '',
                    postText: '',
                    showMaxLength: true,
                    placement: 'bottom',
                    message: null, // an alternative way to provide the message text
                    showCharsTyped: true, // show the number of characters typed and not the number of characters remaining
                    validate: false, // if the browser doesn't support the maxlength attribute, attempt to type more than
                    // the indicated chars, will be prevented.
                    utf8: false, // counts using bytesize rather than length. eg: '£' is counted as 2 characters.
                    appendToParent: false, // append the indicator to the input field's parent instead of body
                    twoCharLinebreak: true,  // count linebreak as 2 characters to match IE/Chrome textarea validation. As well as DB storage.
                    allowOverMax: false  // false = use maxlength attribute and browswer functionality.
                    // true = removes maxlength attribute and replaces with 'data-bs-mxl'.
                    // Form submit validation is handled on your own.  when maxlength has been exceeded 'overmax' class added to element
                };

            if ($.isFunction(options) && !callback) {
                callback = options;
                options = {};
            }
            options = $.extend(defaults, options);

            /**
             * Return the length of the specified input.
             *
             * @param input
             * @return {number}
             */
            function inputLength(input) {
                var text = input.val();

                if (options.twoCharLinebreak) {
                    // Count all line breaks as 2 characters
                    text = text.replace(/\r(?!\n)|\n(?!\r)/g, '\r\n');
                } else {
                    // Remove all double-character (\r\n) linebreaks, so they're counted only once.
                    text = text.replace(new RegExp('\r?\n', 'g'), '\n');
                }

                var currentLength = 0;

                if (options.utf8) {
                    currentLength = utf8Length(text);
                } else {
                    currentLength = text.length;
                }
                return currentLength;
            }

            /**
             * Truncate the text of the specified input.
             *
             * @param input
             * @param limit
             */
            function truncateChars(input, maxlength) {
                var text = input.val();
                var newlines = 0;

                if (options.twoCharLinebreak) {
                    text = text.replace(/\r(?!\n)|\n(?!\r)/g, '\r\n');

                    if (text.substr(text.length - 1) === '\n' && text.length % 2 === 1) {
                        newlines = 1;
                    }
                }

                input.val(text.substr(0, maxlength - newlines));
            }

            /**
             * Return the length of the specified input in UTF8 encoding.
             *
             * @param input
             * @return {number}
             */
            function utf8Length(string) {
                var utf8length = 0;
                for (var n = 0; n < string.length; n++) {
                    var c = string.charCodeAt(n);
                    if (c < 128) {
                        utf8length++;
                    }
                    else if ((c > 127) && (c < 2048)) {
                        utf8length = utf8length + 2;
                    }
                    else {
                        utf8length = utf8length + 3;
                    }
                }
                return utf8length;
            }

            /**
             * Return true if the indicator should be showing up.
             *
             * @param input
             * @param thereshold
             * @param maxlength
             * @return {number}
             */
            function charsLeftThreshold(input, thereshold, maxlength) {
                var output = true;
                if (!options.alwaysShow && (maxlength - inputLength(input) > thereshold)) {
                    output = false;
                }
                return output;
            }

            /**
             * Returns how many chars are left to complete the fill up of the form.
             *
             * @param input
             * @param maxlength
             * @return {number}
             */
            function remainingChars(input, maxlength) {
                var length = maxlength - inputLength(input);
                return length;
            }

            /**
             * When called displays the indicator.
             *
             * @param indicator
             */
            function showRemaining(currentInput, indicator) {
                indicator.css({
                    display: 'block'
                });
                currentInput.trigger('maxlength.shown');
            }

            /**
             * When called shows the indicator.
             *
             * @param indicator
             */
            function hideRemaining(currentInput, indicator) {
                indicator.css({
                    display: 'none'
                });
                currentInput.trigger('maxlength.hidden');
            }

            /**
             * This function updates the value in the indicator
             *
             * @param maxLengthThisInput
             * @param typedChars
             * @return String
             */
            function updateMaxLengthHTML(currentInputText, maxLengthThisInput, typedChars) {
                var output = '';
                if (options.message) {
                    if (typeof options.message === 'function') {
                        output = options.message(currentInputText, maxLengthThisInput);
                    } else {
                        output = options.message.replace('%charsTyped%', typedChars)
                            .replace('%charsRemaining%', maxLengthThisInput - typedChars)
                            .replace('%charsTotal%', maxLengthThisInput);
                    }
                } else {
                    if (options.preText) {
                        output += options.preText;
                    }
                    if (!options.showCharsTyped) {
                        output += maxLengthThisInput - typedChars;
                    }
                    else {
                        output += typedChars;
                    }
                    if (options.showMaxLength) {
                        output += options.separator + maxLengthThisInput;
                    }
                    if (options.postText) {
                        output += options.postText;
                    }
                }
                return output;
            }

            /**
             * This function updates the value of the counter in the indicator.
             * Wants as parameters: the number of remaining chars, the element currently managed,
             * the maxLength for the current input and the indicator generated for it.
             *
             * @param remaining
             * @param currentInput
             * @param maxLengthCurrentInput
             * @param maxLengthIndicator
             */
            function manageRemainingVisibility(remaining, currentInput, maxLengthCurrentInput, maxLengthIndicator) {
                if (maxLengthIndicator) {
                    maxLengthIndicator.html(updateMaxLengthHTML(currentInput.val(), maxLengthCurrentInput, (maxLengthCurrentInput - remaining)));

                    if (remaining > 0) {
                        if (charsLeftThreshold(currentInput, options.threshold, maxLengthCurrentInput)) {
                            showRemaining(currentInput, maxLengthIndicator.removeClass(options.limitReachedClass).addClass(options.warningClass));
                        } else {
                            hideRemaining(currentInput, maxLengthIndicator);
                        }
                    } else {
                        showRemaining(currentInput, maxLengthIndicator.removeClass(options.warningClass).addClass(options.limitReachedClass));
                    }
                }

                if (options.allowOverMax) {
                    // class to use for form validation on custom maxlength attribute
                    if (remaining < 0) {
                        currentInput.addClass('overmax');
                    } else {
                        currentInput.removeClass('overmax');
                    }
                }
            }

            /**
             * This function returns an object containing all the
             * informations about the position of the current input
             *
             * @param currentInput
             * @return object {bottom height left right top width}
             *
             */
            function getPosition(currentInput) {
                var el = currentInput[0];
                return $.extend({}, (typeof el.getBoundingClientRect === 'function') ? el.getBoundingClientRect() : {
                    width: el.offsetWidth,
                    height: el.offsetHeight
                }, currentInput.offset());
            }

            /**
             * This function places the maxLengthIndicator at the
             * top / bottom / left / right of the currentInput
             *
             * @param currentInput
             * @param maxLengthIndicator
             * @return null
             *
             */
            function place(currentInput, maxLengthIndicator) {
                var pos = getPosition(currentInput);

                // Supports custom placement handler
                if ($.type(options.placement) === 'function') {
                    options.placement(currentInput, maxLengthIndicator, pos);
                    return;
                }

                // Supports custom placement via css positional properties
                if ($.isPlainObject(options.placement)) {
                    placeWithCSS(options.placement, maxLengthIndicator);
                    return;
                }

                var inputOuter = currentInput.outerWidth(),
                    outerWidth = maxLengthIndicator.outerWidth(),
                    actualWidth = maxLengthIndicator.width(),
                    actualHeight = maxLengthIndicator.height();

                // get the right position if the indicator is appended to the input's parent
                if (options.appendToParent) {
                    pos.top -= currentInput.parent().offset().top;
                    pos.left -= currentInput.parent().offset().left;
                }

                switch (options.placement) {
                    case 'bottom':
                        maxLengthIndicator.css({
                            top: pos.top + pos.height,
                            left: pos.left + pos.width / 2 - actualWidth / 2
                        });
                        break;
                    case 'top':
                        maxLengthIndicator.css({
                            top: pos.top - actualHeight,
                            left: pos.left + pos.width / 2 - actualWidth / 2
                        });
                        break;
                    case 'left':
                        maxLengthIndicator.css({
                            top: pos.top + pos.height / 2 - actualHeight / 2,
                            left: pos.left - actualWidth
                        });
                        break;
                    case 'right':
                        maxLengthIndicator.css({
                            top: pos.top + pos.height / 2 - actualHeight / 2,
                            left: pos.left + pos.width
                        });
                        break;
                    case 'bottom-right':
                        maxLengthIndicator.css({top: pos.top + pos.height, left: pos.left + pos.width});
                        break;
                    case 'top-right':
                        maxLengthIndicator.css({top: pos.top - actualHeight, left: pos.left + inputOuter});
                        break;
                    case 'top-left':
                        maxLengthIndicator.css({top: pos.top - actualHeight, left: pos.left - outerWidth});
                        break;
                    case 'bottom-left':
                        maxLengthIndicator.css({
                            top: pos.top + currentInput.outerHeight(),
                            left: pos.left - outerWidth
                        });
                        break;
                    case 'centered-right':
                        maxLengthIndicator.css({
                            top: pos.top + (actualHeight / 2),
                            left: pos.left + inputOuter - outerWidth - 3
                        });
                        break;

                    // Some more options for placements
                    case 'bottom-right-inside':
                        maxLengthIndicator.css({top: pos.top + pos.height, left: pos.left + pos.width - outerWidth});
                        break;
                    case 'top-right-inside':
                        maxLengthIndicator.css({top: pos.top - actualHeight, left: pos.left + inputOuter - outerWidth});
                        break;
                    case 'top-left-inside':
                        maxLengthIndicator.css({top: pos.top - actualHeight, left: pos.left});
                        break;
                    case 'bottom-left-inside':
                        maxLengthIndicator.css({top: pos.top + currentInput.outerHeight(), left: pos.left});
                        break;
                }
            }

            /**
             * This function places the maxLengthIndicator based on placement config object.
             *
             * @param {object} placement
             * @param {$} maxLengthIndicator
             * @return null
             *
             */
            function placeWithCSS(placement, maxLengthIndicator) {
                if (!placement || !maxLengthIndicator) {
                    return;
                }

                var POSITION_KEYS = [
                    'top',
                    'bottom',
                    'left',
                    'right',
                    'position'
                ];

                var cssPos = {};

                // filter css properties to position
                $.each(POSITION_KEYS, function (i, key) {
                    var val = options.placement[key];
                    if (typeof val !== 'undefined') {
                        cssPos[key] = val;
                    }
                });

                maxLengthIndicator.css(cssPos);

                return;
            }

            /**
             * This function retrieves the maximum length of currentInput
             *
             * @param currentInput
             * @return {number}
             *
             */
            function getMaxLength(currentInput) {
                var attr = 'maxlength';
                if (options.allowOverMax) {
                    attr = 'data-bs-mxl';
                }
                return currentInput.attr(attr) || currentInput.attr('size');
            }

            return this.each(function () {

                var currentInput = $(this),
                    maxLengthCurrentInput,
                    maxLengthIndicator;

                $(window).resize(function () {
                    if (maxLengthIndicator) {
                        place(currentInput, maxLengthIndicator);
                    }
                });

                if (options.allowOverMax) {
                    $(this).attr('data-bs-mxl', $(this).attr('maxlength'));
                    $(this).removeAttr('maxlength');
                }

                function firstInit() {
                    var maxlengthContent = updateMaxLengthHTML(currentInput.val(), maxLengthCurrentInput, '0');
                    maxLengthCurrentInput = getMaxLength(currentInput);

                    if (!maxLengthIndicator) {
                        maxLengthIndicator = $('<span class="bootstrap-maxlength"></span>').css({
                            display: 'none',
                            position: 'absolute',
                            whiteSpace: 'nowrap',
                            zIndex: 1099
                        }).html(maxlengthContent);
                    }

                    // We need to detect resizes if we are dealing with a textarea:
                    if (currentInput.is('textarea')) {
                        currentInput.data('maxlenghtsizex', currentInput.outerWidth());
                        currentInput.data('maxlenghtsizey', currentInput.outerHeight());

                        currentInput.mouseup(function () {
                            if (currentInput.outerWidth() !== currentInput.data('maxlenghtsizex') || currentInput.outerHeight() !== currentInput.data('maxlenghtsizey')) {
                                place(currentInput, maxLengthIndicator);
                            }

                            currentInput.data('maxlenghtsizex', currentInput.outerWidth());
                            currentInput.data('maxlenghtsizey', currentInput.outerHeight());
                        });
                    }

                    if (options.appendToParent) {
                        currentInput.parent().append(maxLengthIndicator);
                        currentInput.parent().css('position', 'relative');
                    } else {
                        documentBody.append(maxLengthIndicator);
                    }

                    var remaining = remainingChars(currentInput, getMaxLength(currentInput));
                    manageRemainingVisibility(remaining, currentInput, maxLengthCurrentInput, maxLengthIndicator);
                    place(currentInput, maxLengthIndicator);
                }

                if (options.showOnReady) {
                    currentInput.ready(function () {
                        firstInit();
                    });
                } else {
                    currentInput.focus(function () {
                        firstInit();
                    });
                }

                currentInput.on('maxlength.reposition', function () {
                    place(currentInput, maxLengthIndicator);
                });


                currentInput.on('destroyed', function () {
                    if (maxLengthIndicator) {
                        maxLengthIndicator.remove();
                    }
                });

                currentInput.on('blur', function () {
                    if (maxLengthIndicator && !options.showOnReady) {
                        maxLengthIndicator.remove();
                    }
                });

                currentInput.on('input', function () {
                    var maxlength = getMaxLength(currentInput),
                        remaining = remainingChars(currentInput, maxlength),
                        output = true;

                    if (options.validate && remaining < 0) {
                        truncateChars(currentInput, maxlength);
                        output = false;
                    } else {
                        manageRemainingVisibility(remaining, currentInput, maxLengthCurrentInput, maxLengthIndicator);
                    }

                    //reposition the indicator if placement "bottom-right-inside" & "top-right-inside" is used
                    if (options.placement === 'bottom-right-inside' || options.placement === 'top-right-inside') {
                        place(currentInput, maxLengthIndicator);
                    }

                    return output;
                });
            });
        }
    });
}(jQuery));

+function (a) {
    "use strict";

    function c(c) {
        return this.each(function () {
            var d = a(this), e = d.data("multiselectsplitter"), f = "object" == typeof c && c;
            (e || "destroy" != c) && (e || d.data("multiselectsplitter", e = new b(this, f)), "string" == typeof c && e[c]())
        })
    }

    var b = function (a, b) {
        this.init("multiselectsplitter", a, b)
    };
    b.DEFAULTS = {
        selectSize: null,
        maxSelectSize: null,
        clearOnFirstChange: !1,
        onlySameGroup: !1,
        groupCounter: !1,
        maximumSelected: null,
        afterInitialize: null,
        maximumAlert: function (a) {
            alert("Only " + a + " values can be selected")
        },
        createFirstSelect: function (a, b) {
            return "<option>" + a + "</option>"
        },
        createSecondSelect: function (a, b) {
            return "<option>" + a + "</option>"
        },
        template: '<div class="row" data-multiselectsplitter-wrapper-selector><div class="col-xs-6 col-sm-6"><select class="form-control" data-multiselectsplitter-firstselect-selector></select></div> <!-- Add the extra clearfix for only the required viewport --><div class="col-xs-6 col-sm-6"><select class="form-control" data-multiselectsplitter-secondselect-selector></select></div></div>'
    }, b.prototype.init = function (c, d, e) {
        var f = this;
        f.type = c, f.last$ElementSelected = [], f.initialized = !1, f.$element = a(d), f.$element.hide(), f.options = a.extend({}, b.DEFAULTS, e), f.$element.after(f.options.template), f.$wrapper = f.$element.next("div[data-multiselectsplitter-wrapper-selector]"), f.$firstSelect = a("select[data-multiselectsplitter-firstselect-selector]", f.$wrapper), f.$secondSelect = a("select[data-multiselectsplitter-secondselect-selector]", f.$wrapper);
        var g = 0, h = 0;
        if (0 != f.$element.find("optgroup").length) {
            f.$element.find("optgroup").each(function () {
                var b = a(this).attr("label"), c = a(f.options.createFirstSelect(b, f.$element));
                c.val(b), c.attr("data-current-label", c.text()), f.$firstSelect.append(c);
                var d = a(this).find("option").length;
                d > h && (h = d), g++
            });
            var i = Math.max(g, h);
            i = Math.min(i, 10), f.options.selectSize ? i = f.options.selectSize : f.options.maxSelectSize && (i = Math.min(i, f.options.maxSelectSize)), f.$firstSelect.attr("size", i), f.$secondSelect.attr("size", i), f.$element.attr("multiple") && f.$secondSelect.attr("multiple", "multiple"), f.$element.is(":disabled") && f.disable(), f.$firstSelect.on("change", a.proxy(f.updateParentCategory, f)), f.$secondSelect.on("click change", a.proxy(f.updateChildCategory, f)), f.update = function () {
                if (!(f.$element.find("option").length < 1)) {
                    var b, a = f.$element.find("option:selected:first");
                    b = a.length ? a.parent().attr("label") : f.$element.find("option:first").parent().attr("label"), f.$firstSelect.find('option[value="' + b + '"]').prop("selected", !0), f.$firstSelect.trigger("change")
                }
            }, f.update(), f.initialized = !0, f.options.afterInitialize && f.options.afterInitialize(f.$firstSelect, f.$secondSelect)
        }
    }, b.prototype.disable = function () {
        this.$secondSelect.prop("disabled", !0), this.$firstSelect.prop("disabled", !0)
    }, b.prototype.enable = function () {
        this.$secondSelect.prop("disabled", !1), this.$firstSelect.prop("disabled", !1)
    }, b.prototype.createSecondSelect = function () {
        var b = this;
        b.$secondSelect.empty(), a.each(b.$element.find('optgroup[label="' + b.$firstSelect.val() + '"] option'), function (c, d) {
            var e = a(this).val(), f = a(this).text(), g = a(b.options.createSecondSelect(f, b.$firstSelect));
            g.val(e), a.each(b.$element.find("option:selected"), function (b, c) {
                a(c).val() == e && g.prop("selected", !0)
            }), b.$secondSelect.append(g)
        })
    }, b.prototype.updateParentCategory = function () {
        var a = this;
        a.last$ElementSelected = a.$element.find("option:selected"), a.options.clearOnFirstChange && a.initialized && a.$element.find("option:selected").prop("selected", !1), a.createSecondSelect(), a.checkSelected(), a.updateCounter()
    }, b.prototype.updateCounter = function () {
        var b = this;
        b.$element.attr("multiple") && b.options.groupCounter && a.each(b.$firstSelect.find("option"), function (c, d) {
            var e = a(d).val(), f = a(d).data("currentLabel"),
                g = b.$element.find('optgroup[label="' + e + '"] option:selected').length;
            g > 0 && (f += " (" + g + ")"), a(d).html(f)
        })
    }, b.prototype.checkSelected = function () {
        var b = this;
        if (b.$element.attr("multiple") && b.options.maximumSelected) {
            var c = 0;
            if (c = "function" == typeof b.options.maximumSelected ? b.options.maximumSelected(b.$firstSelect, b.$secondSelect) : b.options.maximumSelected, !(c < 1)) {
                var d = b.$element.find("option:selected");
                if (d.length > c) {
                    b.$firstSelect.find("option:selected").prop("selected", !1), b.$secondSelect.find("option:selected").prop("selected", !1), b.initialized ? (b.$element.find("option:selected").prop("selected", !1), b.last$ElementSelected.prop("selected", !0)) : a.each(b.$element.find("option:selected"), function (b, d) {
                        b > c - 1 && a(d).prop("selected", !1)
                    });
                    var e = b.last$ElementSelected.first().parent().attr("label");
                    b.$firstSelect.find('option[value="' + e + '"]').prop("selected", !0), b.createSecondSelect(), b.options.maximumAlert(c)
                }
            }
        }
    }, b.prototype.basicUpdateChildCategory = function (b, c) {
        var d = this;
        d.last$ElementSelected = d.$element.find("option:selected");
        var e = d.$secondSelect.val();
        a.isArray(e) || (e = [e]);
        var f = d.$firstSelect.val(), g = !1;
        d.$element.attr("multiple") ? d.options.onlySameGroup ? a.each(d.$element.find("option:selected"), function (b, c) {
            if (a(c).parent().attr("label") != f) return g = !0, !1
        }) : c || (g = !0) : g = !0, g ? d.$element.find("option:selected").prop("selected", !1) : a.each(d.$element.find("option:selected"), function (b, c) {
            f == a(c).parent().attr("label") && a.inArray(a(c).val(), e) == -1 && a(c).prop("selected", !1)
        }), a.each(e, function (a, b) {
            d.$element.find('option[value="' + b + '"]').prop("selected", !0)
        }), d.checkSelected(), d.updateCounter(), d.$element.trigger("change")
    }, b.prototype.updateChildCategory = function (b) {
        "change" == b.type ? this.timeOut = setTimeout(a.proxy(function () {
            this.basicUpdateChildCategory(b, b.ctrlKey)
        }, this), 10) : "click" == b.type && (clearTimeout(this.timeOut), this.basicUpdateChildCategory(b, b.ctrlKey))
    }, b.prototype.destroy = function () {
        this.$wrapper.remove(), this.$element.removeData(this.type), this.$element.show()
    }, a.fn.multiselectsplitter = c, a.fn.multiselectsplitter.Constructor = b, a.fn.multiselectsplitter.VERSION = "1.0.1"
}(jQuery);
/*!
 * Bootstrap-select v1.13.0-beta (https://developer.snapappointments.com/bootstrap-select)
 *
 * Copyright 2012-2018 SnapAppointments, LLC
 * Licensed under MIT (https://github.com/snapappointments/bootstrap-select/blob/master/LICENSE)
 */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module unless amdModuleId is set
        define(["jquery"], function (a0) {
            return (factory(a0));
        });
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(require("jquery"));
    } else {
        factory(root["jQuery"]);
    }
}(this, function (jQuery) {

    (function ($) {
        'use strict';

        var testElement = document.createElement('_');

        testElement.classList.toggle('c3', false);

        // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
        // support the second argument.
        if (testElement.classList.contains('c3')) {
            var _toggle = DOMTokenList.prototype.toggle;

            DOMTokenList.prototype.toggle = function (token, force) {
                if (1 in arguments && !this.contains(token) === !force) {
                    return force;
                } else {
                    return _toggle.call(this, token);
                }
            };
        }

        // shallow array comparison
        function isEqual(array1, array2) {
            return array1.length === array2.length && array1.every(function (element, index) {
                return element === array2[index];
            });
        };

        //<editor-fold desc="Shims">
        if (!String.prototype.startsWith) {
            (function () {
                'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
                var defineProperty = (function () {
                    // IE 8 only supports `Object.defineProperty` on DOM elements
                    try {
                        var object = {};
                        var $defineProperty = Object.defineProperty;
                        var result = $defineProperty(object, object, object) && $defineProperty;
                    } catch (error) {
                    }
                    return result;
                }());
                var toString = {}.toString;
                var startsWith = function (search) {
                    if (this == null) {
                        throw new TypeError();
                    }
                    var string = String(this);
                    if (search && toString.call(search) == '[object RegExp]') {
                        throw new TypeError();
                    }
                    var stringLength = string.length;
                    var searchString = String(search);
                    var searchLength = searchString.length;
                    var position = arguments.length > 1 ? arguments[1] : undefined;
                    // `ToInteger`
                    var pos = position ? Number(position) : 0;
                    if (pos != pos) { // better `isNaN`
                        pos = 0;
                    }
                    var start = Math.min(Math.max(pos, 0), stringLength);
                    // Avoid the `indexOf` call if no match is possible
                    if (searchLength + start > stringLength) {
                        return false;
                    }
                    var index = -1;
                    while (++index < searchLength) {
                        if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
                            return false;
                        }
                    }
                    return true;
                };
                if (defineProperty) {
                    defineProperty(String.prototype, 'startsWith', {
                        'value': startsWith,
                        'configurable': true,
                        'writable': true
                    });
                } else {
                    String.prototype.startsWith = startsWith;
                }
            }());
        }

        if (!Object.keys) {
            Object.keys = function (
                o, // object
                k, // key
                r  // result array
            ) {
                // initialize object and result
                r = [];
                // iterate over object keys
                for (k in o)
                    // fill result array with non-prototypical keys
                    r.hasOwnProperty.call(o, k) && r.push(k);
                // return result
                return r;
            };
        }

        // set data-selected on select element if the value has been programmatically selected
        // prior to initialization of bootstrap-select
        // * consider removing or replacing an alternative method *
        var valHooks = {
            useDefault: false,
            _set: $.valHooks.select.set
        };

        $.valHooks.select.set = function (elem, value) {
            if (value && !valHooks.useDefault) $(elem).data('selected', true);

            return valHooks._set.apply(this, arguments);
        };

        var changed_arguments = null;

        var EventIsSupported = (function () {
            try {
                new Event('change');
                return true;
            } catch (e) {
                return false;
            }
        })();

        $.fn.triggerNative = function (eventName) {
            var el = this[0],
                event;

            if (el.dispatchEvent) { // for modern browsers & IE9+
                if (EventIsSupported) {
                    // For modern browsers
                    event = new Event(eventName, {
                        bubbles: true
                    });
                } else {
                    // For IE since it doesn't support Event constructor
                    event = document.createEvent('Event');
                    event.initEvent(eventName, true, false);
                }

                el.dispatchEvent(event);
            } else if (el.fireEvent) { // for IE8
                event = document.createEventObject();
                event.eventType = eventName;
                el.fireEvent('on' + eventName, event);
            } else {
                // fall back to jQuery.trigger
                this.trigger(eventName);
            }
        };

        //</editor-fold>

        function stringSearch(li, searchString, method, normalize) {
            var stringTypes = [
                    'content',
                    'subtext',
                    'tokens'
                ],
                searchSuccess = false;

            for (var i = 0; i < stringTypes.length; i++) {
                var stringType = stringTypes[i],
                    string = li[stringType];

                if (string) {
                    if (normalize) string = normalizeToBase(string);
                    string = string.toUpperCase();

                    if (method === 'contains') {
                        searchSuccess = string.indexOf(searchString) >= 0;
                    } else {
                        searchSuccess = string.startsWith(searchString);
                    }

                    if (searchSuccess) break;
                }
            }

            return searchSuccess;
        }

        function toInteger(value) {
            return parseInt(value, 10) || 0;
        }

        /**
         * Remove all diatrics from the given text.
         * @access private
         * @param {String} text
         * @returns {String}
         */
        function normalizeToBase(text) {
            var rExps = [
                {re: /[\xC0-\xC6]/g, ch: "A"},
                {re: /[\xE0-\xE6]/g, ch: "a"},
                {re: /[\xC8-\xCB]/g, ch: "E"},
                {re: /[\xE8-\xEB]/g, ch: "e"},
                {re: /[\xCC-\xCF]/g, ch: "I"},
                {re: /[\xEC-\xEF]/g, ch: "i"},
                {re: /[\xD2-\xD6]/g, ch: "O"},
                {re: /[\xF2-\xF6]/g, ch: "o"},
                {re: /[\xD9-\xDC]/g, ch: "U"},
                {re: /[\xF9-\xFC]/g, ch: "u"},
                {re: /[\xC7-\xE7]/g, ch: "c"},
                {re: /[\xD1]/g, ch: "N"},
                {re: /[\xF1]/g, ch: "n"}
            ];
            $.each(rExps, function () {
                text = text ? text.replace(this.re, this.ch) : '';
            });
            return text;
        }


        // List of HTML entities for escaping.
        var escapeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '`': '&#x60;'
        };

        var unescapeMap = {
            '&amp;': '&',
            '&lt;': '<',
            '&gt;': '>',
            '&quot;': '"',
            '&#x27;': "'",
            '&#x60;': '`'
        };

        // Functions for escaping and unescaping strings to/from HTML interpolation.
        var createEscaper = function (map) {
            var escaper = function (match) {
                return map[match];
            };
            // Regexes for identifying a key that needs to be escaped.
            var source = '(?:' + Object.keys(map).join('|') + ')';
            var testRegexp = RegExp(source);
            var replaceRegexp = RegExp(source, 'g');
            return function (string) {
                string = string == null ? '' : '' + string;
                return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
            };
        };

        var htmlEscape = createEscaper(escapeMap);
        var htmlUnescape = createEscaper(unescapeMap);

        /**
         * ------------------------------------------------------------------------
         * Constants
         * ------------------------------------------------------------------------
         */

        var keyCodeMap = {
            32: ' ',
            48: '0',
            49: '1',
            50: '2',
            51: '3',
            52: '4',
            53: '5',
            54: '6',
            55: '7',
            56: '8',
            57: '9',
            59: ';',
            65: 'A',
            66: 'B',
            67: 'C',
            68: 'D',
            69: 'E',
            70: 'F',
            71: 'G',
            72: 'H',
            73: 'I',
            74: 'J',
            75: 'K',
            76: 'L',
            77: 'M',
            78: 'N',
            79: 'O',
            80: 'P',
            81: 'Q',
            82: 'R',
            83: 'S',
            84: 'T',
            85: 'U',
            86: 'V',
            87: 'W',
            88: 'X',
            89: 'Y',
            90: 'Z',
            96: '0',
            97: '1',
            98: '2',
            99: '3',
            100: '4',
            101: '5',
            102: '6',
            103: '7',
            104: '8',
            105: '9'
        };

        var keyCodes = {
            ESCAPE: 27, // KeyboardEvent.which value for Escape (Esc) key
            ENTER: 13, // KeyboardEvent.which value for Enter key
            SPACE: 32, // KeyboardEvent.which value for space key
            TAB: 9, // KeyboardEvent.which value for tab key
            ARROW_UP: 38, // KeyboardEvent.which value for up arrow key
            ARROW_DOWN: 40 // KeyboardEvent.which value for down arrow key
        }

        var version = {};
        version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');
        version.major = version.full[0];

        var classNames = {
            DISABLED: 'disabled',
            DIVIDER: version.major === '4' ? 'dropdown-divider' : 'divider',
            SHOW: version.major === '4' ? 'show' : 'open',
            DROPUP: 'dropup',
            MENURIGHT: 'dropdown-menu-right',
            MENULEFT: 'dropdown-menu-left',
            // to-do: replace with more advanced template/customization options
            BUTTONCLASS: version.major === '4' ? 'btn-light' : 'btn-default'
        }

        var REGEXP_ARROW = new RegExp(keyCodes.ARROW_UP + '|' + keyCodes.ARROW_DOWN);
        var REGEXP_TAB_OR_ESCAPE = new RegExp('^' + keyCodes.TAB + '$|' + keyCodes.ESCAPE);
        var REGEXP_ENTER_OR_SPACE = new RegExp(keyCodes.ENTER + '|' + keyCodes.SPACE);

        var Selectpicker = function (element, options) {
            var that = this;

            // bootstrap-select has been initialized - revert valHooks.select.set back to its original function
            if (!valHooks.useDefault) {
                $.valHooks.select.set = valHooks._set;
                valHooks.useDefault = true;
            }

            this.$element = $(element);
            this.$newElement = null;
            this.$button = null;
            this.$menu = null;
            this.options = options;
            this.selectpicker = {
                main: {
                    // store originalIndex (key) and newIndex (value) in this.selectpicker.main.map.newIndex for fast accessibility
                    // allows us to do this.main.elements[this.selectpicker.main.map.newIndex[index]] to select an element based on the originalIndex
                    map: {
                        newIndex: {},
                        originalIndex: {}
                    }
                },
                current: {
                    map: {}
                }, // current changes if a search is in progress
                search: {
                    map: {}
                },
                view: {},
                keydown: {
                    keyHistory: '',
                    resetKeyHistory: {
                        start: function () {
                            return setTimeout(function () {
                                that.selectpicker.keydown.keyHistory = '';
                            }, 800);
                        }
                    }
                }
            };
            // If we have no title yet, try to pull it from the html title attribute (jQuery doesnt' pick it up as it's not a
            // data-attribute)
            if (this.options.title === null) {
                this.options.title = this.$element.attr('title');
            }

            // Format window padding
            var winPad = this.options.windowPadding;
            if (typeof winPad === 'number') {
                this.options.windowPadding = [winPad, winPad, winPad, winPad];
            }

            //Expose public methods
            this.val = Selectpicker.prototype.val;
            this.render = Selectpicker.prototype.render;
            this.refresh = Selectpicker.prototype.refresh;
            this.setStyle = Selectpicker.prototype.setStyle;
            this.selectAll = Selectpicker.prototype.selectAll;
            this.deselectAll = Selectpicker.prototype.deselectAll;
            this.destroy = Selectpicker.prototype.destroy;
            this.remove = Selectpicker.prototype.remove;
            this.show = Selectpicker.prototype.show;
            this.hide = Selectpicker.prototype.hide;

            this.init();
        };

        Selectpicker.VERSION = '1.13.0-beta';

        // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.
        Selectpicker.DEFAULTS = {
            noneSelectedText: 'Nothing selected',
            noneResultsText: 'No results matched {0}',
            countSelectedText: function (numSelected, numTotal) {
                return (numSelected == 1) ? "{0} item selected" : "{0} items selected";
            },
            maxOptionsText: function (numAll, numGroup) {
                return [
                    (numAll == 1) ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)',
                    (numGroup == 1) ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'
                ];
            },
            selectAllText: 'Select All',
            deselectAllText: 'Deselect All',
            doneButton: false,
            doneButtonText: 'Close',
            multipleSeparator: ', ',
            styleBase: 'btn',
            style: 'btn-default',
            size: 'auto',
            title: null,
            selectedTextFormat: 'values',
            width: false,
            container: false,
            hideDisabled: false,
            showSubtext: false,
            showIcon: true,
            showContent: true,
            dropupAuto: true,
            header: false,
            liveSearch: false,
            liveSearchPlaceholder: null,
            liveSearchNormalize: false,
            liveSearchStyle: 'contains',
            actionsBox: false,
            iconBase: 'glyphicon',
            tickIcon: 'glyphicon-ok',
            showTick: false,
            template: {
                caret: '<span class="caret"></span>'
            },
            maxOptions: false,
            mobile: false,
            selectOnTab: false,
            dropdownAlignRight: false,
            windowPadding: 0,
            virtualScroll: 600
        };

        if (version.major === '4') {
            Selectpicker.DEFAULTS.style = 'btn-light';
            Selectpicker.DEFAULTS.iconBase = '';
            Selectpicker.DEFAULTS.tickIcon = 'bs-ok-default';
        }

        Selectpicker.prototype = {

            constructor: Selectpicker,

            init: function () {
                var that = this,
                    id = this.$element.attr('id');

                this.$element.addClass('bs-select-hidden');

                this.multiple = this.$element.prop('multiple');
                this.autofocus = this.$element.prop('autofocus');
                this.$newElement = this.createDropdown();
                this.createLi();
                this.$element
                    .after(this.$newElement)
                    .prependTo(this.$newElement);
                this.$button = this.$newElement.children('button');
                this.$menu = this.$newElement.children('.dropdown-menu');
                this.$menuInner = this.$menu.children('.inner');
                this.$searchbox = this.$menu.find('input');

                this.$element.removeClass('bs-select-hidden');

                if (this.options.dropdownAlignRight === true) this.$menu.addClass(classNames.MENURIGHT);

                if (typeof id !== 'undefined') {
                    this.$button.attr('data-id', id);
                }

                this.checkDisabled();
                this.clickListener();
                if (this.options.liveSearch) this.liveSearchListener();
                this.render();
                this.setStyle();
                this.setWidth();
                if (this.options.container) {
                    this.selectPosition();
                } else {
                    this.$element.on('hide.bs.select', function () {
                        if (that.isVirtual()) {
                            // empty menu on close
                            var menuInner = that.$menuInner[0],
                                emptyMenu = menuInner.firstChild.cloneNode(false);

                            // replace the existing UL with an empty one - this is faster than $.empty() or innerHTML = ''
                            menuInner.replaceChild(emptyMenu, menuInner.firstChild);
                            menuInner.scrollTop = 0;
                        }
                    });
                }
                this.$menu.data('this', this);
                this.$newElement.data('this', this);
                if (this.options.mobile) this.mobile();

                this.$newElement.on({
                    'hide.bs.dropdown': function (e) {
                        that.$menuInner.attr('aria-expanded', false);
                        that.$element.trigger('hide.bs.select', e);
                    },
                    'hidden.bs.dropdown': function (e) {
                        that.$element.trigger('hidden.bs.select', e);
                    },
                    'show.bs.dropdown': function (e) {
                        that.$menuInner.attr('aria-expanded', true);
                        that.$element.trigger('show.bs.select', e);
                    },
                    'shown.bs.dropdown': function (e) {
                        that.$element.trigger('shown.bs.select', e);
                    }
                });

                if (that.$element[0].hasAttribute('required')) {
                    this.$element.on('invalid', function () {
                        that.$button.addClass('bs-invalid');

                        that.$element.on({
                            'shown.bs.select': function () {
                                that.$element
                                    .val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened
                                    .off('shown.bs.select');
                            },
                            'rendered.bs.select': function () {
                                // if select is no longer invalid, remove the bs-invalid class
                                if (this.validity.valid) that.$button.removeClass('bs-invalid');
                                that.$element.off('rendered.bs.select');
                            }
                        });

                        that.$button.on('blur.bs.select', function () {
                            that.$element.focus().blur();
                            that.$button.off('blur.bs.select');
                        });
                    });
                }

                setTimeout(function () {
                    that.$element.trigger('loaded.bs.select');
                });
            },

            createDropdown: function () {
                // Options
                // If we are multiple or showTick option is set, then add the show-tick class
                var showTick = (this.multiple || this.options.showTick) ? ' show-tick' : '',
                    inputGroup = this.$element.parent().hasClass('input-group') ? ' input-group-btn' : '',
                    autofocus = this.autofocus ? ' autofocus' : '';
                // Elements
                var header = this.options.header ? '<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + '</div>' : '';
                var searchbox = this.options.liveSearch ?
                    '<div class="bs-searchbox">' +
                    '<input type="text" class="form-control" autocomplete="off"' +
                    (null === this.options.liveSearchPlaceholder ? '' : ' placeholder="' + htmlEscape(this.options.liveSearchPlaceholder) + '"') + ' role="textbox" aria-label="Search">' +
                    '</div>'
                    : '';
                var actionsbox = this.multiple && this.options.actionsBox ?
                    '<div class="bs-actionsbox">' +
                    '<div class="btn-group btn-group-sm btn-block">' +
                    '<button type="button" class="actions-btn bs-select-all btn ' + classNames.BUTTONCLASS + '">' +
                    this.options.selectAllText +
                    '</button>' +
                    '<button type="button" class="actions-btn bs-deselect-all btn ' + classNames.BUTTONCLASS + '">' +
                    this.options.deselectAllText +
                    '</button>' +
                    '</div>' +
                    '</div>'
                    : '';
                var donebutton = this.multiple && this.options.doneButton ?
                    '<div class="bs-donebutton">' +
                    '<div class="btn-group btn-block">' +
                    '<button type="button" class="btn btn-sm ' + classNames.BUTTONCLASS + '">' +
                    this.options.doneButtonText +
                    '</button>' +
                    '</div>' +
                    '</div>'
                    : '';
                var drop =
                    '<div class="dropdown bootstrap-select' + showTick + inputGroup + '">' +
                    '<button type="button" class="' + this.options.styleBase + ' dropdown-toggle" data-toggle="dropdown"' + autofocus + ' role="button">' +
                    '<div class="filter-option">' +
                    '<div class="filter-option-inner"></div>' +
                    '</div>&nbsp;' +
                    '<span class="bs-caret">' +
                    this.options.template.caret +
                    '</span>' +
                    '</button>' +
                    '<div class="dropdown-menu ' + (version.major === '4' ? '' : classNames.SHOW) + '" role="combobox">' +
                    header +
                    searchbox +
                    actionsbox +
                    '<div class="inner ' + classNames.SHOW + '" role="listbox" aria-expanded="false" tabindex="-1">' +
                    '<ul class="dropdown-menu inner ' + (version.major === '4' ? classNames.SHOW : '') + '">' +
                    '</ul>' +
                    '</div>' +
                    donebutton +
                    '</div>' +
                    '</div>';

                return $(drop);
            },

            setPositionData: function () {
                this.selectpicker.view.canHighlight = [];

                for (var i = 0; i < this.selectpicker.current.data.length; i++) {
                    var li = this.selectpicker.current.data[i],
                        canHighlight = true;

                    if (li.type === 'divider') {
                        canHighlight = false;
                        li.height = this.sizeInfo.dividerHeight;
                    } else if (li.type === 'optgroup-label') {
                        canHighlight = false;
                        li.height = this.sizeInfo.dropdownHeaderHeight;
                    } else {
                        li.height = this.sizeInfo.liHeight;
                    }

                    if (li.disabled) canHighlight = false;

                    this.selectpicker.view.canHighlight.push(canHighlight);

                    li.position = (i === 0 ? 0 : this.selectpicker.current.data[i - 1].position) + li.height;
                }
            },

            isVirtual: function () {
                return (this.options.virtualScroll !== false) && this.selectpicker.main.elements.length >= this.options.virtualScroll || this.options.virtualScroll === true;
            },

            createView: function (isSearching, scrollTop) {
                scrollTop = scrollTop || 0;

                var that = this;

                this.selectpicker.current = isSearching ? this.selectpicker.search : this.selectpicker.main;

                var $lis;
                var active = [];
                var selected;
                var prevActive;
                var activeIndex;
                var prevActiveIndex;

                this.setPositionData();

                scroll(scrollTop, true);

                this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, updateValue) {
                    if (!that.noScroll) scroll(this.scrollTop, updateValue);
                    that.noScroll = false;
                });

                function scroll(scrollTop, init) {
                    var size = that.selectpicker.current.elements.length,
                        chunks = [],
                        chunkSize,
                        chunkCount,
                        firstChunk,
                        lastChunk,
                        currentChunk = undefined,
                        prevPositions,
                        positionIsDifferent,
                        previousElements,
                        menuIsDifferent = true,
                        isVirtual = that.isVirtual();

                    that.selectpicker.view.scrollTop = scrollTop;

                    if (isVirtual === true) {
                        // if an option that is encountered that is wider than the current menu width, update the menu width accordingly
                        if (that.sizeInfo.hasScrollBar && that.$menu[0].offsetWidth > that.sizeInfo.totalMenuWidth) {
                            that.sizeInfo.menuWidth = that.$menu[0].offsetWidth;
                            that.sizeInfo.totalMenuWidth = that.sizeInfo.menuWidth + that.sizeInfo.scrollBarWidth;
                            that.$menu.css('min-width', that.sizeInfo.menuWidth);
                        }
                    }

                    chunkSize = Math.ceil(that.sizeInfo.menuInnerHeight / that.sizeInfo.liHeight * 1.5); // number of options in a chunk
                    chunkCount = Math.round(size / chunkSize) || 1; // number of chunks

                    for (var i = 0; i < chunkCount; i++) {
                        var end_of_chunk = (i + 1) * chunkSize;

                        if (i === chunkCount - 1) {
                            end_of_chunk = size;
                        }

                        chunks[i] = [
                            (i) * chunkSize + (!i ? 0 : 1),
                            end_of_chunk
                        ];

                        if (!size) break;

                        if (currentChunk === undefined && scrollTop <= that.selectpicker.current.data[end_of_chunk - 1].position - that.sizeInfo.menuInnerHeight) {
                            currentChunk = i;
                        }
                    }

                    if (currentChunk === undefined) currentChunk = 0;

                    prevPositions = [that.selectpicker.view.position0, that.selectpicker.view.position1];

                    // always display previous, current, and next chunks
                    firstChunk = Math.max(0, currentChunk - 1);
                    lastChunk = Math.min(chunkCount - 1, currentChunk + 1);

                    that.selectpicker.view.position0 = Math.max(0, chunks[firstChunk][0]) || 0;
                    that.selectpicker.view.position1 = Math.min(size, chunks[lastChunk][1]) || 0;

                    positionIsDifferent = prevPositions[0] !== that.selectpicker.view.position0 || prevPositions[1] !== that.selectpicker.view.position1;

                    if (that.activeIndex !== undefined) {
                        prevActive = that.selectpicker.current.elements[that.selectpicker.current.map.newIndex[that.prevActiveIndex]];
                        active = that.selectpicker.current.elements[that.selectpicker.current.map.newIndex[that.activeIndex]];
                        selected = that.selectpicker.current.elements[that.selectpicker.current.map.newIndex[that.selectedIndex]];

                        if (init) {
                            if (that.activeIndex !== that.selectedIndex) {
                                active.classList.remove('active');
                                if (active.firstChild) active.firstChild.classList.remove('active');
                            }
                            that.activeIndex = undefined;
                        }

                        if (that.activeIndex && that.activeIndex !== that.selectedIndex && selected && selected.length) {
                            selected.classList.remove('active');
                            if (selected.firstChild) selected.firstChild.classList.remove('active');
                        }
                    }

                    if (that.prevActiveIndex !== undefined && that.prevActiveIndex !== that.activeIndex && that.prevActiveIndex !== that.selectedIndex && prevActive && prevActive.length) {
                        prevActive.classList.remove('active');
                        if (prevActive.firstChild) prevActive.firstChild.classList.remove('active');
                    }

                    if (init || positionIsDifferent) {
                        previousElements = that.selectpicker.view.visibleElements ? that.selectpicker.view.visibleElements.slice() : [];

                        that.selectpicker.view.visibleElements = that.selectpicker.current.elements.slice(that.selectpicker.view.position0, that.selectpicker.view.position1);

                        that.setOptionStatus();

                        // if searching, check to make sure the list has actually been updated before updating DOM
                        // this prevents unnecessary repaints
                        if (isSearching || (isVirtual === false && init)) menuIsDifferent = !isEqual(previousElements, that.selectpicker.view.visibleElements);

                        // if virtual scroll is disabled and not searching,
                        // menu should never need to be updated more than once
                        if ((init || isVirtual === true) && menuIsDifferent) {
                            var menuInner = that.$menuInner[0],
                                menuFragment = document.createDocumentFragment(),
                                emptyMenu = menuInner.firstChild.cloneNode(false),
                                marginTop,
                                marginBottom,
                                elements = isVirtual === true ? that.selectpicker.view.visibleElements : that.selectpicker.current.elements;

                            // replace the existing UL with an empty one - this is faster than $.empty()
                            menuInner.replaceChild(emptyMenu, menuInner.firstChild);

                            for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {
                                menuFragment.appendChild(elements[i]);
                            }

                            if (isVirtual === true) {
                                marginTop = (that.selectpicker.view.position0 === 0 ? 0 : that.selectpicker.current.data[that.selectpicker.view.position0 - 1].position),
                                    marginBottom = (that.selectpicker.view.position1 > size - 1 ? 0 : that.selectpicker.current.data[size - 1].position - that.selectpicker.current.data[that.selectpicker.view.position1 - 1].position);

                                menuInner.firstChild.style.marginTop = marginTop + 'px';
                                menuInner.firstChild.style.marginBottom = marginBottom + 'px';
                            }

                            menuInner.firstChild.appendChild(menuFragment);
                        }
                    }

                    that.prevActiveIndex = that.activeIndex;

                    if (!that.options.liveSearch) {
                        that.$menuInner.focus();
                    } else if (isSearching && init) {
                        var index = 0,
                            newActive;

                        if (!that.selectpicker.view.canHighlight[index]) {
                            index = 1 + that.selectpicker.view.canHighlight.slice(1).indexOf(true);
                        }

                        newActive = that.selectpicker.view.visibleElements[index];

                        if (that.selectpicker.view.currentActive) {
                            that.selectpicker.view.currentActive.classList.remove('active');
                            if (that.selectpicker.view.currentActive.firstChild) that.selectpicker.view.currentActive.firstChild.classList.remove('active');
                        }

                        if (newActive) {
                            newActive.classList.add('active');
                            if (newActive.firstChild) newActive.firstChild.classList.add('active');
                        }

                        that.activeIndex = that.selectpicker.current.map.originalIndex[index];
                    }
                }

                $(window).off('resize.createView').on('resize.createView', function () {
                    scroll(that.$menuInner[0].scrollTop);
                });
            },

            createLi: function () {
                var that = this,
                    mainElements = [],
                    widestOption,
                    availableOptionsCount = 0,
                    widestOptionLength = 0,
                    mainData = [],
                    optID = 0,
                    headerIndex = 0,
                    liIndex = -1; // increment liIndex whenever a new <li> element is created to ensure newIndex is correct

                if (!this.selectpicker.view.titleOption) this.selectpicker.view.titleOption = document.createElement('option');

                var elementTemplates = {
                        span: document.createElement('span'),
                        subtext: document.createElement('small'),
                        a: document.createElement('a'),
                        li: document.createElement('li'),
                        whitespace: document.createTextNode("\u00A0")
                    },
                    checkMark = elementTemplates.span.cloneNode(false),
                    fragment = document.createDocumentFragment();

                checkMark.className = that.options.iconBase + ' ' + that.options.tickIcon + ' check-mark';
                elementTemplates.a.appendChild(checkMark);
                elementTemplates.a.setAttribute('role', 'option');

                elementTemplates.subtext.className = 'text-muted';

                elementTemplates.text = elementTemplates.span.cloneNode(false);
                elementTemplates.text.className = 'text';

                // Helper functions
                /**
                 * @param content
                 * @param [index]
                 * @param [classes]
                 * @param [optgroup]
                 * @returns {HTMLElement}
                 */
                var generateLI = function (content, index, classes, optgroup) {
                    var li = elementTemplates.li.cloneNode(false);

                    if (content) {
                        if (content.nodeType === 1 || content.nodeType === 11) {
                            li.appendChild(content);
                        } else {
                            li.innerHTML = content;
                        }
                    }

                    if (typeof classes !== 'undefined' && '' !== classes) li.className = classes;
                    if (typeof optgroup !== 'undefined' && null !== optgroup) li.classList.add('optgroup-' + optgroup);

                    return li;
                };

                /**
                 * @param text
                 * @param [classes]
                 * @param [inline]
                 * @returns {string}
                 */
                var generateA = function (text, classes, inline) {
                    var a = elementTemplates.a.cloneNode(true);

                    if (text) {
                        if (text.nodeType === 11) {
                            a.appendChild(text);
                        } else {
                            a.insertAdjacentHTML('beforeend', text);
                        }
                    }

                    if (typeof classes !== 'undefined' & '' !== classes) a.className = classes;
                    if (version.major === '4') a.classList.add('dropdown-item');
                    if (inline) a.setAttribute('style', inline);

                    return a;
                };

                var generateText = function (options) {
                    var textElement = elementTemplates.text.cloneNode(false),
                        optionSubtextElement,
                        optionIconElement;

                    if (options.optionContent) {
                        textElement.innerHTML = options.optionContent;
                    } else {
                        textElement.textContent = options.text;

                        if (options.optionIcon) {
                            var whitespace = elementTemplates.whitespace.cloneNode(false);

                            optionIconElement = elementTemplates.span.cloneNode(false);
                            optionIconElement.className = that.options.iconBase + ' ' + options.optionIcon;

                            fragment.appendChild(optionIconElement);
                            fragment.appendChild(whitespace);
                        }

                        if (options.optionSubtext) {
                            optionSubtextElement = elementTemplates.subtext.cloneNode(false);
                            optionSubtextElement.textContent = options.optionSubtext;
                            textElement.appendChild(optionSubtextElement);
                        }
                    }

                    fragment.appendChild(textElement);

                    return fragment;
                };

                var generateLabel = function (options) {
                    var labelTextElement = elementTemplates.text.cloneNode(false),
                        labelSubtextElement,
                        labelIconElement;

                    labelTextElement.textContent = options.labelEscaped;

                    if (options.labelIcon) {
                        var whitespace = elementTemplates.whitespace.cloneNode(false);

                        labelIconElement = elementTemplates.span.cloneNode(false);
                        labelIconElement.className = that.options.iconBase + ' ' + options.labelIcon;

                        fragment.appendChild(labelIconElement);
                        fragment.appendChild(whitespace);
                    }

                    if (options.labelSubtext) {
                        labelSubtextElement = elementTemplates.subtext.cloneNode(false);
                        labelSubtextElement.textContent = options.labelSubtext;
                        labelTextElement.appendChild(labelSubtextElement);
                    }

                    fragment.appendChild(labelTextElement);

                    return fragment;
                }

                if (this.options.title && !this.multiple) {
                    // this option doesn't create a new <li> element, but does add a new option, so liIndex is decreased
                    // since newIndex is recalculated on every refresh, liIndex needs to be decreased even if the titleOption is already appended
                    liIndex--;

                    var element = this.$element[0],
                        isSelected = false;

                    if (!this.selectpicker.view.titleOption.parentNode) {
                        // Use native JS to prepend option (faster)
                        this.selectpicker.view.titleOption.className = 'bs-title-option';
                        this.selectpicker.view.titleOption.innerHTML = this.options.title;
                        this.selectpicker.view.titleOption.value = '';

                        // Check if selected or data-selected attribute is already set on an option. If not, select the titleOption option.
                        // the selected item may have been changed by user or programmatically before the bootstrap select plugin runs,
                        // if so, the select will have the data-selected attribute
                        var $opt = $(element.options[element.selectedIndex]);
                        isSelected = $opt.attr('selected') === undefined && this.$element.data('selected') === undefined;
                    }

                    element.insertBefore(this.selectpicker.view.titleOption, element.firstChild);

                    // Set selected *after* appending to select,
                    // otherwise the option doesn't get selected in IE
                    // set using selectedIndex, as setting the selected attr to true here doesn't work in IE11
                    if (isSelected) element.selectedIndex = 0;
                }

                var $selectOptions = this.$element.find('option');

                $selectOptions.each(function (index) {
                    var $this = $(this);

                    liIndex++;

                    if ($this.hasClass('bs-title-option')) return;

                    var thisData = $this.data();

                    // Get the class and text for the option
                    var optionClass = this.className || '',
                        inline = htmlEscape(this.style.cssText),
                        optionContent = thisData.content,
                        text = this.textContent,
                        tokens = thisData.tokens,
                        subtext = thisData.subtext,
                        icon = thisData.icon,
                        $parent = $this.parent(),
                        parent = $parent[0],
                        isOptgroup = parent.tagName === 'OPTGROUP',
                        isOptgroupDisabled = isOptgroup && parent.disabled,
                        isDisabled = this.disabled || isOptgroupDisabled,
                        prevHiddenIndex,
                        showDivider = this.previousElementSibling && this.previousElementSibling.tagName === 'OPTGROUP',
                        textElement;

                    var parentData = $parent.data();

                    if (thisData.hidden === true || that.options.hideDisabled && (isDisabled && !isOptgroup || isOptgroupDisabled)) {
                        // set prevHiddenIndex - the index of the first hidden option in a group of hidden options
                        // used to determine whether or not a divider should be placed after an optgroup if there are
                        // hidden options between the optgroup and the first visible option
                        prevHiddenIndex = thisData.prevHiddenIndex;
                        $this.next().data('prevHiddenIndex', (prevHiddenIndex !== undefined ? prevHiddenIndex : index));

                        liIndex--;

                        // if previous element is not an optgroup
                        if (!showDivider) {
                            if (prevHiddenIndex !== undefined) {
                                // select the element **before** the first hidden element in the group
                                var prevHidden = $selectOptions[prevHiddenIndex].previousElementSibling;

                                if (prevHidden && prevHidden.tagName === 'OPTGROUP' && !prevHidden.disabled) {
                                    showDivider = true;
                                }
                            }
                        }

                        if (showDivider && mainData[mainData.length - 1].type !== 'divider') {
                            liIndex++;
                            mainElements.push(
                                generateLI(
                                    false,
                                    null,
                                    classNames.DIVIDER,
                                    optID + 'div'
                                )
                            );
                            mainData.push({
                                type: 'divider',
                                optID: optID,
                                originalIndex: index
                            });
                        }

                        return;
                    }

                    if (isOptgroup && thisData.divider !== true) {
                        if (that.options.hideDisabled && isDisabled) {
                            if (parentData.allOptionsDisabled === undefined) {
                                var $options = $parent.children();
                                $parent.data('allOptionsDisabled', $options.filter(':disabled').length === $options.length);
                            }

                            if ($parent.data('allOptionsDisabled')) {
                                liIndex--;
                                return;
                            }
                        }

                        var optGroupClass = ' ' + parent.className || '';

                        if (!this.previousElementSibling) { // Is it the first option of the optgroup?
                            optID += 1;

                            // Get the opt group label
                            var label = parent.label,
                                labelEscaped = htmlEscape(label),
                                labelSubtext = parentData.subtext,
                                labelIcon = parentData.icon;

                            if (index !== 0 && mainElements.length > 0) { // Is it NOT the first option of the select && are there elements in the dropdown?
                                liIndex++;
                                mainElements.push(
                                    generateLI(
                                        false,
                                        null,
                                        classNames.DIVIDER,
                                        optID + 'div'
                                    )
                                );
                                mainData.push({
                                    type: 'divider',
                                    optID: optID,
                                    originalIndex: index
                                });
                            }
                            liIndex++;

                            var labelElement = generateLabel({
                                labelEscaped: labelEscaped,
                                labelSubtext: labelSubtext,
                                labelIcon: labelIcon
                            });

                            mainElements.push(generateLI(labelElement, null, 'dropdown-header' + optGroupClass, optID));
                            mainData.push({
                                content: labelEscaped,
                                subtext: labelSubtext,
                                type: 'optgroup-label',
                                optID: optID,
                                originalIndex: index
                            });

                            headerIndex = liIndex - 1;
                        }

                        if (that.options.hideDisabled && isDisabled || thisData.hidden === true) {
                            liIndex--;
                            return;
                        }

                        textElement = generateText({
                            text: text,
                            optionContent: optionContent,
                            optionSubtext: subtext,
                            optionIcon: icon
                        });

                        mainElements.push(generateLI(generateA(textElement, 'opt ' + optionClass + optGroupClass, inline), index, '', optID));
                        mainData.push({
                            content: text,
                            subtext: subtext,
                            tokens: tokens,
                            type: 'option',
                            optID: optID,
                            headerIndex: headerIndex,
                            lastIndex: headerIndex + parent.childElementCount,
                            originalIndex: index
                        });

                        availableOptionsCount++;
                    } else if (thisData.divider === true) {
                        mainElements.push(generateLI(false, index, 'divider'));
                        mainData.push({
                            type: 'divider',
                            originalIndex: index
                        });
                    } else {
                        // if previous element is not an optgroup and hideDisabled is true
                        if (!showDivider && that.options.hideDisabled) {
                            prevHiddenIndex = thisData.prevHiddenIndex;

                            if (prevHiddenIndex !== undefined) {
                                // select the element **before** the first hidden element in the group
                                var prevHidden = $selectOptions[prevHiddenIndex].previousElementSibling;

                                if (prevHidden && prevHidden.tagName === 'OPTGROUP' && !prevHidden.disabled) {
                                    showDivider = true;
                                }
                            }
                        }

                        if (showDivider && mainData[mainData.length - 1].type !== 'divider') {
                            liIndex++;
                            mainElements.push(
                                generateLI(
                                    false,
                                    null,
                                    classNames.DIVIDER,
                                    optID + 'div'
                                )
                            );
                            mainData.push({
                                type: 'divider',
                                optID: optID,
                                originalIndex: index
                            });
                        }

                        textElement = generateText({
                            text: text,
                            optionContent: optionContent,
                            optionSubtext: subtext,
                            optionIcon: icon
                        });

                        mainElements.push(generateLI(generateA(textElement, optionClass, inline), index));
                        mainData.push({
                            content: text,
                            subtext: subtext,
                            tokens: tokens,
                            type: 'option',
                            originalIndex: index
                        });

                        availableOptionsCount++;
                    }

                    that.selectpicker.main.map.newIndex[index] = liIndex;
                    that.selectpicker.main.map.originalIndex[liIndex] = index;

                    // get the most recent option info added to mainData
                    var _mainDataLast = mainData[mainData.length - 1];

                    _mainDataLast.disabled = isDisabled;

                    var combinedLength = 0;

                    // count the number of characters in the option - not perfect, but should work in most cases
                    if (_mainDataLast.content) combinedLength += _mainDataLast.content.length;
                    if (_mainDataLast.subtext) combinedLength += _mainDataLast.subtext.length;
                    // if there is an icon, ensure this option's width is checked
                    if (icon) combinedLength += 1;

                    if (combinedLength > widestOptionLength) {
                        widestOptionLength = combinedLength;

                        // guess which option is the widest
                        // use this when calculating menu width
                        // not perfect, but it's fast, and the width will be updating accordingly when scrolling
                        widestOption = mainElements[mainElements.length - 1];
                    }
                });

                this.selectpicker.main.elements = mainElements;
                this.selectpicker.main.data = mainData;

                this.selectpicker.current = this.selectpicker.main;

                this.selectpicker.view.widestOption = widestOption;
                this.selectpicker.view.availableOptionsCount = availableOptionsCount; // faster way to get # of available options without filter
            },

            findLis: function () {
                return this.$menuInner.find('.inner > li');
            },

            render: function () {
                var that = this,
                    $selectOptions = this.$element.find('option'),
                    selectedItems = [],
                    selectedItemsInTitle = [];

                this.togglePlaceholder();

                this.tabIndex();

                $selectOptions.each(function (index) {
                    if (this.selected) {
                        selectedItems.push(this);

                        if (selectedItemsInTitle.length < 100 && that.options.selectedTextFormat !== 'count') {
                            if (that.options.hideDisabled && (this.disabled || this.parentNode.tagName === 'OPTGROUP' && this.parentNode.disabled)) return;

                            var $this = $(this),
                                thisData = $this.data(),
                                icon = thisData.icon && that.options.showIcon ? '<i class="' + that.options.iconBase + ' ' + thisData.icon + '"></i> ' : '',
                                subtext,
                                titleItem;

                            if (that.options.showSubtext && thisData.subtext && !that.multiple) {
                                subtext = ' <small class="text-muted">' + thisData.subtext + '</small>';
                            } else {
                                subtext = '';
                            }
                            if (typeof $this.attr('title') !== 'undefined') {
                                titleItem = $this.attr('title');
                            } else if (thisData.content && that.options.showContent) {
                                titleItem = thisData.content.toString();
                            } else {
                                titleItem = icon + $this.html() + subtext;
                            }

                            selectedItemsInTitle.push(titleItem);
                        }
                    }
                });

                //Fixes issue in IE10 occurring when no default option is selected and at least one option is disabled
                //Convert all the values into a comma delimited string
                var title = !this.multiple ? selectedItemsInTitle[0] : selectedItemsInTitle.join(this.options.multipleSeparator);

                // add ellipsis
                if (selectedItems.length > 100) title += '...';

                //If this is multi select, and the selectText type is count, the show 1 of 2 selected etc..
                if (this.multiple && this.options.selectedTextFormat.indexOf('count') > -1) {
                    var max = this.options.selectedTextFormat.split('>');

                    if ((max.length > 1 && selectedItems.length > max[1]) || (max.length === 1 && selectedItems.length >= 2)) {
                        var totalCount = this.selectpicker.view.availableOptionsCount,
                            tr8nText = (typeof this.options.countSelectedText === 'function') ? this.options.countSelectedText(selectedItems.length, totalCount) : this.options.countSelectedText;

                        title = tr8nText.replace('{0}', selectedItems.length.toString()).replace('{1}', totalCount.toString());
                    }
                }

                if (this.options.title == undefined) {
                    this.options.title = this.$element.attr('title');
                }

                if (this.options.selectedTextFormat == 'static') {
                    title = this.options.title;
                }

                //If we dont have a title, then use the default, or if nothing is set at all, use the not selected text
                if (!title) {
                    title = typeof this.options.title !== 'undefined' ? this.options.title : this.options.noneSelectedText;
                }

                //strip all HTML tags and trim the result, then unescape any escaped tags
                this.$button.attr('title', htmlUnescape($.trim(title.replace(/<[^>]*>?/g, ''))));
                this.$button.find('.filter-option-inner').html(title);

                this.$element.trigger('rendered.bs.select');
            },

            /**
             * @param [style]
             * @param [status]
             */
            setStyle: function (style, status) {
                if (this.$element.attr('class')) {
                    this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, ''));
                }

                var buttonClass = style ? style : this.options.style;

                if (status == 'add') {
                    this.$button.addClass(buttonClass);
                } else if (status == 'remove') {
                    this.$button.removeClass(buttonClass);
                } else {
                    this.$button.removeClass(this.options.style);
                    this.$button.addClass(buttonClass);
                }
            },

            liHeight: function (refresh) {
                if (!refresh && (this.options.size === false || this.sizeInfo)) return;

                if (!this.sizeInfo) this.sizeInfo = {};

                var newElement = document.createElement('div'),
                    menu = document.createElement('div'),
                    menuInner = document.createElement('div'),
                    menuInnerInner = document.createElement('ul'),
                    divider = document.createElement('li'),
                    dropdownHeader = document.createElement('li'),
                    li = document.createElement('li'),
                    a = document.createElement('a'),
                    text = document.createElement('span'),
                    header = this.options.header && this.$menu.find('.popover-title').length > 0 ? this.$menu.find('.popover-title')[0].cloneNode(true) : null,
                    search = this.options.liveSearch ? document.createElement('div') : null,
                    actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,
                    doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null;

                this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth;

                text.className = 'text';
                a.className = 'dropdown-item';
                newElement.className = this.$menu[0].parentNode.className + ' ' + classNames.SHOW;
                newElement.style.width = this.sizeInfo.selectWidth + 'px';
                menu.className = 'dropdown-menu ' + classNames.SHOW;
                menuInner.className = 'inner ' + classNames.SHOW;
                menuInnerInner.className = 'dropdown-menu inner ' + (version.major === '4' ? classNames.SHOW : '');
                divider.className = classNames.DIVIDER;
                dropdownHeader.className = 'dropdown-header';

                text.appendChild(document.createTextNode('Inner text'));
                a.appendChild(text);
                li.appendChild(a);
                dropdownHeader.appendChild(text.cloneNode(true));

                if (this.selectpicker.view.widestOption) {
                    menuInnerInner.appendChild(this.selectpicker.view.widestOption.cloneNode(true));
                }

                menuInnerInner.appendChild(li);
                menuInnerInner.appendChild(divider);
                menuInnerInner.appendChild(dropdownHeader);
                if (header) menu.appendChild(header);
                if (search) {
                    var input = document.createElement('input');
                    search.className = 'bs-searchbox';
                    input.className = 'form-control';
                    search.appendChild(input);
                    menu.appendChild(search);
                }
                if (actions) menu.appendChild(actions);
                menuInner.appendChild(menuInnerInner);
                menu.appendChild(menuInner);
                if (doneButton) menu.appendChild(doneButton);
                newElement.appendChild(menu);

                document.body.appendChild(newElement);

                var liHeight = a.offsetHeight,
                    dropdownHeaderHeight = dropdownHeader ? dropdownHeader.offsetHeight : 0,
                    headerHeight = header ? header.offsetHeight : 0,
                    searchHeight = search ? search.offsetHeight : 0,
                    actionsHeight = actions ? actions.offsetHeight : 0,
                    doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,
                    dividerHeight = $(divider).outerHeight(true),
                    // fall back to jQuery if getComputedStyle is not supported
                    menuStyle = window.getComputedStyle ? window.getComputedStyle(menu) : false,
                    menuWidth = menu.offsetWidth,
                    $menu = menuStyle ? null : $(menu),
                    menuPadding = {
                        vert: toInteger(menuStyle ? menuStyle.paddingTop : $menu.css('paddingTop')) +
                        toInteger(menuStyle ? menuStyle.paddingBottom : $menu.css('paddingBottom')) +
                        toInteger(menuStyle ? menuStyle.borderTopWidth : $menu.css('borderTopWidth')) +
                        toInteger(menuStyle ? menuStyle.borderBottomWidth : $menu.css('borderBottomWidth')),
                        horiz: toInteger(menuStyle ? menuStyle.paddingLeft : $menu.css('paddingLeft')) +
                        toInteger(menuStyle ? menuStyle.paddingRight : $menu.css('paddingRight')) +
                        toInteger(menuStyle ? menuStyle.borderLeftWidth : $menu.css('borderLeftWidth')) +
                        toInteger(menuStyle ? menuStyle.borderRightWidth : $menu.css('borderRightWidth'))
                    },
                    menuExtras = {
                        vert: menuPadding.vert +
                        toInteger(menuStyle ? menuStyle.marginTop : $menu.css('marginTop')) +
                        toInteger(menuStyle ? menuStyle.marginBottom : $menu.css('marginBottom')) + 2,
                        horiz: menuPadding.horiz +
                        toInteger(menuStyle ? menuStyle.marginLeft : $menu.css('marginLeft')) +
                        toInteger(menuStyle ? menuStyle.marginRight : $menu.css('marginRight')) + 2
                    },
                    scrollBarWidth;

                menuInner.style.overflowY = 'scroll';

                scrollBarWidth = menu.offsetWidth - menuWidth;

                document.body.removeChild(newElement);

                this.sizeInfo.liHeight = liHeight;
                this.sizeInfo.dropdownHeaderHeight = dropdownHeaderHeight;
                this.sizeInfo.headerHeight = headerHeight;
                this.sizeInfo.searchHeight = searchHeight;
                this.sizeInfo.actionsHeight = actionsHeight;
                this.sizeInfo.doneButtonHeight = doneButtonHeight;
                this.sizeInfo.dividerHeight = dividerHeight;
                this.sizeInfo.menuPadding = menuPadding;
                this.sizeInfo.menuExtras = menuExtras;
                this.sizeInfo.menuWidth = menuWidth;
                this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth;
                this.sizeInfo.scrollBarWidth = scrollBarWidth;
                this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight;

                this.setPositionData();
            },

            getSelectPosition: function () {
                var that = this,
                    $window = $(window),
                    pos = that.$newElement.offset(),
                    $container = $(that.options.container),
                    containerPos;

                if (that.options.container && !$container.is('body')) {
                    containerPos = $container.offset();
                    containerPos.top += parseInt($container.css('borderTopWidth'));
                    containerPos.left += parseInt($container.css('borderLeftWidth'));
                } else {
                    containerPos = {top: 0, left: 0};
                }

                var winPad = that.options.windowPadding;

                this.sizeInfo.selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();
                this.sizeInfo.selectOffsetBot = $window.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo['selectHeight'] - containerPos.top - winPad[2];
                this.sizeInfo.selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();
                this.sizeInfo.selectOffsetRight = $window.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo['selectWidth'] - containerPos.left - winPad[1];
                this.sizeInfo.selectOffsetTop -= winPad[0];
                this.sizeInfo.selectOffsetLeft -= winPad[3];
            },

            setMenuSize: function (isAuto) {
                this.getSelectPosition();

                var selectWidth = this.sizeInfo['selectWidth'],
                    liHeight = this.sizeInfo['liHeight'],
                    headerHeight = this.sizeInfo['headerHeight'],
                    searchHeight = this.sizeInfo['searchHeight'],
                    actionsHeight = this.sizeInfo['actionsHeight'],
                    doneButtonHeight = this.sizeInfo['doneButtonHeight'],
                    divHeight = this.sizeInfo['dividerHeight'],
                    menuPadding = this.sizeInfo['menuPadding'],
                    menuInnerHeight,
                    menuHeight,
                    divLength = 0,
                    minHeight,
                    _minHeight,
                    maxHeight,
                    menuInnerMinHeight,
                    estimate;

                if (this.options.dropupAuto) {
                    // Get the estimated height of the menu without scrollbars.
                    // This is useful for smaller menus, where there might be plenty of room
                    // below the button without setting dropup, but we can't know
                    // the exact height of the menu until createView is called later
                    estimate = liHeight * this.selectpicker.current.elements.length + menuPadding.vert;
                    this.$newElement.toggleClass(classNames.DROPUP, this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && estimate + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot);
                }

                if (this.options.size === 'auto') {
                    _minHeight = this.selectpicker.current.elements.length > 3 ? this.sizeInfo.liHeight * 3 + this.sizeInfo.menuExtras.vert - 2 : 0;
                    menuHeight = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert;
                    minHeight = _minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;
                    menuInnerMinHeight = Math.max(_minHeight - menuPadding.vert, 0);

                    if (this.$newElement.hasClass(classNames.DROPUP)) {
                        menuHeight = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert;
                    }

                    maxHeight = menuHeight;
                    menuInnerHeight = menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert;
                } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {
                    for (var i = 0; i < this.options.size; i++) {
                        if (this.selectpicker.current.data[i].type === 'divider') divLength++;
                    }

                    menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;
                    menuInnerHeight = menuHeight - menuPadding.vert;
                    maxHeight = menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;
                    minHeight = menuInnerMinHeight = '';
                }

                if (this.options.dropdownAlignRight === 'auto') {
                    this.$menu.toggleClass(classNames.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < (this.$menu[0].offsetWidth - selectWidth));
                }

                this.$menu.css({
                    'max-height': maxHeight + 'px',
                    'overflow': 'hidden',
                    'min-height': minHeight + 'px'
                });

                this.$menuInner.css({
                    'max-height': menuInnerHeight + 'px',
                    'overflow-y': 'auto',
                    'min-height': menuInnerMinHeight + 'px'
                });

                this.sizeInfo['menuInnerHeight'] = menuInnerHeight;

                if (this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight) {
                    this.sizeInfo.hasScrollBar = true;
                    this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth;

                    this.$menu.css('min-width', this.sizeInfo.totalMenuWidth);
                }

                if (this.dropdown) this.dropdown._popper.update();
            },

            setSize: function (refresh) {
                this.liHeight(refresh);

                if (this.options.header) this.$menu.css('padding-top', 0);
                if (this.options.size === false) return;

                var that = this,
                    $window = $(window),
                    selectedIndex,
                    offset = 0;

                this.setMenuSize();

                if (this.options.size === 'auto') {
                    this.$searchbox.off('input.setMenuSize propertychange.setMenuSize').on('input.setMenuSize propertychange.setMenuSize', function () {
                        return that.setMenuSize();
                    });
                    $window.off('resize.setMenuSize scroll.setMenuSize').on('resize.setMenuSize scroll.setMenuSize', function () {
                        return that.setMenuSize();
                    });
                } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {
                    this.$searchbox.off('input.setMenuSize propertychange.setMenuSize');
                    $window.off('resize.setMenuSize scroll.setMenuSize');
                }

                if (refresh) {
                    offset = this.$menuInner[0].scrollTop;
                } else if (!that.multiple) {
                    selectedIndex = that.selectpicker.main.map.newIndex[that.$element[0].selectedIndex];

                    if (typeof selectedIndex === 'number' && that.options.size !== false) {
                        offset = that.sizeInfo.liHeight * selectedIndex;
                        offset = offset - (that.sizeInfo.menuInnerHeight / 2) + (that.sizeInfo.liHeight / 2);
                    }
                }

                that.createView(false, offset);
            },

            setWidth: function () {
                var that = this;

                if (this.options.width === 'auto') {
                    requestAnimationFrame(function () {
                        that.$menu.css('min-width', '0');
                        that.liHeight();
                        that.setMenuSize();

                        // Get correct width if element is hidden
                        var $selectClone = that.$newElement.clone().appendTo('body'),
                            btnWidth = $selectClone.css('width', 'auto').children('button').outerWidth();

                        $selectClone.remove();

                        // Set width to whatever's larger, button title or longest option
                        that.sizeInfo.selectWidth = Math.max(that.sizeInfo.totalMenuWidth, btnWidth);
                        that.$newElement.css('width', that.sizeInfo.selectWidth + 'px');
                    });
                } else if (this.options.width === 'fit') {
                    // Remove inline min-width so width can be changed from 'auto'
                    this.$menu.css('min-width', '');
                    this.$newElement.css('width', '').addClass('fit-width');
                } else if (this.options.width) {
                    // Remove inline min-width so width can be changed from 'auto'
                    this.$menu.css('min-width', '');
                    this.$newElement.css('width', this.options.width);
                } else {
                    // Remove inline min-width/width so width can be changed
                    this.$menu.css('min-width', '');
                    this.$newElement.css('width', '');
                }
                // Remove fit-width class if width is changed programmatically
                if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {
                    this.$newElement.removeClass('fit-width');
                }
            },

            selectPosition: function () {
                this.$bsContainer = $('<div class="bs-container" />');

                var that = this,
                    $container = $(this.options.container),
                    pos,
                    containerPos,
                    actualHeight,
                    getPlacement = function ($element) {
                        var containerPosition = {};

                        that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(classNames.DROPUP, $element.hasClass(classNames.DROPUP));
                        pos = $element.offset();

                        if (!$container.is('body')) {
                            containerPos = $container.offset();
                            containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();
                            containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();
                        } else {
                            containerPos = {top: 0, left: 0};
                        }

                        actualHeight = $element.hasClass(classNames.DROPUP) ? 0 : $element[0].offsetHeight;

                        // Bootstrap 4+ uses Popper for menu positioning
                        if (version.major < 4) {
                            containerPosition['top'] = pos.top - containerPos.top + actualHeight;
                            containerPosition['left'] = pos.left - containerPos.left;
                        }

                        containerPosition['width'] = $element[0].offsetWidth;

                        that.$bsContainer.css(containerPosition);
                    };

                this.$button.on('click.bs.dropdown.data-api', function () {
                    if (that.isDisabled()) {
                        return;
                    }

                    getPlacement(that.$newElement);

                    that.$bsContainer
                        .appendTo(that.options.container)
                        .toggleClass(classNames.SHOW, !that.$button.hasClass(classNames.SHOW))
                        .append(that.$menu);
                });

                $(window).on('resize scroll', function () {
                    getPlacement(that.$newElement);
                });

                this.$element.on('hide.bs.select', function () {
                    that.$menu.data('height', that.$menu.height());
                    that.$bsContainer.detach();
                });
            },

            setOptionStatus: function () {
                var that = this,
                    $selectOptions = this.$element.find('option');

                that.noScroll = false;

                if (that.selectpicker.view.visibleElements && that.selectpicker.view.visibleElements.length) {
                    for (var i = 0; i < that.selectpicker.view.visibleElements.length; i++) {
                        var index = that.selectpicker.current.map.originalIndex[i + that.selectpicker.view.position0], // faster than $(li).data('originalIndex')
                            option = $selectOptions[index];

                        if (option) {
                            var liIndex = this.selectpicker.main.map.newIndex[index],
                                li = this.selectpicker.main.elements[liIndex];

                            that.setDisabled(
                                index,
                                option.disabled || option.parentNode.tagName === 'OPTGROUP' && option.parentNode.disabled,
                                liIndex,
                                li
                            );

                            that.setSelected(
                                index,
                                option.selected,
                                liIndex,
                                li
                            );
                        }
                    }
                }
            },

            /**
             * @param {number} index - the index of the option that is being changed
             * @param {boolean} selected - true if the option is being selected, false if being deselected
             */
            setSelected: function (index, selected, liIndex, li) {
                var activeIndexIsSet = this.activeIndex !== undefined,
                    thisIsActive = this.activeIndex === index,
                    prevActiveIndex,
                    prevActive,
                    a,
                    keepActive = thisIsActive || selected && !this.multiple && !activeIndexIsSet;

                if (!liIndex) liIndex = this.selectpicker.main.map.newIndex[index];
                if (!li) li = this.selectpicker.main.elements[liIndex];

                a = li.firstChild;

                if (selected) {
                    this.selectedIndex = index;
                }

                li.classList.toggle('selected', selected);
                li.classList.toggle('active', keepActive);

                if (keepActive) {
                    this.selectpicker.view.currentActive = li;
                    this.activeIndex = index
                }

                if (a) {
                    a.classList.toggle('selected', selected);
                    a.classList.toggle('active', keepActive);
                    a.setAttribute('aria-selected', selected);
                }

                if (!keepActive) {
                    if (!activeIndexIsSet && selected && this.prevActiveIndex) {
                        prevActiveIndex = this.selectpicker.main.map.newIndex[this.prevActiveIndex];
                        prevActive = this.selectpicker.main.elements[prevActiveIndex];

                        prevActive.classList.remove('active');
                        if (prevActive.firstChild) prevActive.firstChild.classList.remove('active');
                    }
                }
            },

            /**
             * @param {number} index - the index of the option that is being disabled
             * @param {boolean} disabled - true if the option is being disabled, false if being enabled
             */
            setDisabled: function (index, disabled, liIndex, li) {
                var a;

                if (!liIndex) liIndex = this.selectpicker.main.map.newIndex[index];
                if (!li) li = this.selectpicker.main.elements[liIndex];

                a = li.firstChild;

                li.classList.toggle(classNames.DISABLED, disabled);

                if (a) {
                    if (version.major === '4') a.classList.toggle(classNames.DISABLED, disabled);

                    a.setAttribute('aria-disabled', disabled);

                    if (disabled) {
                        a.setAttribute('tabindex', -1);
                    } else {
                        a.setAttribute('tabindex', 0);
                    }
                }
            },

            isDisabled: function () {
                return this.$element[0].disabled;
            },

            checkDisabled: function () {
                var that = this;

                if (this.isDisabled()) {
                    this.$newElement.addClass(classNames.DISABLED);
                    this.$button.addClass(classNames.DISABLED).attr('tabindex', -1).attr('aria-disabled', true);
                } else {
                    if (this.$button.hasClass(classNames.DISABLED)) {
                        this.$newElement.removeClass(classNames.DISABLED);
                        this.$button.removeClass(classNames.DISABLED).attr('aria-disabled', false);
                    }

                    if (this.$button.attr('tabindex') == -1 && !this.$element.data('tabindex')) {
                        this.$button.removeAttr('tabindex');
                    }
                }

                this.$button.click(function () {
                    return !that.isDisabled();
                });
            },

            togglePlaceholder: function () {
                // much faster than calling $.val()
                var element = this.$element[0],
                    selectedIndex = element.selectedIndex,
                    nothingSelected = selectedIndex === -1;

                if (!nothingSelected && !element.options[selectedIndex].value) nothingSelected = true;

                this.$button.toggleClass('bs-placeholder', nothingSelected);
            },

            tabIndex: function () {
                if (this.$element.data('tabindex') !== this.$element.attr('tabindex') &&
                    (this.$element.attr('tabindex') !== -98 && this.$element.attr('tabindex') !== '-98')) {
                    this.$element.data('tabindex', this.$element.attr('tabindex'));
                    this.$button.attr('tabindex', this.$element.data('tabindex'));
                }

                this.$element.attr('tabindex', -98);
            },

            clickListener: function () {
                var that = this,
                    $document = $(document);

                $document.data('spaceSelect', false);

                this.$button.on('keyup', function (e) {
                    if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {
                        e.preventDefault();
                        $document.data('spaceSelect', false);
                    }
                });

                this.$newElement.on('show.bs.dropdown', function () {
                    if (version.major > 3 && !that.dropdown) {
                        that.dropdown = that.$button.data('bs.dropdown');
                        that.dropdown._menu = that.$menu[0];
                    }
                });

                this.$button.on('click.bs.dropdown.data-api', function () {
                    if (!that.$newElement.hasClass(classNames.SHOW)) {
                        that.setSize();
                    }
                });

                this.$element.on('shown.bs.select', function () {
                    if (that.$menuInner[0].scrollTop !== that.selectpicker.view.scrollTop) {
                        that.$menuInner[0].scrollTop = that.selectpicker.view.scrollTop;
                    }

                    if (that.options.liveSearch) {
                        that.$searchbox.focus();
                    } else {
                        that.$menuInner.focus();
                    }
                });

                this.$menuInner.on('click', 'li a', function (e, retainActive) {
                    var $this = $(this),
                        position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,
                        clickedIndex = that.selectpicker.current.map.originalIndex[$this.parent().index() + position0],
                        prevValue = that.$element.val(),
                        prevIndex = that.$element.prop('selectedIndex'),
                        triggerChange = true;

                    // Don't close on multi choice menu
                    if (that.multiple && that.options.maxOptions !== 1) {
                        e.stopPropagation();
                    }

                    e.preventDefault();

                    //Don't run if we have been disabled
                    if (!that.isDisabled() && !$this.parent().hasClass(classNames.DISABLED)) {
                        var $options = that.$element.find('option'),
                            $option = $options.eq(clickedIndex),
                            state = $option.prop('selected'),
                            $optgroup = $option.parent('optgroup'),
                            maxOptions = that.options.maxOptions,
                            maxOptionsGrp = $optgroup.data('maxOptions') || false;

                        if (!that.multiple) { // Deselect all others if not multi select box
                            $options.prop('selected', false);
                            $option.prop('selected', true);
                            that.setSelected(clickedIndex, true);
                        } else { // Toggle the one we have chosen if we are multi select.
                            $option.prop('selected', !state);

                            if (clickedIndex === that.activeIndex) retainActive = true;

                            if (!retainActive) {
                                that.prevActiveIndex = that.activeIndex;
                                that.activeIndex = undefined;
                            }

                            that.setSelected(clickedIndex, !state);
                            $this.blur();

                            if (maxOptions !== false || maxOptionsGrp !== false) {
                                var maxReached = maxOptions < $options.filter(':selected').length,
                                    maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length;

                                if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {
                                    if (maxOptions && maxOptions == 1) {
                                        $options.prop('selected', false);
                                        $option.prop('selected', true);
                                        that.$menuInner.find('.selected').removeClass('selected');
                                        that.setSelected(clickedIndex, true);
                                    } else if (maxOptionsGrp && maxOptionsGrp == 1) {
                                        $optgroup.find('option:selected').prop('selected', false);
                                        $option.prop('selected', true);
                                        var optgroupID = that.selectpicker.current.data[$this.parent().index() + that.selectpicker.view.position0].optID;
                                        that.$menuInner.find('.optgroup-' + optgroupID).removeClass('selected');
                                        that.setSelected(clickedIndex, true);
                                    } else {
                                        var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,
                                            maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,
                                            maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),
                                            maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),
                                            $notify = $('<div class="notify"></div>');
                                        // If {var} is set in array, replace it
                                        /** @deprecated */
                                        if (maxOptionsArr[2]) {
                                            maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);
                                            maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);
                                        }

                                        $option.prop('selected', false);

                                        that.$menu.append($notify);

                                        if (maxOptions && maxReached) {
                                            $notify.append($('<div>' + maxTxt + '</div>'));
                                            triggerChange = false;
                                            that.$element.trigger('maxReached.bs.select');
                                        }

                                        if (maxOptionsGrp && maxReachedGrp) {
                                            $notify.append($('<div>' + maxTxtGrp + '</div>'));
                                            triggerChange = false;
                                            that.$element.trigger('maxReachedGrp.bs.select');
                                        }

                                        setTimeout(function () {
                                            that.setSelected(clickedIndex, false);
                                        }, 10);

                                        $notify.delay(750).fadeOut(300, function () {
                                            $(this).remove();
                                        });
                                    }
                                }
                            }
                        }

                        if (!that.multiple || (that.multiple && that.options.maxOptions === 1)) {
                            that.$button.focus();
                        } else if (that.options.liveSearch) {
                            that.$searchbox.focus();
                        }

                        // Trigger select 'change'
                        if (triggerChange) {
                            if ((prevValue != that.$element.val() && that.multiple) || (prevIndex != that.$element.prop('selectedIndex') && !that.multiple)) {
                                // $option.prop('selected') is current option state (selected/unselected). state is previous option state.
                                changed_arguments = [clickedIndex, $option.prop('selected'), state];
                                that.$element
                                    .triggerNative('change');
                            }
                        }
                    }
                });

                this.$menu.on('click', 'li.' + classNames.DISABLED + ' a, .popover-title, .popover-title :not(.close)', function (e) {
                    if (e.currentTarget == this) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (that.options.liveSearch && !$(e.target).hasClass('close')) {
                            that.$searchbox.focus();
                        } else {
                            that.$button.focus();
                        }
                    }
                });

                this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (that.options.liveSearch) {
                        that.$searchbox.focus();
                    } else {
                        that.$button.focus();
                    }
                });

                this.$menu.on('click', '.popover-title .close', function () {
                    that.$button.click();
                });

                this.$searchbox.on('click', function (e) {
                    e.stopPropagation();
                });

                this.$menu.on('click', '.actions-btn', function (e) {
                    if (that.options.liveSearch) {
                        that.$searchbox.focus();
                    } else {
                        that.$button.focus();
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    if ($(this).hasClass('bs-select-all')) {
                        that.selectAll();
                    } else {
                        that.deselectAll();
                    }
                });

                this.$element.on({
                    'change': function () {
                        that.render();
                        that.$element.trigger('changed.bs.select', changed_arguments);
                        changed_arguments = null;
                    },
                    'focus': function () {
                        that.$button.focus();
                    }
                });
            },

            liveSearchListener: function () {
                var that = this,
                    no_results = document.createElement('li');

                this.$button.on('click.bs.dropdown.data-api', function () {
                    if (!!that.$searchbox.val()) {
                        that.$searchbox.val('');
                    }
                });

                this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', function (e) {
                    e.stopPropagation();
                });

                this.$searchbox.on('input propertychange', function () {
                    var searchValue = that.$searchbox.val();

                    that.selectpicker.search.map.newIndex = {};
                    that.selectpicker.search.map.originalIndex = {};
                    that.selectpicker.search.elements = [];
                    that.selectpicker.search.data = [];

                    if (searchValue) {
                        var i,
                            searchMatch = [],
                            q = searchValue.toUpperCase(),
                            cache = {},
                            cacheArr = [],
                            searchStyle = that._searchStyle(),
                            normalizeSearch = that.options.liveSearchNormalize;

                        that._$lisSelected = that.$menuInner.find('.selected');

                        for (var i = 0; i < that.selectpicker.main.data.length; i++) {
                            var li = that.selectpicker.main.data[i];

                            if (!cache[i]) {
                                cache[i] = stringSearch(li, q, searchStyle, normalizeSearch);
                            }

                            if (cache[i] && li.headerIndex !== undefined && cacheArr.indexOf(li.headerIndex) === -1) {
                                if (li.headerIndex > 0) {
                                    cache[li.headerIndex - 1] = true;
                                    cacheArr.push(li.headerIndex - 1);
                                }

                                cache[li.headerIndex] = true;
                                cacheArr.push(li.headerIndex);

                                cache[li.lastIndex + 1] = true;
                            }

                            if (cache[i] && li.type !== 'optgroup-label') cacheArr.push(i);
                        }

                        for (var i = 0, cacheLen = cacheArr.length; i < cacheLen; i++) {
                            var index = cacheArr[i],
                                prevIndex = cacheArr[i - 1],
                                li = that.selectpicker.main.data[index],
                                liPrev = that.selectpicker.main.data[prevIndex];

                            if (li.type !== 'divider' || (li.type === 'divider' && liPrev && liPrev.type !== 'divider' && cacheLen - 1 !== i)) {
                                that.selectpicker.search.data.push(li);
                                searchMatch.push(that.selectpicker.main.elements[index]);
                                that.selectpicker.search.map.newIndex[li.originalIndex] = searchMatch.length - 1;
                                that.selectpicker.search.map.originalIndex[searchMatch.length - 1] = li.originalIndex;
                            }
                        }

                        that.activeIndex = undefined;
                        that.noScroll = true;
                        that.$menuInner.scrollTop(0);
                        that.selectpicker.search.elements = searchMatch;
                        that.createView(true);

                        if (!searchMatch.length) {
                            no_results.className = 'no-results';
                            no_results.innerHTML = that.options.noneResultsText.replace('{0}', '"' + htmlEscape(searchValue) + '"');
                            that.$menuInner[0].firstChild.appendChild(no_results);
                        }
                    } else {
                        that.$menuInner.scrollTop(0);
                        that.createView(false);
                    }
                });
            },

            _searchStyle: function () {
                return this.options.liveSearchStyle || 'contains';
            },

            val: function (value) {
                if (typeof value !== 'undefined') {
                    this.$element
                        .val(value)
                        .triggerNative('change');

                    return this.$element;
                } else {
                    return this.$element.val();
                }
            },

            changeAll: function (status) {
                if (!this.multiple) return;
                if (typeof status === 'undefined') status = true;

                var $selectOptions = this.$element.find('option'),
                    previousSelected = 0,
                    currentSelected = 0;

                for (var i = 0; i < this.selectpicker.current.elements.length; i++) {
                    var index = this.selectpicker.current.map.originalIndex[i], // faster than $(li).data('originalIndex')
                        option = $selectOptions[index];

                    if (option) {
                        if (option.selected) previousSelected++;
                        option.selected = status;
                        if (option.selected) currentSelected++;
                    }
                }

                if (previousSelected === currentSelected) return;

                this.setOptionStatus();

                this.togglePlaceholder();

                this.$element
                    .triggerNative('change');
            },

            selectAll: function () {
                return this.changeAll(true);
            },

            deselectAll: function () {
                return this.changeAll(false);
            },

            toggle: function (e) {
                e = e || window.event;

                if (e) e.stopPropagation();

                this.$button.trigger('click.bs.dropdown.data-api');
            },

            keydown: function (e) {
                var $this = $(this),
                    $parent = $this.is('input') ? $this.parent().parent() : $this.parent(),
                    that = $parent.data('this'),
                    $items = that.findLis(),
                    index,
                    isActive,
                    liActive,
                    activeLi,
                    offset,
                    updateScroll = false,
                    downOnTab = e.which === keyCodes.TAB && !$this.hasClass('dropdown-toggle') && !that.options.selectOnTab,
                    isArrowKey = REGEXP_ARROW.test(e.which) || downOnTab,
                    scrollTop = that.$menuInner[0].scrollTop,
                    isVirtual = that.isVirtual(),
                    position0 = isVirtual === true ? that.selectpicker.view.position0 : 0;

                isActive = that.$newElement.hasClass(classNames.SHOW);

                if (
                    !isActive &&
                    (
                        isArrowKey ||
                        e.which >= 48 && e.which <= 57 ||
                        e.which >= 96 && e.which <= 105 ||
                        e.which >= 65 && e.which <= 90
                    )
                ) {
                    that.$button.trigger('click.bs.dropdown.data-api');
                }

                if (e.which === keyCodes.ESCAPE && isActive) {
                    e.preventDefault();
                    that.$button.trigger('click.bs.dropdown.data-api').focus();
                }

                if (isArrowKey) { // if up or down
                    if (!$items.length) return;

                    // $items.index/.filter is too slow with a large list and no virtual scroll
                    index = isVirtual === true ? $items.index($items.filter('.active')) : that.selectpicker.current.map.newIndex[that.activeIndex];

                    if (index === undefined) index = -1;

                    if (index !== -1) {
                        liActive = that.selectpicker.current.elements[index + position0];
                        liActive.classList.remove('active');
                        if (liActive.firstChild) liActive.firstChild.classList.remove('active');
                    }

                    if (e.which === keyCodes.ARROW_UP) { // up
                        if (index !== -1) index--;
                        if (index + position0 < 0) index += $items.length;

                        if (!that.selectpicker.view.canHighlight[index + position0]) {
                            index = that.selectpicker.view.canHighlight.slice(0, index + position0).lastIndexOf(true) - position0;
                            if (index === -1) index = $items.length - 1;
                        }
                    } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down
                        index++;
                        if (index + position0 >= that.selectpicker.view.canHighlight.length) index = 0;

                        if (!that.selectpicker.view.canHighlight[index + position0]) {
                            index = index + 1 + that.selectpicker.view.canHighlight.slice(index + position0 + 1).indexOf(true);
                        }
                    }

                    e.preventDefault();

                    var liActiveIndex = position0 + index;

                    if (e.which === keyCodes.ARROW_UP) { // up
                        // scroll to bottom and highlight last option
                        if (position0 === 0 && index === $items.length - 1) {
                            that.$menuInner[0].scrollTop = that.$menuInner[0].scrollHeight;

                            liActiveIndex = that.selectpicker.current.elements.length - 1;
                        } else {
                            activeLi = that.selectpicker.current.data[liActiveIndex];
                            offset = activeLi.position - activeLi.height;

                            updateScroll = offset < scrollTop;
                        }
                    } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down
                        // scroll to top and highlight first option
                        if (position0 !== 0 && index === 0) {
                            that.$menuInner[0].scrollTop = 0;

                            liActiveIndex = 0;
                        } else {
                            activeLi = that.selectpicker.current.data[liActiveIndex];
                            offset = activeLi.position - that.sizeInfo.menuInnerHeight;

                            updateScroll = offset > scrollTop;
                        }
                    }

                    liActive = that.selectpicker.current.elements[liActiveIndex];
                    liActive.classList.add('active');
                    if (liActive.firstChild) liActive.firstChild.classList.add('active');
                    that.activeIndex = that.selectpicker.current.map.originalIndex[liActiveIndex];

                    that.selectpicker.view.currentActive = liActive;

                    if (updateScroll) that.$menuInner[0].scrollTop = offset;

                    if (that.options.liveSearch) {
                        that.$searchbox.focus();
                    } else {
                        $this.focus();
                    }
                } else if (
                    !$this.is('input') &&
                    !REGEXP_TAB_OR_ESCAPE.test(e.which) ||
                    (e.which === keyCodes.SPACE && that.selectpicker.keydown.keyHistory)
                ) {
                    var searchMatch,
                        matches = [],
                        keyHistory;

                    e.preventDefault();

                    that.selectpicker.keydown.keyHistory += keyCodeMap[e.which];

                    if (that.selectpicker.keydown.resetKeyHistory.cancel) clearTimeout(that.selectpicker.keydown.resetKeyHistory.cancel);
                    that.selectpicker.keydown.resetKeyHistory.cancel = that.selectpicker.keydown.resetKeyHistory.start();

                    keyHistory = that.selectpicker.keydown.keyHistory;

                    // if all letters are the same, set keyHistory to just the first character when searching
                    if (/^(.)\1+$/.test(keyHistory)) {
                        keyHistory = keyHistory.charAt(0);
                    }

                    // find matches
                    for (var i = 0; i < that.selectpicker.current.data.length; i++) {
                        var li = that.selectpicker.current.data[i],
                            hasMatch;

                        hasMatch = stringSearch(li, keyHistory, 'startsWith', true);

                        if (hasMatch && that.selectpicker.view.canHighlight[i]) {
                            li.index = i;
                            matches.push(li.originalIndex);
                        }
                    }

                    if (matches.length) {
                        var matchIndex = 0;

                        $items.removeClass('active').find('a').removeClass('active');

                        // either only one key has been pressed or they are all the same key
                        if (keyHistory.length === 1) {
                            matchIndex = matches.indexOf(that.activeIndex);

                            if (matchIndex === -1 || matchIndex === matches.length - 1) {
                                matchIndex = 0;
                            } else {
                                matchIndex++;
                            }
                        }

                        searchMatch = that.selectpicker.current.map.newIndex[matches[matchIndex]];

                        activeLi = that.selectpicker.current.data[searchMatch];

                        if (scrollTop - activeLi.position > 0) {
                            offset = activeLi.position - activeLi.height;
                            updateScroll = true;
                        } else {
                            offset = activeLi.position - that.sizeInfo.menuInnerHeight;
                            // if the option is already visible at the current scroll position, just keep it the same
                            updateScroll = activeLi.position > scrollTop + that.sizeInfo.menuInnerHeight;
                        }

                        liActive = that.selectpicker.current.elements[searchMatch];
                        liActive.classList.add('active');
                        if (liActive.firstChild) liActive.firstChild.classList.add('active');
                        that.activeIndex = matches[matchIndex];

                        liActive.firstChild.focus();

                        if (updateScroll) that.$menuInner[0].scrollTop = offset;

                        $this.focus();
                    }
                }

                // Select focused option if "Enter", "Spacebar" or "Tab" (when selectOnTab is true) are pressed inside the menu.
                if (
                    isActive &&
                    (
                        (e.which === keyCodes.SPACE && !that.selectpicker.keydown.keyHistory) ||
                        e.which === keyCodes.ENTER ||
                        (e.which === keyCodes.TAB && that.options.selectOnTab)
                    )
                ) {
                    if (e.which !== keyCodes.SPACE) e.preventDefault();

                    if (!that.options.liveSearch || e.which !== keyCodes.SPACE) {
                        that.$menuInner.find('.active a').trigger('click', true); // retain active class
                        $this.focus();

                        if (!that.options.liveSearch) {
                            // Prevent screen from scrolling if the user hits the spacebar
                            e.preventDefault();
                            // Fixes spacebar selection of dropdown items in FF & IE
                            $(document).data('spaceSelect', true);
                        }
                    }
                }
            },

            mobile: function () {
                this.$element.addClass('mobile-device');
            },

            refresh: function () {
                // update options if data attributes have been changed
                var config = $.extend({}, this.options, this.$element.data());
                this.options = config;

                this.selectpicker.main.map.newIndex = {};
                this.selectpicker.main.map.originalIndex = {};
                this.createLi();
                this.checkDisabled();
                this.render();
                this.setStyle();
                this.setWidth();

                this.setSize(true);

                this.$element.trigger('refreshed.bs.select');
            },

            hide: function () {
                this.$newElement.hide();
            },

            show: function () {
                this.$newElement.show();
            },

            remove: function () {
                this.$newElement.remove();
                this.$element.remove();
            },

            destroy: function () {
                this.$newElement.before(this.$element).remove();

                if (this.$bsContainer) {
                    this.$bsContainer.remove();
                } else {
                    this.$menu.remove();
                }

                this.$element
                    .off('.bs.select')
                    .removeData('selectpicker')
                    .removeClass('bs-select-hidden selectpicker');
            }
        };

        // SELECTPICKER PLUGIN DEFINITION
        // ==============================
        function Plugin(option) {
            // get the args of the outer function..
            var args = arguments;
            // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them
            // to get lost/corrupted in android 2.3 and IE9 #715 #775
            var _option = option;

            [].shift.apply(args);

            var value;
            var chain = this.each(function () {
                var $this = $(this);
                if ($this.is('select')) {
                    var data = $this.data('selectpicker'),
                        options = typeof _option == 'object' && _option;

                    if (!data) {
                        var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, $this.data(), options);
                        config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), $this.data().template, options.template);
                        $this.data('selectpicker', (data = new Selectpicker(this, config)));
                    } else if (options) {
                        for (var i in options) {
                            if (options.hasOwnProperty(i)) {
                                data.options[i] = options[i];
                            }
                        }
                    }

                    if (typeof _option == 'string') {
                        if (data[_option] instanceof Function) {
                            value = data[_option].apply(data, args);
                        } else {
                            value = data.options[_option];
                        }
                    }
                }
            });

            if (typeof value !== 'undefined') {
                //noinspection JSUnusedAssignment
                return value;
            } else {
                return chain;
            }
        }

        var old = $.fn.selectpicker;
        $.fn.selectpicker = Plugin;
        $.fn.selectpicker.Constructor = Selectpicker;

        // SELECTPICKER NO CONFLICT
        // ========================
        $.fn.selectpicker.noConflict = function () {
            $.fn.selectpicker = old;
            return this;
        };

        $(document)
            .off('keydown.bs.dropdown.data-api')
            .on('keydown.bs.select', '.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bs-searchbox input', Selectpicker.prototype.keydown)
            .on('focusin.modal', '.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bs-searchbox input', function (e) {
                e.stopPropagation();
            });

        // SELECTPICKER DATA-API
        // =====================
        $(window).on('load.bs.select.data-api', function () {
            $('.selectpicker').each(function () {
                var $selectpicker = $(this);
                Plugin.call($selectpicker, $selectpicker.data());
            })
        });
    })(jQuery);


}));

/*!
 * typeahead.js 0.11.1
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
 */

(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define("bloodhound", ["jquery"], function (a0) {
            return root["Bloodhound"] = factory(a0);
        });
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"));
    } else {
        root["Bloodhound"] = factory(jQuery);
    }
})(this, function ($) {
    var _ = function () {
        "use strict";
        return {
            isMsie: function () {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
            },
            isBlankString: function (str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function (str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function (obj) {
                return typeof obj === "string";
            },
            isNumber: function (obj) {
                return typeof obj === "number";
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function (obj) {
                return typeof obj === "undefined";
            },
            isElement: function (obj) {
                return !!(obj && obj.nodeType === 1);
            },
            isJQuery: function (obj) {
                return obj instanceof $;
            },
            toStr: function toStr(s) {
                return _.isUndefined(s) || s === null ? "" : s + "";
            },
            bind: $.proxy,
            each: function (collection, cb) {
                $.each(collection, reverseArgs);

                function reverseArgs(index, value) {
                    return cb(value, index);
                }
            },
            map: $.map,
            filter: $.grep,
            every: function (obj, test) {
                var result = true;
                if (!obj) {
                    return result;
                }
                $.each(obj, function (key, val) {
                    if (!(result = test.call(null, val, key, obj))) {
                        return false;
                    }
                });
                return !!result;
            },
            some: function (obj, test) {
                var result = false;
                if (!obj) {
                    return result;
                }
                $.each(obj, function (key, val) {
                    if (result = test.call(null, val, key, obj)) {
                        return false;
                    }
                });
                return !!result;
            },
            mixin: $.extend,
            identity: function (x) {
                return x;
            },
            clone: function (obj) {
                return $.extend(true, {}, obj);
            },
            getIdGenerator: function () {
                var counter = 0;
                return function () {
                    return counter++;
                };
            },
            templatify: function templatify(obj) {
                return $.isFunction(obj) ? obj : template;

                function template() {
                    return String(obj);
                }
            },
            defer: function (fn) {
                setTimeout(fn, 0);
            },
            debounce: function (func, wait, immediate) {
                var timeout, result;
                return function () {
                    var context = this, args = arguments, later, callNow;
                    later = function () {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                };
            },
            throttle: function (func, wait) {
                var context, args, timeout, result, previous, later;
                previous = 0;
                later = function () {
                    previous = new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function () {
                    var now = new Date(), remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            stringify: function (val) {
                return _.isString(val) ? val : JSON.stringify(val);
            },
            noop: function () {
            }
        };
    }();
    var VERSION = "0.11.1";
    var tokenizers = function () {
        "use strict";
        return {
            nonword: nonword,
            whitespace: whitespace,
            obj: {
                nonword: getObjTokenizer(nonword),
                whitespace: getObjTokenizer(whitespace)
            }
        };

        function whitespace(str) {
            str = _.toStr(str);
            return str ? str.split(/\s+/) : [];
        }

        function nonword(str) {
            str = _.toStr(str);
            return str ? str.split(/\W+/) : [];
        }

        function getObjTokenizer(tokenizer) {
            return function setKey(keys) {
                keys = _.isArray(keys) ? keys : [].slice.call(arguments, 0);
                return function tokenize(o) {
                    var tokens = [];
                    _.each(keys, function (k) {
                        tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                    });
                    return tokens;
                };
            };
        }
    }();
    var LruCache = function () {
        "use strict";

        function LruCache(maxSize) {
            this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
            this.reset();
            if (this.maxSize <= 0) {
                this.set = this.get = $.noop;
            }
        }

        _.mixin(LruCache.prototype, {
            set: function set(key, val) {
                var tailItem = this.list.tail, node;
                if (this.size >= this.maxSize) {
                    this.list.remove(tailItem);
                    delete this.hash[tailItem.key];
                    this.size--;
                }
                if (node = this.hash[key]) {
                    node.val = val;
                    this.list.moveToFront(node);
                } else {
                    node = new Node(key, val);
                    this.list.add(node);
                    this.hash[key] = node;
                    this.size++;
                }
            },
            get: function get(key) {
                var node = this.hash[key];
                if (node) {
                    this.list.moveToFront(node);
                    return node.val;
                }
            },
            reset: function reset() {
                this.size = 0;
                this.hash = {};
                this.list = new List();
            }
        });

        function List() {
            this.head = this.tail = null;
        }

        _.mixin(List.prototype, {
            add: function add(node) {
                if (this.head) {
                    node.next = this.head;
                    this.head.prev = node;
                }
                this.head = node;
                this.tail = this.tail || node;
            },
            remove: function remove(node) {
                node.prev ? node.prev.next = node.next : this.head = node.next;
                node.next ? node.next.prev = node.prev : this.tail = node.prev;
            },
            moveToFront: function (node) {
                this.remove(node);
                this.add(node);
            }
        });

        function Node(key, val) {
            this.key = key;
            this.val = val;
            this.prev = this.next = null;
        }

        return LruCache;
    }();
    var PersistentStorage = function () {
        "use strict";
        var LOCAL_STORAGE;
        try {
            LOCAL_STORAGE = window.localStorage;
            LOCAL_STORAGE.setItem("~~~", "!");
            LOCAL_STORAGE.removeItem("~~~");
        } catch (err) {
            LOCAL_STORAGE = null;
        }

        function PersistentStorage(namespace, override) {
            this.prefix = ["__", namespace, "__"].join("");
            this.ttlKey = "__ttl__";
            this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
            this.ls = override || LOCAL_STORAGE;
            !this.ls && this._noop();
        }

        _.mixin(PersistentStorage.prototype, {
            _prefix: function (key) {
                return this.prefix + key;
            },
            _ttlKey: function (key) {
                return this._prefix(key) + this.ttlKey;
            },
            _noop: function () {
                this.get = this.set = this.remove = this.clear = this.isExpired = _.noop;
            },
            _safeSet: function (key, val) {
                try {
                    this.ls.setItem(key, val);
                } catch (err) {
                    if (err.name === "QuotaExceededError") {
                        this.clear();
                        this._noop();
                    }
                }
            },
            get: function (key) {
                if (this.isExpired(key)) {
                    this.remove(key);
                }
                return decode(this.ls.getItem(this._prefix(key)));
            },
            set: function (key, val, ttl) {
                if (_.isNumber(ttl)) {
                    this._safeSet(this._ttlKey(key), encode(now() + ttl));
                } else {
                    this.ls.removeItem(this._ttlKey(key));
                }
                return this._safeSet(this._prefix(key), encode(val));
            },
            remove: function (key) {
                this.ls.removeItem(this._ttlKey(key));
                this.ls.removeItem(this._prefix(key));
                return this;
            },
            clear: function () {
                var i, keys = gatherMatchingKeys(this.keyMatcher);
                for (i = keys.length; i--;) {
                    this.remove(keys[i]);
                }
                return this;
            },
            isExpired: function (key) {
                var ttl = decode(this.ls.getItem(this._ttlKey(key)));
                return _.isNumber(ttl) && now() > ttl ? true : false;
            }
        });
        return PersistentStorage;

        function now() {
            return new Date().getTime();
        }

        function encode(val) {
            return JSON.stringify(_.isUndefined(val) ? null : val);
        }

        function decode(val) {
            return $.parseJSON(val);
        }

        function gatherMatchingKeys(keyMatcher) {
            var i, key, keys = [], len = LOCAL_STORAGE.length;
            for (i = 0; i < len; i++) {
                if ((key = LOCAL_STORAGE.key(i)).match(keyMatcher)) {
                    keys.push(key.replace(keyMatcher, ""));
                }
            }
            return keys;
        }
    }();
    var Transport = function () {
        "use strict";
        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);

        function Transport(o) {
            o = o || {};
            this.cancelled = false;
            this.lastReq = null;
            this._send = o.transport;
            this._get = o.limiter ? o.limiter(this._get) : this._get;
            this._cache = o.cache === false ? new LruCache(0) : sharedCache;
        }

        Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
            maxPendingRequests = num;
        };
        Transport.resetCache = function resetCache() {
            sharedCache.reset();
        };
        _.mixin(Transport.prototype, {
            _fingerprint: function fingerprint(o) {
                o = o || {};
                return o.url + o.type + $.param(o.data || {});
            },
            _get: function (o, cb) {
                var that = this, fingerprint, jqXhr;
                fingerprint = this._fingerprint(o);
                if (this.cancelled || fingerprint !== this.lastReq) {
                    return;
                }
                if (jqXhr = pendingRequests[fingerprint]) {
                    jqXhr.done(done).fail(fail);
                } else if (pendingRequestsCount < maxPendingRequests) {
                    pendingRequestsCount++;
                    pendingRequests[fingerprint] = this._send(o).done(done).fail(fail).always(always);
                } else {
                    this.onDeckRequestArgs = [].slice.call(arguments, 0);
                }

                function done(resp) {
                    cb(null, resp);
                    that._cache.set(fingerprint, resp);
                }

                function fail() {
                    cb(true);
                }

                function always() {
                    pendingRequestsCount--;
                    delete pendingRequests[fingerprint];
                    if (that.onDeckRequestArgs) {
                        that._get.apply(that, that.onDeckRequestArgs);
                        that.onDeckRequestArgs = null;
                    }
                }
            },
            get: function (o, cb) {
                var resp, fingerprint;
                cb = cb || $.noop;
                o = _.isString(o) ? {
                    url: o
                } : o || {};
                fingerprint = this._fingerprint(o);
                this.cancelled = false;
                this.lastReq = fingerprint;
                if (resp = this._cache.get(fingerprint)) {
                    cb(null, resp);
                } else {
                    this._get(o, cb);
                }
            },
            cancel: function () {
                this.cancelled = true;
            }
        });
        return Transport;
    }();
    var SearchIndex = window.SearchIndex = function () {
        "use strict";
        var CHILDREN = "c", IDS = "i";

        function SearchIndex(o) {
            o = o || {};
            if (!o.datumTokenizer || !o.queryTokenizer) {
                $.error("datumTokenizer and queryTokenizer are both required");
            }
            this.identify = o.identify || _.stringify;
            this.datumTokenizer = o.datumTokenizer;
            this.queryTokenizer = o.queryTokenizer;
            this.reset();
        }

        _.mixin(SearchIndex.prototype, {
            bootstrap: function bootstrap(o) {
                this.datums = o.datums;
                this.trie = o.trie;
            },
            add: function (data) {
                var that = this;
                data = _.isArray(data) ? data : [data];
                _.each(data, function (datum) {
                    var id, tokens;
                    that.datums[id = that.identify(datum)] = datum;
                    tokens = normalizeTokens(that.datumTokenizer(datum));
                    _.each(tokens, function (token) {
                        var node, chars, ch;
                        node = that.trie;
                        chars = token.split("");
                        while (ch = chars.shift()) {
                            node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());
                            node[IDS].push(id);
                        }
                    });
                });
            },
            get: function get(ids) {
                var that = this;
                return _.map(ids, function (id) {
                    return that.datums[id];
                });
            },
            search: function search(query) {
                var that = this, tokens, matches;
                tokens = normalizeTokens(this.queryTokenizer(query));
                _.each(tokens, function (token) {
                    var node, chars, ch, ids;
                    if (matches && matches.length === 0) {
                        return false;
                    }
                    node = that.trie;
                    chars = token.split("");
                    while (node && (ch = chars.shift())) {
                        node = node[CHILDREN][ch];
                    }
                    if (node && chars.length === 0) {
                        ids = node[IDS].slice(0);
                        matches = matches ? getIntersection(matches, ids) : ids;
                    } else {
                        matches = [];
                        return false;
                    }
                });
                return matches ? _.map(unique(matches), function (id) {
                    return that.datums[id];
                }) : [];
            },
            all: function all() {
                var values = [];
                for (var key in this.datums) {
                    values.push(this.datums[key]);
                }
                return values;
            },
            reset: function reset() {
                this.datums = {};
                this.trie = newNode();
            },
            serialize: function serialize() {
                return {
                    datums: this.datums,
                    trie: this.trie
                };
            }
        });
        return SearchIndex;

        function normalizeTokens(tokens) {
            tokens = _.filter(tokens, function (token) {
                return !!token;
            });
            tokens = _.map(tokens, function (token) {
                return token.toLowerCase();
            });
            return tokens;
        }

        function newNode() {
            var node = {};
            node[IDS] = [];
            node[CHILDREN] = {};
            return node;
        }

        function unique(array) {
            var seen = {}, uniques = [];
            for (var i = 0, len = array.length; i < len; i++) {
                if (!seen[array[i]]) {
                    seen[array[i]] = true;
                    uniques.push(array[i]);
                }
            }
            return uniques;
        }

        function getIntersection(arrayA, arrayB) {
            var ai = 0, bi = 0, intersection = [];
            arrayA = arrayA.sort();
            arrayB = arrayB.sort();
            var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
            while (ai < lenArrayA && bi < lenArrayB) {
                if (arrayA[ai] < arrayB[bi]) {
                    ai++;
                } else if (arrayA[ai] > arrayB[bi]) {
                    bi++;
                } else {
                    intersection.push(arrayA[ai]);
                    ai++;
                    bi++;
                }
            }
            return intersection;
        }
    }();
    var Prefetch = function () {
        "use strict";
        var keys;
        keys = {
            data: "data",
            protocol: "protocol",
            thumbprint: "thumbprint"
        };

        function Prefetch(o) {
            this.url = o.url;
            this.ttl = o.ttl;
            this.cache = o.cache;
            this.prepare = o.prepare;
            this.transform = o.transform;
            this.transport = o.transport;
            this.thumbprint = o.thumbprint;
            this.storage = new PersistentStorage(o.cacheKey);
        }

        _.mixin(Prefetch.prototype, {
            _settings: function settings() {
                return {
                    url: this.url,
                    type: "GET",
                    dataType: "json"
                };
            },
            store: function store(data) {
                if (!this.cache) {
                    return;
                }
                this.storage.set(keys.data, data, this.ttl);
                this.storage.set(keys.protocol, location.protocol, this.ttl);
                this.storage.set(keys.thumbprint, this.thumbprint, this.ttl);
            },
            fromCache: function fromCache() {
                var stored = {}, isExpired;
                if (!this.cache) {
                    return null;
                }
                stored.data = this.storage.get(keys.data);
                stored.protocol = this.storage.get(keys.protocol);
                stored.thumbprint = this.storage.get(keys.thumbprint);
                isExpired = stored.thumbprint !== this.thumbprint || stored.protocol !== location.protocol;
                return stored.data && !isExpired ? stored.data : null;
            },
            fromNetwork: function (cb) {
                var that = this, settings;
                if (!cb) {
                    return;
                }
                settings = this.prepare(this._settings());
                this.transport(settings).fail(onError).done(onResponse);

                function onError() {
                    cb(true);
                }

                function onResponse(resp) {
                    cb(null, that.transform(resp));
                }
            },
            clear: function clear() {
                this.storage.clear();
                return this;
            }
        });
        return Prefetch;
    }();
    var Remote = function () {
        "use strict";

        function Remote(o) {
            this.url = o.url;
            this.prepare = o.prepare;
            this.transform = o.transform;
            this.transport = new Transport({
                cache: o.cache,
                limiter: o.limiter,
                transport: o.transport
            });
        }

        _.mixin(Remote.prototype, {
            _settings: function settings() {
                return {
                    url: this.url,
                    type: "GET",
                    dataType: "json"
                };
            },
            get: function get(query, cb) {
                var that = this, settings;
                if (!cb) {
                    return;
                }
                query = query || "";
                settings = this.prepare(query, this._settings());
                return this.transport.get(settings, onResponse);

                function onResponse(err, resp) {
                    err ? cb([]) : cb(that.transform(resp));
                }
            },
            cancelLastRequest: function cancelLastRequest() {
                this.transport.cancel();
            }
        });
        return Remote;
    }();
    var oParser = function () {
        "use strict";
        return function parse(o) {
            var defaults, sorter;
            defaults = {
                initialize: true,
                identify: _.stringify,
                datumTokenizer: null,
                queryTokenizer: null,
                sufficient: 5,
                sorter: null,
                local: [],
                prefetch: null,
                remote: null
            };
            o = _.mixin(defaults, o || {});
            !o.datumTokenizer && $.error("datumTokenizer is required");
            !o.queryTokenizer && $.error("queryTokenizer is required");
            sorter = o.sorter;
            o.sorter = sorter ? function (x) {
                return x.sort(sorter);
            } : _.identity;
            o.local = _.isFunction(o.local) ? o.local() : o.local;
            o.prefetch = parsePrefetch(o.prefetch);
            o.remote = parseRemote(o.remote);
            return o;
        };

        function parsePrefetch(o) {
            var defaults;
            if (!o) {
                return null;
            }
            defaults = {
                url: null,
                ttl: 24 * 60 * 60 * 1e3,
                cache: true,
                cacheKey: null,
                thumbprint: "",
                prepare: _.identity,
                transform: _.identity,
                transport: null
            };
            o = _.isString(o) ? {
                url: o
            } : o;
            o = _.mixin(defaults, o);
            !o.url && $.error("prefetch requires url to be set");
            o.transform = o.filter || o.transform;
            o.cacheKey = o.cacheKey || o.url;
            o.thumbprint = VERSION + o.thumbprint;
            o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            return o;
        }

        function parseRemote(o) {
            var defaults;
            if (!o) {
                return;
            }
            defaults = {
                url: null,
                cache: true,
                prepare: null,
                replace: null,
                wildcard: null,
                limiter: null,
                rateLimitBy: "debounce",
                rateLimitWait: 300,
                transform: _.identity,
                transport: null
            };
            o = _.isString(o) ? {
                url: o
            } : o;
            o = _.mixin(defaults, o);
            !o.url && $.error("remote requires url to be set");
            o.transform = o.filter || o.transform;
            o.prepare = toRemotePrepare(o);
            o.limiter = toLimiter(o);
            o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            delete o.replace;
            delete o.wildcard;
            delete o.rateLimitBy;
            delete o.rateLimitWait;
            return o;
        }

        function toRemotePrepare(o) {
            var prepare, replace, wildcard;
            prepare = o.prepare;
            replace = o.replace;
            wildcard = o.wildcard;
            if (prepare) {
                return prepare;
            }
            if (replace) {
                prepare = prepareByReplace;
            } else if (o.wildcard) {
                prepare = prepareByWildcard;
            } else {
                prepare = idenityPrepare;
            }
            return prepare;

            function prepareByReplace(query, settings) {
                settings.url = replace(settings.url, query);
                return settings;
            }

            function prepareByWildcard(query, settings) {
                settings.url = settings.url.replace(wildcard, encodeURIComponent(query));
                return settings;
            }

            function idenityPrepare(query, settings) {
                return settings;
            }
        }

        function toLimiter(o) {
            var limiter, method, wait;
            limiter = o.limiter;
            method = o.rateLimitBy;
            wait = o.rateLimitWait;
            if (!limiter) {
                limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);
            }
            return limiter;

            function debounce(wait) {
                return function debounce(fn) {
                    return _.debounce(fn, wait);
                };
            }

            function throttle(wait) {
                return function throttle(fn) {
                    return _.throttle(fn, wait);
                };
            }
        }

        function callbackToDeferred(fn) {
            return function wrapper(o) {
                var deferred = $.Deferred();
                fn(o, onSuccess, onError);
                return deferred;

                function onSuccess(resp) {
                    _.defer(function () {
                        deferred.resolve(resp);
                    });
                }

                function onError(err) {
                    _.defer(function () {
                        deferred.reject(err);
                    });
                }
            };
        }
    }();
    var Bloodhound = function () {
        "use strict";
        var old;
        old = window && window.Bloodhound;

        function Bloodhound(o) {
            o = oParser(o);
            this.sorter = o.sorter;
            this.identify = o.identify;
            this.sufficient = o.sufficient;
            this.local = o.local;
            this.remote = o.remote ? new Remote(o.remote) : null;
            this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null;
            this.index = new SearchIndex({
                identify: this.identify,
                datumTokenizer: o.datumTokenizer,
                queryTokenizer: o.queryTokenizer
            });
            o.initialize !== false && this.initialize();
        }

        Bloodhound.noConflict = function noConflict() {
            window && (window.Bloodhound = old);
            return Bloodhound;
        };
        Bloodhound.tokenizers = tokenizers;
        _.mixin(Bloodhound.prototype, {
            __ttAdapter: function ttAdapter() {
                var that = this;
                return this.remote ? withAsync : withoutAsync;

                function withAsync(query, sync, async) {
                    return that.search(query, sync, async);
                }

                function withoutAsync(query, sync) {
                    return that.search(query, sync);
                }
            },
            _loadPrefetch: function loadPrefetch() {
                var that = this, deferred, serialized;
                deferred = $.Deferred();
                if (!this.prefetch) {
                    deferred.resolve();
                } else if (serialized = this.prefetch.fromCache()) {
                    this.index.bootstrap(serialized);
                    deferred.resolve();
                } else {
                    this.prefetch.fromNetwork(done);
                }
                return deferred.promise();

                function done(err, data) {
                    if (err) {
                        return deferred.reject();
                    }
                    that.add(data);
                    that.prefetch.store(that.index.serialize());
                    deferred.resolve();
                }
            },
            _initialize: function initialize() {
                var that = this, deferred;
                this.clear();
                (this.initPromise = this._loadPrefetch()).done(addLocalToIndex);
                return this.initPromise;

                function addLocalToIndex() {
                    that.add(that.local);
                }
            },
            initialize: function initialize(force) {
                return !this.initPromise || force ? this._initialize() : this.initPromise;
            },
            add: function add(data) {
                this.index.add(data);
                return this;
            },
            get: function get(ids) {
                ids = _.isArray(ids) ? ids : [].slice.call(arguments);
                return this.index.get(ids);
            },
            search: function search(query, sync, async) {
                var that = this, local;
                local = this.sorter(this.index.search(query));
                sync(this.remote ? local.slice() : local);
                if (this.remote && local.length < this.sufficient) {
                    this.remote.get(query, processRemote);
                } else if (this.remote) {
                    this.remote.cancelLastRequest();
                }
                return this;

                function processRemote(remote) {
                    var nonDuplicates = [];
                    _.each(remote, function (r) {
                        !_.some(local, function (l) {
                            return that.identify(r) === that.identify(l);
                        }) && nonDuplicates.push(r);
                    });
                    async && async(nonDuplicates);
                }
            },
            all: function all() {
                return this.index.all();
            },
            clear: function clear() {
                this.index.reset();
                return this;
            },
            clearPrefetchCache: function clearPrefetchCache() {
                this.prefetch && this.prefetch.clear();
                return this;
            },
            clearRemoteCache: function clearRemoteCache() {
                Transport.resetCache();
                return this;
            },
            ttAdapter: function ttAdapter() {
                return this.__ttAdapter();
            }
        });
        return Bloodhound;
    }();
    return Bloodhound;
});

(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define("typeahead.js", ["jquery"], function (a0) {
            return factory(a0);
        });
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(this, function ($) {
    var _ = function () {
        "use strict";
        return {
            isMsie: function () {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
            },
            isBlankString: function (str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function (str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function (obj) {
                return typeof obj === "string";
            },
            isNumber: function (obj) {
                return typeof obj === "number";
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function (obj) {
                return typeof obj === "undefined";
            },
            isElement: function (obj) {
                return !!(obj && obj.nodeType === 1);
            },
            isJQuery: function (obj) {
                return obj instanceof $;
            },
            toStr: function toStr(s) {
                return _.isUndefined(s) || s === null ? "" : s + "";
            },
            bind: $.proxy,
            each: function (collection, cb) {
                $.each(collection, reverseArgs);

                function reverseArgs(index, value) {
                    return cb(value, index);
                }
            },
            map: $.map,
            filter: $.grep,
            every: function (obj, test) {
                var result = true;
                if (!obj) {
                    return result;
                }
                $.each(obj, function (key, val) {
                    if (!(result = test.call(null, val, key, obj))) {
                        return false;
                    }
                });
                return !!result;
            },
            some: function (obj, test) {
                var result = false;
                if (!obj) {
                    return result;
                }
                $.each(obj, function (key, val) {
                    if (result = test.call(null, val, key, obj)) {
                        return false;
                    }
                });
                return !!result;
            },
            mixin: $.extend,
            identity: function (x) {
                return x;
            },
            clone: function (obj) {
                return $.extend(true, {}, obj);
            },
            getIdGenerator: function () {
                var counter = 0;
                return function () {
                    return counter++;
                };
            },
            templatify: function templatify(obj) {
                return $.isFunction(obj) ? obj : template;

                function template() {
                    return String(obj);
                }
            },
            defer: function (fn) {
                setTimeout(fn, 0);
            },
            debounce: function (func, wait, immediate) {
                var timeout, result;
                return function () {
                    var context = this, args = arguments, later, callNow;
                    later = function () {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                };
            },
            throttle: function (func, wait) {
                var context, args, timeout, result, previous, later;
                previous = 0;
                later = function () {
                    previous = new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function () {
                    var now = new Date(), remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            stringify: function (val) {
                return _.isString(val) ? val : JSON.stringify(val);
            },
            noop: function () {
            }
        };
    }();
    var WWW = function () {
        "use strict";
        var defaultClassNames = {
            wrapper: "twitter-typeahead",
            input: "tt-input",
            hint: "tt-hint",
            menu: "tt-menu",
            dataset: "tt-dataset",
            suggestion: "tt-suggestion",
            selectable: "tt-selectable",
            empty: "tt-empty",
            open: "tt-open",
            cursor: "tt-cursor",
            highlight: "tt-highlight"
        };
        return build;

        function build(o) {
            var www, classes;
            classes = _.mixin({}, defaultClassNames, o);
            www = {
                css: buildCss(),
                classes: classes,
                html: buildHtml(classes),
                selectors: buildSelectors(classes)
            };
            return {
                css: www.css,
                html: www.html,
                classes: www.classes,
                selectors: www.selectors,
                mixin: function (o) {
                    _.mixin(o, www);
                }
            };
        }

        function buildHtml(c) {
            return {
                wrapper: '<span class="' + c.wrapper + '"></span>',
                menu: '<div class="' + c.menu + '"></div>'
            };
        }

        function buildSelectors(classes) {
            var selectors = {};
            _.each(classes, function (v, k) {
                selectors[k] = "." + v;
            });
            return selectors;
        }

        function buildCss() {
            var css = {
                wrapper: {
                    position: "relative",
                    display: "inline-block"
                },
                hint: {
                    position: "absolute",
                    top: "0",
                    left: "0",
                    borderColor: "transparent",
                    boxShadow: "none",
                    opacity: "1"
                },
                input: {
                    position: "relative",
                    verticalAlign: "top",
                    backgroundColor: "transparent"
                },
                inputWithNoHint: {
                    position: "relative",
                    verticalAlign: "top"
                },
                menu: {
                    position: "absolute",
                    top: "100%",
                    left: "0",
                    zIndex: "100",
                    display: "none"
                },
                ltr: {
                    left: "0",
                    right: "auto"
                },
                rtl: {
                    left: "auto",
                    right: " 0"
                }
            };
            if (_.isMsie()) {
                _.mixin(css.input, {
                    backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
                });
            }
            return css;
        }
    }();
    var EventBus = function () {
        "use strict";
        var namespace, deprecationMap;
        namespace = "typeahead:";
        deprecationMap = {
            render: "rendered",
            cursorchange: "cursorchanged",
            select: "selected",
            autocomplete: "autocompleted"
        };

        function EventBus(o) {
            if (!o || !o.el) {
                $.error("EventBus initialized without el");
            }
            this.$el = $(o.el);
        }

        _.mixin(EventBus.prototype, {
            _trigger: function (type, args) {
                var $e;
                $e = $.Event(namespace + type);
                (args = args || []).unshift($e);
                this.$el.trigger.apply(this.$el, args);
                return $e;
            },
            before: function (type) {
                var args, $e;
                args = [].slice.call(arguments, 1);
                $e = this._trigger("before" + type, args);
                return $e.isDefaultPrevented();
            },
            trigger: function (type) {
                var deprecatedType;
                this._trigger(type, [].slice.call(arguments, 1));
                if (deprecatedType = deprecationMap[type]) {
                    this._trigger(deprecatedType, [].slice.call(arguments, 1));
                }
            }
        });
        return EventBus;
    }();
    var EventEmitter = function () {
        "use strict";
        var splitter = /\s+/, nextTick = getNextTick();
        return {
            onSync: onSync,
            onAsync: onAsync,
            off: off,
            trigger: trigger
        };

        function on(method, types, cb, context) {
            var type;
            if (!cb) {
                return this;
            }
            types = types.split(splitter);
            cb = context ? bindContext(cb, context) : cb;
            this._callbacks = this._callbacks || {};
            while (type = types.shift()) {
                this._callbacks[type] = this._callbacks[type] || {
                    sync: [],
                    async: []
                };
                this._callbacks[type][method].push(cb);
            }
            return this;
        }

        function onAsync(types, cb, context) {
            return on.call(this, "async", types, cb, context);
        }

        function onSync(types, cb, context) {
            return on.call(this, "sync", types, cb, context);
        }

        function off(types) {
            var type;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            while (type = types.shift()) {
                delete this._callbacks[type];
            }
            return this;
        }

        function trigger(types) {
            var type, callbacks, args, syncFlush, asyncFlush;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            args = [].slice.call(arguments, 1);
            while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                syncFlush = getFlush(callbacks.sync, this, [type].concat(args));
                asyncFlush = getFlush(callbacks.async, this, [type].concat(args));
                syncFlush() && nextTick(asyncFlush);
            }
            return this;
        }

        function getFlush(callbacks, context, args) {
            return flush;

            function flush() {
                var cancelled;
                for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
                    cancelled = callbacks[i].apply(context, args) === false;
                }
                return !cancelled;
            }
        }

        function getNextTick() {
            var nextTickFn;
            if (window.setImmediate) {
                nextTickFn = function nextTickSetImmediate(fn) {
                    setImmediate(function () {
                        fn();
                    });
                };
            } else {
                nextTickFn = function nextTickSetTimeout(fn) {
                    setTimeout(function () {
                        fn();
                    }, 0);
                };
            }
            return nextTickFn;
        }

        function bindContext(fn, context) {
            return fn.bind ? fn.bind(context) : function () {
                fn.apply(context, [].slice.call(arguments, 0));
            };
        }
    }();
    var highlight = function (doc) {
        "use strict";
        var defaults = {
            node: null,
            pattern: null,
            tagName: "strong",
            className: null,
            wordsOnly: false,
            caseSensitive: false
        };
        return function hightlight(o) {
            var regex;
            o = _.mixin({}, defaults, o);
            if (!o.node || !o.pattern) {
                return;
            }
            o.pattern = _.isArray(o.pattern) ? o.pattern : [o.pattern];
            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
            traverse(o.node, hightlightTextNode);

            function hightlightTextNode(textNode) {
                var match, patternNode, wrapperNode;
                if (match = regex.exec(textNode.data)) {
                    wrapperNode = doc.createElement(o.tagName);
                    o.className && (wrapperNode.className = o.className);
                    patternNode = textNode.splitText(match.index);
                    patternNode.splitText(match[0].length);
                    wrapperNode.appendChild(patternNode.cloneNode(true));
                    textNode.parentNode.replaceChild(wrapperNode, patternNode);
                }
                return !!match;
            }

            function traverse(el, hightlightTextNode) {
                var childNode, TEXT_NODE_TYPE = 3;
                for (var i = 0; i < el.childNodes.length; i++) {
                    childNode = el.childNodes[i];
                    if (childNode.nodeType === TEXT_NODE_TYPE) {
                        i += hightlightTextNode(childNode) ? 1 : 0;
                    } else {
                        traverse(childNode, hightlightTextNode);
                    }
                }
            }
        };

        function getRegex(patterns, caseSensitive, wordsOnly) {
            var escapedPatterns = [], regexStr;
            for (var i = 0, len = patterns.length; i < len; i++) {
                escapedPatterns.push(_.escapeRegExChars(patterns[i]));
            }
            regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
            return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
        }
    }(window.document);
    var Input = function () {
        "use strict";
        var specialKeyCodeMap;
        specialKeyCodeMap = {
            9: "tab",
            27: "esc",
            37: "left",
            39: "right",
            13: "enter",
            38: "up",
            40: "down"
        };

        function Input(o, www) {
            o = o || {};
            if (!o.input) {
                $.error("input is missing");
            }
            www.mixin(this);
            this.$hint = $(o.hint);
            this.$input = $(o.input);
            this.query = this.$input.val();
            this.queryWhenFocused = this.hasFocus() ? this.query : null;
            this.$overflowHelper = buildOverflowHelper(this.$input);
            this._checkLanguageDirection();
            if (this.$hint.length === 0) {
                this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
            }
        }

        Input.normalizeQuery = function (str) {
            return _.toStr(str).replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
        };
        _.mixin(Input.prototype, EventEmitter, {
            _onBlur: function onBlur() {
                this.resetInputValue();
                this.trigger("blurred");
            },
            _onFocus: function onFocus() {
                this.queryWhenFocused = this.query;
                this.trigger("focused");
            },
            _onKeydown: function onKeydown($e) {
                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                this._managePreventDefault(keyName, $e);
                if (keyName && this._shouldTrigger(keyName, $e)) {
                    this.trigger(keyName + "Keyed", $e);
                }
            },
            _onInput: function onInput() {
                this._setQuery(this.getInputValue());
                this.clearHintIfInvalid();
                this._checkLanguageDirection();
            },
            _managePreventDefault: function managePreventDefault(keyName, $e) {
                var preventDefault;
                switch (keyName) {
                    case "up":
                    case "down":
                        preventDefault = !withModifier($e);
                        break;

                    default:
                        preventDefault = false;
                }
                preventDefault && $e.preventDefault();
            },
            _shouldTrigger: function shouldTrigger(keyName, $e) {
                var trigger;
                switch (keyName) {
                    case "tab":
                        trigger = !withModifier($e);
                        break;

                    default:
                        trigger = true;
                }
                return trigger;
            },
            _checkLanguageDirection: function checkLanguageDirection() {
                var dir = (this.$input.css("direction") || "ltr").toLowerCase();
                if (this.dir !== dir) {
                    this.dir = dir;
                    this.$hint.attr("dir", dir);
                    this.trigger("langDirChanged", dir);
                }
            },
            _setQuery: function setQuery(val, silent) {
                var areEquivalent, hasDifferentWhitespace;
                areEquivalent = areQueriesEquivalent(val, this.query);
                hasDifferentWhitespace = areEquivalent ? this.query.length !== val.length : false;
                this.query = val;
                if (!silent && !areEquivalent) {
                    this.trigger("queryChanged", this.query);
                } else if (!silent && hasDifferentWhitespace) {
                    this.trigger("whitespaceChanged", this.query);
                }
            },
            bind: function () {
                var that = this, onBlur, onFocus, onKeydown, onInput;
                onBlur = _.bind(this._onBlur, this);
                onFocus = _.bind(this._onFocus, this);
                onKeydown = _.bind(this._onKeydown, this);
                onInput = _.bind(this._onInput, this);
                this.$input.on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
                if (!_.isMsie() || _.isMsie() > 9) {
                    this.$input.on("input.tt", onInput);
                } else {
                    this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function ($e) {
                        if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                            return;
                        }
                        _.defer(_.bind(that._onInput, that, $e));
                    });
                }
                return this;
            },
            focus: function focus() {
                this.$input.focus();
            },
            blur: function blur() {
                this.$input.blur();
            },
            getLangDir: function getLangDir() {
                return this.dir;
            },
            getQuery: function getQuery() {
                return this.query || "";
            },
            setQuery: function setQuery(val, silent) {
                this.setInputValue(val);
                this._setQuery(val, silent);
            },
            hasQueryChangedSinceLastFocus: function hasQueryChangedSinceLastFocus() {
                return this.query !== this.queryWhenFocused;
            },
            getInputValue: function getInputValue() {
                return this.$input.val();
            },
            setInputValue: function setInputValue(value) {
                this.$input.val(value);
                this.clearHintIfInvalid();
                this._checkLanguageDirection();
            },
            resetInputValue: function resetInputValue() {
                this.setInputValue(this.query);
            },
            getHint: function getHint() {
                return this.$hint.val();
            },
            setHint: function setHint(value) {
                this.$hint.val(value);
            },
            clearHint: function clearHint() {
                this.setHint("");
            },
            clearHintIfInvalid: function clearHintIfInvalid() {
                var val, hint, valIsPrefixOfHint, isValid;
                val = this.getInputValue();
                hint = this.getHint();
                valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
                isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
                !isValid && this.clearHint();
            },
            hasFocus: function hasFocus() {
                return this.$input.is(":focus");
            },
            hasOverflow: function hasOverflow() {
                var constraint = this.$input.width() - 2;
                this.$overflowHelper.text(this.getInputValue());
                return this.$overflowHelper.width() >= constraint;
            },
            isCursorAtEnd: function () {
                var valueLength, selectionStart, range;
                valueLength = this.$input.val().length;
                selectionStart = this.$input[0].selectionStart;
                if (_.isNumber(selectionStart)) {
                    return selectionStart === valueLength;
                } else if (document.selection) {
                    range = document.selection.createRange();
                    range.moveStart("character", -valueLength);
                    return valueLength === range.text.length;
                }
                return true;
            },
            destroy: function destroy() {
                this.$hint.off(".tt");
                this.$input.off(".tt");
                this.$overflowHelper.remove();
                this.$hint = this.$input = this.$overflowHelper = $("<div>");
            }
        });
        return Input;

        function buildOverflowHelper($input) {
            return $('<pre aria-hidden="true"></pre>').css({
                position: "absolute",
                visibility: "hidden",
                whiteSpace: "pre",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }

        function areQueriesEquivalent(a, b) {
            return Input.normalizeQuery(a) === Input.normalizeQuery(b);
        }

        function withModifier($e) {
            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
        }
    }();
    var Dataset = function () {
        "use strict";
        var keys, nameGenerator;
        keys = {
            val: "tt-selectable-display",
            obj: "tt-selectable-object"
        };
        nameGenerator = _.getIdGenerator();

        function Dataset(o, www) {
            o = o || {};
            o.templates = o.templates || {};
            o.templates.notFound = o.templates.notFound || o.templates.empty;
            if (!o.source) {
                $.error("missing source");
            }
            if (!o.node) {
                $.error("missing node");
            }
            if (o.name && !isValidName(o.name)) {
                $.error("invalid dataset name: " + o.name);
            }
            www.mixin(this);
            this.highlight = !!o.highlight;
            this.name = o.name || nameGenerator();
            this.limit = o.limit || 5;
            this.displayFn = getDisplayFn(o.display || o.displayKey);
            this.templates = getTemplates(o.templates, this.displayFn);
            this.source = o.source.__ttAdapter ? o.source.__ttAdapter() : o.source;
            this.async = _.isUndefined(o.async) ? this.source.length > 2 : !!o.async;
            this._resetLastSuggestion();
            this.$el = $(o.node).addClass(this.classes.dataset).addClass(this.classes.dataset + "-" + this.name);
        }

        Dataset.extractData = function extractData(el) {
            var $el = $(el);
            if ($el.data(keys.obj)) {
                return {
                    val: $el.data(keys.val) || "",
                    obj: $el.data(keys.obj) || null
                };
            }
            return null;
        };
        _.mixin(Dataset.prototype, EventEmitter, {
            _overwrite: function overwrite(query, suggestions) {
                suggestions = suggestions || [];
                if (suggestions.length) {
                    this._renderSuggestions(query, suggestions);
                } else if (this.async && this.templates.pending) {
                    this._renderPending(query);
                } else if (!this.async && this.templates.notFound) {
                    this._renderNotFound(query);
                } else {
                    this._empty();
                }
                this.trigger("rendered", this.name, suggestions, false);
            },
            _append: function append(query, suggestions) {
                suggestions = suggestions || [];
                if (suggestions.length && this.$lastSuggestion.length) {
                    this._appendSuggestions(query, suggestions);
                } else if (suggestions.length) {
                    this._renderSuggestions(query, suggestions);
                } else if (!this.$lastSuggestion.length && this.templates.notFound) {
                    this._renderNotFound(query);
                }
                this.trigger("rendered", this.name, suggestions, true);
            },
            _renderSuggestions: function renderSuggestions(query, suggestions) {
                var $fragment;
                $fragment = this._getSuggestionsFragment(query, suggestions);
                this.$lastSuggestion = $fragment.children().last();
                this.$el.html($fragment).prepend(this._getHeader(query, suggestions)).append(this._getFooter(query, suggestions));
            },
            _appendSuggestions: function appendSuggestions(query, suggestions) {
                var $fragment, $lastSuggestion;
                $fragment = this._getSuggestionsFragment(query, suggestions);
                $lastSuggestion = $fragment.children().last();
                this.$lastSuggestion.after($fragment);
                this.$lastSuggestion = $lastSuggestion;
            },
            _renderPending: function renderPending(query) {
                var template = this.templates.pending;
                this._resetLastSuggestion();
                template && this.$el.html(template({
                    query: query,
                    dataset: this.name
                }));
            },
            _renderNotFound: function renderNotFound(query) {
                var template = this.templates.notFound;
                this._resetLastSuggestion();
                template && this.$el.html(template({
                    query: query,
                    dataset: this.name
                }));
            },
            _empty: function empty() {
                this.$el.empty();
                this._resetLastSuggestion();
            },
            _getSuggestionsFragment: function getSuggestionsFragment(query, suggestions) {
                var that = this, fragment;
                fragment = document.createDocumentFragment();
                _.each(suggestions, function getSuggestionNode(suggestion) {
                    var $el, context;
                    context = that._injectQuery(query, suggestion);
                    $el = $(that.templates.suggestion(context)).data(keys.obj, suggestion).data(keys.val, that.displayFn(suggestion)).addClass(that.classes.suggestion + " " + that.classes.selectable);
                    fragment.appendChild($el[0]);
                });
                this.highlight && highlight({
                    className: this.classes.highlight,
                    node: fragment,
                    pattern: query
                });
                return $(fragment);
            },
            _getFooter: function getFooter(query, suggestions) {
                return this.templates.footer ? this.templates.footer({
                    query: query,
                    suggestions: suggestions,
                    dataset: this.name
                }) : null;
            },
            _getHeader: function getHeader(query, suggestions) {
                return this.templates.header ? this.templates.header({
                    query: query,
                    suggestions: suggestions,
                    dataset: this.name
                }) : null;
            },
            _resetLastSuggestion: function resetLastSuggestion() {
                this.$lastSuggestion = $();
            },
            _injectQuery: function injectQuery(query, obj) {
                return _.isObject(obj) ? _.mixin({
                    _query: query
                }, obj) : obj;
            },
            update: function update(query) {
                var that = this, canceled = false, syncCalled = false, rendered = 0;
                this.cancel();
                this.cancel = function cancel() {
                    canceled = true;
                    that.cancel = $.noop;
                    that.async && that.trigger("asyncCanceled", query);
                };
                this.source(query, sync, async);
                !syncCalled && sync([]);

                function sync(suggestions) {
                    if (syncCalled) {
                        return;
                    }
                    syncCalled = true;
                    suggestions = (suggestions || []).slice(0, that.limit);
                    rendered = suggestions.length;
                    that._overwrite(query, suggestions);
                    if (rendered < that.limit && that.async) {
                        that.trigger("asyncRequested", query);
                    }
                }

                function async(suggestions) {
                    suggestions = suggestions || [];
                    if (!canceled && rendered < that.limit) {
                        that.cancel = $.noop;
                        rendered += suggestions.length;
                        that._append(query, suggestions.slice(0, that.limit - rendered));
                        that.async && that.trigger("asyncReceived", query);
                    }
                }
            },
            cancel: $.noop,
            clear: function clear() {
                this._empty();
                this.cancel();
                this.trigger("cleared");
            },
            isEmpty: function isEmpty() {
                return this.$el.is(":empty");
            },
            destroy: function destroy() {
                this.$el = $("<div>");
            }
        });
        return Dataset;

        function getDisplayFn(display) {
            display = display || _.stringify;
            return _.isFunction(display) ? display : displayFn;

            function displayFn(obj) {
                return obj[display];
            }
        }

        function getTemplates(templates, displayFn) {
            return {
                notFound: templates.notFound && _.templatify(templates.notFound),
                pending: templates.pending && _.templatify(templates.pending),
                header: templates.header && _.templatify(templates.header),
                footer: templates.footer && _.templatify(templates.footer),
                suggestion: templates.suggestion || suggestionTemplate
            };

            function suggestionTemplate(context) {
                return $("<div>").text(displayFn(context));
            }
        }

        function isValidName(str) {
            return /^[_a-zA-Z0-9-]+$/.test(str);
        }
    }();
    var Menu = function () {
        "use strict";

        function Menu(o, www) {
            var that = this;
            o = o || {};
            if (!o.node) {
                $.error("node is required");
            }
            www.mixin(this);
            this.$node = $(o.node);
            this.query = null;
            this.datasets = _.map(o.datasets, initializeDataset);

            function initializeDataset(oDataset) {
                var node = that.$node.find(oDataset.node).first();
                oDataset.node = node.length ? node : $("<div>").appendTo(that.$node);
                return new Dataset(oDataset, www);
            }
        }

        _.mixin(Menu.prototype, EventEmitter, {
            _onSelectableClick: function onSelectableClick($e) {
                this.trigger("selectableClicked", $($e.currentTarget));
            },
            _onRendered: function onRendered(type, dataset, suggestions, async) {
                this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                this.trigger("datasetRendered", dataset, suggestions, async);
            },
            _onCleared: function onCleared() {
                this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                this.trigger("datasetCleared");
            },
            _propagate: function propagate() {
                this.trigger.apply(this, arguments);
            },
            _allDatasetsEmpty: function allDatasetsEmpty() {
                return _.every(this.datasets, isDatasetEmpty);

                function isDatasetEmpty(dataset) {
                    return dataset.isEmpty();
                }
            },
            _getSelectables: function getSelectables() {
                return this.$node.find(this.selectors.selectable);
            },
            _removeCursor: function _removeCursor() {
                var $selectable = this.getActiveSelectable();
                $selectable && $selectable.removeClass(this.classes.cursor);
            },
            _ensureVisible: function ensureVisible($el) {
                var elTop, elBottom, nodeScrollTop, nodeHeight;
                elTop = $el.position().top;
                elBottom = elTop + $el.outerHeight(true);
                nodeScrollTop = this.$node.scrollTop();
                nodeHeight = this.$node.height() + parseInt(this.$node.css("paddingTop"), 10) + parseInt(this.$node.css("paddingBottom"), 10);
                if (elTop < 0) {
                    this.$node.scrollTop(nodeScrollTop + elTop);
                } else if (nodeHeight < elBottom) {
                    this.$node.scrollTop(nodeScrollTop + (elBottom - nodeHeight));
                }
            },
            bind: function () {
                var that = this, onSelectableClick;
                onSelectableClick = _.bind(this._onSelectableClick, this);
                this.$node.on("click.tt", this.selectors.selectable, onSelectableClick);
                _.each(this.datasets, function (dataset) {
                    dataset.onSync("asyncRequested", that._propagate, that).onSync("asyncCanceled", that._propagate, that).onSync("asyncReceived", that._propagate, that).onSync("rendered", that._onRendered, that).onSync("cleared", that._onCleared, that);
                });
                return this;
            },
            isOpen: function isOpen() {
                return this.$node.hasClass(this.classes.open);
            },
            open: function open() {
                this.$node.addClass(this.classes.open);
            },
            close: function close() {
                this.$node.removeClass(this.classes.open);
                this._removeCursor();
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$node.attr("dir", dir);
            },
            selectableRelativeToCursor: function selectableRelativeToCursor(delta) {
                var $selectables, $oldCursor, oldIndex, newIndex;
                $oldCursor = this.getActiveSelectable();
                $selectables = this._getSelectables();
                oldIndex = $oldCursor ? $selectables.index($oldCursor) : -1;
                newIndex = oldIndex + delta;
                newIndex = (newIndex + 1) % ($selectables.length + 1) - 1;
                newIndex = newIndex < -1 ? $selectables.length - 1 : newIndex;
                return newIndex === -1 ? null : $selectables.eq(newIndex);
            },
            setCursor: function setCursor($selectable) {
                this._removeCursor();
                if ($selectable = $selectable && $selectable.first()) {
                    $selectable.addClass(this.classes.cursor);
                    this._ensureVisible($selectable);
                }
            },
            getSelectableData: function getSelectableData($el) {
                return $el && $el.length ? Dataset.extractData($el) : null;
            },
            getActiveSelectable: function getActiveSelectable() {
                var $selectable = this._getSelectables().filter(this.selectors.cursor).first();
                return $selectable.length ? $selectable : null;
            },
            getTopSelectable: function getTopSelectable() {
                var $selectable = this._getSelectables().first();
                return $selectable.length ? $selectable : null;
            },
            update: function update(query) {
                var isValidUpdate = query !== this.query;
                if (isValidUpdate) {
                    this.query = query;
                    _.each(this.datasets, updateDataset);
                }
                return isValidUpdate;

                function updateDataset(dataset) {
                    dataset.update(query);
                }
            },
            empty: function empty() {
                _.each(this.datasets, clearDataset);
                this.query = null;
                this.$node.addClass(this.classes.empty);

                function clearDataset(dataset) {
                    dataset.clear();
                }
            },
            destroy: function destroy() {
                this.$node.off(".tt");
                this.$node = $("<div>");
                _.each(this.datasets, destroyDataset);

                function destroyDataset(dataset) {
                    dataset.destroy();
                }
            }
        });
        return Menu;
    }();
    var DefaultMenu = function () {
        "use strict";
        var s = Menu.prototype;

        function DefaultMenu() {
            Menu.apply(this, [].slice.call(arguments, 0));
        }

        _.mixin(DefaultMenu.prototype, Menu.prototype, {
            open: function open() {
                !this._allDatasetsEmpty() && this._show();
                return s.open.apply(this, [].slice.call(arguments, 0));
            },
            close: function close() {
                this._hide();
                return s.close.apply(this, [].slice.call(arguments, 0));
            },
            _onRendered: function onRendered() {
                if (this._allDatasetsEmpty()) {
                    this._hide();
                } else {
                    this.isOpen() && this._show();
                }
                return s._onRendered.apply(this, [].slice.call(arguments, 0));
            },
            _onCleared: function onCleared() {
                if (this._allDatasetsEmpty()) {
                    this._hide();
                } else {
                    this.isOpen() && this._show();
                }
                return s._onCleared.apply(this, [].slice.call(arguments, 0));
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$node.css(dir === "ltr" ? this.css.ltr : this.css.rtl);
                return s.setLanguageDirection.apply(this, [].slice.call(arguments, 0));
            },
            _hide: function hide() {
                this.$node.hide();
            },
            _show: function show() {
                this.$node.css("display", "block");
            }
        });
        return DefaultMenu;
    }();
    var Typeahead = function () {
        "use strict";

        function Typeahead(o, www) {
            var onFocused, onBlurred, onEnterKeyed, onTabKeyed, onEscKeyed, onUpKeyed, onDownKeyed, onLeftKeyed,
                onRightKeyed, onQueryChanged, onWhitespaceChanged;
            o = o || {};
            if (!o.input) {
                $.error("missing input");
            }
            if (!o.menu) {
                $.error("missing menu");
            }
            if (!o.eventBus) {
                $.error("missing event bus");
            }
            www.mixin(this);
            this.eventBus = o.eventBus;
            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
            this.input = o.input;
            this.menu = o.menu;
            this.enabled = true;
            this.active = false;
            this.input.hasFocus() && this.activate();
            this.dir = this.input.getLangDir();
            this._hacks();
            this.menu.bind().onSync("selectableClicked", this._onSelectableClicked, this).onSync("asyncRequested", this._onAsyncRequested, this).onSync("asyncCanceled", this._onAsyncCanceled, this).onSync("asyncReceived", this._onAsyncReceived, this).onSync("datasetRendered", this._onDatasetRendered, this).onSync("datasetCleared", this._onDatasetCleared, this);
            onFocused = c(this, "activate", "open", "_onFocused");
            onBlurred = c(this, "deactivate", "_onBlurred");
            onEnterKeyed = c(this, "isActive", "isOpen", "_onEnterKeyed");
            onTabKeyed = c(this, "isActive", "isOpen", "_onTabKeyed");
            onEscKeyed = c(this, "isActive", "_onEscKeyed");
            onUpKeyed = c(this, "isActive", "open", "_onUpKeyed");
            onDownKeyed = c(this, "isActive", "open", "_onDownKeyed");
            onLeftKeyed = c(this, "isActive", "isOpen", "_onLeftKeyed");
            onRightKeyed = c(this, "isActive", "isOpen", "_onRightKeyed");
            onQueryChanged = c(this, "_openIfActive", "_onQueryChanged");
            onWhitespaceChanged = c(this, "_openIfActive", "_onWhitespaceChanged");
            this.input.bind().onSync("focused", onFocused, this).onSync("blurred", onBlurred, this).onSync("enterKeyed", onEnterKeyed, this).onSync("tabKeyed", onTabKeyed, this).onSync("escKeyed", onEscKeyed, this).onSync("upKeyed", onUpKeyed, this).onSync("downKeyed", onDownKeyed, this).onSync("leftKeyed", onLeftKeyed, this).onSync("rightKeyed", onRightKeyed, this).onSync("queryChanged", onQueryChanged, this).onSync("whitespaceChanged", onWhitespaceChanged, this).onSync("langDirChanged", this._onLangDirChanged, this);
        }

        _.mixin(Typeahead.prototype, {
            _hacks: function hacks() {
                var $input, $menu;
                $input = this.input.$input || $("<div>");
                $menu = this.menu.$node || $("<div>");
                $input.on("blur.tt", function ($e) {
                    var active, isActive, hasActive;
                    active = document.activeElement;
                    isActive = $menu.is(active);
                    hasActive = $menu.has(active).length > 0;
                    if (_.isMsie() && (isActive || hasActive)) {
                        $e.preventDefault();
                        $e.stopImmediatePropagation();
                        _.defer(function () {
                            $input.focus();
                        });
                    }
                });
                $menu.on("mousedown.tt", function ($e) {
                    $e.preventDefault();
                });
            },
            _onSelectableClicked: function onSelectableClicked(type, $el) {
                this.select($el);
            },
            _onDatasetCleared: function onDatasetCleared() {
                this._updateHint();
            },
            _onDatasetRendered: function onDatasetRendered(type, dataset, suggestions, async) {
                this._updateHint();
                this.eventBus.trigger("render", suggestions, async, dataset);
            },
            _onAsyncRequested: function onAsyncRequested(type, dataset, query) {
                this.eventBus.trigger("asyncrequest", query, dataset);
            },
            _onAsyncCanceled: function onAsyncCanceled(type, dataset, query) {
                this.eventBus.trigger("asynccancel", query, dataset);
            },
            _onAsyncReceived: function onAsyncReceived(type, dataset, query) {
                this.eventBus.trigger("asyncreceive", query, dataset);
            },
            _onFocused: function onFocused() {
                this._minLengthMet() && this.menu.update(this.input.getQuery());
            },
            _onBlurred: function onBlurred() {
                if (this.input.hasQueryChangedSinceLastFocus()) {
                    this.eventBus.trigger("change", this.input.getQuery());
                }
            },
            _onEnterKeyed: function onEnterKeyed(type, $e) {
                var $selectable;
                if ($selectable = this.menu.getActiveSelectable()) {
                    this.select($selectable) && $e.preventDefault();
                }
            },
            _onTabKeyed: function onTabKeyed(type, $e) {
                var $selectable;
                if ($selectable = this.menu.getActiveSelectable()) {
                    this.select($selectable) && $e.preventDefault();
                } else if ($selectable = this.menu.getTopSelectable()) {
                    this.autocomplete($selectable) && $e.preventDefault();
                }
            },
            _onEscKeyed: function onEscKeyed() {
                this.close();
            },
            _onUpKeyed: function onUpKeyed() {
                this.moveCursor(-1);
            },
            _onDownKeyed: function onDownKeyed() {
                this.moveCursor(+1);
            },
            _onLeftKeyed: function onLeftKeyed() {
                if (this.dir === "rtl" && this.input.isCursorAtEnd()) {
                    this.autocomplete(this.menu.getTopSelectable());
                }
            },
            _onRightKeyed: function onRightKeyed() {
                if (this.dir === "ltr" && this.input.isCursorAtEnd()) {
                    this.autocomplete(this.menu.getTopSelectable());
                }
            },
            _onQueryChanged: function onQueryChanged(e, query) {
                this._minLengthMet(query) ? this.menu.update(query) : this.menu.empty();
            },
            _onWhitespaceChanged: function onWhitespaceChanged() {
                this._updateHint();
            },
            _onLangDirChanged: function onLangDirChanged(e, dir) {
                if (this.dir !== dir) {
                    this.dir = dir;
                    this.menu.setLanguageDirection(dir);
                }
            },
            _openIfActive: function openIfActive() {
                this.isActive() && this.open();
            },
            _minLengthMet: function minLengthMet(query) {
                query = _.isString(query) ? query : this.input.getQuery() || "";
                return query.length >= this.minLength;
            },
            _updateHint: function updateHint() {
                var $selectable, data, val, query, escapedQuery, frontMatchRegEx, match;
                $selectable = this.menu.getTopSelectable();
                data = this.menu.getSelectableData($selectable);
                val = this.input.getInputValue();
                if (data && !_.isBlankString(val) && !this.input.hasOverflow()) {
                    query = Input.normalizeQuery(val);
                    escapedQuery = _.escapeRegExChars(query);
                    frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
                    match = frontMatchRegEx.exec(data.val);
                    match && this.input.setHint(val + match[1]);
                } else {
                    this.input.clearHint();
                }
            },
            isEnabled: function isEnabled() {
                return this.enabled;
            },
            enable: function enable() {
                this.enabled = true;
            },
            disable: function disable() {
                this.enabled = false;
            },
            isActive: function isActive() {
                return this.active;
            },
            activate: function activate() {
                if (this.isActive()) {
                    return true;
                } else if (!this.isEnabled() || this.eventBus.before("active")) {
                    return false;
                } else {
                    this.active = true;
                    this.eventBus.trigger("active");
                    return true;
                }
            },
            deactivate: function deactivate() {
                if (!this.isActive()) {
                    return true;
                } else if (this.eventBus.before("idle")) {
                    return false;
                } else {
                    this.active = false;
                    this.close();
                    this.eventBus.trigger("idle");
                    return true;
                }
            },
            isOpen: function isOpen() {
                return this.menu.isOpen();
            },
            open: function open() {
                if (!this.isOpen() && !this.eventBus.before("open")) {
                    this.menu.open();
                    this._updateHint();
                    this.eventBus.trigger("open");
                }
                return this.isOpen();
            },
            close: function close() {
                if (this.isOpen() && !this.eventBus.before("close")) {
                    this.menu.close();
                    this.input.clearHint();
                    this.input.resetInputValue();
                    this.eventBus.trigger("close");
                }
                return !this.isOpen();
            },
            setVal: function setVal(val) {
                this.input.setQuery(_.toStr(val));
            },
            getVal: function getVal() {
                return this.input.getQuery();
            },
            select: function select($selectable) {
                var data = this.menu.getSelectableData($selectable);
                if (data && !this.eventBus.before("select", data.obj)) {
                    this.input.setQuery(data.val, true);
                    this.eventBus.trigger("select", data.obj);
                    this.close();
                    return true;
                }
                return false;
            },
            autocomplete: function autocomplete($selectable) {
                var query, data, isValid;
                query = this.input.getQuery();
                data = this.menu.getSelectableData($selectable);
                isValid = data && query !== data.val;
                if (isValid && !this.eventBus.before("autocomplete", data.obj)) {
                    this.input.setQuery(data.val);
                    this.eventBus.trigger("autocomplete", data.obj);
                    return true;
                }
                return false;
            },
            moveCursor: function moveCursor(delta) {
                var query, $candidate, data, payload, cancelMove;
                query = this.input.getQuery();
                $candidate = this.menu.selectableRelativeToCursor(delta);
                data = this.menu.getSelectableData($candidate);
                payload = data ? data.obj : null;
                cancelMove = this._minLengthMet() && this.menu.update(query);
                if (!cancelMove && !this.eventBus.before("cursorchange", payload)) {
                    this.menu.setCursor($candidate);
                    if (data) {
                        this.input.setInputValue(data.val);
                    } else {
                        this.input.resetInputValue();
                        this._updateHint();
                    }
                    this.eventBus.trigger("cursorchange", payload);
                    return true;
                }
                return false;
            },
            destroy: function destroy() {
                this.input.destroy();
                this.menu.destroy();
            }
        });
        return Typeahead;

        function c(ctx) {
            var methods = [].slice.call(arguments, 1);
            return function () {
                var args = [].slice.call(arguments);
                _.each(methods, function (method) {
                    return ctx[method].apply(ctx, args);
                });
            };
        }
    }();
    (function () {
        "use strict";
        var old, keys, methods;
        old = $.fn.typeahead;
        keys = {
            www: "tt-www",
            attrs: "tt-attrs",
            typeahead: "tt-typeahead"
        };
        methods = {
            initialize: function initialize(o, datasets) {
                var www;
                datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                o = o || {};
                www = WWW(o.classNames);
                return this.each(attach);

                function attach() {
                    var $input, $wrapper, $hint, $menu, defaultHint, defaultMenu, eventBus, input, menu, typeahead,
                        MenuConstructor;
                    _.each(datasets, function (d) {
                        d.highlight = !!o.highlight;
                    });
                    $input = $(this);
                    $wrapper = $(www.html.wrapper);
                    $hint = $elOrNull(o.hint);
                    $menu = $elOrNull(o.menu);
                    defaultHint = o.hint !== false && !$hint;
                    defaultMenu = o.menu !== false && !$menu;
                    defaultHint && ($hint = buildHintFromInput($input, www));
                    defaultMenu && ($menu = $(www.html.menu).css(www.css.menu));
                    $hint && $hint.val("");
                    $input = prepInput($input, www);
                    if (defaultHint || defaultMenu) {
                        $wrapper.css(www.css.wrapper);
                        $input.css(defaultHint ? www.css.input : www.css.inputWithNoHint);
                        $input.wrap($wrapper).parent().prepend(defaultHint ? $hint : null).append(defaultMenu ? $menu : null);
                    }
                    MenuConstructor = defaultMenu ? DefaultMenu : Menu;
                    eventBus = new EventBus({
                        el: $input
                    });
                    input = new Input({
                        hint: $hint,
                        input: $input
                    }, www);
                    menu = new MenuConstructor({
                        node: $menu,
                        datasets: datasets
                    }, www);
                    typeahead = new Typeahead({
                        input: input,
                        menu: menu,
                        eventBus: eventBus,
                        minLength: o.minLength
                    }, www);
                    $input.data(keys.www, www);
                    $input.data(keys.typeahead, typeahead);
                }
            },
            isEnabled: function isEnabled() {
                var enabled;
                ttEach(this.first(), function (t) {
                    enabled = t.isEnabled();
                });
                return enabled;
            },
            enable: function enable() {
                ttEach(this, function (t) {
                    t.enable();
                });
                return this;
            },
            disable: function disable() {
                ttEach(this, function (t) {
                    t.disable();
                });
                return this;
            },
            isActive: function isActive() {
                var active;
                ttEach(this.first(), function (t) {
                    active = t.isActive();
                });
                return active;
            },
            activate: function activate() {
                ttEach(this, function (t) {
                    t.activate();
                });
                return this;
            },
            deactivate: function deactivate() {
                ttEach(this, function (t) {
                    t.deactivate();
                });
                return this;
            },
            isOpen: function isOpen() {
                var open;
                ttEach(this.first(), function (t) {
                    open = t.isOpen();
                });
                return open;
            },
            open: function open() {
                ttEach(this, function (t) {
                    t.open();
                });
                return this;
            },
            close: function close() {
                ttEach(this, function (t) {
                    t.close();
                });
                return this;
            },
            select: function select(el) {
                var success = false, $el = $(el);
                ttEach(this.first(), function (t) {
                    success = t.select($el);
                });
                return success;
            },
            autocomplete: function autocomplete(el) {
                var success = false, $el = $(el);
                ttEach(this.first(), function (t) {
                    success = t.autocomplete($el);
                });
                return success;
            },
            moveCursor: function moveCursoe(delta) {
                var success = false;
                ttEach(this.first(), function (t) {
                    success = t.moveCursor(delta);
                });
                return success;
            },
            val: function val(newVal) {
                var query;
                if (!arguments.length) {
                    ttEach(this.first(), function (t) {
                        query = t.getVal();
                    });
                    return query;
                } else {
                    ttEach(this, function (t) {
                        t.setVal(newVal);
                    });
                    return this;
                }
            },
            destroy: function destroy() {
                ttEach(this, function (typeahead, $input) {
                    revert($input);
                    typeahead.destroy();
                });
                return this;
            }
        };
        $.fn.typeahead = function (method) {
            if (methods[method]) {
                return methods[method].apply(this, [].slice.call(arguments, 1));
            } else {
                return methods.initialize.apply(this, arguments);
            }
        };
        $.fn.typeahead.noConflict = function noConflict() {
            $.fn.typeahead = old;
            return this;
        };

        function ttEach($els, fn) {
            $els.each(function () {
                var $input = $(this), typeahead;
                (typeahead = $input.data(keys.typeahead)) && fn(typeahead, $input);
            });
        }

        function buildHintFromInput($input, www) {
            return $input.clone().addClass(www.classes.hint).removeData().css(www.css.hint).css(getBackgroundStyles($input)).prop("readonly", true).removeAttr("id name placeholder required").attr({
                autocomplete: "off",
                spellcheck: "false",
                tabindex: -1
            });
        }

        function prepInput($input, www) {
            $input.data(keys.attrs, {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            });
            $input.addClass(www.classes.input).attr({
                autocomplete: "off",
                spellcheck: false
            });
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {
            }
            return $input;
        }

        function getBackgroundStyles($el) {
            return {
                backgroundAttachment: $el.css("background-attachment"),
                backgroundClip: $el.css("background-clip"),
                backgroundColor: $el.css("background-color"),
                backgroundImage: $el.css("background-image"),
                backgroundOrigin: $el.css("background-origin"),
                backgroundPosition: $el.css("background-position"),
                backgroundRepeat: $el.css("background-repeat"),
                backgroundSize: $el.css("background-size")
            };
        }

        function revert($input) {
            var www, $wrapper;
            www = $input.data(keys.www);
            $wrapper = $input.parent().filter(www.selectors.wrapper);
            _.each($input.data(keys.attrs), function (val, key) {
                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            });
            $input.removeData(keys.typeahead).removeData(keys.www).removeData(keys.attr).removeClass(www.classes.input);
            if ($wrapper.length) {
                $input.detach().insertAfter($wrapper);
                $wrapper.remove();
            }
        }

        function $elOrNull(obj) {
            var isValid, $el;
            isValid = _.isJQuery(obj) || _.isElement(obj);
            $el = isValid ? $(obj).first() : [];
            return $el.length ? $el : null;
        }
    })();
});
/**!

 @license
 handlebars v4.0.10

 Copyright (C) 2011-2016 by Yehuda Katz

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 */
(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else if (typeof exports === 'object')
        exports["Handlebars"] = factory();
    else
        root["Handlebars"] = factory();
})(this, function () {
    return /******/ (function (modules) { // webpackBootstrap
        /******/ 	// The module cache
        /******/
        var installedModules = {};

        /******/ 	// The require function
        /******/
        function __webpack_require__(moduleId) {

            /******/ 		// Check if module is in cache
            /******/
            if (installedModules[moduleId])
            /******/            return installedModules[moduleId].exports;

            /******/ 		// Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/            exports: {},
                /******/            id: moduleId,
                /******/            loaded: false
                /******/
            };

            /******/ 		// Execute the module function
            /******/
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

            /******/ 		// Flag the module as loaded
            /******/
            module.loaded = true;

            /******/ 		// Return the exports of the module
            /******/
            return module.exports;
            /******/
        }


        /******/ 	// expose the modules object (__webpack_modules__)
        /******/
        __webpack_require__.m = modules;

        /******/ 	// expose the module cache
        /******/
        __webpack_require__.c = installedModules;

        /******/ 	// __webpack_public_path__
        /******/
        __webpack_require__.p = "";

        /******/ 	// Load entry module and return exports
        /******/
        return __webpack_require__(0);
        /******/
    })
    /************************************************************************/
    /******/([
        /* 0 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _handlebarsRuntime = __webpack_require__(2);

            var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

            // Compiler imports

            var _handlebarsCompilerAst = __webpack_require__(35);

            var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

            var _handlebarsCompilerBase = __webpack_require__(36);

            var _handlebarsCompilerCompiler = __webpack_require__(41);

            var _handlebarsCompilerJavascriptCompiler = __webpack_require__(42);

            var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

            var _handlebarsCompilerVisitor = __webpack_require__(39);

            var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

            var _handlebarsNoConflict = __webpack_require__(34);

            var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

            var _create = _handlebarsRuntime2['default'].create;

            function create() {
                var hb = _create();

                hb.compile = function (input, options) {
                    return _handlebarsCompilerCompiler.compile(input, options, hb);
                };
                hb.precompile = function (input, options) {
                    return _handlebarsCompilerCompiler.precompile(input, options, hb);
                };

                hb.AST = _handlebarsCompilerAst2['default'];
                hb.Compiler = _handlebarsCompilerCompiler.Compiler;
                hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
                hb.Parser = _handlebarsCompilerBase.parser;
                hb.parse = _handlebarsCompilerBase.parse;

                return hb;
            }

            var inst = create();
            inst.create = create;

            _handlebarsNoConflict2['default'](inst);

            inst.Visitor = _handlebarsCompilerVisitor2['default'];

            inst['default'] = inst;

            exports['default'] = inst;
            module.exports = exports['default'];

            /***/
        }),
        /* 1 */
        /***/ (function (module, exports) {

            "use strict";

            exports["default"] = function (obj) {
                return obj && obj.__esModule ? obj : {
                    "default": obj
                };
            };

            exports.__esModule = true;

            /***/
        }),
        /* 2 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _handlebarsBase = __webpack_require__(4);

            var base = _interopRequireWildcard(_handlebarsBase);

            // Each of these augment the Handlebars object. No need to setup here.
            // (This is done to easily share code between commonjs and browse envs)

            var _handlebarsSafeString = __webpack_require__(21);

            var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

            var _handlebarsException = __webpack_require__(6);

            var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

            var _handlebarsUtils = __webpack_require__(5);

            var Utils = _interopRequireWildcard(_handlebarsUtils);

            var _handlebarsRuntime = __webpack_require__(22);

            var runtime = _interopRequireWildcard(_handlebarsRuntime);

            var _handlebarsNoConflict = __webpack_require__(34);

            var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

            // For compatibility and usage outside of module systems, make the Handlebars object a namespace
            function create() {
                var hb = new base.HandlebarsEnvironment();

                Utils.extend(hb, base);
                hb.SafeString = _handlebarsSafeString2['default'];
                hb.Exception = _handlebarsException2['default'];
                hb.Utils = Utils;
                hb.escapeExpression = Utils.escapeExpression;

                hb.VM = runtime;
                hb.template = function (spec) {
                    return runtime.template(spec, hb);
                };

                return hb;
            }

            var inst = create();
            inst.create = create;

            _handlebarsNoConflict2['default'](inst);

            inst['default'] = inst;

            exports['default'] = inst;
            module.exports = exports['default'];

            /***/
        }),
        /* 3 */
        /***/ (function (module, exports) {

            "use strict";

            exports["default"] = function (obj) {
                if (obj && obj.__esModule) {
                    return obj;
                } else {
                    var newObj = {};

                    if (obj != null) {
                        for (var key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                        }
                    }

                    newObj["default"] = obj;
                    return newObj;
                }
            };

            exports.__esModule = true;

            /***/
        }),
        /* 4 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.HandlebarsEnvironment = HandlebarsEnvironment;

            var _utils = __webpack_require__(5);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _helpers = __webpack_require__(10);

            var _decorators = __webpack_require__(18);

            var _logger = __webpack_require__(20);

            var _logger2 = _interopRequireDefault(_logger);

            var VERSION = '4.0.10';
            exports.VERSION = VERSION;
            var COMPILER_REVISION = 7;

            exports.COMPILER_REVISION = COMPILER_REVISION;
            var REVISION_CHANGES = {
                1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
                2: '== 1.0.0-rc.3',
                3: '== 1.0.0-rc.4',
                4: '== 1.x.x',
                5: '== 2.0.0-alpha.x',
                6: '>= 2.0.0-beta.1',
                7: '>= 4.0.0'
            };

            exports.REVISION_CHANGES = REVISION_CHANGES;
            var objectType = '[object Object]';

            function HandlebarsEnvironment(helpers, partials, decorators) {
                this.helpers = helpers || {};
                this.partials = partials || {};
                this.decorators = decorators || {};

                _helpers.registerDefaultHelpers(this);
                _decorators.registerDefaultDecorators(this);
            }

            HandlebarsEnvironment.prototype = {
                constructor: HandlebarsEnvironment,

                logger: _logger2['default'],
                log: _logger2['default'].log,

                registerHelper: function registerHelper(name, fn) {
                    if (_utils.toString.call(name) === objectType) {
                        if (fn) {
                            throw new _exception2['default']('Arg not supported with multiple helpers');
                        }
                        _utils.extend(this.helpers, name);
                    } else {
                        this.helpers[name] = fn;
                    }
                },
                unregisterHelper: function unregisterHelper(name) {
                    delete this.helpers[name];
                },

                registerPartial: function registerPartial(name, partial) {
                    if (_utils.toString.call(name) === objectType) {
                        _utils.extend(this.partials, name);
                    } else {
                        if (typeof partial === 'undefined') {
                            throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
                        }
                        this.partials[name] = partial;
                    }
                },
                unregisterPartial: function unregisterPartial(name) {
                    delete this.partials[name];
                },

                registerDecorator: function registerDecorator(name, fn) {
                    if (_utils.toString.call(name) === objectType) {
                        if (fn) {
                            throw new _exception2['default']('Arg not supported with multiple decorators');
                        }
                        _utils.extend(this.decorators, name);
                    } else {
                        this.decorators[name] = fn;
                    }
                },
                unregisterDecorator: function unregisterDecorator(name) {
                    delete this.decorators[name];
                }
            };

            var log = _logger2['default'].log;

            exports.log = log;
            exports.createFrame = _utils.createFrame;
            exports.logger = _logger2['default'];

            /***/
        }),
        /* 5 */
        /***/ (function (module, exports) {

            'use strict';

            exports.__esModule = true;
            exports.extend = extend;
            exports.indexOf = indexOf;
            exports.escapeExpression = escapeExpression;
            exports.isEmpty = isEmpty;
            exports.createFrame = createFrame;
            exports.blockParams = blockParams;
            exports.appendContextPath = appendContextPath;
            var escape = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '`': '&#x60;',
                '=': '&#x3D;'
            };

            var badChars = /[&<>"'`=]/g,
                possible = /[&<>"'`=]/;

            function escapeChar(chr) {
                return escape[chr];
            }

            function extend(obj /* , ...source */) {
                for (var i = 1; i < arguments.length; i++) {
                    for (var key in arguments[i]) {
                        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                            obj[key] = arguments[i][key];
                        }
                    }
                }

                return obj;
            }

            var toString = Object.prototype.toString;

            exports.toString = toString;
            // Sourced from lodash
            // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
            /* eslint-disable func-style */
            var isFunction = function isFunction(value) {
                return typeof value === 'function';
            };
            // fallback for older versions of Chrome and Safari
            /* istanbul ignore next */
            if (isFunction(/x/)) {
                exports.isFunction = isFunction = function (value) {
                    return typeof value === 'function' && toString.call(value) === '[object Function]';
                };
            }
            exports.isFunction = isFunction;

            /* eslint-enable func-style */

            /* istanbul ignore next */
            var isArray = Array.isArray || function (value) {
                return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
            };

            exports.isArray = isArray;

            // Older IE versions do not directly support indexOf so we must implement our own, sadly.

            function indexOf(array, value) {
                for (var i = 0, len = array.length; i < len; i++) {
                    if (array[i] === value) {
                        return i;
                    }
                }
                return -1;
            }

            function escapeExpression(string) {
                if (typeof string !== 'string') {
                    // don't escape SafeStrings, since they're already safe
                    if (string && string.toHTML) {
                        return string.toHTML();
                    } else if (string == null) {
                        return '';
                    } else if (!string) {
                        return string + '';
                    }

                    // Force a string conversion as this will be done by the append regardless and
                    // the regex test will do this transparently behind the scenes, causing issues if
                    // an object's to string has escaped characters in it.
                    string = '' + string;
                }

                if (!possible.test(string)) {
                    return string;
                }
                return string.replace(badChars, escapeChar);
            }

            function isEmpty(value) {
                if (!value && value !== 0) {
                    return true;
                } else if (isArray(value) && value.length === 0) {
                    return true;
                } else {
                    return false;
                }
            }

            function createFrame(object) {
                var frame = extend({}, object);
                frame._parent = object;
                return frame;
            }

            function blockParams(params, ids) {
                params.path = ids;
                return params;
            }

            function appendContextPath(contextPath, id) {
                return (contextPath ? contextPath + '.' : '') + id;
            }

            /***/
        }),
        /* 6 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _Object$defineProperty = __webpack_require__(7)['default'];

            exports.__esModule = true;

            var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

            function Exception(message, node) {
                var loc = node && node.loc,
                    line = undefined,
                    column = undefined;
                if (loc) {
                    line = loc.start.line;
                    column = loc.start.column;

                    message += ' - ' + line + ':' + column;
                }

                var tmp = Error.prototype.constructor.call(this, message);

                // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
                for (var idx = 0; idx < errorProps.length; idx++) {
                    this[errorProps[idx]] = tmp[errorProps[idx]];
                }

                /* istanbul ignore else */
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, Exception);
                }

                try {
                    if (loc) {
                        this.lineNumber = line;

                        // Work around issue under safari where we can't directly set the column value
                        /* istanbul ignore next */
                        if (_Object$defineProperty) {
                            Object.defineProperty(this, 'column', {
                                value: column,
                                enumerable: true
                            });
                        } else {
                            this.column = column;
                        }
                    }
                } catch (nop) {
                    /* Ignore if the browser is very particular */
                }
            }

            Exception.prototype = new Error();

            exports['default'] = Exception;
            module.exports = exports['default'];

            /***/
        }),
        /* 7 */
        /***/ (function (module, exports, __webpack_require__) {

            module.exports = {"default": __webpack_require__(8), __esModule: true};

            /***/
        }),
        /* 8 */
        /***/ (function (module, exports, __webpack_require__) {

            var $ = __webpack_require__(9);
            module.exports = function defineProperty(it, key, desc) {
                return $.setDesc(it, key, desc);
            };

            /***/
        }),
        /* 9 */
        /***/ (function (module, exports) {

            var $Object = Object;
            module.exports = {
                create: $Object.create,
                getProto: $Object.getPrototypeOf,
                isEnum: {}.propertyIsEnumerable,
                getDesc: $Object.getOwnPropertyDescriptor,
                setDesc: $Object.defineProperty,
                setDescs: $Object.defineProperties,
                getKeys: $Object.keys,
                getNames: $Object.getOwnPropertyNames,
                getSymbols: $Object.getOwnPropertySymbols,
                each: [].forEach
            };

            /***/
        }),
        /* 10 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.registerDefaultHelpers = registerDefaultHelpers;

            var _helpersBlockHelperMissing = __webpack_require__(11);

            var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

            var _helpersEach = __webpack_require__(12);

            var _helpersEach2 = _interopRequireDefault(_helpersEach);

            var _helpersHelperMissing = __webpack_require__(13);

            var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

            var _helpersIf = __webpack_require__(14);

            var _helpersIf2 = _interopRequireDefault(_helpersIf);

            var _helpersLog = __webpack_require__(15);

            var _helpersLog2 = _interopRequireDefault(_helpersLog);

            var _helpersLookup = __webpack_require__(16);

            var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

            var _helpersWith = __webpack_require__(17);

            var _helpersWith2 = _interopRequireDefault(_helpersWith);

            function registerDefaultHelpers(instance) {
                _helpersBlockHelperMissing2['default'](instance);
                _helpersEach2['default'](instance);
                _helpersHelperMissing2['default'](instance);
                _helpersIf2['default'](instance);
                _helpersLog2['default'](instance);
                _helpersLookup2['default'](instance);
                _helpersWith2['default'](instance);
            }

            /***/
        }),
        /* 11 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('blockHelperMissing', function (context, options) {
                    var inverse = options.inverse,
                        fn = options.fn;

                    if (context === true) {
                        return fn(this);
                    } else if (context === false || context == null) {
                        return inverse(this);
                    } else if (_utils.isArray(context)) {
                        if (context.length > 0) {
                            if (options.ids) {
                                options.ids = [options.name];
                            }

                            return instance.helpers.each(context, options);
                        } else {
                            return inverse(this);
                        }
                    } else {
                        if (options.data && options.ids) {
                            var data = _utils.createFrame(options.data);
                            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
                            options = {data: data};
                        }

                        return fn(context, options);
                    }
                });
            };

            module.exports = exports['default'];

            /***/
        }),
        /* 12 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            exports['default'] = function (instance) {
                instance.registerHelper('each', function (context, options) {
                    if (!options) {
                        throw new _exception2['default']('Must pass iterator to #each');
                    }

                    var fn = options.fn,
                        inverse = options.inverse,
                        i = 0,
                        ret = '',
                        data = undefined,
                        contextPath = undefined;

                    if (options.data && options.ids) {
                        contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
                    }

                    if (_utils.isFunction(context)) {
                        context = context.call(this);
                    }

                    if (options.data) {
                        data = _utils.createFrame(options.data);
                    }

                    function execIteration(field, index, last) {
                        if (data) {
                            data.key = field;
                            data.index = index;
                            data.first = index === 0;
                            data.last = !!last;

                            if (contextPath) {
                                data.contextPath = contextPath + field;
                            }
                        }

                        ret = ret + fn(context[field], {
                            data: data,
                            blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
                        });
                    }

                    if (context && typeof context === 'object') {
                        if (_utils.isArray(context)) {
                            for (var j = context.length; i < j; i++) {
                                if (i in context) {
                                    execIteration(i, i, i === context.length - 1);
                                }
                            }
                        } else {
                            var priorKey = undefined;

                            for (var key in context) {
                                if (context.hasOwnProperty(key)) {
                                    // We're running the iterations one step out of sync so we can detect
                                    // the last iteration without have to scan the object twice and create
                                    // an itermediate keys array.
                                    if (priorKey !== undefined) {
                                        execIteration(priorKey, i - 1);
                                    }
                                    priorKey = key;
                                    i++;
                                }
                            }
                            if (priorKey !== undefined) {
                                execIteration(priorKey, i - 1, true);
                            }
                        }
                    }

                    if (i === 0) {
                        ret = inverse(this);
                    }

                    return ret;
                });
            };

            module.exports = exports['default'];

            /***/
        }),
        /* 13 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            exports['default'] = function (instance) {
                instance.registerHelper('helperMissing', function () /* [args, ]options */ {
                    if (arguments.length === 1) {
                        // A missing field in a {{foo}} construct.
                        return undefined;
                    } else {
                        // Someone is actually trying to call something, blow up.
                        throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                    }
                });
            };

            module.exports = exports['default'];

            /***/
        }),
        /* 14 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('if', function (conditional, options) {
                    if (_utils.isFunction(conditional)) {
                        conditional = conditional.call(this);
                    }

                    // Default behavior is to render the positive path if the value is truthy and not empty.
                    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
                        return options.inverse(this);
                    } else {
                        return options.fn(this);
                    }
                });

                instance.registerHelper('unless', function (conditional, options) {
                    return instance.helpers['if'].call(this, conditional, {
                        fn: options.inverse,
                        inverse: options.fn,
                        hash: options.hash
                    });
                });
            };

            module.exports = exports['default'];

            /***/
        }),
        /* 15 */
        /***/ (function (module, exports) {

            'use strict';

            exports.__esModule = true;

            exports['default'] = function (instance) {
                instance.registerHelper('log', function () /* message, options */ {
                    var args = [undefined],
                        options = arguments[arguments.length - 1];
                    for (var i = 0; i < arguments.length - 1; i++) {
                        args.push(arguments[i]);
                    }

                    var level = 1;
                    if (options.hash.level != null) {
                        level = options.hash.level;
                    } else if (options.data && options.data.level != null) {
                        level = options.data.level;
                    }
                    args[0] = level;

                    instance.log.apply(instance, args);
                });
            };

            module.exports = exports['default'];

            /***/
        }),
        /* 16 */
        /***/ (function (module, exports) {

            'use strict';

            exports.__esModule = true;

            exports['default'] = function (instance) {
                instance.registerHelper('lookup', function (obj, field) {
                    return obj && obj[field];
                });
            };

            module.exports = exports['default'];

            /***/
        }),
        /* 17 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('with', function (context, options) {
                    if (_utils.isFunction(context)) {
                        context = context.call(this);
                    }

                    var fn = options.fn;

                    if (!_utils.isEmpty(context)) {
                        var data = options.data;
                        if (options.data && options.ids) {
                            data = _utils.createFrame(options.data);
                            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
                        }

                        return fn(context, {
                            data: data,
                            blockParams: _utils.blockParams([context], [data && data.contextPath])
                        });
                    } else {
                        return options.inverse(this);
                    }
                });
            };

            module.exports = exports['default'];

            /***/
        }),
        /* 18 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.registerDefaultDecorators = registerDefaultDecorators;

            var _decoratorsInline = __webpack_require__(19);

            var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

            function registerDefaultDecorators(instance) {
                _decoratorsInline2['default'](instance);
            }

            /***/
        }),
        /* 19 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerDecorator('inline', function (fn, props, container, options) {
                    var ret = fn;
                    if (!props.partials) {
                        props.partials = {};
                        ret = function (context, options) {
                            // Create a new partials stack frame prior to exec.
                            var original = container.partials;
                            container.partials = _utils.extend({}, original, props.partials);
                            var ret = fn(context, options);
                            container.partials = original;
                            return ret;
                        };
                    }

                    props.partials[options.args[0]] = options.fn;

                    return ret;
                });
            };

            module.exports = exports['default'];

            /***/
        }),
        /* 20 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var logger = {
                methodMap: ['debug', 'info', 'warn', 'error'],
                level: 'info',

                // Maps a given level value to the `methodMap` indexes above.
                lookupLevel: function lookupLevel(level) {
                    if (typeof level === 'string') {
                        var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
                        if (levelMap >= 0) {
                            level = levelMap;
                        } else {
                            level = parseInt(level, 10);
                        }
                    }

                    return level;
                },

                // Can be overridden in the host environment
                log: function log(level) {
                    level = logger.lookupLevel(level);

                    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
                        var method = logger.methodMap[level];
                        if (!console[method]) {
                            // eslint-disable-line no-console
                            method = 'log';
                        }

                        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            message[_key - 1] = arguments[_key];
                        }

                        console[method].apply(console, message); // eslint-disable-line no-console
                    }
                }
            };

            exports['default'] = logger;
            module.exports = exports['default'];

            /***/
        }),
        /* 21 */
        /***/ (function (module, exports) {

            // Build out our basic SafeString type
            'use strict';

            exports.__esModule = true;

            function SafeString(string) {
                this.string = string;
            }

            SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
                return '' + this.string;
            };

            exports['default'] = SafeString;
            module.exports = exports['default'];

            /***/
        }),
        /* 22 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _Object$seal = __webpack_require__(23)['default'];

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.checkRevision = checkRevision;
            exports.template = template;
            exports.wrapProgram = wrapProgram;
            exports.resolvePartial = resolvePartial;
            exports.invokePartial = invokePartial;
            exports.noop = noop;

            var _utils = __webpack_require__(5);

            var Utils = _interopRequireWildcard(_utils);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _base = __webpack_require__(4);

            function checkRevision(compilerInfo) {
                var compilerRevision = compilerInfo && compilerInfo[0] || 1,
                    currentRevision = _base.COMPILER_REVISION;

                if (compilerRevision !== currentRevision) {
                    if (compilerRevision < currentRevision) {
                        var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
                            compilerVersions = _base.REVISION_CHANGES[compilerRevision];
                        throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
                    } else {
                        // Use the embedded version info since the runtime doesn't know about this revision yet
                        throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
                    }
                }
            }

            function template(templateSpec, env) {
                /* istanbul ignore next */
                if (!env) {
                    throw new _exception2['default']('No environment passed to template');
                }
                if (!templateSpec || !templateSpec.main) {
                    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
                }

                templateSpec.main.decorator = templateSpec.main_d;

                // Note: Using env.VM references rather than local var references throughout this section to allow
                // for external users to override these as psuedo-supported APIs.
                env.VM.checkRevision(templateSpec.compiler);

                function invokePartialWrapper(partial, context, options) {
                    if (options.hash) {
                        context = Utils.extend({}, context, options.hash);
                        if (options.ids) {
                            options.ids[0] = true;
                        }
                    }

                    partial = env.VM.resolvePartial.call(this, partial, context, options);
                    var result = env.VM.invokePartial.call(this, partial, context, options);

                    if (result == null && env.compile) {
                        options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
                        result = options.partials[options.name](context, options);
                    }
                    if (result != null) {
                        if (options.indent) {
                            var lines = result.split('\n');
                            for (var i = 0, l = lines.length; i < l; i++) {
                                if (!lines[i] && i + 1 === l) {
                                    break;
                                }

                                lines[i] = options.indent + lines[i];
                            }
                            result = lines.join('\n');
                        }
                        return result;
                    } else {
                        throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
                    }
                }

                // Just add water
                var container = {
                    strict: function strict(obj, name) {
                        if (!(name in obj)) {
                            throw new _exception2['default']('"' + name + '" not defined in ' + obj);
                        }
                        return obj[name];
                    },
                    lookup: function lookup(depths, name) {
                        var len = depths.length;
                        for (var i = 0; i < len; i++) {
                            if (depths[i] && depths[i][name] != null) {
                                return depths[i][name];
                            }
                        }
                    },
                    lambda: function lambda(current, context) {
                        return typeof current === 'function' ? current.call(context) : current;
                    },

                    escapeExpression: Utils.escapeExpression,
                    invokePartial: invokePartialWrapper,

                    fn: function fn(i) {
                        var ret = templateSpec[i];
                        ret.decorator = templateSpec[i + '_d'];
                        return ret;
                    },

                    programs: [],
                    program: function program(i, data, declaredBlockParams, blockParams, depths) {
                        var programWrapper = this.programs[i],
                            fn = this.fn(i);
                        if (data || depths || blockParams || declaredBlockParams) {
                            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                        } else if (!programWrapper) {
                            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                        }
                        return programWrapper;
                    },

                    data: function data(value, depth) {
                        while (value && depth--) {
                            value = value._parent;
                        }
                        return value;
                    },
                    merge: function merge(param, common) {
                        var obj = param || common;

                        if (param && common && param !== common) {
                            obj = Utils.extend({}, common, param);
                        }

                        return obj;
                    },
                    // An empty object to use as replacement for null-contexts
                    nullContext: _Object$seal({}),

                    noop: env.VM.noop,
                    compilerInfo: templateSpec.compiler
                };

                function ret(context) {
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    var data = options.data;

                    ret._setup(options);
                    if (!options.partial && templateSpec.useData) {
                        data = initData(context, data);
                    }
                    var depths = undefined,
                        blockParams = templateSpec.useBlockParams ? [] : undefined;
                    if (templateSpec.useDepths) {
                        if (options.depths) {
                            depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
                        } else {
                            depths = [context];
                        }
                    }

                    function main(context /*, options*/) {
                        return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
                    }

                    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
                    return main(context, options);
                }

                ret.isTop = true;

                ret._setup = function (options) {
                    if (!options.partial) {
                        container.helpers = container.merge(options.helpers, env.helpers);

                        if (templateSpec.usePartial) {
                            container.partials = container.merge(options.partials, env.partials);
                        }
                        if (templateSpec.usePartial || templateSpec.useDecorators) {
                            container.decorators = container.merge(options.decorators, env.decorators);
                        }
                    } else {
                        container.helpers = options.helpers;
                        container.partials = options.partials;
                        container.decorators = options.decorators;
                    }
                };

                ret._child = function (i, data, blockParams, depths) {
                    if (templateSpec.useBlockParams && !blockParams) {
                        throw new _exception2['default']('must pass block params');
                    }
                    if (templateSpec.useDepths && !depths) {
                        throw new _exception2['default']('must pass parent depths');
                    }

                    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
                };
                return ret;
            }

            function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
                function prog(context) {
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    var currentDepths = depths;
                    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
                        currentDepths = [context].concat(depths);
                    }

                    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
                }

                prog = executeDecorators(fn, prog, container, depths, data, blockParams);

                prog.program = i;
                prog.depth = depths ? depths.length : 0;
                prog.blockParams = declaredBlockParams || 0;
                return prog;
            }

            function resolvePartial(partial, context, options) {
                if (!partial) {
                    if (options.name === '@partial-block') {
                        partial = options.data['partial-block'];
                    } else {
                        partial = options.partials[options.name];
                    }
                } else if (!partial.call && !options.name) {
                    // This is a dynamic partial that returned a string
                    options.name = partial;
                    partial = options.partials[partial];
                }
                return partial;
            }

            function invokePartial(partial, context, options) {
                // Use the current closure context to save the partial-block if this partial
                var currentPartialBlock = options.data && options.data['partial-block'];
                options.partial = true;
                if (options.ids) {
                    options.data.contextPath = options.ids[0] || options.data.contextPath;
                }

                var partialBlock = undefined;
                if (options.fn && options.fn !== noop) {
                    (function () {
                        options.data = _base.createFrame(options.data);
                        // Wrapper function to get access to currentPartialBlock from the closure
                        var fn = options.fn;
                        partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
                            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                            // Restore the partial-block from the closure for the execution of the block
                            // i.e. the part inside the block of the partial call.
                            options.data = _base.createFrame(options.data);
                            options.data['partial-block'] = currentPartialBlock;
                            return fn(context, options);
                        };
                        if (fn.partials) {
                            options.partials = Utils.extend({}, options.partials, fn.partials);
                        }
                    })();
                }

                if (partial === undefined && partialBlock) {
                    partial = partialBlock;
                }

                if (partial === undefined) {
                    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
                } else if (partial instanceof Function) {
                    return partial(context, options);
                }
            }

            function noop() {
                return '';
            }

            function initData(context, data) {
                if (!data || !('root' in data)) {
                    data = data ? _base.createFrame(data) : {};
                    data.root = context;
                }
                return data;
            }

            function executeDecorators(fn, prog, container, depths, data, blockParams) {
                if (fn.decorator) {
                    var props = {};
                    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                    Utils.extend(prog, props);
                }
                return prog;
            }

            /***/
        }),
        /* 23 */
        /***/ (function (module, exports, __webpack_require__) {

            module.exports = {"default": __webpack_require__(24), __esModule: true};

            /***/
        }),
        /* 24 */
        /***/ (function (module, exports, __webpack_require__) {

            __webpack_require__(25);
            module.exports = __webpack_require__(30).Object.seal;

            /***/
        }),
        /* 25 */
        /***/ (function (module, exports, __webpack_require__) {

            // 19.1.2.17 Object.seal(O)
            var isObject = __webpack_require__(26);

            __webpack_require__(27)('seal', function ($seal) {
                return function seal(it) {
                    return $seal && isObject(it) ? $seal(it) : it;
                };
            });

            /***/
        }),
        /* 26 */
        /***/ (function (module, exports) {

            module.exports = function (it) {
                return typeof it === 'object' ? it !== null : typeof it === 'function';
            };

            /***/
        }),
        /* 27 */
        /***/ (function (module, exports, __webpack_require__) {

            // most Object methods by ES6 should accept primitives
            var $export = __webpack_require__(28)
                , core = __webpack_require__(30)
                , fails = __webpack_require__(33);
            module.exports = function (KEY, exec) {
                var fn = (core.Object || {})[KEY] || Object[KEY]
                    , exp = {};
                exp[KEY] = exec(fn);
                $export($export.S + $export.F * fails(function () {
                    fn(1);
                }), 'Object', exp);
            };

            /***/
        }),
        /* 28 */
        /***/ (function (module, exports, __webpack_require__) {

            var global = __webpack_require__(29)
                , core = __webpack_require__(30)
                , ctx = __webpack_require__(31)
                , PROTOTYPE = 'prototype';

            var $export = function (type, name, source) {
                var IS_FORCED = type & $export.F
                    , IS_GLOBAL = type & $export.G
                    , IS_STATIC = type & $export.S
                    , IS_PROTO = type & $export.P
                    , IS_BIND = type & $export.B
                    , IS_WRAP = type & $export.W
                    , exports = IS_GLOBAL ? core : core[name] || (core[name] = {})
                    , target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
                    , key, own, out;
                if (IS_GLOBAL) source = name;
                for (key in source) {
                    // contains in native
                    own = !IS_FORCED && target && key in target;
                    if (own && key in exports) continue;
                    // export native or passed
                    out = own ? target[key] : source[key];
                    // prevent global pollution for namespaces
                    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
                        // bind timers to global for call from export context
                        : IS_BIND && own ? ctx(out, global)
                            // wrap global constructors for prevent change them in library
                            : IS_WRAP && target[key] == out ? (function (C) {
                                var F = function (param) {
                                    return this instanceof C ? new C(param) : C(param);
                                };
                                F[PROTOTYPE] = C[PROTOTYPE];
                                return F;
                                // make static versions for prototype methods
                            })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
                    if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
                }
            };
            // type bitmap
            $export.F = 1;  // forced
            $export.G = 2;  // global
            $export.S = 4;  // static
            $export.P = 8;  // proto
            $export.B = 16; // bind
            $export.W = 32; // wrap
            module.exports = $export;

            /***/
        }),
        /* 29 */
        /***/ (function (module, exports) {

            // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
            var global = module.exports = typeof window != 'undefined' && window.Math == Math
                ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
            if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

            /***/
        }),
        /* 30 */
        /***/ (function (module, exports) {

            var core = module.exports = {version: '1.2.6'};
            if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

            /***/
        }),
        /* 31 */
        /***/ (function (module, exports, __webpack_require__) {

            // optional / simple context binding
            var aFunction = __webpack_require__(32);
            module.exports = function (fn, that, length) {
                aFunction(fn);
                if (that === undefined) return fn;
                switch (length) {
                    case 1:
                        return function (a) {
                            return fn.call(that, a);
                        };
                    case 2:
                        return function (a, b) {
                            return fn.call(that, a, b);
                        };
                    case 3:
                        return function (a, b, c) {
                            return fn.call(that, a, b, c);
                        };
                }
                return function (/* ...args */) {
                    return fn.apply(that, arguments);
                };
            };

            /***/
        }),
        /* 32 */
        /***/ (function (module, exports) {

            module.exports = function (it) {
                if (typeof it != 'function') throw TypeError(it + ' is not a function!');
                return it;
            };

            /***/
        }),
        /* 33 */
        /***/ (function (module, exports) {

            module.exports = function (exec) {
                try {
                    return !!exec();
                } catch (e) {
                    return true;
                }
            };

            /***/
        }),
        /* 34 */
        /***/ (function (module, exports) {

            /* WEBPACK VAR INJECTION */
            (function (global) {/* global window */
                'use strict';

                exports.__esModule = true;

                exports['default'] = function (Handlebars) {
                    /* istanbul ignore next */
                    var root = typeof global !== 'undefined' ? global : window,
                        $Handlebars = root.Handlebars;
                    /* istanbul ignore next */
                    Handlebars.noConflict = function () {
                        if (root.Handlebars === Handlebars) {
                            root.Handlebars = $Handlebars;
                        }
                        return Handlebars;
                    };
                };

                module.exports = exports['default'];
                /* WEBPACK VAR INJECTION */
            }.call(exports, (function () {
                return this;
            }())))

            /***/
        }),
        /* 35 */
        /***/ (function (module, exports) {

            'use strict';

            exports.__esModule = true;
            var AST = {
                // Public API used to evaluate derived attributes regarding AST nodes
                helpers: {
                    // a mustache is definitely a helper if:
                    // * it is an eligible helper, and
                    // * it has at least one parameter or hash segment
                    helperExpression: function helperExpression(node) {
                        return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
                    },

                    scopedId: function scopedId(path) {
                        return (/^\.|this\b/.test(path.original)
                        );
                    },

                    // an ID is simple if it only has one part, and that part is not
                    // `..` or `this`.
                    simpleId: function simpleId(path) {
                        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
                    }
                }
            };

            // Must be exported as an object rather than the root of the module as the jison lexer
            // must modify the object to operate properly.
            exports['default'] = AST;
            module.exports = exports['default'];

            /***/
        }),
        /* 36 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            exports.__esModule = true;
            exports.parse = parse;

            var _parser = __webpack_require__(37);

            var _parser2 = _interopRequireDefault(_parser);

            var _whitespaceControl = __webpack_require__(38);

            var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

            var _helpers = __webpack_require__(40);

            var Helpers = _interopRequireWildcard(_helpers);

            var _utils = __webpack_require__(5);

            exports.parser = _parser2['default'];

            var yy = {};
            _utils.extend(yy, Helpers);

            function parse(input, options) {
                // Just return if an already-compiled AST was passed in.
                if (input.type === 'Program') {
                    return input;
                }

                _parser2['default'].yy = yy;

                // Altering the shared object here, but this is ok as parser is a sync operation
                yy.locInfo = function (locInfo) {
                    return new yy.SourceLocation(options && options.srcName, locInfo);
                };

                var strip = new _whitespaceControl2['default'](options);
                return strip.accept(_parser2['default'].parse(input));
            }

            /***/
        }),
        /* 37 */
        /***/ (function (module, exports) {

            // File ignored in coverage tests via setting in .istanbul.yml
            /* Jison generated parser */
            "use strict";

            exports.__esModule = true;
            var handlebars = (function () {
                var parser = {
                    trace: function trace() {
                    },
                    yy: {},
                    symbols_: {
                        "error": 2,
                        "root": 3,
                        "program": 4,
                        "EOF": 5,
                        "program_repetition0": 6,
                        "statement": 7,
                        "mustache": 8,
                        "block": 9,
                        "rawBlock": 10,
                        "partial": 11,
                        "partialBlock": 12,
                        "content": 13,
                        "COMMENT": 14,
                        "CONTENT": 15,
                        "openRawBlock": 16,
                        "rawBlock_repetition_plus0": 17,
                        "END_RAW_BLOCK": 18,
                        "OPEN_RAW_BLOCK": 19,
                        "helperName": 20,
                        "openRawBlock_repetition0": 21,
                        "openRawBlock_option0": 22,
                        "CLOSE_RAW_BLOCK": 23,
                        "openBlock": 24,
                        "block_option0": 25,
                        "closeBlock": 26,
                        "openInverse": 27,
                        "block_option1": 28,
                        "OPEN_BLOCK": 29,
                        "openBlock_repetition0": 30,
                        "openBlock_option0": 31,
                        "openBlock_option1": 32,
                        "CLOSE": 33,
                        "OPEN_INVERSE": 34,
                        "openInverse_repetition0": 35,
                        "openInverse_option0": 36,
                        "openInverse_option1": 37,
                        "openInverseChain": 38,
                        "OPEN_INVERSE_CHAIN": 39,
                        "openInverseChain_repetition0": 40,
                        "openInverseChain_option0": 41,
                        "openInverseChain_option1": 42,
                        "inverseAndProgram": 43,
                        "INVERSE": 44,
                        "inverseChain": 45,
                        "inverseChain_option0": 46,
                        "OPEN_ENDBLOCK": 47,
                        "OPEN": 48,
                        "mustache_repetition0": 49,
                        "mustache_option0": 50,
                        "OPEN_UNESCAPED": 51,
                        "mustache_repetition1": 52,
                        "mustache_option1": 53,
                        "CLOSE_UNESCAPED": 54,
                        "OPEN_PARTIAL": 55,
                        "partialName": 56,
                        "partial_repetition0": 57,
                        "partial_option0": 58,
                        "openPartialBlock": 59,
                        "OPEN_PARTIAL_BLOCK": 60,
                        "openPartialBlock_repetition0": 61,
                        "openPartialBlock_option0": 62,
                        "param": 63,
                        "sexpr": 64,
                        "OPEN_SEXPR": 65,
                        "sexpr_repetition0": 66,
                        "sexpr_option0": 67,
                        "CLOSE_SEXPR": 68,
                        "hash": 69,
                        "hash_repetition_plus0": 70,
                        "hashSegment": 71,
                        "ID": 72,
                        "EQUALS": 73,
                        "blockParams": 74,
                        "OPEN_BLOCK_PARAMS": 75,
                        "blockParams_repetition_plus0": 76,
                        "CLOSE_BLOCK_PARAMS": 77,
                        "path": 78,
                        "dataName": 79,
                        "STRING": 80,
                        "NUMBER": 81,
                        "BOOLEAN": 82,
                        "UNDEFINED": 83,
                        "NULL": 84,
                        "DATA": 85,
                        "pathSegments": 86,
                        "SEP": 87,
                        "$accept": 0,
                        "$end": 1
                    },
                    terminals_: {
                        2: "error",
                        5: "EOF",
                        14: "COMMENT",
                        15: "CONTENT",
                        18: "END_RAW_BLOCK",
                        19: "OPEN_RAW_BLOCK",
                        23: "CLOSE_RAW_BLOCK",
                        29: "OPEN_BLOCK",
                        33: "CLOSE",
                        34: "OPEN_INVERSE",
                        39: "OPEN_INVERSE_CHAIN",
                        44: "INVERSE",
                        47: "OPEN_ENDBLOCK",
                        48: "OPEN",
                        51: "OPEN_UNESCAPED",
                        54: "CLOSE_UNESCAPED",
                        55: "OPEN_PARTIAL",
                        60: "OPEN_PARTIAL_BLOCK",
                        65: "OPEN_SEXPR",
                        68: "CLOSE_SEXPR",
                        72: "ID",
                        73: "EQUALS",
                        75: "OPEN_BLOCK_PARAMS",
                        77: "CLOSE_BLOCK_PARAMS",
                        80: "STRING",
                        81: "NUMBER",
                        82: "BOOLEAN",
                        83: "UNDEFINED",
                        84: "NULL",
                        85: "DATA",
                        87: "SEP"
                    },
                    productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
                    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
                                                      /**/) {

                        var $0 = $$.length - 1;
                        switch (yystate) {
                            case 1:
                                return $$[$0 - 1];
                                break;
                            case 2:
                                this.$ = yy.prepareProgram($$[$0]);
                                break;
                            case 3:
                                this.$ = $$[$0];
                                break;
                            case 4:
                                this.$ = $$[$0];
                                break;
                            case 5:
                                this.$ = $$[$0];
                                break;
                            case 6:
                                this.$ = $$[$0];
                                break;
                            case 7:
                                this.$ = $$[$0];
                                break;
                            case 8:
                                this.$ = $$[$0];
                                break;
                            case 9:
                                this.$ = {
                                    type: 'CommentStatement',
                                    value: yy.stripComment($$[$0]),
                                    strip: yy.stripFlags($$[$0], $$[$0]),
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 10:
                                this.$ = {
                                    type: 'ContentStatement',
                                    original: $$[$0],
                                    value: $$[$0],
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 11:
                                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                break;
                            case 12:
                                this.$ = {path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1]};
                                break;
                            case 13:
                                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                                break;
                            case 14:
                                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                                break;
                            case 15:
                                this.$ = {
                                    open: $$[$0 - 5],
                                    path: $$[$0 - 4],
                                    params: $$[$0 - 3],
                                    hash: $$[$0 - 2],
                                    blockParams: $$[$0 - 1],
                                    strip: yy.stripFlags($$[$0 - 5], $$[$0])
                                };
                                break;
                            case 16:
                                this.$ = {
                                    path: $$[$0 - 4],
                                    params: $$[$0 - 3],
                                    hash: $$[$0 - 2],
                                    blockParams: $$[$0 - 1],
                                    strip: yy.stripFlags($$[$0 - 5], $$[$0])
                                };
                                break;
                            case 17:
                                this.$ = {
                                    path: $$[$0 - 4],
                                    params: $$[$0 - 3],
                                    hash: $$[$0 - 2],
                                    blockParams: $$[$0 - 1],
                                    strip: yy.stripFlags($$[$0 - 5], $$[$0])
                                };
                                break;
                            case 18:
                                this.$ = {strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0]};
                                break;
                            case 19:
                                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                                    program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                                program.chained = true;

                                this.$ = {strip: $$[$0 - 2].strip, program: program, chain: true};

                                break;
                            case 20:
                                this.$ = $$[$0];
                                break;
                            case 21:
                                this.$ = {path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0])};
                                break;
                            case 22:
                                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                break;
                            case 23:
                                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                break;
                            case 24:
                                this.$ = {
                                    type: 'PartialStatement',
                                    name: $$[$0 - 3],
                                    params: $$[$0 - 2],
                                    hash: $$[$0 - 1],
                                    indent: '',
                                    strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 25:
                                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                break;
                            case 26:
                                this.$ = {
                                    path: $$[$0 - 3],
                                    params: $$[$0 - 2],
                                    hash: $$[$0 - 1],
                                    strip: yy.stripFlags($$[$0 - 4], $$[$0])
                                };
                                break;
                            case 27:
                                this.$ = $$[$0];
                                break;
                            case 28:
                                this.$ = $$[$0];
                                break;
                            case 29:
                                this.$ = {
                                    type: 'SubExpression',
                                    path: $$[$0 - 3],
                                    params: $$[$0 - 2],
                                    hash: $$[$0 - 1],
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 30:
                                this.$ = {type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$)};
                                break;
                            case 31:
                                this.$ = {
                                    type: 'HashPair',
                                    key: yy.id($$[$0 - 2]),
                                    value: $$[$0],
                                    loc: yy.locInfo(this._$)
                                };
                                break;
                            case 32:
                                this.$ = yy.id($$[$0 - 1]);
                                break;
                            case 33:
                                this.$ = $$[$0];
                                break;
                            case 34:
                                this.$ = $$[$0];
                                break;
                            case 35:
                                this.$ = {
                                    type: 'StringLiteral',
                                    value: $$[$0],
                                    original: $$[$0],
                                    loc: yy.locInfo(this._$)
                                };
                                break;
                            case 36:
                                this.$ = {
                                    type: 'NumberLiteral',
                                    value: Number($$[$0]),
                                    original: Number($$[$0]),
                                    loc: yy.locInfo(this._$)
                                };
                                break;
                            case 37:
                                this.$ = {
                                    type: 'BooleanLiteral',
                                    value: $$[$0] === 'true',
                                    original: $$[$0] === 'true',
                                    loc: yy.locInfo(this._$)
                                };
                                break;
                            case 38:
                                this.$ = {
                                    type: 'UndefinedLiteral',
                                    original: undefined,
                                    value: undefined,
                                    loc: yy.locInfo(this._$)
                                };
                                break;
                            case 39:
                                this.$ = {type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$)};
                                break;
                            case 40:
                                this.$ = $$[$0];
                                break;
                            case 41:
                                this.$ = $$[$0];
                                break;
                            case 42:
                                this.$ = yy.preparePath(true, $$[$0], this._$);
                                break;
                            case 43:
                                this.$ = yy.preparePath(false, $$[$0], this._$);
                                break;
                            case 44:
                                $$[$0 - 2].push({part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1]});
                                this.$ = $$[$0 - 2];
                                break;
                            case 45:
                                this.$ = [{part: yy.id($$[$0]), original: $$[$0]}];
                                break;
                            case 46:
                                this.$ = [];
                                break;
                            case 47:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 48:
                                this.$ = [$$[$0]];
                                break;
                            case 49:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 50:
                                this.$ = [];
                                break;
                            case 51:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 58:
                                this.$ = [];
                                break;
                            case 59:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 64:
                                this.$ = [];
                                break;
                            case 65:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 70:
                                this.$ = [];
                                break;
                            case 71:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 78:
                                this.$ = [];
                                break;
                            case 79:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 82:
                                this.$ = [];
                                break;
                            case 83:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 86:
                                this.$ = [];
                                break;
                            case 87:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 90:
                                this.$ = [];
                                break;
                            case 91:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 94:
                                this.$ = [];
                                break;
                            case 95:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 98:
                                this.$ = [$$[$0]];
                                break;
                            case 99:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 100:
                                this.$ = [$$[$0]];
                                break;
                            case 101:
                                $$[$0 - 1].push($$[$0]);
                                break;
                        }
                    },
                    table: [{
                        3: 1,
                        4: 2,
                        5: [2, 46],
                        6: 3,
                        14: [2, 46],
                        15: [2, 46],
                        19: [2, 46],
                        29: [2, 46],
                        34: [2, 46],
                        48: [2, 46],
                        51: [2, 46],
                        55: [2, 46],
                        60: [2, 46]
                    }, {1: [3]}, {5: [1, 4]}, {
                        5: [2, 2],
                        7: 5,
                        8: 6,
                        9: 7,
                        10: 8,
                        11: 9,
                        12: 10,
                        13: 11,
                        14: [1, 12],
                        15: [1, 20],
                        16: 17,
                        19: [1, 23],
                        24: 15,
                        27: 16,
                        29: [1, 21],
                        34: [1, 22],
                        39: [2, 2],
                        44: [2, 2],
                        47: [2, 2],
                        48: [1, 13],
                        51: [1, 14],
                        55: [1, 18],
                        59: 19,
                        60: [1, 24]
                    }, {1: [2, 1]}, {
                        5: [2, 47],
                        14: [2, 47],
                        15: [2, 47],
                        19: [2, 47],
                        29: [2, 47],
                        34: [2, 47],
                        39: [2, 47],
                        44: [2, 47],
                        47: [2, 47],
                        48: [2, 47],
                        51: [2, 47],
                        55: [2, 47],
                        60: [2, 47]
                    }, {
                        5: [2, 3],
                        14: [2, 3],
                        15: [2, 3],
                        19: [2, 3],
                        29: [2, 3],
                        34: [2, 3],
                        39: [2, 3],
                        44: [2, 3],
                        47: [2, 3],
                        48: [2, 3],
                        51: [2, 3],
                        55: [2, 3],
                        60: [2, 3]
                    }, {
                        5: [2, 4],
                        14: [2, 4],
                        15: [2, 4],
                        19: [2, 4],
                        29: [2, 4],
                        34: [2, 4],
                        39: [2, 4],
                        44: [2, 4],
                        47: [2, 4],
                        48: [2, 4],
                        51: [2, 4],
                        55: [2, 4],
                        60: [2, 4]
                    }, {
                        5: [2, 5],
                        14: [2, 5],
                        15: [2, 5],
                        19: [2, 5],
                        29: [2, 5],
                        34: [2, 5],
                        39: [2, 5],
                        44: [2, 5],
                        47: [2, 5],
                        48: [2, 5],
                        51: [2, 5],
                        55: [2, 5],
                        60: [2, 5]
                    }, {
                        5: [2, 6],
                        14: [2, 6],
                        15: [2, 6],
                        19: [2, 6],
                        29: [2, 6],
                        34: [2, 6],
                        39: [2, 6],
                        44: [2, 6],
                        47: [2, 6],
                        48: [2, 6],
                        51: [2, 6],
                        55: [2, 6],
                        60: [2, 6]
                    }, {
                        5: [2, 7],
                        14: [2, 7],
                        15: [2, 7],
                        19: [2, 7],
                        29: [2, 7],
                        34: [2, 7],
                        39: [2, 7],
                        44: [2, 7],
                        47: [2, 7],
                        48: [2, 7],
                        51: [2, 7],
                        55: [2, 7],
                        60: [2, 7]
                    }, {
                        5: [2, 8],
                        14: [2, 8],
                        15: [2, 8],
                        19: [2, 8],
                        29: [2, 8],
                        34: [2, 8],
                        39: [2, 8],
                        44: [2, 8],
                        47: [2, 8],
                        48: [2, 8],
                        51: [2, 8],
                        55: [2, 8],
                        60: [2, 8]
                    }, {
                        5: [2, 9],
                        14: [2, 9],
                        15: [2, 9],
                        19: [2, 9],
                        29: [2, 9],
                        34: [2, 9],
                        39: [2, 9],
                        44: [2, 9],
                        47: [2, 9],
                        48: [2, 9],
                        51: [2, 9],
                        55: [2, 9],
                        60: [2, 9]
                    }, {
                        20: 25,
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        20: 36,
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        4: 37,
                        6: 3,
                        14: [2, 46],
                        15: [2, 46],
                        19: [2, 46],
                        29: [2, 46],
                        34: [2, 46],
                        39: [2, 46],
                        44: [2, 46],
                        47: [2, 46],
                        48: [2, 46],
                        51: [2, 46],
                        55: [2, 46],
                        60: [2, 46]
                    }, {
                        4: 38,
                        6: 3,
                        14: [2, 46],
                        15: [2, 46],
                        19: [2, 46],
                        29: [2, 46],
                        34: [2, 46],
                        44: [2, 46],
                        47: [2, 46],
                        48: [2, 46],
                        51: [2, 46],
                        55: [2, 46],
                        60: [2, 46]
                    }, {13: 40, 15: [1, 20], 17: 39}, {
                        20: 42,
                        56: 41,
                        64: 43,
                        65: [1, 44],
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        4: 45,
                        6: 3,
                        14: [2, 46],
                        15: [2, 46],
                        19: [2, 46],
                        29: [2, 46],
                        34: [2, 46],
                        47: [2, 46],
                        48: [2, 46],
                        51: [2, 46],
                        55: [2, 46],
                        60: [2, 46]
                    }, {
                        5: [2, 10],
                        14: [2, 10],
                        15: [2, 10],
                        18: [2, 10],
                        19: [2, 10],
                        29: [2, 10],
                        34: [2, 10],
                        39: [2, 10],
                        44: [2, 10],
                        47: [2, 10],
                        48: [2, 10],
                        51: [2, 10],
                        55: [2, 10],
                        60: [2, 10]
                    }, {
                        20: 46,
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        20: 47,
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        20: 48,
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        20: 42,
                        56: 49,
                        64: 43,
                        65: [1, 44],
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        33: [2, 78],
                        49: 50,
                        65: [2, 78],
                        72: [2, 78],
                        80: [2, 78],
                        81: [2, 78],
                        82: [2, 78],
                        83: [2, 78],
                        84: [2, 78],
                        85: [2, 78]
                    }, {
                        23: [2, 33],
                        33: [2, 33],
                        54: [2, 33],
                        65: [2, 33],
                        68: [2, 33],
                        72: [2, 33],
                        75: [2, 33],
                        80: [2, 33],
                        81: [2, 33],
                        82: [2, 33],
                        83: [2, 33],
                        84: [2, 33],
                        85: [2, 33]
                    }, {
                        23: [2, 34],
                        33: [2, 34],
                        54: [2, 34],
                        65: [2, 34],
                        68: [2, 34],
                        72: [2, 34],
                        75: [2, 34],
                        80: [2, 34],
                        81: [2, 34],
                        82: [2, 34],
                        83: [2, 34],
                        84: [2, 34],
                        85: [2, 34]
                    }, {
                        23: [2, 35],
                        33: [2, 35],
                        54: [2, 35],
                        65: [2, 35],
                        68: [2, 35],
                        72: [2, 35],
                        75: [2, 35],
                        80: [2, 35],
                        81: [2, 35],
                        82: [2, 35],
                        83: [2, 35],
                        84: [2, 35],
                        85: [2, 35]
                    }, {
                        23: [2, 36],
                        33: [2, 36],
                        54: [2, 36],
                        65: [2, 36],
                        68: [2, 36],
                        72: [2, 36],
                        75: [2, 36],
                        80: [2, 36],
                        81: [2, 36],
                        82: [2, 36],
                        83: [2, 36],
                        84: [2, 36],
                        85: [2, 36]
                    }, {
                        23: [2, 37],
                        33: [2, 37],
                        54: [2, 37],
                        65: [2, 37],
                        68: [2, 37],
                        72: [2, 37],
                        75: [2, 37],
                        80: [2, 37],
                        81: [2, 37],
                        82: [2, 37],
                        83: [2, 37],
                        84: [2, 37],
                        85: [2, 37]
                    }, {
                        23: [2, 38],
                        33: [2, 38],
                        54: [2, 38],
                        65: [2, 38],
                        68: [2, 38],
                        72: [2, 38],
                        75: [2, 38],
                        80: [2, 38],
                        81: [2, 38],
                        82: [2, 38],
                        83: [2, 38],
                        84: [2, 38],
                        85: [2, 38]
                    }, {
                        23: [2, 39],
                        33: [2, 39],
                        54: [2, 39],
                        65: [2, 39],
                        68: [2, 39],
                        72: [2, 39],
                        75: [2, 39],
                        80: [2, 39],
                        81: [2, 39],
                        82: [2, 39],
                        83: [2, 39],
                        84: [2, 39],
                        85: [2, 39]
                    }, {
                        23: [2, 43],
                        33: [2, 43],
                        54: [2, 43],
                        65: [2, 43],
                        68: [2, 43],
                        72: [2, 43],
                        75: [2, 43],
                        80: [2, 43],
                        81: [2, 43],
                        82: [2, 43],
                        83: [2, 43],
                        84: [2, 43],
                        85: [2, 43],
                        87: [1, 51]
                    }, {72: [1, 35], 86: 52}, {
                        23: [2, 45],
                        33: [2, 45],
                        54: [2, 45],
                        65: [2, 45],
                        68: [2, 45],
                        72: [2, 45],
                        75: [2, 45],
                        80: [2, 45],
                        81: [2, 45],
                        82: [2, 45],
                        83: [2, 45],
                        84: [2, 45],
                        85: [2, 45],
                        87: [2, 45]
                    }, {
                        52: 53,
                        54: [2, 82],
                        65: [2, 82],
                        72: [2, 82],
                        80: [2, 82],
                        81: [2, 82],
                        82: [2, 82],
                        83: [2, 82],
                        84: [2, 82],
                        85: [2, 82]
                    }, {25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54]}, {
                        28: 60,
                        43: 61,
                        44: [1, 59],
                        47: [2, 56]
                    }, {13: 63, 15: [1, 20], 18: [1, 62]}, {15: [2, 48], 18: [2, 48]}, {
                        33: [2, 86],
                        57: 64,
                        65: [2, 86],
                        72: [2, 86],
                        80: [2, 86],
                        81: [2, 86],
                        82: [2, 86],
                        83: [2, 86],
                        84: [2, 86],
                        85: [2, 86]
                    }, {
                        33: [2, 40],
                        65: [2, 40],
                        72: [2, 40],
                        80: [2, 40],
                        81: [2, 40],
                        82: [2, 40],
                        83: [2, 40],
                        84: [2, 40],
                        85: [2, 40]
                    }, {
                        33: [2, 41],
                        65: [2, 41],
                        72: [2, 41],
                        80: [2, 41],
                        81: [2, 41],
                        82: [2, 41],
                        83: [2, 41],
                        84: [2, 41],
                        85: [2, 41]
                    }, {
                        20: 65,
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {26: 66, 47: [1, 67]}, {
                        30: 68,
                        33: [2, 58],
                        65: [2, 58],
                        72: [2, 58],
                        75: [2, 58],
                        80: [2, 58],
                        81: [2, 58],
                        82: [2, 58],
                        83: [2, 58],
                        84: [2, 58],
                        85: [2, 58]
                    }, {
                        33: [2, 64],
                        35: 69,
                        65: [2, 64],
                        72: [2, 64],
                        75: [2, 64],
                        80: [2, 64],
                        81: [2, 64],
                        82: [2, 64],
                        83: [2, 64],
                        84: [2, 64],
                        85: [2, 64]
                    }, {
                        21: 70,
                        23: [2, 50],
                        65: [2, 50],
                        72: [2, 50],
                        80: [2, 50],
                        81: [2, 50],
                        82: [2, 50],
                        83: [2, 50],
                        84: [2, 50],
                        85: [2, 50]
                    }, {
                        33: [2, 90],
                        61: 71,
                        65: [2, 90],
                        72: [2, 90],
                        80: [2, 90],
                        81: [2, 90],
                        82: [2, 90],
                        83: [2, 90],
                        84: [2, 90],
                        85: [2, 90]
                    }, {
                        20: 75,
                        33: [2, 80],
                        50: 72,
                        63: 73,
                        64: 76,
                        65: [1, 44],
                        69: 74,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {72: [1, 80]}, {
                        23: [2, 42],
                        33: [2, 42],
                        54: [2, 42],
                        65: [2, 42],
                        68: [2, 42],
                        72: [2, 42],
                        75: [2, 42],
                        80: [2, 42],
                        81: [2, 42],
                        82: [2, 42],
                        83: [2, 42],
                        84: [2, 42],
                        85: [2, 42],
                        87: [1, 51]
                    }, {
                        20: 75,
                        53: 81,
                        54: [2, 84],
                        63: 82,
                        64: 76,
                        65: [1, 44],
                        69: 83,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {26: 84, 47: [1, 67]}, {47: [2, 55]}, {
                        4: 85,
                        6: 3,
                        14: [2, 46],
                        15: [2, 46],
                        19: [2, 46],
                        29: [2, 46],
                        34: [2, 46],
                        39: [2, 46],
                        44: [2, 46],
                        47: [2, 46],
                        48: [2, 46],
                        51: [2, 46],
                        55: [2, 46],
                        60: [2, 46]
                    }, {47: [2, 20]}, {
                        20: 86,
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        4: 87,
                        6: 3,
                        14: [2, 46],
                        15: [2, 46],
                        19: [2, 46],
                        29: [2, 46],
                        34: [2, 46],
                        47: [2, 46],
                        48: [2, 46],
                        51: [2, 46],
                        55: [2, 46],
                        60: [2, 46]
                    }, {26: 88, 47: [1, 67]}, {47: [2, 57]}, {
                        5: [2, 11],
                        14: [2, 11],
                        15: [2, 11],
                        19: [2, 11],
                        29: [2, 11],
                        34: [2, 11],
                        39: [2, 11],
                        44: [2, 11],
                        47: [2, 11],
                        48: [2, 11],
                        51: [2, 11],
                        55: [2, 11],
                        60: [2, 11]
                    }, {15: [2, 49], 18: [2, 49]}, {
                        20: 75,
                        33: [2, 88],
                        58: 89,
                        63: 90,
                        64: 76,
                        65: [1, 44],
                        69: 91,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        65: [2, 94],
                        66: 92,
                        68: [2, 94],
                        72: [2, 94],
                        80: [2, 94],
                        81: [2, 94],
                        82: [2, 94],
                        83: [2, 94],
                        84: [2, 94],
                        85: [2, 94]
                    }, {
                        5: [2, 25],
                        14: [2, 25],
                        15: [2, 25],
                        19: [2, 25],
                        29: [2, 25],
                        34: [2, 25],
                        39: [2, 25],
                        44: [2, 25],
                        47: [2, 25],
                        48: [2, 25],
                        51: [2, 25],
                        55: [2, 25],
                        60: [2, 25]
                    }, {
                        20: 93,
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        20: 75,
                        31: 94,
                        33: [2, 60],
                        63: 95,
                        64: 76,
                        65: [1, 44],
                        69: 96,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        75: [2, 60],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        20: 75,
                        33: [2, 66],
                        36: 97,
                        63: 98,
                        64: 76,
                        65: [1, 44],
                        69: 99,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        75: [2, 66],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        20: 75,
                        22: 100,
                        23: [2, 52],
                        63: 101,
                        64: 76,
                        65: [1, 44],
                        69: 102,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        20: 75,
                        33: [2, 92],
                        62: 103,
                        63: 104,
                        64: 76,
                        65: [1, 44],
                        69: 105,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {33: [1, 106]}, {
                        33: [2, 79],
                        65: [2, 79],
                        72: [2, 79],
                        80: [2, 79],
                        81: [2, 79],
                        82: [2, 79],
                        83: [2, 79],
                        84: [2, 79],
                        85: [2, 79]
                    }, {33: [2, 81]}, {
                        23: [2, 27],
                        33: [2, 27],
                        54: [2, 27],
                        65: [2, 27],
                        68: [2, 27],
                        72: [2, 27],
                        75: [2, 27],
                        80: [2, 27],
                        81: [2, 27],
                        82: [2, 27],
                        83: [2, 27],
                        84: [2, 27],
                        85: [2, 27]
                    }, {
                        23: [2, 28],
                        33: [2, 28],
                        54: [2, 28],
                        65: [2, 28],
                        68: [2, 28],
                        72: [2, 28],
                        75: [2, 28],
                        80: [2, 28],
                        81: [2, 28],
                        82: [2, 28],
                        83: [2, 28],
                        84: [2, 28],
                        85: [2, 28]
                    }, {
                        23: [2, 30],
                        33: [2, 30],
                        54: [2, 30],
                        68: [2, 30],
                        71: 107,
                        72: [1, 108],
                        75: [2, 30]
                    }, {23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98]}, {
                        23: [2, 45],
                        33: [2, 45],
                        54: [2, 45],
                        65: [2, 45],
                        68: [2, 45],
                        72: [2, 45],
                        73: [1, 109],
                        75: [2, 45],
                        80: [2, 45],
                        81: [2, 45],
                        82: [2, 45],
                        83: [2, 45],
                        84: [2, 45],
                        85: [2, 45],
                        87: [2, 45]
                    }, {
                        23: [2, 44],
                        33: [2, 44],
                        54: [2, 44],
                        65: [2, 44],
                        68: [2, 44],
                        72: [2, 44],
                        75: [2, 44],
                        80: [2, 44],
                        81: [2, 44],
                        82: [2, 44],
                        83: [2, 44],
                        84: [2, 44],
                        85: [2, 44],
                        87: [2, 44]
                    }, {54: [1, 110]}, {
                        54: [2, 83],
                        65: [2, 83],
                        72: [2, 83],
                        80: [2, 83],
                        81: [2, 83],
                        82: [2, 83],
                        83: [2, 83],
                        84: [2, 83],
                        85: [2, 83]
                    }, {54: [2, 85]}, {
                        5: [2, 13],
                        14: [2, 13],
                        15: [2, 13],
                        19: [2, 13],
                        29: [2, 13],
                        34: [2, 13],
                        39: [2, 13],
                        44: [2, 13],
                        47: [2, 13],
                        48: [2, 13],
                        51: [2, 13],
                        55: [2, 13],
                        60: [2, 13]
                    }, {38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76]}, {
                        33: [2, 70],
                        40: 113,
                        65: [2, 70],
                        72: [2, 70],
                        75: [2, 70],
                        80: [2, 70],
                        81: [2, 70],
                        82: [2, 70],
                        83: [2, 70],
                        84: [2, 70],
                        85: [2, 70]
                    }, {47: [2, 18]}, {
                        5: [2, 14],
                        14: [2, 14],
                        15: [2, 14],
                        19: [2, 14],
                        29: [2, 14],
                        34: [2, 14],
                        39: [2, 14],
                        44: [2, 14],
                        47: [2, 14],
                        48: [2, 14],
                        51: [2, 14],
                        55: [2, 14],
                        60: [2, 14]
                    }, {33: [1, 114]}, {
                        33: [2, 87],
                        65: [2, 87],
                        72: [2, 87],
                        80: [2, 87],
                        81: [2, 87],
                        82: [2, 87],
                        83: [2, 87],
                        84: [2, 87],
                        85: [2, 87]
                    }, {33: [2, 89]}, {
                        20: 75,
                        63: 116,
                        64: 76,
                        65: [1, 44],
                        67: 115,
                        68: [2, 96],
                        69: 117,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {33: [1, 118]}, {32: 119, 33: [2, 62], 74: 120, 75: [1, 121]}, {
                        33: [2, 59],
                        65: [2, 59],
                        72: [2, 59],
                        75: [2, 59],
                        80: [2, 59],
                        81: [2, 59],
                        82: [2, 59],
                        83: [2, 59],
                        84: [2, 59],
                        85: [2, 59]
                    }, {33: [2, 61], 75: [2, 61]}, {33: [2, 68], 37: 122, 74: 123, 75: [1, 121]}, {
                        33: [2, 65],
                        65: [2, 65],
                        72: [2, 65],
                        75: [2, 65],
                        80: [2, 65],
                        81: [2, 65],
                        82: [2, 65],
                        83: [2, 65],
                        84: [2, 65],
                        85: [2, 65]
                    }, {33: [2, 67], 75: [2, 67]}, {23: [1, 124]}, {
                        23: [2, 51],
                        65: [2, 51],
                        72: [2, 51],
                        80: [2, 51],
                        81: [2, 51],
                        82: [2, 51],
                        83: [2, 51],
                        84: [2, 51],
                        85: [2, 51]
                    }, {23: [2, 53]}, {33: [1, 125]}, {
                        33: [2, 91],
                        65: [2, 91],
                        72: [2, 91],
                        80: [2, 91],
                        81: [2, 91],
                        82: [2, 91],
                        83: [2, 91],
                        84: [2, 91],
                        85: [2, 91]
                    }, {33: [2, 93]}, {
                        5: [2, 22],
                        14: [2, 22],
                        15: [2, 22],
                        19: [2, 22],
                        29: [2, 22],
                        34: [2, 22],
                        39: [2, 22],
                        44: [2, 22],
                        47: [2, 22],
                        48: [2, 22],
                        51: [2, 22],
                        55: [2, 22],
                        60: [2, 22]
                    }, {
                        23: [2, 99],
                        33: [2, 99],
                        54: [2, 99],
                        68: [2, 99],
                        72: [2, 99],
                        75: [2, 99]
                    }, {73: [1, 109]}, {
                        20: 75,
                        63: 126,
                        64: 76,
                        65: [1, 44],
                        72: [1, 35],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        5: [2, 23],
                        14: [2, 23],
                        15: [2, 23],
                        19: [2, 23],
                        29: [2, 23],
                        34: [2, 23],
                        39: [2, 23],
                        44: [2, 23],
                        47: [2, 23],
                        48: [2, 23],
                        51: [2, 23],
                        55: [2, 23],
                        60: [2, 23]
                    }, {47: [2, 19]}, {47: [2, 77]}, {
                        20: 75,
                        33: [2, 72],
                        41: 127,
                        63: 128,
                        64: 76,
                        65: [1, 44],
                        69: 129,
                        70: 77,
                        71: 78,
                        72: [1, 79],
                        75: [2, 72],
                        78: 26,
                        79: 27,
                        80: [1, 28],
                        81: [1, 29],
                        82: [1, 30],
                        83: [1, 31],
                        84: [1, 32],
                        85: [1, 34],
                        86: 33
                    }, {
                        5: [2, 24],
                        14: [2, 24],
                        15: [2, 24],
                        19: [2, 24],
                        29: [2, 24],
                        34: [2, 24],
                        39: [2, 24],
                        44: [2, 24],
                        47: [2, 24],
                        48: [2, 24],
                        51: [2, 24],
                        55: [2, 24],
                        60: [2, 24]
                    }, {68: [1, 130]}, {
                        65: [2, 95],
                        68: [2, 95],
                        72: [2, 95],
                        80: [2, 95],
                        81: [2, 95],
                        82: [2, 95],
                        83: [2, 95],
                        84: [2, 95],
                        85: [2, 95]
                    }, {68: [2, 97]}, {
                        5: [2, 21],
                        14: [2, 21],
                        15: [2, 21],
                        19: [2, 21],
                        29: [2, 21],
                        34: [2, 21],
                        39: [2, 21],
                        44: [2, 21],
                        47: [2, 21],
                        48: [2, 21],
                        51: [2, 21],
                        55: [2, 21],
                        60: [2, 21]
                    }, {33: [1, 131]}, {33: [2, 63]}, {
                        72: [1, 133],
                        76: 132
                    }, {33: [1, 134]}, {33: [2, 69]}, {15: [2, 12]}, {
                        14: [2, 26],
                        15: [2, 26],
                        19: [2, 26],
                        29: [2, 26],
                        34: [2, 26],
                        47: [2, 26],
                        48: [2, 26],
                        51: [2, 26],
                        55: [2, 26],
                        60: [2, 26]
                    }, {23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31]}, {
                        33: [2, 74],
                        42: 135,
                        74: 136,
                        75: [1, 121]
                    }, {
                        33: [2, 71],
                        65: [2, 71],
                        72: [2, 71],
                        75: [2, 71],
                        80: [2, 71],
                        81: [2, 71],
                        82: [2, 71],
                        83: [2, 71],
                        84: [2, 71],
                        85: [2, 71]
                    }, {33: [2, 73], 75: [2, 73]}, {
                        23: [2, 29],
                        33: [2, 29],
                        54: [2, 29],
                        65: [2, 29],
                        68: [2, 29],
                        72: [2, 29],
                        75: [2, 29],
                        80: [2, 29],
                        81: [2, 29],
                        82: [2, 29],
                        83: [2, 29],
                        84: [2, 29],
                        85: [2, 29]
                    }, {
                        14: [2, 15],
                        15: [2, 15],
                        19: [2, 15],
                        29: [2, 15],
                        34: [2, 15],
                        39: [2, 15],
                        44: [2, 15],
                        47: [2, 15],
                        48: [2, 15],
                        51: [2, 15],
                        55: [2, 15],
                        60: [2, 15]
                    }, {72: [1, 138], 77: [1, 137]}, {72: [2, 100], 77: [2, 100]}, {
                        14: [2, 16],
                        15: [2, 16],
                        19: [2, 16],
                        29: [2, 16],
                        34: [2, 16],
                        44: [2, 16],
                        47: [2, 16],
                        48: [2, 16],
                        51: [2, 16],
                        55: [2, 16],
                        60: [2, 16]
                    }, {33: [1, 139]}, {33: [2, 75]}, {33: [2, 32]}, {72: [2, 101], 77: [2, 101]}, {
                        14: [2, 17],
                        15: [2, 17],
                        19: [2, 17],
                        29: [2, 17],
                        34: [2, 17],
                        39: [2, 17],
                        44: [2, 17],
                        47: [2, 17],
                        48: [2, 17],
                        51: [2, 17],
                        55: [2, 17],
                        60: [2, 17]
                    }],
                    defaultActions: {
                        4: [2, 1],
                        55: [2, 55],
                        57: [2, 20],
                        61: [2, 57],
                        74: [2, 81],
                        83: [2, 85],
                        87: [2, 18],
                        91: [2, 89],
                        102: [2, 53],
                        105: [2, 93],
                        111: [2, 19],
                        112: [2, 77],
                        117: [2, 97],
                        120: [2, 63],
                        123: [2, 69],
                        124: [2, 12],
                        136: [2, 75],
                        137: [2, 32]
                    },
                    parseError: function parseError(str, hash) {
                        throw new Error(str);
                    },
                    parse: function parse(input) {
                        var self = this,
                            stack = [0],
                            vstack = [null],
                            lstack = [],
                            table = this.table,
                            yytext = "",
                            yylineno = 0,
                            yyleng = 0,
                            recovering = 0,
                            TERROR = 2,
                            EOF = 1;
                        this.lexer.setInput(input);
                        this.lexer.yy = this.yy;
                        this.yy.lexer = this.lexer;
                        this.yy.parser = this;
                        if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
                        var yyloc = this.lexer.yylloc;
                        lstack.push(yyloc);
                        var ranges = this.lexer.options && this.lexer.options.ranges;
                        if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;

                        function popStack(n) {
                            stack.length = stack.length - 2 * n;
                            vstack.length = vstack.length - n;
                            lstack.length = lstack.length - n;
                        }

                        function lex() {
                            var token;
                            token = self.lexer.lex() || 1;
                            if (typeof token !== "number") {
                                token = self.symbols_[token] || token;
                            }
                            return token;
                        }

                        var symbol,
                            preErrorSymbol,
                            state,
                            action,
                            a,
                            r,
                            yyval = {},
                            p,
                            len,
                            newState,
                            expected;
                        while (true) {
                            state = stack[stack.length - 1];
                            if (this.defaultActions[state]) {
                                action = this.defaultActions[state];
                            } else {
                                if (symbol === null || typeof symbol == "undefined") {
                                    symbol = lex();
                                }
                                action = table[state] && table[state][symbol];
                            }
                            if (typeof action === "undefined" || !action.length || !action[0]) {
                                var errStr = "";
                                if (!recovering) {
                                    expected = [];
                                    for (p in table[state]) if (this.terminals_[p] && p > 2) {
                                        expected.push("'" + this.terminals_[p] + "'");
                                    }
                                    if (this.lexer.showPosition) {
                                        errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                                    } else {
                                        errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                                    }
                                    this.parseError(errStr, {
                                        text: this.lexer.match,
                                        token: this.terminals_[symbol] || symbol,
                                        line: this.lexer.yylineno,
                                        loc: yyloc,
                                        expected: expected
                                    });
                                }
                            }
                            if (action[0] instanceof Array && action.length > 1) {
                                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                            }
                            switch (action[0]) {
                                case 1:
                                    stack.push(symbol);
                                    vstack.push(this.lexer.yytext);
                                    lstack.push(this.lexer.yylloc);
                                    stack.push(action[1]);
                                    symbol = null;
                                    if (!preErrorSymbol) {
                                        yyleng = this.lexer.yyleng;
                                        yytext = this.lexer.yytext;
                                        yylineno = this.lexer.yylineno;
                                        yyloc = this.lexer.yylloc;
                                        if (recovering > 0) recovering--;
                                    } else {
                                        symbol = preErrorSymbol;
                                        preErrorSymbol = null;
                                    }
                                    break;
                                case 2:
                                    len = this.productions_[action[1]][1];
                                    yyval.$ = vstack[vstack.length - len];
                                    yyval._$ = {
                                        first_line: lstack[lstack.length - (len || 1)].first_line,
                                        last_line: lstack[lstack.length - 1].last_line,
                                        first_column: lstack[lstack.length - (len || 1)].first_column,
                                        last_column: lstack[lstack.length - 1].last_column
                                    };
                                    if (ranges) {
                                        yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                                    }
                                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                                    if (typeof r !== "undefined") {
                                        return r;
                                    }
                                    if (len) {
                                        stack = stack.slice(0, -1 * len * 2);
                                        vstack = vstack.slice(0, -1 * len);
                                        lstack = lstack.slice(0, -1 * len);
                                    }
                                    stack.push(this.productions_[action[1]][0]);
                                    vstack.push(yyval.$);
                                    lstack.push(yyval._$);
                                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                                    stack.push(newState);
                                    break;
                                case 3:
                                    return true;
                            }
                        }
                        return true;
                    }
                };
                /* Jison generated lexer */
                var lexer = (function () {
                    var lexer = {
                        EOF: 1,
                        parseError: function parseError(str, hash) {
                            if (this.yy.parser) {
                                this.yy.parser.parseError(str, hash);
                            } else {
                                throw new Error(str);
                            }
                        },
                        setInput: function setInput(input) {
                            this._input = input;
                            this._more = this._less = this.done = false;
                            this.yylineno = this.yyleng = 0;
                            this.yytext = this.matched = this.match = '';
                            this.conditionStack = ['INITIAL'];
                            this.yylloc = {first_line: 1, first_column: 0, last_line: 1, last_column: 0};
                            if (this.options.ranges) this.yylloc.range = [0, 0];
                            this.offset = 0;
                            return this;
                        },
                        input: function input() {
                            var ch = this._input[0];
                            this.yytext += ch;
                            this.yyleng++;
                            this.offset++;
                            this.match += ch;
                            this.matched += ch;
                            var lines = ch.match(/(?:\r\n?|\n).*/g);
                            if (lines) {
                                this.yylineno++;
                                this.yylloc.last_line++;
                            } else {
                                this.yylloc.last_column++;
                            }
                            if (this.options.ranges) this.yylloc.range[1]++;

                            this._input = this._input.slice(1);
                            return ch;
                        },
                        unput: function unput(ch) {
                            var len = ch.length;
                            var lines = ch.split(/(?:\r\n?|\n)/g);

                            this._input = ch + this._input;
                            this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                            //this.yyleng -= len;
                            this.offset -= len;
                            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                            this.match = this.match.substr(0, this.match.length - 1);
                            this.matched = this.matched.substr(0, this.matched.length - 1);

                            if (lines.length - 1) this.yylineno -= lines.length - 1;
                            var r = this.yylloc.range;

                            this.yylloc = {
                                first_line: this.yylloc.first_line,
                                last_line: this.yylineno + 1,
                                first_column: this.yylloc.first_column,
                                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                            };

                            if (this.options.ranges) {
                                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                            }
                            return this;
                        },
                        more: function more() {
                            this._more = true;
                            return this;
                        },
                        less: function less(n) {
                            this.unput(this.match.slice(n));
                        },
                        pastInput: function pastInput() {
                            var past = this.matched.substr(0, this.matched.length - this.match.length);
                            return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                        },
                        upcomingInput: function upcomingInput() {
                            var next = this.match;
                            if (next.length < 20) {
                                next += this._input.substr(0, 20 - next.length);
                            }
                            return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                        },
                        showPosition: function showPosition() {
                            var pre = this.pastInput();
                            var c = new Array(pre.length + 1).join("-");
                            return pre + this.upcomingInput() + "\n" + c + "^";
                        },
                        next: function next() {
                            if (this.done) {
                                return this.EOF;
                            }
                            if (!this._input) this.done = true;

                            var token, match, tempMatch, index, col, lines;
                            if (!this._more) {
                                this.yytext = '';
                                this.match = '';
                            }
                            var rules = this._currentRules();
                            for (var i = 0; i < rules.length; i++) {
                                tempMatch = this._input.match(this.rules[rules[i]]);
                                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                                    match = tempMatch;
                                    index = i;
                                    if (!this.options.flex) break;
                                }
                            }
                            if (match) {
                                lines = match[0].match(/(?:\r\n?|\n).*/g);
                                if (lines) this.yylineno += lines.length;
                                this.yylloc = {
                                    first_line: this.yylloc.last_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.last_column,
                                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                                };
                                this.yytext += match[0];
                                this.match += match[0];
                                this.matches = match;
                                this.yyleng = this.yytext.length;
                                if (this.options.ranges) {
                                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
                                }
                                this._more = false;
                                this._input = this._input.slice(match[0].length);
                                this.matched += match[0];
                                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                                if (this.done && this._input) this.done = false;
                                if (token) return token; else return;
                            }
                            if (this._input === "") {
                                return this.EOF;
                            } else {
                                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                                    text: "",
                                    token: null,
                                    line: this.yylineno
                                });
                            }
                        },
                        lex: function lex() {
                            var r = this.next();
                            if (typeof r !== 'undefined') {
                                return r;
                            } else {
                                return this.lex();
                            }
                        },
                        begin: function begin(condition) {
                            this.conditionStack.push(condition);
                        },
                        popState: function popState() {
                            return this.conditionStack.pop();
                        },
                        _currentRules: function _currentRules() {
                            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                        },
                        topState: function topState() {
                            return this.conditionStack[this.conditionStack.length - 2];
                        },
                        pushState: function begin(condition) {
                            this.begin(condition);
                        }
                    };
                    lexer.options = {};
                    lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
                                                             /**/) {

                        function strip(start, end) {
                            return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                        }

                        var YYSTATE = YY_START;
                        switch ($avoiding_name_collisions) {
                            case 0:
                                if (yy_.yytext.slice(-2) === "\\\\") {
                                    strip(0, 1);
                                    this.begin("mu");
                                } else if (yy_.yytext.slice(-1) === "\\") {
                                    strip(0, 1);
                                    this.begin("emu");
                                } else {
                                    this.begin("mu");
                                }
                                if (yy_.yytext) return 15;

                                break;
                            case 1:
                                return 15;
                                break;
                            case 2:
                                this.popState();
                                return 15;

                                break;
                            case 3:
                                this.begin('raw');
                                return 15;
                                break;
                            case 4:
                                this.popState();
                                // Should be using `this.topState()` below, but it currently
                                // returns the second top instead of the first top. Opened an
                                // issue about it at https://github.com/zaach/jison/issues/291
                                if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
                                    return 15;
                                } else {
                                    yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                                    return 'END_RAW_BLOCK';
                                }

                                break;
                            case 5:
                                return 15;
                                break;
                            case 6:
                                this.popState();
                                return 14;

                                break;
                            case 7:
                                return 65;
                                break;
                            case 8:
                                return 68;
                                break;
                            case 9:
                                return 19;
                                break;
                            case 10:
                                this.popState();
                                this.begin('raw');
                                return 23;

                                break;
                            case 11:
                                return 55;
                                break;
                            case 12:
                                return 60;
                                break;
                            case 13:
                                return 29;
                                break;
                            case 14:
                                return 47;
                                break;
                            case 15:
                                this.popState();
                                return 44;
                                break;
                            case 16:
                                this.popState();
                                return 44;
                                break;
                            case 17:
                                return 34;
                                break;
                            case 18:
                                return 39;
                                break;
                            case 19:
                                return 51;
                                break;
                            case 20:
                                return 48;
                                break;
                            case 21:
                                this.unput(yy_.yytext);
                                this.popState();
                                this.begin('com');

                                break;
                            case 22:
                                this.popState();
                                return 14;

                                break;
                            case 23:
                                return 48;
                                break;
                            case 24:
                                return 73;
                                break;
                            case 25:
                                return 72;
                                break;
                            case 26:
                                return 72;
                                break;
                            case 27:
                                return 87;
                                break;
                            case 28:
                                // ignore whitespace
                                break;
                            case 29:
                                this.popState();
                                return 54;
                                break;
                            case 30:
                                this.popState();
                                return 33;
                                break;
                            case 31:
                                yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                                return 80;
                                break;
                            case 32:
                                yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                                return 80;
                                break;
                            case 33:
                                return 85;
                                break;
                            case 34:
                                return 82;
                                break;
                            case 35:
                                return 82;
                                break;
                            case 36:
                                return 83;
                                break;
                            case 37:
                                return 84;
                                break;
                            case 38:
                                return 81;
                                break;
                            case 39:
                                return 75;
                                break;
                            case 40:
                                return 77;
                                break;
                            case 41:
                                return 72;
                                break;
                            case 42:
                                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');
                                return 72;
                                break;
                            case 43:
                                return 'INVALID';
                                break;
                            case 44:
                                return 5;
                                break;
                        }
                    };
                    lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
                    lexer.conditions = {
                        "mu": {
                            "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
                            "inclusive": false
                        },
                        "emu": {"rules": [2], "inclusive": false},
                        "com": {"rules": [6], "inclusive": false},
                        "raw": {"rules": [3, 4, 5], "inclusive": false},
                        "INITIAL": {"rules": [0, 1, 44], "inclusive": true}
                    };
                    return lexer;
                })();
                parser.lexer = lexer;

                function Parser() {
                    this.yy = {};
                }

                Parser.prototype = parser;
                parser.Parser = Parser;
                return new Parser();
            })();
            exports["default"] = handlebars;
            module.exports = exports["default"];

            /***/
        }),
        /* 38 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _visitor = __webpack_require__(39);

            var _visitor2 = _interopRequireDefault(_visitor);

            function WhitespaceControl() {
                var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                this.options = options;
            }

            WhitespaceControl.prototype = new _visitor2['default']();

            WhitespaceControl.prototype.Program = function (program) {
                var doStandalone = !this.options.ignoreStandalone;

                var isRoot = !this.isRootSeen;
                this.isRootSeen = true;

                var body = program.body;
                for (var i = 0, l = body.length; i < l; i++) {
                    var current = body[i],
                        strip = this.accept(current);

                    if (!strip) {
                        continue;
                    }

                    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
                        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
                        openStandalone = strip.openStandalone && _isPrevWhitespace,
                        closeStandalone = strip.closeStandalone && _isNextWhitespace,
                        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

                    if (strip.close) {
                        omitRight(body, i, true);
                    }
                    if (strip.open) {
                        omitLeft(body, i, true);
                    }

                    if (doStandalone && inlineStandalone) {
                        omitRight(body, i);

                        if (omitLeft(body, i)) {
                            // If we are on a standalone node, save the indent info for partials
                            if (current.type === 'PartialStatement') {
                                // Pull out the whitespace from the final line
                                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
                            }
                        }
                    }
                    if (doStandalone && openStandalone) {
                        omitRight((current.program || current.inverse).body);

                        // Strip out the previous content node if it's whitespace only
                        omitLeft(body, i);
                    }
                    if (doStandalone && closeStandalone) {
                        // Always strip the next node
                        omitRight(body, i);

                        omitLeft((current.inverse || current.program).body);
                    }
                }

                return program;
            };

            WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
                this.accept(block.program);
                this.accept(block.inverse);

                // Find the inverse program that is involed with whitespace stripping.
                var program = block.program || block.inverse,
                    inverse = block.program && block.inverse,
                    firstInverse = inverse,
                    lastInverse = inverse;

                if (inverse && inverse.chained) {
                    firstInverse = inverse.body[0].program;

                    // Walk the inverse chain to find the last inverse that is actually in the chain.
                    while (lastInverse.chained) {
                        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
                    }
                }

                var strip = {
                    open: block.openStrip.open,
                    close: block.closeStrip.close,

                    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
                    // so our parent can determine if we actually are standalone
                    openStandalone: isNextWhitespace(program.body),
                    closeStandalone: isPrevWhitespace((firstInverse || program).body)
                };

                if (block.openStrip.close) {
                    omitRight(program.body, null, true);
                }

                if (inverse) {
                    var inverseStrip = block.inverseStrip;

                    if (inverseStrip.open) {
                        omitLeft(program.body, null, true);
                    }

                    if (inverseStrip.close) {
                        omitRight(firstInverse.body, null, true);
                    }
                    if (block.closeStrip.open) {
                        omitLeft(lastInverse.body, null, true);
                    }

                    // Find standalone else statments
                    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
                        omitLeft(program.body);
                        omitRight(firstInverse.body);
                    }
                } else if (block.closeStrip.open) {
                    omitLeft(program.body, null, true);
                }

                return strip;
            };

            WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
                return mustache.strip;
            };

            WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
                /* istanbul ignore next */
                var strip = node.strip || {};
                return {
                    inlineStandalone: true,
                    open: strip.open,
                    close: strip.close
                };
            };

            function isPrevWhitespace(body, i, isRoot) {
                if (i === undefined) {
                    i = body.length;
                }

                // Nodes that end with newlines are considered whitespace (but are special
                // cased for strip operations)
                var prev = body[i - 1],
                    sibling = body[i - 2];
                if (!prev) {
                    return isRoot;
                }

                if (prev.type === 'ContentStatement') {
                    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
                }
            }

            function isNextWhitespace(body, i, isRoot) {
                if (i === undefined) {
                    i = -1;
                }

                var next = body[i + 1],
                    sibling = body[i + 2];
                if (!next) {
                    return isRoot;
                }

                if (next.type === 'ContentStatement') {
                    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
                }
            }

            // Marks the node to the right of the position as omitted.
            // I.e. {{foo}}' ' will mark the ' ' node as omitted.
            //
            // If i is undefined, then the first child will be marked as such.
            //
            // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
            // content is met.
            function omitRight(body, i, multiple) {
                var current = body[i == null ? 0 : i + 1];
                if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
                    return;
                }

                var original = current.value;
                current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
                current.rightStripped = current.value !== original;
            }

            // Marks the node to the left of the position as omitted.
            // I.e. ' '{{foo}} will mark the ' ' node as omitted.
            //
            // If i is undefined then the last child will be marked as such.
            //
            // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
            // content is met.
            function omitLeft(body, i, multiple) {
                var current = body[i == null ? body.length - 1 : i - 1];
                if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
                    return;
                }

                // We omit the last node if it's whitespace only and not preceeded by a non-content node.
                var original = current.value;
                current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
                current.leftStripped = current.value !== original;
                return current.leftStripped;
            }

            exports['default'] = WhitespaceControl;
            module.exports = exports['default'];

            /***/
        }),
        /* 39 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            function Visitor() {
                this.parents = [];
            }

            Visitor.prototype = {
                constructor: Visitor,
                mutating: false,

                // Visits a given value. If mutating, will replace the value if necessary.
                acceptKey: function acceptKey(node, name) {
                    var value = this.accept(node[name]);
                    if (this.mutating) {
                        // Hacky sanity check: This may have a few false positives for type for the helper
                        // methods but will generally do the right thing without a lot of overhead.
                        if (value && !Visitor.prototype[value.type]) {
                            throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
                        }
                        node[name] = value;
                    }
                },

                // Performs an accept operation with added sanity check to ensure
                // required keys are not removed.
                acceptRequired: function acceptRequired(node, name) {
                    this.acceptKey(node, name);

                    if (!node[name]) {
                        throw new _exception2['default'](node.type + ' requires ' + name);
                    }
                },

                // Traverses a given array. If mutating, empty respnses will be removed
                // for child elements.
                acceptArray: function acceptArray(array) {
                    for (var i = 0, l = array.length; i < l; i++) {
                        this.acceptKey(array, i);

                        if (!array[i]) {
                            array.splice(i, 1);
                            i--;
                            l--;
                        }
                    }
                },

                accept: function accept(object) {
                    if (!object) {
                        return;
                    }

                    /* istanbul ignore next: Sanity code */
                    if (!this[object.type]) {
                        throw new _exception2['default']('Unknown type: ' + object.type, object);
                    }

                    if (this.current) {
                        this.parents.unshift(this.current);
                    }
                    this.current = object;

                    var ret = this[object.type](object);

                    this.current = this.parents.shift();

                    if (!this.mutating || ret) {
                        return ret;
                    } else if (ret !== false) {
                        return object;
                    }
                },

                Program: function Program(program) {
                    this.acceptArray(program.body);
                },

                MustacheStatement: visitSubExpression,
                Decorator: visitSubExpression,

                BlockStatement: visitBlock,
                DecoratorBlock: visitBlock,

                PartialStatement: visitPartial,
                PartialBlockStatement: function PartialBlockStatement(partial) {
                    visitPartial.call(this, partial);

                    this.acceptKey(partial, 'program');
                },

                ContentStatement: function ContentStatement() /* content */ {
                },
                CommentStatement: function CommentStatement() /* comment */ {
                },

                SubExpression: visitSubExpression,

                PathExpression: function PathExpression() /* path */ {
                },

                StringLiteral: function StringLiteral() /* string */ {
                },
                NumberLiteral: function NumberLiteral() /* number */ {
                },
                BooleanLiteral: function BooleanLiteral() /* bool */ {
                },
                UndefinedLiteral: function UndefinedLiteral() /* literal */ {
                },
                NullLiteral: function NullLiteral() /* literal */ {
                },

                Hash: function Hash(hash) {
                    this.acceptArray(hash.pairs);
                },
                HashPair: function HashPair(pair) {
                    this.acceptRequired(pair, 'value');
                }
            };

            function visitSubExpression(mustache) {
                this.acceptRequired(mustache, 'path');
                this.acceptArray(mustache.params);
                this.acceptKey(mustache, 'hash');
            }

            function visitBlock(block) {
                visitSubExpression.call(this, block);

                this.acceptKey(block, 'program');
                this.acceptKey(block, 'inverse');
            }

            function visitPartial(partial) {
                this.acceptRequired(partial, 'name');
                this.acceptArray(partial.params);
                this.acceptKey(partial, 'hash');
            }

            exports['default'] = Visitor;
            module.exports = exports['default'];

            /***/
        }),
        /* 40 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.SourceLocation = SourceLocation;
            exports.id = id;
            exports.stripFlags = stripFlags;
            exports.stripComment = stripComment;
            exports.preparePath = preparePath;
            exports.prepareMustache = prepareMustache;
            exports.prepareRawBlock = prepareRawBlock;
            exports.prepareBlock = prepareBlock;
            exports.prepareProgram = prepareProgram;
            exports.preparePartialBlock = preparePartialBlock;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            function validateClose(open, close) {
                close = close.path ? close.path.original : close;

                if (open.path.original !== close) {
                    var errorNode = {loc: open.path.loc};

                    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
                }
            }

            function SourceLocation(source, locInfo) {
                this.source = source;
                this.start = {
                    line: locInfo.first_line,
                    column: locInfo.first_column
                };
                this.end = {
                    line: locInfo.last_line,
                    column: locInfo.last_column
                };
            }

            function id(token) {
                if (/^\[.*\]$/.test(token)) {
                    return token.substr(1, token.length - 2);
                } else {
                    return token;
                }
            }

            function stripFlags(open, close) {
                return {
                    open: open.charAt(2) === '~',
                    close: close.charAt(close.length - 3) === '~'
                };
            }

            function stripComment(comment) {
                return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
            }

            function preparePath(data, parts, loc) {
                loc = this.locInfo(loc);

                var original = data ? '@' : '',
                    dig = [],
                    depth = 0,
                    depthString = '';

                for (var i = 0, l = parts.length; i < l; i++) {
                    var part = parts[i].part,

                        // If we have [] syntax then we do not treat path references as operators,
                        // i.e. foo.[this] resolves to approximately context.foo['this']
                        isLiteral = parts[i].original !== part;
                    original += (parts[i].separator || '') + part;

                    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
                        if (dig.length > 0) {
                            throw new _exception2['default']('Invalid path: ' + original, {loc: loc});
                        } else if (part === '..') {
                            depth++;
                            depthString += '../';
                        }
                    } else {
                        dig.push(part);
                    }
                }

                return {
                    type: 'PathExpression',
                    data: data,
                    depth: depth,
                    parts: dig,
                    original: original,
                    loc: loc
                };
            }

            function prepareMustache(path, params, hash, open, strip, locInfo) {
                // Must use charAt to support IE pre-10
                var escapeFlag = open.charAt(3) || open.charAt(2),
                    escaped = escapeFlag !== '{' && escapeFlag !== '&';

                var decorator = /\*/.test(open);
                return {
                    type: decorator ? 'Decorator' : 'MustacheStatement',
                    path: path,
                    params: params,
                    hash: hash,
                    escaped: escaped,
                    strip: strip,
                    loc: this.locInfo(locInfo)
                };
            }

            function prepareRawBlock(openRawBlock, contents, close, locInfo) {
                validateClose(openRawBlock, close);

                locInfo = this.locInfo(locInfo);
                var program = {
                    type: 'Program',
                    body: contents,
                    strip: {},
                    loc: locInfo
                };

                return {
                    type: 'BlockStatement',
                    path: openRawBlock.path,
                    params: openRawBlock.params,
                    hash: openRawBlock.hash,
                    program: program,
                    openStrip: {},
                    inverseStrip: {},
                    closeStrip: {},
                    loc: locInfo
                };
            }

            function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
                if (close && close.path) {
                    validateClose(openBlock, close);
                }

                var decorator = /\*/.test(openBlock.open);

                program.blockParams = openBlock.blockParams;

                var inverse = undefined,
                    inverseStrip = undefined;

                if (inverseAndProgram) {
                    if (decorator) {
                        throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
                    }

                    if (inverseAndProgram.chain) {
                        inverseAndProgram.program.body[0].closeStrip = close.strip;
                    }

                    inverseStrip = inverseAndProgram.strip;
                    inverse = inverseAndProgram.program;
                }

                if (inverted) {
                    inverted = inverse;
                    inverse = program;
                    program = inverted;
                }

                return {
                    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
                    path: openBlock.path,
                    params: openBlock.params,
                    hash: openBlock.hash,
                    program: program,
                    inverse: inverse,
                    openStrip: openBlock.strip,
                    inverseStrip: inverseStrip,
                    closeStrip: close && close.strip,
                    loc: this.locInfo(locInfo)
                };
            }

            function prepareProgram(statements, loc) {
                if (!loc && statements.length) {
                    var firstLoc = statements[0].loc,
                        lastLoc = statements[statements.length - 1].loc;

                    /* istanbul ignore else */
                    if (firstLoc && lastLoc) {
                        loc = {
                            source: firstLoc.source,
                            start: {
                                line: firstLoc.start.line,
                                column: firstLoc.start.column
                            },
                            end: {
                                line: lastLoc.end.line,
                                column: lastLoc.end.column
                            }
                        };
                    }
                }

                return {
                    type: 'Program',
                    body: statements,
                    strip: {},
                    loc: loc
                };
            }

            function preparePartialBlock(open, program, close, locInfo) {
                validateClose(open, close);

                return {
                    type: 'PartialBlockStatement',
                    name: open.path,
                    params: open.params,
                    hash: open.hash,
                    program: program,
                    openStrip: open.strip,
                    closeStrip: close && close.strip,
                    loc: this.locInfo(locInfo)
                };
            }

            /***/
        }),
        /* 41 */
        /***/ (function (module, exports, __webpack_require__) {

            /* eslint-disable new-cap */

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.Compiler = Compiler;
            exports.precompile = precompile;
            exports.compile = compile;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _utils = __webpack_require__(5);

            var _ast = __webpack_require__(35);

            var _ast2 = _interopRequireDefault(_ast);

            var slice = [].slice;

            function Compiler() {
            }

            // the foundHelper register will disambiguate helper lookup from finding a
            // function in a context. This is necessary for mustache compatibility, which
            // requires that context functions in blocks are evaluated by blockHelperMissing,
            // and then proceed as if the resulting value was provided to blockHelperMissing.

            Compiler.prototype = {
                compiler: Compiler,

                equals: function equals(other) {
                    var len = this.opcodes.length;
                    if (other.opcodes.length !== len) {
                        return false;
                    }

                    for (var i = 0; i < len; i++) {
                        var opcode = this.opcodes[i],
                            otherOpcode = other.opcodes[i];
                        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
                            return false;
                        }
                    }

                    // We know that length is the same between the two arrays because they are directly tied
                    // to the opcode behavior above.
                    len = this.children.length;
                    for (var i = 0; i < len; i++) {
                        if (!this.children[i].equals(other.children[i])) {
                            return false;
                        }
                    }

                    return true;
                },

                guid: 0,

                compile: function compile(program, options) {
                    this.sourceNode = [];
                    this.opcodes = [];
                    this.children = [];
                    this.options = options;
                    this.stringParams = options.stringParams;
                    this.trackIds = options.trackIds;

                    options.blockParams = options.blockParams || [];

                    // These changes will propagate to the other compiler components
                    var knownHelpers = options.knownHelpers;
                    options.knownHelpers = {
                        'helperMissing': true,
                        'blockHelperMissing': true,
                        'each': true,
                        'if': true,
                        'unless': true,
                        'with': true,
                        'log': true,
                        'lookup': true
                    };
                    if (knownHelpers) {
                        for (var _name in knownHelpers) {
                            /* istanbul ignore else */
                            if (_name in knownHelpers) {
                                this.options.knownHelpers[_name] = knownHelpers[_name];
                            }
                        }
                    }

                    return this.accept(program);
                },

                compileProgram: function compileProgram(program) {
                    var childCompiler = new this.compiler(),
                        // eslint-disable-line new-cap
                        result = childCompiler.compile(program, this.options),
                        guid = this.guid++;

                    this.usePartial = this.usePartial || result.usePartial;

                    this.children[guid] = result;
                    this.useDepths = this.useDepths || result.useDepths;

                    return guid;
                },

                accept: function accept(node) {
                    /* istanbul ignore next: Sanity code */
                    if (!this[node.type]) {
                        throw new _exception2['default']('Unknown type: ' + node.type, node);
                    }

                    this.sourceNode.unshift(node);
                    var ret = this[node.type](node);
                    this.sourceNode.shift();
                    return ret;
                },

                Program: function Program(program) {
                    this.options.blockParams.unshift(program.blockParams);

                    var body = program.body,
                        bodyLength = body.length;
                    for (var i = 0; i < bodyLength; i++) {
                        this.accept(body[i]);
                    }

                    this.options.blockParams.shift();

                    this.isSimple = bodyLength === 1;
                    this.blockParams = program.blockParams ? program.blockParams.length : 0;

                    return this;
                },

                BlockStatement: function BlockStatement(block) {
                    transformLiteralToPath(block);

                    var program = block.program,
                        inverse = block.inverse;

                    program = program && this.compileProgram(program);
                    inverse = inverse && this.compileProgram(inverse);

                    var type = this.classifySexpr(block);

                    if (type === 'helper') {
                        this.helperSexpr(block, program, inverse);
                    } else if (type === 'simple') {
                        this.simpleSexpr(block);

                        // now that the simple mustache is resolved, we need to
                        // evaluate it by executing `blockHelperMissing`
                        this.opcode('pushProgram', program);
                        this.opcode('pushProgram', inverse);
                        this.opcode('emptyHash');
                        this.opcode('blockValue', block.path.original);
                    } else {
                        this.ambiguousSexpr(block, program, inverse);

                        // now that the simple mustache is resolved, we need to
                        // evaluate it by executing `blockHelperMissing`
                        this.opcode('pushProgram', program);
                        this.opcode('pushProgram', inverse);
                        this.opcode('emptyHash');
                        this.opcode('ambiguousBlockValue');
                    }

                    this.opcode('append');
                },

                DecoratorBlock: function DecoratorBlock(decorator) {
                    var program = decorator.program && this.compileProgram(decorator.program);
                    var params = this.setupFullMustacheParams(decorator, program, undefined),
                        path = decorator.path;

                    this.useDecorators = true;
                    this.opcode('registerDecorator', params.length, path.original);
                },

                PartialStatement: function PartialStatement(partial) {
                    this.usePartial = true;

                    var program = partial.program;
                    if (program) {
                        program = this.compileProgram(partial.program);
                    }

                    var params = partial.params;
                    if (params.length > 1) {
                        throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
                    } else if (!params.length) {
                        if (this.options.explicitPartialContext) {
                            this.opcode('pushLiteral', 'undefined');
                        } else {
                            params.push({type: 'PathExpression', parts: [], depth: 0});
                        }
                    }

                    var partialName = partial.name.original,
                        isDynamic = partial.name.type === 'SubExpression';
                    if (isDynamic) {
                        this.accept(partial.name);
                    }

                    this.setupFullMustacheParams(partial, program, undefined, true);

                    var indent = partial.indent || '';
                    if (this.options.preventIndent && indent) {
                        this.opcode('appendContent', indent);
                        indent = '';
                    }

                    this.opcode('invokePartial', isDynamic, partialName, indent);
                    this.opcode('append');
                },
                PartialBlockStatement: function PartialBlockStatement(partialBlock) {
                    this.PartialStatement(partialBlock);
                },

                MustacheStatement: function MustacheStatement(mustache) {
                    this.SubExpression(mustache);

                    if (mustache.escaped && !this.options.noEscape) {
                        this.opcode('appendEscaped');
                    } else {
                        this.opcode('append');
                    }
                },
                Decorator: function Decorator(decorator) {
                    this.DecoratorBlock(decorator);
                },

                ContentStatement: function ContentStatement(content) {
                    if (content.value) {
                        this.opcode('appendContent', content.value);
                    }
                },

                CommentStatement: function CommentStatement() {
                },

                SubExpression: function SubExpression(sexpr) {
                    transformLiteralToPath(sexpr);
                    var type = this.classifySexpr(sexpr);

                    if (type === 'simple') {
                        this.simpleSexpr(sexpr);
                    } else if (type === 'helper') {
                        this.helperSexpr(sexpr);
                    } else {
                        this.ambiguousSexpr(sexpr);
                    }
                },
                ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
                    var path = sexpr.path,
                        name = path.parts[0],
                        isBlock = program != null || inverse != null;

                    this.opcode('getContext', path.depth);

                    this.opcode('pushProgram', program);
                    this.opcode('pushProgram', inverse);

                    path.strict = true;
                    this.accept(path);

                    this.opcode('invokeAmbiguous', name, isBlock);
                },

                simpleSexpr: function simpleSexpr(sexpr) {
                    var path = sexpr.path;
                    path.strict = true;
                    this.accept(path);
                    this.opcode('resolvePossibleLambda');
                },

                helperSexpr: function helperSexpr(sexpr, program, inverse) {
                    var params = this.setupFullMustacheParams(sexpr, program, inverse),
                        path = sexpr.path,
                        name = path.parts[0];

                    if (this.options.knownHelpers[name]) {
                        this.opcode('invokeKnownHelper', params.length, name);
                    } else if (this.options.knownHelpersOnly) {
                        throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
                    } else {
                        path.strict = true;
                        path.falsy = true;

                        this.accept(path);
                        this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
                    }
                },

                PathExpression: function PathExpression(path) {
                    this.addDepth(path.depth);
                    this.opcode('getContext', path.depth);

                    var name = path.parts[0],
                        scoped = _ast2['default'].helpers.scopedId(path),
                        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

                    if (blockParamId) {
                        this.opcode('lookupBlockParam', blockParamId, path.parts);
                    } else if (!name) {
                        // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
                        this.opcode('pushContext');
                    } else if (path.data) {
                        this.options.data = true;
                        this.opcode('lookupData', path.depth, path.parts, path.strict);
                    } else {
                        this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
                    }
                },

                StringLiteral: function StringLiteral(string) {
                    this.opcode('pushString', string.value);
                },

                NumberLiteral: function NumberLiteral(number) {
                    this.opcode('pushLiteral', number.value);
                },

                BooleanLiteral: function BooleanLiteral(bool) {
                    this.opcode('pushLiteral', bool.value);
                },

                UndefinedLiteral: function UndefinedLiteral() {
                    this.opcode('pushLiteral', 'undefined');
                },

                NullLiteral: function NullLiteral() {
                    this.opcode('pushLiteral', 'null');
                },

                Hash: function Hash(hash) {
                    var pairs = hash.pairs,
                        i = 0,
                        l = pairs.length;

                    this.opcode('pushHash');

                    for (; i < l; i++) {
                        this.pushParam(pairs[i].value);
                    }
                    while (i--) {
                        this.opcode('assignToHash', pairs[i].key);
                    }
                    this.opcode('popHash');
                },

                // HELPERS
                opcode: function opcode(name) {
                    this.opcodes.push({opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc});
                },

                addDepth: function addDepth(depth) {
                    if (!depth) {
                        return;
                    }

                    this.useDepths = true;
                },

                classifySexpr: function classifySexpr(sexpr) {
                    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

                    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

                    // a mustache is an eligible helper if:
                    // * its id is simple (a single part, not `this` or `..`)
                    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

                    // if a mustache is an eligible helper but not a definite
                    // helper, it is ambiguous, and will be resolved in a later
                    // pass or at runtime.
                    var isEligible = !isBlockParam && (isHelper || isSimple);

                    // if ambiguous, we can possibly resolve the ambiguity now
                    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
                    if (isEligible && !isHelper) {
                        var _name2 = sexpr.path.parts[0],
                            options = this.options;

                        if (options.knownHelpers[_name2]) {
                            isHelper = true;
                        } else if (options.knownHelpersOnly) {
                            isEligible = false;
                        }
                    }

                    if (isHelper) {
                        return 'helper';
                    } else if (isEligible) {
                        return 'ambiguous';
                    } else {
                        return 'simple';
                    }
                },

                pushParams: function pushParams(params) {
                    for (var i = 0, l = params.length; i < l; i++) {
                        this.pushParam(params[i]);
                    }
                },

                pushParam: function pushParam(val) {
                    var value = val.value != null ? val.value : val.original || '';

                    if (this.stringParams) {
                        if (value.replace) {
                            value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
                        }

                        if (val.depth) {
                            this.addDepth(val.depth);
                        }
                        this.opcode('getContext', val.depth || 0);
                        this.opcode('pushStringParam', value, val.type);

                        if (val.type === 'SubExpression') {
                            // SubExpressions get evaluated and passed in
                            // in string params mode.
                            this.accept(val);
                        }
                    } else {
                        if (this.trackIds) {
                            var blockParamIndex = undefined;
                            if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
                                blockParamIndex = this.blockParamIndex(val.parts[0]);
                            }
                            if (blockParamIndex) {
                                var blockParamChild = val.parts.slice(1).join('.');
                                this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
                            } else {
                                value = val.original || value;
                                if (value.replace) {
                                    value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
                                }

                                this.opcode('pushId', val.type, value);
                            }
                        }
                        this.accept(val);
                    }
                },

                setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
                    var params = sexpr.params;
                    this.pushParams(params);

                    this.opcode('pushProgram', program);
                    this.opcode('pushProgram', inverse);

                    if (sexpr.hash) {
                        this.accept(sexpr.hash);
                    } else {
                        this.opcode('emptyHash', omitEmpty);
                    }

                    return params;
                },

                blockParamIndex: function blockParamIndex(name) {
                    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
                        var blockParams = this.options.blockParams[depth],
                            param = blockParams && _utils.indexOf(blockParams, name);
                        if (blockParams && param >= 0) {
                            return [depth, param];
                        }
                    }
                }
            };

            function precompile(input, options, env) {
                if (input == null || typeof input !== 'string' && input.type !== 'Program') {
                    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
                }

                options = options || {};
                if (!('data' in options)) {
                    options.data = true;
                }
                if (options.compat) {
                    options.useDepths = true;
                }

                var ast = env.parse(input, options),
                    environment = new env.Compiler().compile(ast, options);
                return new env.JavaScriptCompiler().compile(environment, options);
            }

            function compile(input, options, env) {
                if (options === undefined) options = {};

                if (input == null || typeof input !== 'string' && input.type !== 'Program') {
                    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
                }

                options = _utils.extend({}, options);
                if (!('data' in options)) {
                    options.data = true;
                }
                if (options.compat) {
                    options.useDepths = true;
                }

                var compiled = undefined;

                function compileInput() {
                    var ast = env.parse(input, options),
                        environment = new env.Compiler().compile(ast, options),
                        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
                    return env.template(templateSpec);
                }

                // Template is only compiled on first use and cached after that point.
                function ret(context, execOptions) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled.call(this, context, execOptions);
                }

                ret._setup = function (setupOptions) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled._setup(setupOptions);
                };
                ret._child = function (i, data, blockParams, depths) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled._child(i, data, blockParams, depths);
                };
                return ret;
            }

            function argEquals(a, b) {
                if (a === b) {
                    return true;
                }

                if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
                    for (var i = 0; i < a.length; i++) {
                        if (!argEquals(a[i], b[i])) {
                            return false;
                        }
                    }
                    return true;
                }
            }

            function transformLiteralToPath(sexpr) {
                if (!sexpr.path.parts) {
                    var literal = sexpr.path;
                    // Casting to string here to make false and 0 literal values play nicely with the rest
                    // of the system.
                    sexpr.path = {
                        type: 'PathExpression',
                        data: false,
                        depth: 0,
                        parts: [literal.original + ''],
                        original: literal.original + '',
                        loc: literal.loc
                    };
                }
            }

            /***/
        }),
        /* 42 */
        /***/ (function (module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _base = __webpack_require__(4);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _utils = __webpack_require__(5);

            var _codeGen = __webpack_require__(43);

            var _codeGen2 = _interopRequireDefault(_codeGen);

            function Literal(value) {
                this.value = value;
            }

            function JavaScriptCompiler() {
            }

            JavaScriptCompiler.prototype = {
                // PUBLIC API: You can override these methods in a subclass to provide
                // alternative compiled forms for name lookup and buffering semantics
                nameLookup: function nameLookup(parent, name /* , type*/) {
                    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
                        return [parent, '.', name];
                    } else {
                        return [parent, '[', JSON.stringify(name), ']'];
                    }
                },
                depthedLookup: function depthedLookup(name) {
                    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
                },

                compilerInfo: function compilerInfo() {
                    var revision = _base.COMPILER_REVISION,
                        versions = _base.REVISION_CHANGES[revision];
                    return [revision, versions];
                },

                appendToBuffer: function appendToBuffer(source, location, explicit) {
                    // Force a source as this simplifies the merge logic.
                    if (!_utils.isArray(source)) {
                        source = [source];
                    }
                    source = this.source.wrap(source, location);

                    if (this.environment.isSimple) {
                        return ['return ', source, ';'];
                    } else if (explicit) {
                        // This is a case where the buffer operation occurs as a child of another
                        // construct, generally braces. We have to explicitly output these buffer
                        // operations to ensure that the emitted code goes in the correct location.
                        return ['buffer += ', source, ';'];
                    } else {
                        source.appendToBuffer = true;
                        return source;
                    }
                },

                initializeBuffer: function initializeBuffer() {
                    return this.quotedString('');
                },
                // END PUBLIC API

                compile: function compile(environment, options, context, asObject) {
                    this.environment = environment;
                    this.options = options;
                    this.stringParams = this.options.stringParams;
                    this.trackIds = this.options.trackIds;
                    this.precompile = !asObject;

                    this.name = this.environment.name;
                    this.isChild = !!context;
                    this.context = context || {
                        decorators: [],
                        programs: [],
                        environments: []
                    };

                    this.preamble();

                    this.stackSlot = 0;
                    this.stackVars = [];
                    this.aliases = {};
                    this.registers = {list: []};
                    this.hashes = [];
                    this.compileStack = [];
                    this.inlineStack = [];
                    this.blockParams = [];

                    this.compileChildren(environment, options);

                    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
                    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

                    var opcodes = environment.opcodes,
                        opcode = undefined,
                        firstLoc = undefined,
                        i = undefined,
                        l = undefined;

                    for (i = 0, l = opcodes.length; i < l; i++) {
                        opcode = opcodes[i];

                        this.source.currentLocation = opcode.loc;
                        firstLoc = firstLoc || opcode.loc;
                        this[opcode.opcode].apply(this, opcode.args);
                    }

                    // Flush any trailing content that might be pending.
                    this.source.currentLocation = firstLoc;
                    this.pushSource('');

                    /* istanbul ignore next */
                    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
                        throw new _exception2['default']('Compile completed with content left on stack');
                    }

                    if (!this.decorators.isEmpty()) {
                        this.useDecorators = true;

                        this.decorators.prepend('var decorators = container.decorators;\n');
                        this.decorators.push('return fn;');

                        if (asObject) {
                            this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
                        } else {
                            this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
                            this.decorators.push('}\n');
                            this.decorators = this.decorators.merge();
                        }
                    } else {
                        this.decorators = undefined;
                    }

                    var fn = this.createFunctionContext(asObject);
                    if (!this.isChild) {
                        var ret = {
                            compiler: this.compilerInfo(),
                            main: fn
                        };

                        if (this.decorators) {
                            ret.main_d = this.decorators; // eslint-disable-line camelcase
                            ret.useDecorators = true;
                        }

                        var _context = this.context;
                        var programs = _context.programs;
                        var decorators = _context.decorators;

                        for (i = 0, l = programs.length; i < l; i++) {
                            if (programs[i]) {
                                ret[i] = programs[i];
                                if (decorators[i]) {
                                    ret[i + '_d'] = decorators[i];
                                    ret.useDecorators = true;
                                }
                            }
                        }

                        if (this.environment.usePartial) {
                            ret.usePartial = true;
                        }
                        if (this.options.data) {
                            ret.useData = true;
                        }
                        if (this.useDepths) {
                            ret.useDepths = true;
                        }
                        if (this.useBlockParams) {
                            ret.useBlockParams = true;
                        }
                        if (this.options.compat) {
                            ret.compat = true;
                        }

                        if (!asObject) {
                            ret.compiler = JSON.stringify(ret.compiler);

                            this.source.currentLocation = {start: {line: 1, column: 0}};
                            ret = this.objectLiteral(ret);

                            if (options.srcName) {
                                ret = ret.toStringWithSourceMap({file: options.destName});
                                ret.map = ret.map && ret.map.toString();
                            } else {
                                ret = ret.toString();
                            }
                        } else {
                            ret.compilerOptions = this.options;
                        }

                        return ret;
                    } else {
                        return fn;
                    }
                },

                preamble: function preamble() {
                    // track the last context pushed into place to allow skipping the
                    // getContext opcode when it would be a noop
                    this.lastContext = 0;
                    this.source = new _codeGen2['default'](this.options.srcName);
                    this.decorators = new _codeGen2['default'](this.options.srcName);
                },

                createFunctionContext: function createFunctionContext(asObject) {
                    var varDeclarations = '';

                    var locals = this.stackVars.concat(this.registers.list);
                    if (locals.length > 0) {
                        varDeclarations += ', ' + locals.join(', ');
                    }

                    // Generate minimizer alias mappings
                    //
                    // When using true SourceNodes, this will update all references to the given alias
                    // as the source nodes are reused in situ. For the non-source node compilation mode,
                    // aliases will not be used, but this case is already being run on the client and
                    // we aren't concern about minimizing the template size.
                    var aliasCount = 0;
                    for (var alias in this.aliases) {
                        // eslint-disable-line guard-for-in
                        var node = this.aliases[alias];

                        if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
                            varDeclarations += ', alias' + ++aliasCount + '=' + alias;
                            node.children[0] = 'alias' + aliasCount;
                        }
                    }

                    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

                    if (this.useBlockParams || this.useDepths) {
                        params.push('blockParams');
                    }
                    if (this.useDepths) {
                        params.push('depths');
                    }

                    // Perform a second pass over the output to merge content when possible
                    var source = this.mergeSource(varDeclarations);

                    if (asObject) {
                        params.push(source);

                        return Function.apply(this, params);
                    } else {
                        return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
                    }
                },
                mergeSource: function mergeSource(varDeclarations) {
                    var isSimple = this.environment.isSimple,
                        appendOnly = !this.forceBuffer,
                        appendFirst = undefined,
                        sourceSeen = undefined,
                        bufferStart = undefined,
                        bufferEnd = undefined;
                    this.source.each(function (line) {
                        if (line.appendToBuffer) {
                            if (bufferStart) {
                                line.prepend('  + ');
                            } else {
                                bufferStart = line;
                            }
                            bufferEnd = line;
                        } else {
                            if (bufferStart) {
                                if (!sourceSeen) {
                                    appendFirst = true;
                                } else {
                                    bufferStart.prepend('buffer += ');
                                }
                                bufferEnd.add(';');
                                bufferStart = bufferEnd = undefined;
                            }

                            sourceSeen = true;
                            if (!isSimple) {
                                appendOnly = false;
                            }
                        }
                    });

                    if (appendOnly) {
                        if (bufferStart) {
                            bufferStart.prepend('return ');
                            bufferEnd.add(';');
                        } else if (!sourceSeen) {
                            this.source.push('return "";');
                        }
                    } else {
                        varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

                        if (bufferStart) {
                            bufferStart.prepend('return buffer + ');
                            bufferEnd.add(';');
                        } else {
                            this.source.push('return buffer;');
                        }
                    }

                    if (varDeclarations) {
                        this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
                    }

                    return this.source.merge();
                },

                // [blockValue]
                //
                // On stack, before: hash, inverse, program, value
                // On stack, after: return value of blockHelperMissing
                //
                // The purpose of this opcode is to take a block of the form
                // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
                // replace it on the stack with the result of properly
                // invoking blockHelperMissing.
                blockValue: function blockValue(name) {
                    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                        params = [this.contextName(0)];
                    this.setupHelperArgs(name, 0, params);

                    var blockName = this.popStack();
                    params.splice(1, 0, blockName);

                    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
                },

                // [ambiguousBlockValue]
                //
                // On stack, before: hash, inverse, program, value
                // Compiler value, before: lastHelper=value of last found helper, if any
                // On stack, after, if no lastHelper: same as [blockValue]
                // On stack, after, if lastHelper: value
                ambiguousBlockValue: function ambiguousBlockValue() {
                    // We're being a bit cheeky and reusing the options value from the prior exec
                    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                        params = [this.contextName(0)];
                    this.setupHelperArgs('', 0, params, true);

                    this.flushInline();

                    var current = this.topStack();
                    params.splice(1, 0, current);

                    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
                },

                // [appendContent]
                //
                // On stack, before: ...
                // On stack, after: ...
                //
                // Appends the string value of `content` to the current buffer
                appendContent: function appendContent(content) {
                    if (this.pendingContent) {
                        content = this.pendingContent + content;
                    } else {
                        this.pendingLocation = this.source.currentLocation;
                    }

                    this.pendingContent = content;
                },

                // [append]
                //
                // On stack, before: value, ...
                // On stack, after: ...
                //
                // Coerces `value` to a String and appends it to the current buffer.
                //
                // If `value` is truthy, or 0, it is coerced into a string and appended
                // Otherwise, the empty string is appended
                append: function append() {
                    if (this.isInline()) {
                        this.replaceStack(function (current) {
                            return [' != null ? ', current, ' : ""'];
                        });

                        this.pushSource(this.appendToBuffer(this.popStack()));
                    } else {
                        var local = this.popStack();
                        this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
                        if (this.environment.isSimple) {
                            this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
                        }
                    }
                },

                // [appendEscaped]
                //
                // On stack, before: value, ...
                // On stack, after: ...
                //
                // Escape `value` and append it to the buffer
                appendEscaped: function appendEscaped() {
                    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
                },

                // [getContext]
                //
                // On stack, before: ...
                // On stack, after: ...
                // Compiler value, after: lastContext=depth
                //
                // Set the value of the `lastContext` compiler value to the depth
                getContext: function getContext(depth) {
                    this.lastContext = depth;
                },

                // [pushContext]
                //
                // On stack, before: ...
                // On stack, after: currentContext, ...
                //
                // Pushes the value of the current context onto the stack.
                pushContext: function pushContext() {
                    this.pushStackLiteral(this.contextName(this.lastContext));
                },

                // [lookupOnContext]
                //
                // On stack, before: ...
                // On stack, after: currentContext[name], ...
                //
                // Looks up the value of `name` on the current context and pushes
                // it onto the stack.
                lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
                    var i = 0;

                    if (!scoped && this.options.compat && !this.lastContext) {
                        // The depthed query is expected to handle the undefined logic for the root level that
                        // is implemented below, so we evaluate that directly in compat mode
                        this.push(this.depthedLookup(parts[i++]));
                    } else {
                        this.pushContext();
                    }

                    this.resolvePath('context', parts, i, falsy, strict);
                },

                // [lookupBlockParam]
                //
                // On stack, before: ...
                // On stack, after: blockParam[name], ...
                //
                // Looks up the value of `parts` on the given block param and pushes
                // it onto the stack.
                lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
                    this.useBlockParams = true;

                    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
                    this.resolvePath('context', parts, 1);
                },

                // [lookupData]
                //
                // On stack, before: ...
                // On stack, after: data, ...
                //
                // Push the data lookup operator
                lookupData: function lookupData(depth, parts, strict) {
                    if (!depth) {
                        this.pushStackLiteral('data');
                    } else {
                        this.pushStackLiteral('container.data(data, ' + depth + ')');
                    }

                    this.resolvePath('data', parts, 0, true, strict);
                },

                resolvePath: function resolvePath(type, parts, i, falsy, strict) {
                    // istanbul ignore next

                    var _this = this;

                    if (this.options.strict || this.options.assumeObjects) {
                        this.push(strictLookup(this.options.strict && strict, this, parts, type));
                        return;
                    }

                    var len = parts.length;
                    for (; i < len; i++) {
                        /* eslint-disable no-loop-func */
                        this.replaceStack(function (current) {
                            var lookup = _this.nameLookup(current, parts[i], type);
                            // We want to ensure that zero and false are handled properly if the context (falsy flag)
                            // needs to have the special handling for these values.
                            if (!falsy) {
                                return [' != null ? ', lookup, ' : ', current];
                            } else {
                                // Otherwise we can use generic falsy handling
                                return [' && ', lookup];
                            }
                        });
                        /* eslint-enable no-loop-func */
                    }
                },

                // [resolvePossibleLambda]
                //
                // On stack, before: value, ...
                // On stack, after: resolved value, ...
                //
                // If the `value` is a lambda, replace it on the stack by
                // the return value of the lambda
                resolvePossibleLambda: function resolvePossibleLambda() {
                    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
                },

                // [pushStringParam]
                //
                // On stack, before: ...
                // On stack, after: string, currentContext, ...
                //
                // This opcode is designed for use in string mode, which
                // provides the string value of a parameter along with its
                // depth rather than resolving it immediately.
                pushStringParam: function pushStringParam(string, type) {
                    this.pushContext();
                    this.pushString(type);

                    // If it's a subexpression, the string result
                    // will be pushed after this opcode.
                    if (type !== 'SubExpression') {
                        if (typeof string === 'string') {
                            this.pushString(string);
                        } else {
                            this.pushStackLiteral(string);
                        }
                    }
                },

                emptyHash: function emptyHash(omitEmpty) {
                    if (this.trackIds) {
                        this.push('{}'); // hashIds
                    }
                    if (this.stringParams) {
                        this.push('{}'); // hashContexts
                        this.push('{}'); // hashTypes
                    }
                    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
                },
                pushHash: function pushHash() {
                    if (this.hash) {
                        this.hashes.push(this.hash);
                    }
                    this.hash = {values: [], types: [], contexts: [], ids: []};
                },
                popHash: function popHash() {
                    var hash = this.hash;
                    this.hash = this.hashes.pop();

                    if (this.trackIds) {
                        this.push(this.objectLiteral(hash.ids));
                    }
                    if (this.stringParams) {
                        this.push(this.objectLiteral(hash.contexts));
                        this.push(this.objectLiteral(hash.types));
                    }

                    this.push(this.objectLiteral(hash.values));
                },

                // [pushString]
                //
                // On stack, before: ...
                // On stack, after: quotedString(string), ...
                //
                // Push a quoted version of `string` onto the stack
                pushString: function pushString(string) {
                    this.pushStackLiteral(this.quotedString(string));
                },

                // [pushLiteral]
                //
                // On stack, before: ...
                // On stack, after: value, ...
                //
                // Pushes a value onto the stack. This operation prevents
                // the compiler from creating a temporary variable to hold
                // it.
                pushLiteral: function pushLiteral(value) {
                    this.pushStackLiteral(value);
                },

                // [pushProgram]
                //
                // On stack, before: ...
                // On stack, after: program(guid), ...
                //
                // Push a program expression onto the stack. This takes
                // a compile-time guid and converts it into a runtime-accessible
                // expression.
                pushProgram: function pushProgram(guid) {
                    if (guid != null) {
                        this.pushStackLiteral(this.programExpression(guid));
                    } else {
                        this.pushStackLiteral(null);
                    }
                },

                // [registerDecorator]
                //
                // On stack, before: hash, program, params..., ...
                // On stack, after: ...
                //
                // Pops off the decorator's parameters, invokes the decorator,
                // and inserts the decorator into the decorators list.
                registerDecorator: function registerDecorator(paramSize, name) {
                    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
                        options = this.setupHelperArgs(name, paramSize);

                    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
                },

                // [invokeHelper]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of helper invocation
                //
                // Pops off the helper's parameters, invokes the helper,
                // and pushes the helper's return value onto the stack.
                //
                // If the helper is not found, `helperMissing` is called.
                invokeHelper: function invokeHelper(paramSize, name, isSimple) {
                    var nonHelper = this.popStack(),
                        helper = this.setupHelper(paramSize, name),
                        simple = isSimple ? [helper.name, ' || '] : '';

                    var lookup = ['('].concat(simple, nonHelper);
                    if (!this.options.strict) {
                        lookup.push(' || ', this.aliasable('helpers.helperMissing'));
                    }
                    lookup.push(')');

                    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
                },

                // [invokeKnownHelper]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of helper invocation
                //
                // This operation is used when the helper is known to exist,
                // so a `helperMissing` fallback is not required.
                invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
                    var helper = this.setupHelper(paramSize, name);
                    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
                },

                // [invokeAmbiguous]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of disambiguation
                //
                // This operation is used when an expression like `{{foo}}`
                // is provided, but we don't know at compile-time whether it
                // is a helper or a path.
                //
                // This operation emits more code than the other options,
                // and can be avoided by passing the `knownHelpers` and
                // `knownHelpersOnly` flags at compile-time.
                invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
                    this.useRegister('helper');

                    var nonHelper = this.popStack();

                    this.emptyHash();
                    var helper = this.setupHelper(0, name, helperCall);

                    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

                    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
                    if (!this.options.strict) {
                        lookup[0] = '(helper = ';
                        lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
                    }

                    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
                },

                // [invokePartial]
                //
                // On stack, before: context, ...
                // On stack after: result of partial invocation
                //
                // This operation pops off a context, invokes a partial with that context,
                // and pushes the result of the invocation back.
                invokePartial: function invokePartial(isDynamic, name, indent) {
                    var params = [],
                        options = this.setupParams(name, 1, params);

                    if (isDynamic) {
                        name = this.popStack();
                        delete options.name;
                    }

                    if (indent) {
                        options.indent = JSON.stringify(indent);
                    }
                    options.helpers = 'helpers';
                    options.partials = 'partials';
                    options.decorators = 'container.decorators';

                    if (!isDynamic) {
                        params.unshift(this.nameLookup('partials', name, 'partial'));
                    } else {
                        params.unshift(name);
                    }

                    if (this.options.compat) {
                        options.depths = 'depths';
                    }
                    options = this.objectLiteral(options);
                    params.push(options);

                    this.push(this.source.functionCall('container.invokePartial', '', params));
                },

                // [assignToHash]
                //
                // On stack, before: value, ..., hash, ...
                // On stack, after: ..., hash, ...
                //
                // Pops a value off the stack and assigns it to the current hash
                assignToHash: function assignToHash(key) {
                    var value = this.popStack(),
                        context = undefined,
                        type = undefined,
                        id = undefined;

                    if (this.trackIds) {
                        id = this.popStack();
                    }
                    if (this.stringParams) {
                        type = this.popStack();
                        context = this.popStack();
                    }

                    var hash = this.hash;
                    if (context) {
                        hash.contexts[key] = context;
                    }
                    if (type) {
                        hash.types[key] = type;
                    }
                    if (id) {
                        hash.ids[key] = id;
                    }
                    hash.values[key] = value;
                },

                pushId: function pushId(type, name, child) {
                    if (type === 'BlockParam') {
                        this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
                    } else if (type === 'PathExpression') {
                        this.pushString(name);
                    } else if (type === 'SubExpression') {
                        this.pushStackLiteral('true');
                    } else {
                        this.pushStackLiteral('null');
                    }
                },

                // HELPERS

                compiler: JavaScriptCompiler,

                compileChildren: function compileChildren(environment, options) {
                    var children = environment.children,
                        child = undefined,
                        compiler = undefined;

                    for (var i = 0, l = children.length; i < l; i++) {
                        child = children[i];
                        compiler = new this.compiler(); // eslint-disable-line new-cap

                        var existing = this.matchExistingProgram(child);

                        if (existing == null) {
                            this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
                            var index = this.context.programs.length;
                            child.index = index;
                            child.name = 'program' + index;
                            this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
                            this.context.decorators[index] = compiler.decorators;
                            this.context.environments[index] = child;

                            this.useDepths = this.useDepths || compiler.useDepths;
                            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
                            child.useDepths = this.useDepths;
                            child.useBlockParams = this.useBlockParams;
                        } else {
                            child.index = existing.index;
                            child.name = 'program' + existing.index;

                            this.useDepths = this.useDepths || existing.useDepths;
                            this.useBlockParams = this.useBlockParams || existing.useBlockParams;
                        }
                    }
                },
                matchExistingProgram: function matchExistingProgram(child) {
                    for (var i = 0, len = this.context.environments.length; i < len; i++) {
                        var environment = this.context.environments[i];
                        if (environment && environment.equals(child)) {
                            return environment;
                        }
                    }
                },

                programExpression: function programExpression(guid) {
                    var child = this.environment.children[guid],
                        programParams = [child.index, 'data', child.blockParams];

                    if (this.useBlockParams || this.useDepths) {
                        programParams.push('blockParams');
                    }
                    if (this.useDepths) {
                        programParams.push('depths');
                    }

                    return 'container.program(' + programParams.join(', ') + ')';
                },

                useRegister: function useRegister(name) {
                    if (!this.registers[name]) {
                        this.registers[name] = true;
                        this.registers.list.push(name);
                    }
                },

                push: function push(expr) {
                    if (!(expr instanceof Literal)) {
                        expr = this.source.wrap(expr);
                    }

                    this.inlineStack.push(expr);
                    return expr;
                },

                pushStackLiteral: function pushStackLiteral(item) {
                    this.push(new Literal(item));
                },

                pushSource: function pushSource(source) {
                    if (this.pendingContent) {
                        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
                        this.pendingContent = undefined;
                    }

                    if (source) {
                        this.source.push(source);
                    }
                },

                replaceStack: function replaceStack(callback) {
                    var prefix = ['('],
                        stack = undefined,
                        createdStack = undefined,
                        usedLiteral = undefined;

                    /* istanbul ignore next */
                    if (!this.isInline()) {
                        throw new _exception2['default']('replaceStack on non-inline');
                    }

                    // We want to merge the inline statement into the replacement statement via ','
                    var top = this.popStack(true);

                    if (top instanceof Literal) {
                        // Literals do not need to be inlined
                        stack = [top.value];
                        prefix = ['(', stack];
                        usedLiteral = true;
                    } else {
                        // Get or create the current stack name for use by the inline
                        createdStack = true;
                        var _name = this.incrStack();

                        prefix = ['((', this.push(_name), ' = ', top, ')'];
                        stack = this.topStack();
                    }

                    var item = callback.call(this, stack);

                    if (!usedLiteral) {
                        this.popStack();
                    }
                    if (createdStack) {
                        this.stackSlot--;
                    }
                    this.push(prefix.concat(item, ')'));
                },

                incrStack: function incrStack() {
                    this.stackSlot++;
                    if (this.stackSlot > this.stackVars.length) {
                        this.stackVars.push('stack' + this.stackSlot);
                    }
                    return this.topStackName();
                },
                topStackName: function topStackName() {
                    return 'stack' + this.stackSlot;
                },
                flushInline: function flushInline() {
                    var inlineStack = this.inlineStack;
                    this.inlineStack = [];
                    for (var i = 0, len = inlineStack.length; i < len; i++) {
                        var entry = inlineStack[i];
                        /* istanbul ignore if */
                        if (entry instanceof Literal) {
                            this.compileStack.push(entry);
                        } else {
                            var stack = this.incrStack();
                            this.pushSource([stack, ' = ', entry, ';']);
                            this.compileStack.push(stack);
                        }
                    }
                },
                isInline: function isInline() {
                    return this.inlineStack.length;
                },

                popStack: function popStack(wrapped) {
                    var inline = this.isInline(),
                        item = (inline ? this.inlineStack : this.compileStack).pop();

                    if (!wrapped && item instanceof Literal) {
                        return item.value;
                    } else {
                        if (!inline) {
                            /* istanbul ignore next */
                            if (!this.stackSlot) {
                                throw new _exception2['default']('Invalid stack pop');
                            }
                            this.stackSlot--;
                        }
                        return item;
                    }
                },

                topStack: function topStack() {
                    var stack = this.isInline() ? this.inlineStack : this.compileStack,
                        item = stack[stack.length - 1];

                    /* istanbul ignore if */
                    if (item instanceof Literal) {
                        return item.value;
                    } else {
                        return item;
                    }
                },

                contextName: function contextName(context) {
                    if (this.useDepths && context) {
                        return 'depths[' + context + ']';
                    } else {
                        return 'depth' + context;
                    }
                },

                quotedString: function quotedString(str) {
                    return this.source.quotedString(str);
                },

                objectLiteral: function objectLiteral(obj) {
                    return this.source.objectLiteral(obj);
                },

                aliasable: function aliasable(name) {
                    var ret = this.aliases[name];
                    if (ret) {
                        ret.referenceCount++;
                        return ret;
                    }

                    ret = this.aliases[name] = this.source.wrap(name);
                    ret.aliasable = true;
                    ret.referenceCount = 1;

                    return ret;
                },

                setupHelper: function setupHelper(paramSize, name, blockHelper) {
                    var params = [],
                        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
                    var foundHelper = this.nameLookup('helpers', name, 'helper'),
                        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

                    return {
                        params: params,
                        paramsInit: paramsInit,
                        name: foundHelper,
                        callParams: [callContext].concat(params)
                    };
                },

                setupParams: function setupParams(helper, paramSize, params) {
                    var options = {},
                        contexts = [],
                        types = [],
                        ids = [],
                        objectArgs = !params,
                        param = undefined;

                    if (objectArgs) {
                        params = [];
                    }

                    options.name = this.quotedString(helper);
                    options.hash = this.popStack();

                    if (this.trackIds) {
                        options.hashIds = this.popStack();
                    }
                    if (this.stringParams) {
                        options.hashTypes = this.popStack();
                        options.hashContexts = this.popStack();
                    }

                    var inverse = this.popStack(),
                        program = this.popStack();

                    // Avoid setting fn and inverse if neither are set. This allows
                    // helpers to do a check for `if (options.fn)`
                    if (program || inverse) {
                        options.fn = program || 'container.noop';
                        options.inverse = inverse || 'container.noop';
                    }

                    // The parameters go on to the stack in order (making sure that they are evaluated in order)
                    // so we need to pop them off the stack in reverse order
                    var i = paramSize;
                    while (i--) {
                        param = this.popStack();
                        params[i] = param;

                        if (this.trackIds) {
                            ids[i] = this.popStack();
                        }
                        if (this.stringParams) {
                            types[i] = this.popStack();
                            contexts[i] = this.popStack();
                        }
                    }

                    if (objectArgs) {
                        options.args = this.source.generateArray(params);
                    }

                    if (this.trackIds) {
                        options.ids = this.source.generateArray(ids);
                    }
                    if (this.stringParams) {
                        options.types = this.source.generateArray(types);
                        options.contexts = this.source.generateArray(contexts);
                    }

                    if (this.options.data) {
                        options.data = 'data';
                    }
                    if (this.useBlockParams) {
                        options.blockParams = 'blockParams';
                    }
                    return options;
                },

                setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
                    var options = this.setupParams(helper, paramSize, params);
                    options = this.objectLiteral(options);
                    if (useRegister) {
                        this.useRegister('options');
                        params.push('options');
                        return ['options=', options];
                    } else if (params) {
                        params.push(options);
                        return '';
                    } else {
                        return options;
                    }
                }
            };

            (function () {
                var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

                var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

                for (var i = 0, l = reservedWords.length; i < l; i++) {
                    compilerWords[reservedWords[i]] = true;
                }
            })();

            JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
                return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
            };

            function strictLookup(requireTerminal, compiler, parts, type) {
                var stack = compiler.popStack(),
                    i = 0,
                    len = parts.length;
                if (requireTerminal) {
                    len--;
                }

                for (; i < len; i++) {
                    stack = compiler.nameLookup(stack, parts[i], type);
                }

                if (requireTerminal) {
                    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
                } else {
                    return stack;
                }
            }

            exports['default'] = JavaScriptCompiler;
            module.exports = exports['default'];

            /***/
        }),
        /* 43 */
        /***/ (function (module, exports, __webpack_require__) {

            /* global define */
            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var SourceNode = undefined;

            try {
                /* istanbul ignore next */
                if (false) {
                    // We don't support this in AMD environments. For these environments, we asusme that
                    // they are running on the browser and thus have no need for the source-map library.
                    var SourceMap = require('source-map');
                    SourceNode = SourceMap.SourceNode;
                }
            } catch (err) {
            }
            /* NOP */

            /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
            if (!SourceNode) {
                SourceNode = function (line, column, srcFile, chunks) {
                    this.src = '';
                    if (chunks) {
                        this.add(chunks);
                    }
                };
                /* istanbul ignore next */
                SourceNode.prototype = {
                    add: function add(chunks) {
                        if (_utils.isArray(chunks)) {
                            chunks = chunks.join('');
                        }
                        this.src += chunks;
                    },
                    prepend: function prepend(chunks) {
                        if (_utils.isArray(chunks)) {
                            chunks = chunks.join('');
                        }
                        this.src = chunks + this.src;
                    },
                    toStringWithSourceMap: function toStringWithSourceMap() {
                        return {code: this.toString()};
                    },
                    toString: function toString() {
                        return this.src;
                    }
                };
            }

            function castChunk(chunk, codeGen, loc) {
                if (_utils.isArray(chunk)) {
                    var ret = [];

                    for (var i = 0, len = chunk.length; i < len; i++) {
                        ret.push(codeGen.wrap(chunk[i], loc));
                    }
                    return ret;
                } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
                    // Handle primitives that the SourceNode will throw up on
                    return chunk + '';
                }
                return chunk;
            }

            function CodeGen(srcFile) {
                this.srcFile = srcFile;
                this.source = [];
            }

            CodeGen.prototype = {
                isEmpty: function isEmpty() {
                    return !this.source.length;
                },
                prepend: function prepend(source, loc) {
                    this.source.unshift(this.wrap(source, loc));
                },
                push: function push(source, loc) {
                    this.source.push(this.wrap(source, loc));
                },

                merge: function merge() {
                    var source = this.empty();
                    this.each(function (line) {
                        source.add(['  ', line, '\n']);
                    });
                    return source;
                },

                each: function each(iter) {
                    for (var i = 0, len = this.source.length; i < len; i++) {
                        iter(this.source[i]);
                    }
                },

                empty: function empty() {
                    var loc = this.currentLocation || {start: {}};
                    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
                },
                wrap: function wrap(chunk) {
                    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || {start: {}} : arguments[1];

                    if (chunk instanceof SourceNode) {
                        return chunk;
                    }

                    chunk = castChunk(chunk, this, loc);

                    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
                },

                functionCall: function functionCall(fn, type, params) {
                    params = this.generateList(params);
                    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
                },

                quotedString: function quotedString(str) {
                    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
                        .replace(/\u2029/g, '\\u2029') + '"';
                },

                objectLiteral: function objectLiteral(obj) {
                    var pairs = [];

                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            var value = castChunk(obj[key], this);
                            if (value !== 'undefined') {
                                pairs.push([this.quotedString(key), ':', value]);
                            }
                        }
                    }

                    var ret = this.generateList(pairs);
                    ret.prepend('{');
                    ret.add('}');
                    return ret;
                },

                generateList: function generateList(entries) {
                    var ret = this.empty();

                    for (var i = 0, len = entries.length; i < len; i++) {
                        if (i) {
                            ret.add(',');
                        }

                        ret.add(castChunk(entries[i], this));
                    }

                    return ret;
                },

                generateArray: function generateArray(entries) {
                    var ret = this.generateList(entries);
                    ret.prepend('[');
                    ret.add(']');

                    return ret;
                }
            };

            exports['default'] = CodeGen;
            module.exports = exports['default'];

            /***/
        })
        /******/])
});
;
/*!
* jquery.inputmask.bundle.js
* https://github.com/RobinHerbots/Inputmask
* Copyright (c) 2010 - 2017 Robin Herbots
* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
* Version: 3.3.11
*/

!function (modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__),
            module.l = !0, module.exports;
    }

    var installedModules = {};
    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function (exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            configurable: !1,
            enumerable: !0,
            get: getter
        });
    }, __webpack_require__.n = function (module) {
        var getter = module && module.__esModule ? function () {
            return module.default;
        } : function () {
            return module;
        };
        return __webpack_require__.d(getter, "a", getter), getter;
    }, __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 3);
}([function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function (factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function ($) {
        return $;
    });
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__,
        _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
        } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    !function (factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(10), __webpack_require__(11)],
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function ($, window, document, undefined) {
        function Inputmask(alias, options, internal) {
            if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);
            this.el = undefined, this.events = {}, this.maskset = undefined, this.refreshValue = !1,
            !0 !== internal && ($.isPlainObject(alias) ? options = alias : (options = options || {}).alias = alias,
                this.opts = $.extend(!0, {}, this.defaults, options), this.noMasksCache = options && options.definitions !== undefined,
                this.userOptions = options || {}, this.isRTL = this.opts.numericInput, resolveAlias(this.opts.alias, options, this.opts));
        }

        function resolveAlias(aliasStr, options, opts) {
            var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
            return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, undefined, opts),
                $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr),
                !1);
        }

        function generateMaskSet(opts, nocache) {
            function generateMask(mask, metadata, opts) {
                var regexMask = !1;
                if (null !== mask && "" !== mask || ((regexMask = null !== opts.regex) ? mask = (mask = opts.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (regexMask = !0,
                    mask = ".*")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = ""),
                opts.repeat > 0 || "*" === opts.repeat || "+" === opts.repeat) {
                    var repeatStart = "*" === opts.repeat ? 0 : "+" === opts.repeat ? 1 : opts.repeat;
                    mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
                }
                var masksetDefinition,
                    maskdefKey = regexMask ? "regex_" + opts.regex : opts.numericInput ? mask.split("").reverse().join("") : mask;
                return Inputmask.prototype.masksCache[maskdefKey] === undefined || !0 === nocache ? (masksetDefinition = {
                    mask: mask,
                    maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),
                    validPositions: {},
                    _buffer: undefined,
                    buffer: undefined,
                    tests: {},
                    metadata: metadata,
                    maskLength: undefined
                }, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition,
                    masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]),
                    masksetDefinition;
            }

            if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {
                if (opts.mask.length > 1) {
                    opts.keepStatic = null === opts.keepStatic || opts.keepStatic;
                    var altMask = opts.groupmarker.start;
                    return $.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function (ndx, msk) {
                        altMask.length > 1 && (altMask += opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start),
                            msk.mask === undefined || $.isFunction(msk.mask) ? altMask += msk : altMask += msk.mask;
                    }), altMask += opts.groupmarker.end, generateMask(altMask, opts.mask, opts);
                }
                opts.mask = opts.mask.pop();
            }
            return opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask) ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts);
        }

        function maskScope(actionObj, maskset, opts) {
            function getMaskTemplate(baseOnInput, minimalPos, includeMode) {
                minimalPos = minimalPos || 0;
                var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0, lvp = getLastValidPosition();
                do {
                    !0 === baseOnInput && getMaskSet().validPositions[pos] ? (test = (testPos = getMaskSet().validPositions[pos]).match,
                        ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))) : (test = (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)).match,
                        ndxIntlzr = testPos.locator.slice(), (!1 === opts.jitMasking || pos < lvp || "number" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos) && maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))),
                        pos++;
                } while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || "" !== test.def) || minimalPos > pos);
                return "" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), getMaskSet().maskLength = pos + 1,
                    maskTemplate;
            }

            function getMaskSet() {
                return maskset;
            }

            function resetMaskSet(soft) {
                var maskset = getMaskSet();
                maskset.buffer = undefined, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0);
            }

            function getLastValidPosition(closestTo, strict, validPositions) {
                var before = -1, after = -1, valids = validPositions || getMaskSet().validPositions;
                closestTo === undefined && (closestTo = -1);
                for (var posNdx in valids) {
                    var psNdx = parseInt(posNdx);
                    valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx),
                    psNdx >= closestTo && (after = psNdx));
                }
                return -1 !== before && closestTo - before > 1 || after < closestTo ? before : after;
            }

            function stripValidPositions(start, end, nocheck, strict) {
                var i, startPos = start, positionsClone = $.extend(!0, {}, getMaskSet().validPositions),
                    needsValidation = !1;
                for (getMaskSet().p = start, i = end - 1; i >= startPos; i--) getMaskSet().validPositions[i] !== undefined && (!0 !== nocheck && (!getMaskSet().validPositions[i].match.optionality && function (pos) {
                    var posMatch = getMaskSet().validPositions[pos];
                    if (posMatch !== undefined && null === posMatch.match.fn) {
                        var prevMatch = getMaskSet().validPositions[pos - 1],
                            nextMatch = getMaskSet().validPositions[pos + 1];
                        return prevMatch !== undefined && nextMatch !== undefined;
                    }
                    return !1;
                }(i) || !1 === opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts)) || delete getMaskSet().validPositions[i]);
                for (resetMaskSet(!0), i = startPos + 1; i <= getLastValidPosition();) {
                    for (; getMaskSet().validPositions[startPos] !== undefined;) startPos++;
                    if (i < startPos && (i = startPos + 1), getMaskSet().validPositions[i] === undefined && isMask(i)) i++; else {
                        var t = getTestTemplate(i);
                        !1 === needsValidation && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def ? (getMaskSet().validPositions[startPos] = $.extend(!0, {}, positionsClone[startPos]),
                            getMaskSet().validPositions[startPos].input = t.input, delete getMaskSet().validPositions[i],
                            i++) : positionCanMatchDefinition(startPos, t.match.def) ? !1 !== isValid(startPos, t.input || getPlaceholder(i), !0) && (delete getMaskSet().validPositions[i],
                            i++, needsValidation = !0) : isMask(i) || (i++, startPos--), startPos++;
                    }
                }
                resetMaskSet(!0);
            }

            function determineTestTemplate(tests, guessNextBest) {
                for (var testPos, testPositions = tests, lvp = getLastValidPosition(), lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0], lvTestAltArr = lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation].toString().split(",") : [], ndx = 0; ndx < testPositions.length && (!((testPos = testPositions[ndx]).match && (opts.greedy && !0 !== testPos.match.optionalQuantifier || (!1 === testPos.match.optionality || !1 === testPos.match.newBlockMarker) && !0 !== testPos.match.optionalQuantifier) && (lvTest.alternation === undefined || lvTest.alternation !== testPos.alternation || testPos.locator[lvTest.alternation] !== undefined && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAltArr))) || !0 === guessNextBest && (null !== testPos.match.fn || /[0-9a-bA-Z]/.test(testPos.match.def))); ndx++) ;
                return testPos;
            }

            function getTestTemplate(pos, ndxIntlzr, tstPs) {
                return getMaskSet().validPositions[pos] || determineTestTemplate(getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));
            }

            function getTest(pos) {
                return getMaskSet().validPositions[pos] ? getMaskSet().validPositions[pos] : getTests(pos)[0];
            }

            function positionCanMatchDefinition(pos, def) {
                for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) if (tests[tndx].match && tests[tndx].match.def === def) {
                    valid = !0;
                    break;
                }
                return valid;
            }

            function getTests(pos, ndxIntlzr, tstPs) {
                function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
                    function handleMatch(match, loopNdx, quantifierRecurse) {
                        function isFirstMatch(latestMatch, tokenGroup) {
                            var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);
                            return firstMatch || $.each(tokenGroup.matches, function (ndx, match) {
                                if (!0 === match.isQuantifier && (firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]))) return !1;
                            }), firstMatch;
                        }

                        function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {
                            var bestMatch, indexPos;
                            if (getMaskSet().validPositions[pos - 1] && targetAlternation && getMaskSet().tests[pos]) for (var vpAlternation = getMaskSet().validPositions[pos - 1].locator, tpAlternation = getMaskSet().tests[pos][0].locator, i = 0; i < targetAlternation; i++) if (vpAlternation[i] !== tpAlternation[i]) return vpAlternation.slice(targetAlternation + 1);
                            return (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) && $.each(getMaskSet().tests[pos] || [getMaskSet().validPositions[pos]], function (ndx, lmnt) {
                                var alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation,
                                    ndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;
                                (indexPos === undefined || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt,
                                    indexPos = ndxPos);
                            }), bestMatch ? bestMatch.locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1) : targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;
                        }

                        if (testPos > 1e4) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask;
                        if (testPos === pos && match.matches === undefined) return matches.push({
                            match: match,
                            locator: loopNdx.reverse(),
                            cd: cacheDependency
                        }), !0;
                        if (match.matches !== undefined) {
                            if (match.isGroup && quantifierRecurse !== match) {
                                if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx)) return !0;
                            } else if (match.isOptional) {
                                var optionalToken = match;
                                if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {
                                    if (latestMatch = matches[matches.length - 1].match, !isFirstMatch(latestMatch, optionalToken)) return !0;
                                    insertStop = !0, testPos = pos;
                                }
                            } else if (match.isAlternator) {
                                var maltMatches, alternateToken = match, malternateMatches = [],
                                    currentMatches = matches.slice(), loopNdxCnt = loopNdx.length,
                                    altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
                                if (-1 === altIndex || "string" == typeof altIndex) {
                                    var amndx, currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(),
                                        altIndexArr = [];
                                    if ("string" == typeof altIndex) altIndexArr = altIndex.split(","); else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx);
                                    for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
                                        if (amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(),
                                        !0 !== (match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) || match) && match !== undefined && altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length) {
                                            var ntndx = $.inArray(match, maskToken.matches) + 1;
                                            maskToken.matches.length > ntndx && (match = handleMatch(maskToken.matches[ntndx], [ntndx].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse)) && (altIndexArr.push(ntndx.toString()),
                                                $.each(matches, function (ndx, lmnt) {
                                                    lmnt.alternation = loopNdx.length - 1;
                                                }));
                                        }
                                        maltMatches = matches.slice(), testPos = currentPos, matches = [];
                                        for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                                            var altMatch = maltMatches[ndx1], dropMatch = !1;
                                            altMatch.alternation = altMatch.alternation || loopNdxCnt;
                                            for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                                                var altMatch2 = malternateMatches[ndx2];
                                                if ("string" != typeof altIndex || -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr)) {
                                                    if (function (source, target) {
                                                        return source.match.nativeDef === target.match.nativeDef || source.match.def === target.match.nativeDef || source.match.nativeDef === target.match.def;
                                                    }(altMatch, altMatch2)) {
                                                        dropMatch = !0, altMatch.alternation === altMatch2.alternation && -1 === altMatch2.locator[altMatch2.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) && (altMatch2.locator[altMatch2.alternation] = altMatch2.locator[altMatch2.alternation] + "," + altMatch.locator[altMatch.alternation],
                                                            altMatch2.alternation = altMatch.alternation), altMatch.match.nativeDef === altMatch2.match.def && (altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation],
                                                            malternateMatches.splice(malternateMatches.indexOf(altMatch2), 1, altMatch));
                                                        break;
                                                    }
                                                    if (altMatch.match.def === altMatch2.match.def) {
                                                        dropMatch = !1;
                                                        break;
                                                    }
                                                    if (function (source, target) {
                                                        return null === source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def, getMaskSet(), pos, !1, opts, !1);
                                                    }(altMatch, altMatch2) || function (source, target) {
                                                        return null !== source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def.replace(/[\[\]]/g, ""), getMaskSet(), pos, !1, opts, !1);
                                                    }(altMatch, altMatch2)) {
                                                        altMatch.alternation === altMatch2.alternation && -1 === altMatch.locator[altMatch.alternation].toString().indexOf(altMatch2.locator[altMatch2.alternation].toString().split("")[0]) && (altMatch.na = altMatch.na || altMatch.locator[altMatch.alternation].toString(),
                                                        -1 === altMatch.na.indexOf(altMatch.locator[altMatch.alternation].toString().split("")[0]) && (altMatch.na = altMatch.na + "," + altMatch.locator[altMatch2.alternation].toString().split("")[0]),
                                                            dropMatch = !0, altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation].toString().split("")[0] + "," + altMatch.locator[altMatch.alternation],
                                                            malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));
                                                        break;
                                                    }
                                                }
                                            }
                                            dropMatch || malternateMatches.push(altMatch);
                                        }
                                    }
                                    "string" == typeof altIndex && (malternateMatches = $.map(malternateMatches, function (lmnt, ndx) {
                                        if (isFinite(ndx)) {
                                            var alternation = lmnt.alternation,
                                                altLocArr = lmnt.locator[alternation].toString().split(",");
                                            lmnt.locator[alternation] = undefined, lmnt.alternation = undefined;
                                            for (var alndx = 0; alndx < altLocArr.length; alndx++) -1 !== $.inArray(altLocArr[alndx], altIndexArr) && (lmnt.locator[alternation] !== undefined ? (lmnt.locator[alternation] += ",",
                                                lmnt.locator[alternation] += altLocArr[alndx]) : lmnt.locator[alternation] = parseInt(altLocArr[alndx]),
                                                lmnt.alternation = alternation);
                                            if (lmnt.locator[alternation] !== undefined) return lmnt;
                                        }
                                    })), matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = matches.length > 0,
                                        match = malternateMatches.length > 0, ndxInitializer = ndxInitializerClone.slice();
                                } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
                                if (match) return !0;
                            } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {
                                var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
                                if (match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup)) {
                                    if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx > qt.quantifier.min - 1,
                                        isFirstMatch(latestMatch, tokenGroup)) {
                                        if (qndx > qt.quantifier.min - 1) {
                                            insertStop = !0, testPos = pos;
                                            break;
                                        }
                                        return !0;
                                    }
                                    return !0;
                                }
                            } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0;
                        } else testPos++;
                    }

                    for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (!0 !== maskToken.matches[tndx].isQuantifier) {
                        var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
                        if (match && testPos === pos) return match;
                        if (testPos > pos) break;
                    }
                }

                function filterTests(tests) {
                    if (opts.keepStatic && pos > 0 && tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0) && !0 !== tests[0].match.optionality && !0 !== tests[0].match.optionalQuantifier && null === tests[0].match.fn && !/[0-9a-bA-Z]/.test(tests[0].match.def)) {
                        if (getMaskSet().validPositions[pos - 1] === undefined) return [determineTestTemplate(tests)];
                        if (getMaskSet().validPositions[pos - 1].alternation === tests[0].alternation) return [determineTestTemplate(tests)];
                        if (getMaskSet().validPositions[pos - 1]) return [determineTestTemplate(tests)];
                    }
                    return tests;
                }

                var latestMatch, maskTokens = getMaskSet().maskToken, testPos = ndxIntlzr ? tstPs : 0,
                    ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0], matches = [], insertStop = !1,
                    cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";
                if (pos > -1) {
                    if (ndxIntlzr === undefined) {
                        for (var test, previousPos = pos - 1; (test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1;) previousPos--;
                        test !== undefined && previousPos > -1 && (ndxInitializer = function (tests) {
                            var locator = [];
                            return $.isArray(tests) || (tests = [tests]), tests.length > 0 && (tests[0].alternation === undefined ? 0 === (locator = determineTestTemplate(tests.slice()).locator.slice()).length && (locator = tests[0].locator.slice()) : $.each(tests, function (ndx, tst) {
                                if ("" !== tst.def) if (0 === locator.length) locator = tst.locator.slice(); else for (var i = 0; i < locator.length; i++) tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += "," + tst.locator[i]);
                            })), locator;
                        }(test), cacheDependency = ndxInitializer.join(""), testPos = previousPos);
                    }
                    if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) return filterTests(getMaskSet().tests[pos]);
                    for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length && !(resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]) && testPos === pos || testPos > pos); mtndx++) ;
                }
                return (0 === matches.length || insertStop) && matches.push({
                    match: {
                        fn: null,
                        cardinality: 0,
                        optionality: !0,
                        casing: null,
                        def: "",
                        placeholder: ""
                    },
                    locator: [],
                    cd: cacheDependency
                }), ndxIntlzr !== undefined && getMaskSet().tests[pos] ? filterTests($.extend(!0, [], matches)) : (getMaskSet().tests[pos] = $.extend(!0, [], matches),
                    filterTests(getMaskSet().tests[pos]));
            }

            function getBufferTemplate() {
                return getMaskSet()._buffer === undefined && (getMaskSet()._buffer = getMaskTemplate(!1, 1),
                getMaskSet().buffer === undefined && (getMaskSet().buffer = getMaskSet()._buffer.slice())),
                    getMaskSet()._buffer;
            }

            function getBuffer(noCache) {
                return getMaskSet().buffer !== undefined && !0 !== noCache || (getMaskSet().buffer = getMaskTemplate(!0, getLastValidPosition(), !0)),
                    getMaskSet().buffer;
            }

            function refreshFromBuffer(start, end, buffer) {
                var i, p;
                if (!0 === start) resetMaskSet(), start = 0, end = buffer.length; else for (i = start; i < end; i++) delete getMaskSet().validPositions[i];
                for (p = start, i = start; i < end; i++) if (resetMaskSet(!0), buffer[i] !== opts.skipOptionalPartCharacter) {
                    var valResult = isValid(p, buffer[i], !0, !0);
                    !1 !== valResult && (resetMaskSet(!0), p = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1);
                }
            }

            function casing(elem, test, pos) {
                switch (opts.casing || test.casing) {
                    case "upper":
                        elem = elem.toUpperCase();
                        break;

                    case "lower":
                        elem = elem.toLowerCase();
                        break;

                    case "title":
                        var posBefore = getMaskSet().validPositions[pos - 1];
                        elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase();
                        break;

                    default:
                        if ($.isFunction(opts.casing)) {
                            var args = Array.prototype.slice.call(arguments);
                            args.push(getMaskSet().validPositions), elem = opts.casing.apply(this, args);
                        }
                }
                return elem;
            }

            function checkAlternationMatch(altArr1, altArr2, na) {
                for (var naNdx, altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = na !== undefined ? na.split(",") : [], i = 0; i < naArr.length; i++) -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);
                for (var alndx = 0; alndx < altArr1.length; alndx++) if (-1 !== $.inArray(altArr1[alndx], altArrC)) {
                    isMatch = !0;
                    break;
                }
                return isMatch;
            }

            function isValid(pos, c, strict, fromSetValid, fromAlternate, validateOnly) {
                function isSelection(posObj) {
                    var selection = isRTL ? posObj.begin - posObj.end > 1 || posObj.begin - posObj.end == 1 : posObj.end - posObj.begin > 1 || posObj.end - posObj.begin == 1;
                    return selection && 0 === posObj.begin && posObj.end === getMaskSet().maskLength ? "full" : selection;
                }

                function _isValid(position, c, strict) {
                    var rslt = !1;
                    return $.each(getTests(position), function (ndx, tst) {
                        for (var test = tst.match, loopend = c ? 1 : 0, chrs = "", i = test.cardinality; i > loopend; i--) chrs += getBufferElement(position - (i - 1));
                        if (c && (chrs += c), getBuffer(!0), !1 !== (rslt = null != test.fn ? test.fn.test(chrs, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && "" !== test.def && {
                            c: getPlaceholder(position, test, !0) || test.def,
                            pos: position
                        })) {
                            var elem = rslt.c !== undefined ? rslt.c : c;
                            elem = elem === opts.skipOptionalPartCharacter && null === test.fn ? getPlaceholder(position, test, !0) || test.def : elem;
                            var validatedPos = position, possibleModifiedBuffer = getBuffer();
                            if (rslt.remove !== undefined && ($.isArray(rslt.remove) || (rslt.remove = [rslt.remove]),
                                $.each(rslt.remove.sort(function (a, b) {
                                    return b - a;
                                }), function (ndx, lmnt) {
                                    stripValidPositions(lmnt, lmnt + 1, !0);
                                })), rslt.insert !== undefined && ($.isArray(rslt.insert) || (rslt.insert = [rslt.insert]),
                                $.each(rslt.insert.sort(function (a, b) {
                                    return a - b;
                                }), function (ndx, lmnt) {
                                    isValid(lmnt.pos, lmnt.c, !0, fromSetValid);
                                })), rslt.refreshFromBuffer) {
                                var refresh = rslt.refreshFromBuffer;
                                if (refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, possibleModifiedBuffer),
                                rslt.pos === undefined && rslt.c === undefined) return rslt.pos = getLastValidPosition(),
                                    !1;
                                if ((validatedPos = rslt.pos !== undefined ? rslt.pos : position) !== position) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0, fromSetValid)),
                                    !1;
                            } else if (!0 !== rslt && rslt.pos !== undefined && rslt.pos !== position && (validatedPos = rslt.pos,
                                refreshFromBuffer(position, validatedPos, getBuffer().slice()), validatedPos !== position)) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0)),
                                !1;
                            return (!0 === rslt || rslt.pos !== undefined || rslt.c !== undefined) && (ndx > 0 && resetMaskSet(!0),
                            setValidPosition(validatedPos, $.extend({}, tst, {
                                input: casing(elem, test, validatedPos)
                            }), fromSetValid, isSelection(pos)) || (rslt = !1), !1);
                        }
                    }), rslt;
                }

                function setValidPosition(pos, validTest, fromSetValid, isSelection) {
                    if (isSelection || opts.insertMode && getMaskSet().validPositions[pos] !== undefined && fromSetValid === undefined) {
                        var i, positionsClone = $.extend(!0, {}, getMaskSet().validPositions),
                            lvp = getLastValidPosition(undefined, !0);
                        for (i = pos; i <= lvp; i++) delete getMaskSet().validPositions[i];
                        getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);
                        var j, valid = !0, vps = getMaskSet().validPositions, needsValidation = !1,
                            initialLength = getMaskSet().maskLength;
                        for (i = j = pos; i <= lvp; i++) {
                            var t = positionsClone[i];
                            if (t !== undefined) for (var posMatch = j; posMatch < getMaskSet().maskLength && (null === t.match.fn && vps[i] && (!0 === vps[i].match.optionalQuantifier || !0 === vps[i].match.optionality) || null != t.match.fn);) {
                                if (posMatch++, !1 === needsValidation && positionsClone[posMatch] && positionsClone[posMatch].match.def === t.match.def) getMaskSet().validPositions[posMatch] = $.extend(!0, {}, positionsClone[posMatch]),
                                    getMaskSet().validPositions[posMatch].input = t.input, fillMissingNonMask(posMatch),
                                    j = posMatch, valid = !0; else if (positionCanMatchDefinition(posMatch, t.match.def)) {
                                    var result = isValid(posMatch, t.input, !0, !0);
                                    valid = !1 !== result, j = result.caret || result.insert ? getLastValidPosition() : posMatch,
                                        needsValidation = !0;
                                } else if (!(valid = !0 === t.generatedInput) && posMatch >= getMaskSet().maskLength - 1) break;
                                if (getMaskSet().maskLength < initialLength && (getMaskSet().maskLength = initialLength),
                                    valid) break;
                            }
                            if (!valid) break;
                        }
                        if (!valid) return getMaskSet().validPositions = $.extend(!0, {}, positionsClone),
                            resetMaskSet(!0), !1;
                    } else getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);
                    return resetMaskSet(!0), !0;
                }

                function fillMissingNonMask(maskPos) {
                    for (var pndx = maskPos - 1; pndx > -1 && !getMaskSet().validPositions[pndx]; pndx--) ;
                    var testTemplate, testsFromPos;
                    for (pndx++; pndx < maskPos; pndx++) getMaskSet().validPositions[pndx] === undefined && (!1 === opts.jitMasking || opts.jitMasking > pndx) && ("" === (testsFromPos = getTests(pndx, getTestTemplate(pndx - 1).locator, pndx - 1).slice())[testsFromPos.length - 1].match.def && testsFromPos.pop(),
                    (testTemplate = determineTestTemplate(testsFromPos)) && (testTemplate.match.def === opts.radixPointDefinitionSymbol || !isMask(pndx, !0) || $.inArray(opts.radixPoint, getBuffer()) < pndx && testTemplate.match.fn && testTemplate.match.fn.test(getPlaceholder(pndx), getMaskSet(), pndx, !1, opts)) && !1 !== (result = _isValid(pndx, getPlaceholder(pndx, testTemplate.match, !0) || (null == testTemplate.match.fn ? testTemplate.match.def : "" !== getPlaceholder(pndx) ? getPlaceholder(pndx) : getBuffer()[pndx]), !0)) && (getMaskSet().validPositions[result.pos || pndx].generatedInput = !0));
                }

                strict = !0 === strict;
                var maskPos = pos;
                pos.begin !== undefined && (maskPos = isRTL && !isSelection(pos) ? pos.end : pos.begin);
                var result = !0, positionsClone = $.extend(!0, {}, getMaskSet().validPositions);
                if ($.isFunction(opts.preValidation) && !strict && !0 !== fromSetValid && !0 !== validateOnly && (result = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts)),
                !0 === result) {
                    if (fillMissingNonMask(maskPos), isSelection(pos) && (handleRemove(undefined, Inputmask.keyCode.DELETE, pos, !0, !0),
                        maskPos = getMaskSet().p), maskPos < getMaskSet().maskLength && (maxLength === undefined || maskPos < maxLength) && (result = _isValid(maskPos, c, strict),
                    (!strict || !0 === fromSetValid) && !1 === result && !0 !== validateOnly)) {
                        var currentPosValid = getMaskSet().validPositions[maskPos];
                        if (!currentPosValid || null !== currentPosValid.match.fn || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {
                            if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && !isMask(maskPos, !0)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) if (!1 !== (result = _isValid(nPos, c, strict))) {
                                !function (originalPos, newPos) {
                                    var vp = getMaskSet().validPositions[newPos];
                                    if (vp) for (var targetLocator = vp.locator, tll = targetLocator.length, ps = originalPos; ps < newPos; ps++) if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, !0)) {
                                        var tests = getTests(ps).slice(), bestMatch = determineTestTemplate(tests, !0),
                                            equality = -1;
                                        "" === tests[tests.length - 1].match.def && tests.pop(), $.each(tests, function (ndx, tst) {
                                            for (var i = 0; i < tll; i++) {
                                                if (tst.locator[i] === undefined || !checkAlternationMatch(tst.locator[i].toString().split(","), targetLocator[i].toString().split(","), tst.na)) {
                                                    var targetAI = targetLocator[i], bestMatchAI = bestMatch.locator[i],
                                                        tstAI = tst.locator[i];
                                                    targetAI - bestMatchAI > Math.abs(targetAI - tstAI) && (bestMatch = tst);
                                                    break;
                                                }
                                                equality < i && (equality = i, bestMatch = tst);
                                            }
                                        }), (bestMatch = $.extend({}, bestMatch, {
                                            input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def
                                        })).generatedInput = !0, setValidPosition(ps, bestMatch, !0), getMaskSet().validPositions[newPos] = undefined,
                                            _isValid(newPos, vp.input, !0);
                                    }
                                }(maskPos, result.pos !== undefined ? result.pos : nPos), maskPos = nPos;
                                break;
                            }
                        } else result = {
                            caret: seekNext(maskPos)
                        };
                    }
                    !1 === result && opts.keepStatic && !strict && !0 !== fromAlternate && (result = function (pos, c, strict) {
                        var lastAlt, alternation, altPos, prevAltPos, i, validPos, altNdxs, decisionPos,
                            validPsClone = $.extend(!0, {}, getMaskSet().validPositions), isValidRslt = !1,
                            lAltPos = getLastValidPosition();
                        for (prevAltPos = getMaskSet().validPositions[lAltPos]; lAltPos >= 0; lAltPos--) if ((altPos = getMaskSet().validPositions[lAltPos]) && altPos.alternation !== undefined) {
                            if (lastAlt = lAltPos, alternation = getMaskSet().validPositions[lastAlt].alternation,
                            prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;
                            prevAltPos = altPos;
                        }
                        if (alternation !== undefined) {
                            decisionPos = parseInt(lastAlt);
                            var decisionTaker = prevAltPos.locator[prevAltPos.alternation || alternation] !== undefined ? prevAltPos.locator[prevAltPos.alternation || alternation] : altNdxs[0];
                            decisionTaker.length > 0 && (decisionTaker = decisionTaker.split(",")[0]);
                            var possibilityPos = getMaskSet().validPositions[decisionPos],
                                prevPos = getMaskSet().validPositions[decisionPos - 1];
                            $.each(getTests(decisionPos, prevPos ? prevPos.locator : undefined, decisionPos - 1), function (ndx, test) {
                                altNdxs = test.locator[alternation] ? test.locator[alternation].toString().split(",") : [];
                                for (var mndx = 0; mndx < altNdxs.length; mndx++) {
                                    var validInputs = [], staticInputsBeforePos = 0, staticInputsBeforePosAlternate = 0,
                                        verifyValidInput = !1;
                                    if (decisionTaker < altNdxs[mndx] && (test.na === undefined || -1 === $.inArray(altNdxs[mndx], test.na.split(",")) || -1 === $.inArray(decisionTaker.toString(), altNdxs))) {
                                        getMaskSet().validPositions[decisionPos] = $.extend(!0, {}, test);
                                        var possibilities = getMaskSet().validPositions[decisionPos].locator;
                                        for (getMaskSet().validPositions[decisionPos].locator[alternation] = parseInt(altNdxs[mndx]),
                                                 null == test.match.fn ? (possibilityPos.input !== test.match.def && (verifyValidInput = !0,
                                                 !0 !== possibilityPos.generatedInput && validInputs.push(possibilityPos.input)),
                                                     staticInputsBeforePosAlternate++, getMaskSet().validPositions[decisionPos].generatedInput = !/[0-9a-bA-Z]/.test(test.match.def),
                                                     getMaskSet().validPositions[decisionPos].input = test.match.def) : getMaskSet().validPositions[decisionPos].input = possibilityPos.input,
                                                 i = decisionPos + 1; i < getLastValidPosition(undefined, !0) + 1; i++) (validPos = getMaskSet().validPositions[i]) && !0 !== validPos.generatedInput && /[0-9a-bA-Z]/.test(validPos.input) ? validInputs.push(validPos.input) : i < pos && staticInputsBeforePos++,
                                            delete getMaskSet().validPositions[i];
                                        for (verifyValidInput && validInputs[0] === test.match.def && validInputs.shift(),
                                                 resetMaskSet(!0), isValidRslt = !0; validInputs.length > 0;) {
                                            var input = validInputs.shift();
                                            if (input !== opts.skipOptionalPartCharacter && !(isValidRslt = isValid(getLastValidPosition(undefined, !0) + 1, input, !1, fromSetValid, !0))) break;
                                        }
                                        if (isValidRslt) {
                                            getMaskSet().validPositions[decisionPos].locator = possibilities;
                                            var targetLvp = getLastValidPosition(pos) + 1;
                                            for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) ((validPos = getMaskSet().validPositions[i]) === undefined || null == validPos.match.fn) && i < pos + (staticInputsBeforePosAlternate - staticInputsBeforePos) && staticInputsBeforePosAlternate++;
                                            isValidRslt = isValid((pos += staticInputsBeforePosAlternate - staticInputsBeforePos) > targetLvp ? targetLvp : pos, c, strict, fromSetValid, !0);
                                        }
                                        if (isValidRslt) return !1;
                                        resetMaskSet(), getMaskSet().validPositions = $.extend(!0, {}, validPsClone);
                                    }
                                }
                            });
                        }
                        return isValidRslt;
                    }(maskPos, c, strict)), !0 === result && (result = {
                        pos: maskPos
                    });
                }
                if ($.isFunction(opts.postValidation) && !1 !== result && !strict && !0 !== fromSetValid && !0 !== validateOnly) {
                    var postResult = opts.postValidation(getBuffer(!0), result, opts);
                    if (postResult.refreshFromBuffer && postResult.buffer) {
                        var refresh = postResult.refreshFromBuffer;
                        refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, postResult.buffer);
                    }
                    result = !0 === postResult ? result : postResult;
                }
                return result && result.pos === undefined && (result.pos = maskPos), !1 !== result && !0 !== validateOnly || (resetMaskSet(!0),
                    getMaskSet().validPositions = $.extend(!0, {}, positionsClone)), result;
            }

            function isMask(pos, strict) {
                var test = getTestTemplate(pos).match;
                if ("" === test.def && (test = getTest(pos).match), null != test.fn) return test.fn;
                if (!0 !== strict && pos > -1) {
                    var tests = getTests(pos);
                    return tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0);
                }
                return !1;
            }

            function seekNext(pos, newBlock) {
                var maskL = getMaskSet().maskLength;
                if (pos >= maskL) return maskL;
                var position = pos;
                for (getTests(maskL + 1).length > 1 && (getMaskTemplate(!0, maskL + 1, !0), maskL = getMaskSet().maskLength); ++position < maskL && (!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position)) || !0 !== newBlock && !isMask(position));) ;
                return position;
            }

            function seekPrevious(pos, newBlock) {
                var tests, position = pos;
                if (position <= 0) return 0;
                for (; --position > 0 && (!0 === newBlock && !0 !== getTest(position).match.newBlockMarker || !0 !== newBlock && !isMask(position) && ((tests = getTests(position)).length < 2 || 2 === tests.length && "" === tests[1].match.def));) ;
                return position;
            }

            function getBufferElement(position) {
                return getMaskSet().validPositions[position] === undefined ? getPlaceholder(position) : getMaskSet().validPositions[position].input;
            }

            function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {
                if (event && $.isFunction(opts.onBeforeWrite)) {
                    var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);
                    if (result) {
                        if (result.refreshFromBuffer) {
                            var refresh = result.refreshFromBuffer;
                            refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer),
                                buffer = getBuffer(!0);
                        }
                        caretPos !== undefined && (caretPos = result.caret !== undefined ? result.caret : caretPos);
                    }
                }
                input !== undefined && (input.inputmask._valueSet(buffer.join("")), caretPos === undefined || event !== undefined && "blur" === event.type ? renderColorMask(input, caretPos, 0 === buffer.length) : android && event && "input" === event.type ? setTimeout(function () {
                    caret(input, caretPos);
                }, 0) : caret(input, caretPos), !0 === triggerInputEvent && (skipInputEvent = !0,
                    $(input).trigger("input")));
            }

            function getPlaceholder(pos, test, returnPL) {
                if ((test = test || getTest(pos).match).placeholder !== undefined || !0 === returnPL) return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;
                if (null === test.fn) {
                    if (pos > -1 && getMaskSet().validPositions[pos] === undefined) {
                        var prevTest, tests = getTests(pos), staticAlternations = [];
                        if (tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) if (!0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (null === tests[i].match.fn || prevTest === undefined || !1 !== tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, !0, opts)) && (staticAlternations.push(tests[i]),
                        null === tests[i].match.fn && (prevTest = tests[i]), staticAlternations.length > 1 && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length);
                    }
                    return test.def;
                }
                return opts.placeholder.charAt(pos % opts.placeholder.length);
            }

            function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
                function isTemplateMatch(ndx, charCodes) {
                    return -1 !== getBufferTemplate().slice(ndx, seekNext(ndx)).join("").indexOf(charCodes) && !isMask(ndx) && getTest(ndx).match.nativeDef === charCodes.charAt(charCodes.length - 1);
                }

                var inputValue = nptvl.slice(), charCodes = "", initialNdx = -1, result = undefined;
                if (resetMaskSet(), strict || !0 === opts.autoUnmask) initialNdx = seekNext(initialNdx); else {
                    var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(""),
                        matches = inputValue.join("").match(new RegExp("^" + Inputmask.escapeRegex(staticInput), "g"));
                    matches && matches.length > 0 && (inputValue.splice(0, matches.length * staticInput.length),
                        initialNdx = seekNext(initialNdx));
                }
                if (-1 === initialNdx ? (getMaskSet().p = seekNext(initialNdx), initialNdx = 0) : getMaskSet().p = initialNdx,
                    $.each(inputValue, function (ndx, charCode) {
                        if (charCode !== undefined) if (getMaskSet().validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, !0) && !1 === isValid(ndx, inputValue[ndx], !0, undefined, undefined, !0)) getMaskSet().p++; else {
                            var keypress = new $.Event("_checkval");
                            keypress.which = charCode.charCodeAt(0), charCodes += charCode;
                            var lvp = getLastValidPosition(undefined, !0), lvTest = getMaskSet().validPositions[lvp],
                                nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : undefined, lvp);
                            if (!isTemplateMatch(initialNdx, charCodes) || strict || opts.autoUnmask) {
                                var pos = strict ? ndx : null == nextTest.match.fn && nextTest.match.optionality && lvp + 1 < getMaskSet().p ? lvp + 1 : getMaskSet().p;
                                result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, pos),
                                    initialNdx = pos + 1, charCodes = "";
                            } else result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, !0, lvp + 1);
                            if (!1 !== result && !strict && $.isFunction(opts.onBeforeWrite)) {
                                var origResult = result;
                                if (result = opts.onBeforeWrite.call(inputmask, keypress, getBuffer(), result.forwardPosition, opts),
                                (result = $.extend(origResult, result)) && result.refreshFromBuffer) {
                                    var refresh = result.refreshFromBuffer;
                                    refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer),
                                        resetMaskSet(!0), result.caret && (getMaskSet().p = result.caret, result.forwardPosition = result.caret);
                                }
                            }
                        }
                    }), writeOut) {
                    var caretPos = undefined;
                    document.activeElement === input && result && (caretPos = opts.numericInput ? seekPrevious(result.forwardPosition) : result.forwardPosition),
                        writeBuffer(input, getBuffer(), caretPos, initiatingEvent || new $.Event("checkval"), initiatingEvent && "input" === initiatingEvent.type);
                }
            }

            function unmaskedvalue(input) {
                if (input) {
                    if (input.inputmask === undefined) return input.value;
                    input.inputmask && input.inputmask.refreshValue && EventHandlers.setValueEvent.call(input);
                }
                var umValue = [], vps = getMaskSet().validPositions;
                for (var pndx in vps) vps[pndx].match && null != vps[pndx].match.fn && umValue.push(vps[pndx].input);
                var unmaskedValue = 0 === umValue.length ? "" : (isRTL ? umValue.reverse() : umValue).join("");
                if ($.isFunction(opts.onUnMask)) {
                    var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
                    unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);
                }
                return unmaskedValue;
            }

            function caret(input, begin, end, notranslate) {
                function translatePosition(pos) {
                    return !0 === notranslate || !isRTL || "number" != typeof pos || opts.greedy && "" === opts.placeholder || (pos = getBuffer().join("").length - pos),
                        pos;
                }

                var range;
                if (begin === undefined) return input.setSelectionRange ? (begin = input.selectionStart,
                    end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset,
                    end = range.endOffset) : document.selection && document.selection.createRange && (end = (begin = 0 - (range = document.selection.createRange()).duplicate().moveStart("character", -input.inputmask._valueGet().length)) + range.text.length),
                    {
                        begin: translatePosition(begin),
                        end: translatePosition(end)
                    };
                if (begin.begin !== undefined && (end = begin.end, begin = begin.begin), "number" == typeof begin) {
                    begin = translatePosition(begin), end = "number" == typeof (end = translatePosition(end)) ? end : begin;
                    var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
                    if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, mobile || !1 !== opts.insertMode || begin !== end || end++,
                        input.setSelectionRange) input.selectionStart = begin, input.selectionEnd = end; else if (window.getSelection) {
                        if (range = document.createRange(), input.firstChild === undefined || null === input.firstChild) {
                            var textNode = document.createTextNode("");
                            input.appendChild(textNode);
                        }
                        range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length),
                            range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length),
                            range.collapse(!0);
                        var sel = window.getSelection();
                        sel.removeAllRanges(), sel.addRange(range);
                    } else input.createTextRange && ((range = input.createTextRange()).collapse(!0),
                        range.moveEnd("character", end), range.moveStart("character", begin), range.select());
                    renderColorMask(input, {
                        begin: begin,
                        end: end
                    });
                }
            }

            function determineLastRequiredPosition(returnDefinition) {
                var pos, testPos, buffer = getBuffer(), bl = buffer.length, lvp = getLastValidPosition(),
                    positions = {}, lvTest = getMaskSet().validPositions[lvp],
                    ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined;
                for (pos = lvp + 1; pos < buffer.length; pos++) ndxIntlzr = (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)).locator.slice(),
                    positions[pos] = $.extend(!0, {}, testPos);
                var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;
                for (pos = bl - 1; pos > lvp && (((testPos = positions[pos]).match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && null != testPos.match.fn || null === testPos.match.fn && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && "" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--) bl--;
                return returnDefinition ? {
                    l: bl,
                    def: positions[bl] ? positions[bl].match : undefined
                } : bl;
            }

            function clearOptionalTail(buffer) {
                for (var validPos, rl = determineLastRequiredPosition(), bl = buffer.length, lv = getMaskSet().validPositions[getLastValidPosition()]; rl < bl && !isMask(rl, !0) && (validPos = lv !== undefined ? getTestTemplate(rl, lv.locator.slice(""), lv) : getTest(rl)) && !0 !== validPos.match.optionality && (!0 !== validPos.match.optionalQuantifier && !0 !== validPos.match.newBlockMarker || rl + 1 === bl && "" === (lv !== undefined ? getTestTemplate(rl + 1, lv.locator.slice(""), lv) : getTest(rl + 1)).match.def);) rl++;
                for (; (validPos = getMaskSet().validPositions[rl - 1]) && validPos && validPos.match.optionality && validPos.input === opts.skipOptionalPartCharacter;) rl--;
                return buffer.splice(rl), buffer;
            }

            function isComplete(buffer) {
                if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
                if ("*" === opts.repeat) return undefined;
                var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l);
                if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
                    complete = !0;
                    for (var i = 0; i <= aml; i++) {
                        var test = getTestTemplate(i).match;
                        if (null !== test.fn && getMaskSet().validPositions[i] === undefined && !0 !== test.optionality && !0 !== test.optionalQuantifier || null === test.fn && buffer[i] !== getPlaceholder(i, test)) {
                            complete = !1;
                            break;
                        }
                    }
                }
                return complete;
            }

            function handleRemove(input, k, pos, strict, fromIsValid) {
                if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE ? k = Inputmask.keyCode.DELETE : k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE),
                    isRTL)) {
                    var pend = pos.end;
                    pos.end = pos.begin, pos.begin = pend;
                }
                k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || !1 === opts.insertMode) ? (pos.begin = seekPrevious(pos.begin),
                getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.begin--) : k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0) && getMaskSet().validPositions[pos.end] && getMaskSet().validPositions[pos.end].input !== opts.radixPoint ? pos.end + 1 : seekNext(pos.end) + 1,
                getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.end++),
                    stripValidPositions(pos.begin, pos.end, !1, strict), !0 !== strict && function () {
                    if (opts.keepStatic) {
                        for (var validInputs = [], lastAlt = getLastValidPosition(-1, !0), positionsClone = $.extend(!0, {}, getMaskSet().validPositions), prevAltPos = getMaskSet().validPositions[lastAlt]; lastAlt >= 0; lastAlt--) {
                            var altPos = getMaskSet().validPositions[lastAlt];
                            if (altPos) {
                                if (!0 !== altPos.generatedInput && /[0-9a-bA-Z]/.test(altPos.input) && validInputs.push(altPos.input),
                                    delete getMaskSet().validPositions[lastAlt], altPos.alternation !== undefined && altPos.locator[altPos.alternation] !== prevAltPos.locator[altPos.alternation]) break;
                                prevAltPos = altPos;
                            }
                        }
                        if (lastAlt > -1) for (getMaskSet().p = seekNext(getLastValidPosition(-1, !0)); validInputs.length > 0;) {
                            var keypress = new $.Event("keypress");
                            keypress.which = validInputs.pop().charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !1, !1, getMaskSet().p);
                        } else getMaskSet().validPositions = $.extend(!0, {}, positionsClone);
                    }
                }();
                var lvp = getLastValidPosition(pos.begin, !0);
                if (lvp < pos.begin) getMaskSet().p = seekNext(lvp); else if (!0 !== strict && (getMaskSet().p = pos.begin,
                !0 !== fromIsValid)) for (; getMaskSet().p < lvp && getMaskSet().validPositions[getMaskSet().p] === undefined;) getMaskSet().p++;
            }

            function initializeColorMask(input) {
                function findCaretPos(clientx) {
                    var caretPos, e = document.createElement("span");
                    for (var style in computedStyle) isNaN(style) && -1 !== style.indexOf("font") && (e.style[style] = computedStyle[style]);
                    e.style.textTransform = computedStyle.textTransform, e.style.letterSpacing = computedStyle.letterSpacing,
                        e.style.position = "absolute", e.style.height = "auto", e.style.width = "auto",
                        e.style.visibility = "hidden", e.style.whiteSpace = "nowrap", document.body.appendChild(e);
                    var itl, inputText = input.inputmask._valueGet(), previousWidth = 0;
                    for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {
                        if (e.innerHTML += inputText.charAt(caretPos) || "_", e.offsetWidth >= clientx) {
                            var offset1 = clientx - previousWidth, offset2 = e.offsetWidth - clientx;
                            e.innerHTML = inputText.charAt(caretPos), caretPos = (offset1 -= e.offsetWidth / 3) < offset2 ? caretPos - 1 : caretPos;
                            break;
                        }
                        previousWidth = e.offsetWidth;
                    }
                    return document.body.removeChild(e), caretPos;
                }

                var computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null),
                    template = document.createElement("div");
                template.style.width = computedStyle.width, template.style.textAlign = computedStyle.textAlign,
                    (colorMask = document.createElement("div")).className = "im-colormask", input.parentNode.insertBefore(colorMask, input),
                    input.parentNode.removeChild(input), colorMask.appendChild(template), colorMask.appendChild(input),
                    input.style.left = template.offsetLeft + "px", $(input).on("click", function (e) {
                    return caret(input, findCaretPos(e.clientX)), EventHandlers.clickEvent.call(input, [e]);
                }), $(input).on("keydown", function (e) {
                    e.shiftKey || !1 === opts.insertMode || setTimeout(function () {
                        renderColorMask(input);
                    }, 0);
                });
            }

            function renderColorMask(input, caretPos, clear) {
                function handleStatic() {
                    isStatic || null !== test.fn && testPos.input !== undefined ? isStatic && (null !== test.fn && testPos.input !== undefined || "" === test.def) && (isStatic = !1,
                        maskTemplate += "</span>") : (isStatic = !0, maskTemplate += "<span class='im-static'>");
                }

                function handleCaret(force) {
                    !0 !== force && pos !== caretPos.begin || document.activeElement !== input || (maskTemplate += "<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>");
                }

                var test, testPos, ndxIntlzr, maskTemplate = "", isStatic = !1, pos = 0;
                if (colorMask !== undefined) {
                    var buffer = getBuffer();
                    if (caretPos === undefined ? caretPos = caret(input) : caretPos.begin === undefined && (caretPos = {
                        begin: caretPos,
                        end: caretPos
                    }), !0 !== clear) {
                        var lvp = getLastValidPosition();
                        do {
                            handleCaret(), getMaskSet().validPositions[pos] ? (testPos = getMaskSet().validPositions[pos],
                                test = testPos.match, ndxIntlzr = testPos.locator.slice(), handleStatic(), maskTemplate += buffer[pos]) : (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1),
                                test = testPos.match, ndxIntlzr = testPos.locator.slice(), (!1 === opts.jitMasking || pos < lvp || "number" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos) && (handleStatic(),
                                maskTemplate += getPlaceholder(pos, test))), pos++;
                        } while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || "" !== test.def) || lvp > pos || isStatic);
                        -1 === maskTemplate.indexOf("im-caret") && handleCaret(!0), isStatic && handleStatic();
                    }
                    var template = colorMask.getElementsByTagName("div")[0];
                    template.innerHTML = maskTemplate, input.inputmask.positionColorMask(input, template);
                }
            }

            maskset = maskset || this.maskset, opts = opts || this.opts;
            var undoValue, $el, maxLength, colorMask, inputmask = this, el = this.el, isRTL = this.isRTL,
                skipKeyPressEvent = !1, skipInputEvent = !1, ignorable = !1, mouseEnter = !1, EventRuler = {
                    on: function (input, eventName, eventHandler) {
                        var ev = function (e) {
                            if (this.inputmask === undefined && "FORM" !== this.nodeName) {
                                var imOpts = $.data(this, "_inputmask_opts");
                                imOpts ? new Inputmask(imOpts).mask(this) : EventRuler.off(this);
                            } else {
                                if ("setvalue" === e.type || "FORM" === this.nodeName || !(this.disabled || this.readOnly && !("keydown" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === Inputmask.keyCode.TAB))) {
                                    switch (e.type) {
                                        case "input":
                                            if (!0 === skipInputEvent) return skipInputEvent = !1, e.preventDefault();
                                            break;

                                        case "keydown":
                                            skipKeyPressEvent = !1, skipInputEvent = !1;
                                            break;

                                        case "keypress":
                                            if (!0 === skipKeyPressEvent) return e.preventDefault();
                                            skipKeyPressEvent = !0;
                                            break;

                                        case "click":
                                            if (iemobile || iphone) {
                                                var that = this, args = arguments;
                                                return setTimeout(function () {
                                                    eventHandler.apply(that, args);
                                                }, 0), !1;
                                            }
                                    }
                                    var returnVal = eventHandler.apply(this, arguments);
                                    return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal;
                                }
                                e.preventDefault();
                            }
                        };
                        input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev),
                            -1 !== $.inArray(eventName, ["submit", "reset"]) ? null !== input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev);
                    },
                    off: function (input, event) {
                        if (input.inputmask && input.inputmask.events) {
                            var events;
                            event ? (events = [])[event] = input.inputmask.events[event] : events = input.inputmask.events,
                                $.each(events, function (eventName, evArr) {
                                    for (; evArr.length > 0;) {
                                        var ev = evArr.pop();
                                        -1 !== $.inArray(eventName, ["submit", "reset"]) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);
                                    }
                                    delete input.inputmask.events[eventName];
                                });
                        }
                    }
                }, EventHandlers = {
                    keydownEvent: function (e) {
                        var input = this, $input = $(input), k = e.keyCode, pos = caret(input);
                        if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !function (eventName) {
                            var el = document.createElement("input"), evName = "on" + eventName, isSupported = evName in el;
                            return isSupported || (el.setAttribute(evName, "return;"), isSupported = "function" == typeof el[evName]),
                                el = null, isSupported;
                        }("cut")) e.preventDefault(), handleRemove(input, k, pos), writeBuffer(input, getBuffer(!0), getMaskSet().p, e, input.inputmask._valueGet() !== getBuffer().join("")),
                            input.inputmask._valueGet() === getBufferTemplate().join("") ? $input.trigger("cleared") : !0 === isComplete(getBuffer()) && $input.trigger("complete"); else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {
                            e.preventDefault();
                            var caretPos = seekNext(getLastValidPosition());
                            opts.insertMode || caretPos !== getMaskSet().maskLength || e.shiftKey || caretPos--,
                                caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);
                        } else k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP ? (e.preventDefault(),
                            caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? (checkVal(input, !0, !1, undoValue.split("")),
                            $input.trigger("click")) : k !== Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? !0 === opts.tabThrough && k === Inputmask.keyCode.TAB ? (!0 === e.shiftKey ? (null === getTest(pos.begin).match.fn && (pos.begin = seekNext(pos.begin)),
                            pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0),
                            pos.end = seekNext(pos.begin, !0), pos.end < getMaskSet().maskLength && pos.end--),
                        pos.begin < getMaskSet().maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end))) : e.shiftKey || !1 === opts.insertMode && (k === Inputmask.keyCode.RIGHT ? setTimeout(function () {
                            var caretPos = caret(input);
                            caret(input, caretPos.begin);
                        }, 0) : k === Inputmask.keyCode.LEFT && setTimeout(function () {
                            var caretPos = caret(input);
                            caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);
                        }, 0)) : (opts.insertMode = !opts.insertMode, caret(input, opts.insertMode || pos.begin !== getMaskSet().maskLength ? pos.begin : pos.begin - 1));
                        opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts), ignorable = -1 !== $.inArray(k, opts.ignorables);
                    },
                    keypressEvent: function (e, checkval, writeOut, strict, ndx) {
                        var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;
                        if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("") && (undoValue = getBuffer().join(""),
                            setTimeout(function () {
                                $input.trigger("change");
                            }, 0)), !0;
                        if (k) {
                            46 === k && !1 === e.shiftKey && "" !== opts.radixPoint && (k = opts.radixPoint.charCodeAt(0));
                            var forwardPosition, pos = checkval ? {
                                begin: ndx,
                                end: ndx
                            } : caret(input), c = String.fromCharCode(k);
                            getMaskSet().writeOutBuffer = !0;
                            var valResult = isValid(pos, c, strict);
                            if (!1 !== valResult && (resetMaskSet(!0), forwardPosition = valResult.caret !== undefined ? valResult.caret : checkval ? valResult.pos + 1 : seekNext(valResult.pos),
                                getMaskSet().p = forwardPosition), !1 !== writeOut && (setTimeout(function () {
                                opts.onKeyValidation.call(input, k, valResult, opts);
                            }, 0), getMaskSet().writeOutBuffer && !1 !== valResult)) {
                                var buffer = getBuffer();
                                writeBuffer(input, buffer, opts.numericInput && valResult.caret === undefined ? seekPrevious(forwardPosition) : forwardPosition, e, !0 !== checkval),
                                !0 !== checkval && setTimeout(function () {
                                    !0 === isComplete(buffer) && $input.trigger("complete");
                                }, 0);
                            }
                            if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition),
                                valResult;
                        }
                    },
                    pasteEvent: function (e) {
                        var tempValue, input = this, ev = e.originalEvent || e, $input = $(input),
                            inputValue = input.inputmask._valueGet(!0), caretPos = caret(input);
                        isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);
                        var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
                            valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
                        if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join("") && (valueBeforeCaret = ""),
                        valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join("") && (valueAfterCaret = ""),
                        isRTL && (tempValue = valueBeforeCaret, valueBeforeCaret = valueAfterCaret, valueAfterCaret = tempValue),
                        window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret; else {
                            if (!ev.clipboardData || !ev.clipboardData.getData) return !0;
                            inputValue = valueBeforeCaret + ev.clipboardData.getData("text/plain") + valueAfterCaret;
                        }
                        var pasteValue = inputValue;
                        if ($.isFunction(opts.onBeforePaste)) {
                            if (!1 === (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts))) return e.preventDefault();
                            pasteValue || (pasteValue = inputValue);
                        }
                        return checkVal(input, !1, !1, isRTL ? pasteValue.split("").reverse() : pasteValue.toString().split("")),
                            writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join("")),
                        !0 === isComplete(getBuffer()) && $input.trigger("complete"), e.preventDefault();
                    },
                    inputFallBackEvent: function (e) {
                        var input = this, inputValue = input.inputmask._valueGet();
                        if (getBuffer().join("") !== inputValue) {
                            var caretPos = caret(input);
                            if (!1 === function (input, inputValue, caretPos) {
                                if ("." === inputValue.charAt(caretPos.begin - 1) && "" !== opts.radixPoint && ((inputValue = inputValue.split(""))[caretPos.begin - 1] = opts.radixPoint.charAt(0),
                                    inputValue = inputValue.join("")), inputValue.charAt(caretPos.begin - 1) === opts.radixPoint && inputValue.length > getBuffer().length) {
                                    var keypress = new $.Event("keypress");
                                    return keypress.which = opts.radixPoint.charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !0, !1, caretPos.begin - 1),
                                        !1;
                                }
                            }(input, inputValue, caretPos)) return !1;
                            if (inputValue = inputValue.replace(new RegExp("(" + Inputmask.escapeRegex(getBufferTemplate().join("")) + ")*"), ""),
                            !1 === function (input, inputValue, caretPos) {
                                if (iemobile) {
                                    var inputChar = inputValue.replace(getBuffer().join(""), "");
                                    if (1 === inputChar.length) {
                                        var keypress = new $.Event("keypress");
                                        return keypress.which = inputChar.charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !0, !1, getMaskSet().validPositions[caretPos.begin - 1] ? caretPos.begin : caretPos.begin - 1),
                                            !1;
                                    }
                                }
                            }(input, inputValue, caretPos)) return !1;
                            caretPos.begin > inputValue.length && (caret(input, inputValue.length), caretPos = caret(input));
                            var buffer = getBuffer().join(""), frontPart = inputValue.substr(0, caretPos.begin),
                                backPart = inputValue.substr(caretPos.begin),
                                frontBufferPart = buffer.substr(0, caretPos.begin),
                                backBufferPart = buffer.substr(caretPos.begin), selection = caretPos, entries = "",
                                isEntry = !1;
                            if (frontPart !== frontBufferPart) {
                                selection.begin = 0;
                                for (var fpl = (isEntry = frontPart.length >= frontBufferPart.length) ? frontPart.length : frontBufferPart.length, i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) selection.begin++;
                                isEntry && (entries += frontPart.slice(selection.begin, selection.end));
                            }
                            backPart !== backBufferPart && (backPart.length > backBufferPart.length ? isEntry && (selection.end = selection.begin) : backPart.length < backBufferPart.length ? selection.end += backBufferPart.length - backPart.length : backPart.charAt(0) !== backBufferPart.charAt(0) && selection.end++),
                                writeBuffer(input, getBuffer(), selection), entries.length > 0 ? $.each(entries.split(""), function (ndx, entry) {
                                var keypress = new $.Event("keypress");
                                keypress.which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress);
                            }) : (selection.begin === selection.end - 1 && caret(input, seekPrevious(selection.begin + 1), selection.end),
                                e.keyCode = Inputmask.keyCode.DELETE, EventHandlers.keydownEvent.call(input, e)),
                                e.preventDefault();
                        }
                    },
                    setValueEvent: function (e) {
                        this.inputmask.refreshValue = !1;
                        var input = this, value = input.inputmask._valueGet(!0);
                        $.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask.call(inputmask, value, opts) || value),
                            value = value.split(""), checkVal(input, !0, !1, isRTL ? value.reverse() : value),
                            undoValue = getBuffer().join(""), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join("") && input.inputmask._valueSet("");
                    },
                    focusEvent: function (e) {
                        var input = this, nptValue = input.inputmask._valueGet();
                        opts.showMaskOnFocus && (!opts.showMaskOnHover || opts.showMaskOnHover && "" === nptValue) && (input.inputmask._valueGet() !== getBuffer().join("") ? writeBuffer(input, getBuffer(), seekNext(getLastValidPosition())) : !1 === mouseEnter && caret(input, seekNext(getLastValidPosition()))),
                        !0 === opts.positionCaretOnTab && !1 === mouseEnter && "" !== nptValue && (writeBuffer(input, getBuffer(), caret(input)),
                            EventHandlers.clickEvent.apply(input, [e, !0])), undoValue = getBuffer().join("");
                    },
                    mouseleaveEvent: function (e) {
                        var input = this;
                        if (mouseEnter = !1, opts.clearMaskOnLostFocus && document.activeElement !== input) {
                            var buffer = getBuffer().slice(), nptValue = input.inputmask._valueGet();
                            nptValue !== input.getAttribute("placeholder") && "" !== nptValue && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer),
                                writeBuffer(input, buffer));
                        }
                    },
                    clickEvent: function (e, tabbed) {
                        function doRadixFocus(clickPos) {
                            if ("" !== opts.radixPoint) {
                                var vps = getMaskSet().validPositions;
                                if (vps[clickPos] === undefined || vps[clickPos].input === getPlaceholder(clickPos)) {
                                    if (clickPos < seekNext(-1)) return !0;
                                    var radixPos = $.inArray(opts.radixPoint, getBuffer());
                                    if (-1 !== radixPos) {
                                        for (var vp in vps) if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;
                                        return !0;
                                    }
                                }
                            }
                            return !1;
                        }

                        var input = this;
                        setTimeout(function () {
                            if (document.activeElement === input) {
                                var selectedCaret = caret(input);
                                if (tabbed && (isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end),
                                selectedCaret.begin === selectedCaret.end) switch (opts.positionCaretOnClick) {
                                    case "none":
                                        break;

                                    case "radixFocus":
                                        if (doRadixFocus(selectedCaret.begin)) {
                                            var radixPos = getBuffer().join("").indexOf(opts.radixPoint);
                                            caret(input, opts.numericInput ? seekNext(radixPos) : radixPos);
                                            break;
                                        }

                                    default:
                                        var clickPosition = selectedCaret.begin,
                                            lvclickPosition = getLastValidPosition(clickPosition, !0),
                                            lastPosition = seekNext(lvclickPosition);
                                        if (clickPosition < lastPosition) caret(input, isMask(clickPosition, !0) || isMask(clickPosition - 1, !0) ? clickPosition : seekNext(clickPosition)); else {
                                            var lvp = getMaskSet().validPositions[lvclickPosition],
                                                tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp),
                                                placeholder = getPlaceholder(lastPosition, tt.match);
                                            if ("" !== placeholder && getBuffer()[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask(lastPosition, !0) && tt.match.def === placeholder) {
                                                var newPos = seekNext(lastPosition);
                                                (clickPosition >= newPos || clickPosition === lastPosition) && (lastPosition = newPos);
                                            }
                                            caret(input, lastPosition);
                                        }
                                }
                            }
                        }, 0);
                    },
                    dblclickEvent: function (e) {
                        var input = this;
                        setTimeout(function () {
                            caret(input, 0, seekNext(getLastValidPosition()));
                        }, 0);
                    },
                    cutEvent: function (e) {
                        var input = this, $input = $(input), pos = caret(input), ev = e.originalEvent || e,
                            clipboardData = window.clipboardData || ev.clipboardData,
                            clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
                        clipboardData.setData("text", isRTL ? clipData.reverse().join("") : clipData.join("")),
                        document.execCommand && document.execCommand("copy"), handleRemove(input, Inputmask.keyCode.DELETE, pos),
                            writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join("")),
                        input.inputmask._valueGet() === getBufferTemplate().join("") && $input.trigger("cleared");
                    },
                    blurEvent: function (e) {
                        var $input = $(this), input = this;
                        if (input.inputmask) {
                            var nptValue = input.inputmask._valueGet(), buffer = getBuffer().slice();
                            "" !== nptValue && (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer)),
                            !1 === isComplete(buffer) && (setTimeout(function () {
                                $input.trigger("incomplete");
                            }, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())),
                                writeBuffer(input, buffer, undefined, e)), undoValue !== getBuffer().join("") && (undoValue = buffer.join(""),
                                $input.trigger("change"));
                        }
                    },
                    mouseenterEvent: function (e) {
                        var input = this;
                        mouseEnter = !0, document.activeElement !== input && opts.showMaskOnHover && input.inputmask._valueGet() !== getBuffer().join("") && writeBuffer(input, getBuffer());
                    },
                    submitEvent: function (e) {
                        undoValue !== getBuffer().join("") && $el.trigger("change"), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("") && el.inputmask._valueSet(""),
                        opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0),
                            setTimeout(function () {
                                writeBuffer(el, getBuffer());
                            }, 0));
                    },
                    resetEvent: function (e) {
                        el.inputmask.refreshValue = !0, setTimeout(function () {
                            $el.trigger("setvalue");
                        }, 0);
                    }
                };
            Inputmask.prototype.positionColorMask = function (input, template) {
                input.style.left = template.offsetLeft + "px";
            };
            var valueBuffer;
            if (actionObj !== undefined) switch (actionObj.action) {
                case "isComplete":
                    return el = actionObj.el, isComplete(getBuffer());

                case "unmaskedvalue":
                    return el !== undefined && actionObj.value === undefined || (valueBuffer = actionObj.value,
                        valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer : valueBuffer).split(""),
                        checkVal(undefined, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts)),
                        unmaskedvalue(el);

                case "mask":
                    !function (elem) {
                        EventRuler.off(elem);
                        var isSupported = function (input, opts) {
                            var elementType = input.getAttribute("type"),
                                isSupported = "INPUT" === input.tagName && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || "TEXTAREA" === input.tagName;
                            if (!isSupported) if ("INPUT" === input.tagName) {
                                var el = document.createElement("input");
                                el.setAttribute("type", elementType), isSupported = "text" === el.type, el = null;
                            } else isSupported = "partial";
                            return !1 !== isSupported ? function (npt) {
                                function getter() {
                                    return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || !0 !== opts.nullable ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") : valueGet.call(this) : "" : valueGet.call(this);
                                }

                                function setter(value) {
                                    valueSet.call(this, value), this.inputmask && $(this).trigger("setvalue");
                                }

                                var valueGet, valueSet;
                                if (!npt.inputmask.__valueGet) {
                                    if (!0 !== opts.noValuePatching) {
                                        if (Object.getOwnPropertyDescriptor) {
                                            "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === _typeof("test".__proto__) ? function (object) {
                                                return object.__proto__;
                                            } : function (object) {
                                                return object.constructor.prototype;
                                            });
                                            var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : undefined;
                                            valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get,
                                                valueSet = valueProperty.set, Object.defineProperty(npt, "value", {
                                                get: getter,
                                                set: setter,
                                                configurable: !0
                                            })) : "INPUT" !== npt.tagName && (valueGet = function () {
                                                return this.textContent;
                                            }, valueSet = function (value) {
                                                this.textContent = value;
                                            }, Object.defineProperty(npt, "value", {
                                                get: getter,
                                                set: setter,
                                                configurable: !0
                                            }));
                                        } else document.__lookupGetter__ && npt.__lookupGetter__("value") && (valueGet = npt.__lookupGetter__("value"),
                                            valueSet = npt.__lookupSetter__("value"), npt.__defineGetter__("value", getter),
                                            npt.__defineSetter__("value", setter));
                                        npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet;
                                    }
                                    npt.inputmask._valueGet = function (overruleRTL) {
                                        return isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el);
                                    }, npt.inputmask._valueSet = function (value, overruleRTL) {
                                        valueSet.call(this.el, null === value || value === undefined ? "" : !0 !== overruleRTL && isRTL ? value.split("").reverse().join("") : value);
                                    }, valueGet === undefined && (valueGet = function () {
                                        return this.value;
                                    }, valueSet = function (value) {
                                        this.value = value;
                                    }, function (type) {
                                        if ($.valHooks && ($.valHooks[type] === undefined || !0 !== $.valHooks[type].inputmaskpatch)) {
                                            var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {
                                                    return elem.value;
                                                },
                                                valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {
                                                    return elem.value = value, elem;
                                                };
                                            $.valHooks[type] = {
                                                get: function (elem) {
                                                    if (elem.inputmask) {
                                                        if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();
                                                        var result = valhookGet(elem);
                                                        return -1 !== getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : "";
                                                    }
                                                    return valhookGet(elem);
                                                },
                                                set: function (elem, value) {
                                                    var result, $elem = $(elem);
                                                    return result = valhookSet(elem, value), elem.inputmask && $elem.trigger("setvalue"),
                                                        result;
                                                },
                                                inputmaskpatch: !0
                                            };
                                        }
                                    }(npt.type), function (npt) {
                                        EventRuler.on(npt, "mouseenter", function (event) {
                                            var $input = $(this);
                                            this.inputmask._valueGet() !== getBuffer().join("") && $input.trigger("setvalue");
                                        });
                                    }(npt));
                                }
                            }(input) : input.inputmask = undefined, isSupported;
                        }(elem, opts);
                        if (!1 !== isSupported && (el = elem, $el = $(el), -1 === (maxLength = el !== undefined ? el.maxLength : undefined) && (maxLength = undefined),
                        !0 === opts.colorMask && initializeColorMask(el), android && (el.hasOwnProperty("inputmode") && (el.inputmode = opts.inputmode,
                            el.setAttribute("inputmode", opts.inputmode)), "rtfm" === opts.androidHack && (!0 !== opts.colorMask && initializeColorMask(el),
                            el.type = "password")), !0 === isSupported && (EventRuler.on(el, "submit", EventHandlers.submitEvent),
                            EventRuler.on(el, "reset", EventHandlers.resetEvent), EventRuler.on(el, "mouseenter", EventHandlers.mouseenterEvent),
                            EventRuler.on(el, "blur", EventHandlers.blurEvent), EventRuler.on(el, "focus", EventHandlers.focusEvent),
                            EventRuler.on(el, "mouseleave", EventHandlers.mouseleaveEvent), !0 !== opts.colorMask && EventRuler.on(el, "click", EventHandlers.clickEvent),
                            EventRuler.on(el, "dblclick", EventHandlers.dblclickEvent), EventRuler.on(el, "paste", EventHandlers.pasteEvent),
                            EventRuler.on(el, "dragdrop", EventHandlers.pasteEvent), EventRuler.on(el, "drop", EventHandlers.pasteEvent),
                            EventRuler.on(el, "cut", EventHandlers.cutEvent), EventRuler.on(el, "complete", opts.oncomplete),
                            EventRuler.on(el, "incomplete", opts.onincomplete), EventRuler.on(el, "cleared", opts.oncleared),
                            android || !0 === opts.inputEventOnly ? el.removeAttribute("maxLength") : (EventRuler.on(el, "keydown", EventHandlers.keydownEvent),
                                EventRuler.on(el, "keypress", EventHandlers.keypressEvent)), EventRuler.on(el, "compositionstart", $.noop),
                            EventRuler.on(el, "compositionupdate", $.noop), EventRuler.on(el, "compositionend", $.noop),
                            EventRuler.on(el, "keyup", $.noop), EventRuler.on(el, "input", EventHandlers.inputFallBackEvent),
                            EventRuler.on(el, "beforeinput", $.noop)), EventRuler.on(el, "setvalue", EventHandlers.setValueEvent),
                            undoValue = getBufferTemplate().join(""), "" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || document.activeElement === el)) {
                            var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(!0), opts) || el.inputmask._valueGet(!0) : el.inputmask._valueGet(!0);
                            "" !== initialValue && checkVal(el, !0, !1, isRTL ? initialValue.split("").reverse() : initialValue.split(""));
                            var buffer = getBuffer().slice();
                            undoValue = buffer.join(""), !1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(),
                            opts.clearMaskOnLostFocus && document.activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)),
                                writeBuffer(el, buffer), document.activeElement === el && caret(el, seekNext(getLastValidPosition()));
                        }
                    }(el);
                    break;

                case "format":
                    return valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value : actionObj.value).split(""),
                        checkVal(undefined, !0, !1, isRTL ? valueBuffer.reverse() : valueBuffer), actionObj.metadata ? {
                        value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
                        metadata: maskScope.call(this, {
                            action: "getmetadata"
                        }, maskset, opts)
                    } : isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");

                case "isValid":
                    actionObj.value ? (valueBuffer = actionObj.value.split(""), checkVal(undefined, !0, !0, isRTL ? valueBuffer.reverse() : valueBuffer)) : actionObj.value = getBuffer().join("");
                    for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;
                    return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === getBuffer().join("");

                case "getemptymask":
                    return getBufferTemplate().join("");

                case "remove":
                    if (el && el.inputmask) {
                        $el = $(el), el.inputmask._valueSet(opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(!0)),
                            EventRuler.off(el);
                        Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), "value") && el.inputmask.__valueGet && Object.defineProperty(el, "value", {
                            get: el.inputmask.__valueGet,
                            set: el.inputmask.__valueSet,
                            configurable: !0
                        }) : document.__lookupGetter__ && el.__lookupGetter__("value") && el.inputmask.__valueGet && (el.__defineGetter__("value", el.inputmask.__valueGet),
                            el.__defineSetter__("value", el.inputmask.__valueSet)), el.inputmask = undefined;
                    }
                    return el;

                case "getmetadata":
                    if ($.isArray(maskset.metadata)) {
                        var maskTarget = getMaskTemplate(!0, 0, !1).join("");
                        return $.each(maskset.metadata, function (ndx, mtdt) {
                            if (mtdt.mask === maskTarget) return maskTarget = mtdt, !1;
                        }), maskTarget;
                    }
                    return maskset.metadata;
            }
        }

        var ua = navigator.userAgent, mobile = /mobile/i.test(ua), iemobile = /iemobile/i.test(ua),
            iphone = /iphone/i.test(ua) && !iemobile, android = /android/i.test(ua) && !iemobile;
        return Inputmask.prototype = {
            dataAttribute: "data-inputmask",
            defaults: {
                placeholder: "_",
                optionalmarker: {
                    start: "[",
                    end: "]"
                },
                quantifiermarker: {
                    start: "{",
                    end: "}"
                },
                groupmarker: {
                    start: "(",
                    end: ")"
                },
                alternatormarker: "|",
                escapeChar: "\\",
                mask: null,
                regex: null,
                oncomplete: $.noop,
                onincomplete: $.noop,
                oncleared: $.noop,
                repeat: 0,
                greedy: !0,
                autoUnmask: !1,
                removeMaskOnSubmit: !1,
                clearMaskOnLostFocus: !0,
                insertMode: !0,
                clearIncomplete: !1,
                alias: null,
                onKeyDown: $.noop,
                onBeforeMask: null,
                onBeforePaste: function (pastedValue, opts) {
                    return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;
                },
                onBeforeWrite: null,
                onUnMask: null,
                showMaskOnFocus: !0,
                showMaskOnHover: !0,
                onKeyValidation: $.noop,
                skipOptionalPartCharacter: " ",
                numericInput: !1,
                rightAlign: !1,
                undoOnEscape: !0,
                radixPoint: "",
                radixPointDefinitionSymbol: undefined,
                groupSeparator: "",
                keepStatic: null,
                positionCaretOnTab: !0,
                tabThrough: !1,
                supportsInputType: ["text", "tel", "password"],
                ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
                isComplete: null,
                canClearPosition: $.noop,
                preValidation: null,
                postValidation: null,
                staticDefinitionSymbol: undefined,
                jitMasking: !1,
                nullable: !0,
                inputEventOnly: !1,
                noValuePatching: !1,
                positionCaretOnClick: "lvp",
                casing: null,
                inputmode: "verbatim",
                colorMask: !1,
                androidHack: !1,
                importDataAttributes: !0
            },
            definitions: {
                "9": {
                    validator: "[0-9１-９]",
                    cardinality: 1,
                    definitionSymbol: "*"
                },
                a: {
                    validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                    cardinality: 1,
                    definitionSymbol: "*"
                },
                "*": {
                    validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ]",
                    cardinality: 1
                }
            },
            aliases: {},
            masksCache: {},
            mask: function (elems) {
                function importAttributeOptions(npt, opts, userOptions, dataAttribute) {
                    if (!0 === opts.importDataAttributes) {
                        var option, dataoptions, optionData, p, importOption = function (option, optionData) {
                            null !== (optionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + "-" + option)) && ("string" == typeof optionData && (0 === option.indexOf("on") ? optionData = window[optionData] : "false" === optionData ? optionData = !1 : "true" === optionData && (optionData = !0)),
                                userOptions[option] = optionData);
                        }, attrOptions = npt.getAttribute(dataAttribute);
                        if (attrOptions && "" !== attrOptions && (attrOptions = attrOptions.replace(new RegExp("'", "g"), '"'),
                            dataoptions = JSON.parse("{" + attrOptions + "}")), dataoptions) {
                            optionData = undefined;
                            for (p in dataoptions) if ("alias" === p.toLowerCase()) {
                                optionData = dataoptions[p];
                                break;
                            }
                        }
                        importOption("alias", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts);
                        for (option in opts) {
                            if (dataoptions) {
                                optionData = undefined;
                                for (p in dataoptions) if (p.toLowerCase() === option.toLowerCase()) {
                                    optionData = dataoptions[p];
                                    break;
                                }
                            }
                            importOption(option, optionData);
                        }
                    }
                    return $.extend(!0, opts, userOptions), ("rtl" === npt.dir || opts.rightAlign) && (npt.style.textAlign = "right"),
                    ("rtl" === npt.dir || opts.numericInput) && (npt.dir = "ltr", npt.removeAttribute("dir"),
                        opts.isRTL = !0), opts;
                }

                var that = this;
                return "string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)),
                    elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) {
                    var scopedOpts = $.extend(!0, {}, that.opts);
                    importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute);
                    var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
                    maskset !== undefined && (el.inputmask !== undefined && (el.inputmask.opts.autoUnmask = !0,
                        el.inputmask.remove()), el.inputmask = new Inputmask(undefined, undefined, !0),
                        el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions),
                        el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput, el.inputmask.el = el,
                        el.inputmask.maskset = maskset, $.data(el, "_inputmask_opts", scopedOpts), maskScope.call(el.inputmask, {
                        action: "mask"
                    }));
                }), elems && elems[0] ? elems[0].inputmask || this : this;
            },
            option: function (options, noremask) {
                return "string" == typeof options ? this.opts[options] : "object" === (void 0 === options ? "undefined" : _typeof(options)) ? ($.extend(this.userOptions, options),
                this.el && !0 !== noremask && this.mask(this.el), this) : void 0;
            },
            unmaskedvalue: function (value) {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
                    maskScope.call(this, {
                        action: "unmaskedvalue",
                        value: value
                    });
            },
            remove: function () {
                return maskScope.call(this, {
                    action: "remove"
                });
            },
            getemptymask: function () {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
                    maskScope.call(this, {
                        action: "getemptymask"
                    });
            },
            hasMaskedValue: function () {
                return !this.opts.autoUnmask;
            },
            isComplete: function () {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
                    maskScope.call(this, {
                        action: "isComplete"
                    });
            },
            getmetadata: function () {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
                    maskScope.call(this, {
                        action: "getmetadata"
                    });
            },
            isValid: function (value) {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
                    maskScope.call(this, {
                        action: "isValid",
                        value: value
                    });
            },
            format: function (value, metadata) {
                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
                    maskScope.call(this, {
                        action: "format",
                        value: value,
                        metadata: metadata
                    });
            },
            analyseMask: function (mask, regexMask, opts) {
                function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
                    this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1,
                        this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1,
                        this.quantifier = {
                            min: 1,
                            max: 1
                        };
                }

                function insertTestDefinition(mtoken, element, position) {
                    position = position !== undefined ? position : mtoken.matches.length;
                    var prevMatch = mtoken.matches[position - 1];
                    if (regexMask) 0 === element.indexOf("[") || escaped && /\\d|\\s|\\w]/i.test(element) || "." === element ? mtoken.matches.splice(position++, 0, {
                        fn: new RegExp(element, opts.casing ? "i" : ""),
                        cardinality: 1,
                        optionality: mtoken.isOptional,
                        newBlockMarker: prevMatch === undefined || prevMatch.def !== element,
                        casing: null,
                        def: element,
                        placeholder: undefined,
                        nativeDef: element
                    }) : (escaped && (element = element[element.length - 1]), $.each(element.split(""), function (ndx, lmnt) {
                        prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {
                            fn: null,
                            cardinality: 0,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || prevMatch.def !== lmnt && null !== prevMatch.fn,
                            casing: null,
                            def: opts.staticDefinitionSymbol || lmnt,
                            placeholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,
                            nativeDef: lmnt
                        });
                    })), escaped = !1; else {
                        var maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];
                        if (maskdef && !escaped) {
                            for (var prevalidators = maskdef.prevalidator, prevalidatorsL = prevalidators ? prevalidators.length : 0, i = 1; i < maskdef.cardinality; i++) {
                                var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [],
                                    validator = prevalidator.validator, cardinality = prevalidator.cardinality;
                                mtoken.matches.splice(position++, 0, {
                                    fn: validator ? "string" == typeof validator ? new RegExp(validator, opts.casing ? "i" : "") : new function () {
                                        this.test = validator;
                                    }() : new RegExp("."),
                                    cardinality: cardinality || 1,
                                    optionality: mtoken.isOptional,
                                    newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
                                    casing: maskdef.casing,
                                    def: maskdef.definitionSymbol || element,
                                    placeholder: maskdef.placeholder,
                                    nativeDef: element
                                }), prevMatch = mtoken.matches[position - 1];
                            }
                            mtoken.matches.splice(position++, 0, {
                                fn: maskdef.validator ? "string" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? "i" : "") : new function () {
                                    this.test = maskdef.validator;
                                }() : new RegExp("."),
                                cardinality: maskdef.cardinality,
                                optionality: mtoken.isOptional,
                                newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
                                casing: maskdef.casing,
                                def: maskdef.definitionSymbol || element,
                                placeholder: maskdef.placeholder,
                                nativeDef: element
                            });
                        } else mtoken.matches.splice(position++, 0, {
                            fn: null,
                            cardinality: 0,
                            optionality: mtoken.isOptional,
                            newBlockMarker: prevMatch === undefined || prevMatch.def !== element && null !== prevMatch.fn,
                            casing: null,
                            def: opts.staticDefinitionSymbol || element,
                            placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,
                            nativeDef: element
                        }), escaped = !1;
                    }
                }

                function verifyGroupMarker(maskToken) {
                    maskToken && maskToken.matches && $.each(maskToken.matches, function (ndx, token) {
                        var nextToken = maskToken.matches[ndx + 1];
                        (nextToken === undefined || nextToken.matches === undefined || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1,
                        regexMask || (insertTestDefinition(token, opts.groupmarker.start, 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker.end))),
                            verifyGroupMarker(token);
                    });
                }

                function defaultCase() {
                    if (openenings.length > 0) {
                        if (currentOpeningToken = openenings[openenings.length - 1], insertTestDefinition(currentOpeningToken, m),
                            currentOpeningToken.isAlternator) {
                            alternator = openenings.pop();
                            for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;
                            openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator);
                        }
                    } else insertTestDefinition(currentToken, m);
                }

                function reverseTokens(maskToken) {
                    maskToken.matches = maskToken.matches.reverse();
                    for (var match in maskToken.matches) if (maskToken.matches.hasOwnProperty(match)) {
                        var intMatch = parseInt(match);
                        if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {
                            var qt = maskToken.matches[match];
                            maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);
                        }
                        maskToken.matches[match].matches !== undefined ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = function (st) {
                            return st === opts.optionalmarker.start ? st = opts.optionalmarker.end : st === opts.optionalmarker.end ? st = opts.optionalmarker.start : st === opts.groupmarker.start ? st = opts.groupmarker.end : st === opts.groupmarker.end && (st = opts.groupmarker.start),
                                st;
                        }(maskToken.matches[match]);
                    }
                    return maskToken;
                }

                var match, m, openingToken, currentOpeningToken, alternator, lastMatch, groupToken,
                    tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g,
                    regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
                    escaped = !1, currentToken = new MaskToken(), openenings = [], maskTokens = [];
                for (regexMask && (opts.optionalmarker.start = undefined, opts.optionalmarker.end = undefined); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask);) {
                    if (m = match[0], regexMask) switch (m.charAt(0)) {
                        case "?":
                            m = "{0,1}";
                            break;

                        case "+":
                        case "*":
                            m = "{" + m + "}";
                    }
                    if (escaped) defaultCase(); else switch (m.charAt(0)) {
                        case opts.escapeChar:
                            escaped = !0, regexMask && defaultCase();
                            break;

                        case opts.optionalmarker.end:
                        case opts.groupmarker.end:
                            if (openingToken = openenings.pop(), openingToken.openGroup = !1, openingToken !== undefined) if (openenings.length > 0) {
                                if ((currentOpeningToken = openenings[openenings.length - 1]).matches.push(openingToken),
                                    currentOpeningToken.isAlternator) {
                                    alternator = openenings.pop();
                                    for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1,
                                        alternator.matches[mndx].alternatorGroup = !1;
                                    openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator);
                                }
                            } else currentToken.matches.push(openingToken); else defaultCase();
                            break;

                        case opts.optionalmarker.start:
                            openenings.push(new MaskToken(!1, !0));
                            break;

                        case opts.groupmarker.start:
                            openenings.push(new MaskToken(!0));
                            break;

                        case opts.quantifiermarker.start:
                            var quantifier = new MaskToken(!1, !1, !0), mq = (m = m.replace(/[{}]/g, "")).split(","),
                                mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                                mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                            if ("*" !== mq1 && "+" !== mq1 || (mq0 = "*" === mq1 ? 0 : 1), quantifier.quantifier = {
                                min: mq0,
                                max: mq1
                            }, openenings.length > 0) {
                                var matches = openenings[openenings.length - 1].matches;
                                (match = matches.pop()).isGroup || ((groupToken = new MaskToken(!0)).matches.push(match),
                                    match = groupToken), matches.push(match), matches.push(quantifier);
                            } else (match = currentToken.matches.pop()).isGroup || (regexMask && null === match.fn && "." === match.def && (match.fn = new RegExp(match.def, opts.casing ? "i" : "")),
                                (groupToken = new MaskToken(!0)).matches.push(match), match = groupToken), currentToken.matches.push(match),
                                currentToken.matches.push(quantifier);
                            break;

                        case opts.alternatormarker:
                            if (openenings.length > 0) {
                                var subToken = (currentOpeningToken = openenings[openenings.length - 1]).matches[currentOpeningToken.matches.length - 1];
                                lastMatch = currentOpeningToken.openGroup && (subToken.matches === undefined || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : currentOpeningToken.matches.pop();
                            } else lastMatch = currentToken.matches.pop();
                            if (lastMatch.isAlternator) openenings.push(lastMatch); else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(),
                                lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch),
                                openenings.push(alternator), lastMatch.openGroup) {
                                lastMatch.openGroup = !1;
                                var alternatorGroup = new MaskToken(!0);
                                alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup);
                            }
                            break;

                        default:
                            defaultCase();
                    }
                }
                for (; openenings.length > 0;) openingToken = openenings.pop(), currentToken.matches.push(openingToken);
                return currentToken.matches.length > 0 && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)),
                (opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]), maskTokens;
            }
        }, Inputmask.extendDefaults = function (options) {
            $.extend(!0, Inputmask.prototype.defaults, options);
        }, Inputmask.extendDefinitions = function (definition) {
            $.extend(!0, Inputmask.prototype.definitions, definition);
        }, Inputmask.extendAliases = function (alias) {
            $.extend(!0, Inputmask.prototype.aliases, alias);
        }, Inputmask.format = function (value, options, metadata) {
            return Inputmask(options).format(value, metadata);
        }, Inputmask.unmask = function (value, options) {
            return Inputmask(options).unmaskedvalue(value);
        }, Inputmask.isValid = function (value, options) {
            return Inputmask(options).isValid(value);
        }, Inputmask.remove = function (elems) {
            $.each(elems, function (ndx, el) {
                el.inputmask && el.inputmask.remove();
            });
        }, Inputmask.escapeRegex = function (str) {
            var specials = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"];
            return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1");
        }, Inputmask.keyCode = {
            ALT: 18,
            BACKSPACE: 8,
            BACKSPACE_SAFARI: 127,
            CAPS_LOCK: 20,
            COMMA: 188,
            COMMAND: 91,
            COMMAND_LEFT: 91,
            COMMAND_RIGHT: 93,
            CONTROL: 17,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            INSERT: 45,
            LEFT: 37,
            MENU: 93,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SHIFT: 16,
            SPACE: 32,
            TAB: 9,
            UP: 38,
            WINDOWS: 91,
            X: 88
        }, Inputmask;
    });
}, function (module, exports) {
    module.exports = jQuery;
}, function (module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    __webpack_require__(4), __webpack_require__(9), __webpack_require__(12), __webpack_require__(13),
        __webpack_require__(14), __webpack_require__(15);
    var _inputmask2 = _interopRequireDefault(__webpack_require__(1)),
        _inputmask4 = _interopRequireDefault(__webpack_require__(0)),
        _jquery2 = _interopRequireDefault(__webpack_require__(2));
    _inputmask4.default === _jquery2.default && __webpack_require__(16), window.Inputmask = _inputmask2.default;
}, function (module, exports, __webpack_require__) {
    var content = __webpack_require__(5);
    "string" == typeof content && (content = [[module.i, content, ""]]);
    var options = {
        hmr: !0
    };
    options.transform = void 0;
    __webpack_require__(7)(content, options);
    content.locals && (module.exports = content.locals);
}, function (module, exports, __webpack_require__) {
    (module.exports = __webpack_require__(6)(void 0)).push([module.i, "span.im-caret {\r\n    -webkit-animation: 1s blink step-end infinite;\r\n    animation: 1s blink step-end infinite;\r\n}\r\n\r\n@keyframes blink {\r\n    from, to {\r\n        border-right-color: black;\r\n    }\r\n    50% {\r\n        border-right-color: transparent;\r\n    }\r\n}\r\n\r\n@-webkit-keyframes blink {\r\n    from, to {\r\n        border-right-color: black;\r\n    }\r\n    50% {\r\n        border-right-color: transparent;\r\n    }\r\n}\r\n\r\nspan.im-static {\r\n    color: grey;\r\n}\r\n\r\ndiv.im-colormask {\r\n    display: inline-block;\r\n    border-style: inset;\r\n    border-width: 2px;\r\n    -webkit-appearance: textfield;\r\n    -moz-appearance: textfield;\r\n    appearance: textfield;\r\n}\r\n\r\ndiv.im-colormask > input {\r\n    position: absolute;\r\n    display: inline-block;\r\n    background-color: transparent;\r\n    color: transparent;\r\n    -webkit-appearance: caret;\r\n    -moz-appearance: caret;\r\n    appearance: caret;\r\n    border-style: none;\r\n    left: 0; /*calculated*/\r\n}\r\n\r\ndiv.im-colormask > input:focus {\r\n    outline: none;\r\n}\r\n\r\ndiv.im-colormask > input::-moz-selection{\r\n    background: none;\r\n}\r\n\r\ndiv.im-colormask > input::selection{\r\n    background: none;\r\n}\r\ndiv.im-colormask > input::-moz-selection{\r\n    background: none;\r\n}\r\n\r\ndiv.im-colormask > div {\r\n    color: black;\r\n    display: inline-block;\r\n    width: 100px; /*calculated*/\r\n}", ""]);
}, function (module, exports) {
    function cssWithMappingToString(item, useSourceMap) {
        var content = item[1] || "", cssMapping = item[3];
        if (!cssMapping) return content;
        if (useSourceMap && "function" == typeof btoa) {
            var sourceMapping = toComment(cssMapping), sourceURLs = cssMapping.sources.map(function (source) {
                return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
            });
            return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
        }
        return [content].join("\n");
    }

    function toComment(sourceMap) {
        return "/*# " + ("sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))) + " */";
    }

    module.exports = function (useSourceMap) {
        var list = [];
        return list.toString = function () {
            return this.map(function (item) {
                var content = cssWithMappingToString(item, useSourceMap);
                return item[2] ? "@media " + item[2] + "{" + content + "}" : content;
            }).join("");
        }, list.i = function (modules, mediaQuery) {
            "string" == typeof modules && (modules = [[null, modules, ""]]);
            for (var alreadyImportedModules = {}, i = 0; i < this.length; i++) {
                var id = this[i][0];
                "number" == typeof id && (alreadyImportedModules[id] = !0);
            }
            for (i = 0; i < modules.length; i++) {
                var item = modules[i];
                "number" == typeof item[0] && alreadyImportedModules[item[0]] || (mediaQuery && !item[2] ? item[2] = mediaQuery : mediaQuery && (item[2] = "(" + item[2] + ") and (" + mediaQuery + ")"),
                    list.push(item));
            }
        }, list;
    };
}, function (module, exports, __webpack_require__) {
    function addStylesToDom(styles, options) {
        for (var i = 0; i < styles.length; i++) {
            var item = styles[i], domStyle = stylesInDom[item.id];
            if (domStyle) {
                domStyle.refs++;
                for (j = 0; j < domStyle.parts.length; j++) domStyle.parts[j](item.parts[j]);
                for (; j < item.parts.length; j++) domStyle.parts.push(addStyle(item.parts[j], options));
            } else {
                for (var parts = [], j = 0; j < item.parts.length; j++) parts.push(addStyle(item.parts[j], options));
                stylesInDom[item.id] = {
                    id: item.id,
                    refs: 1,
                    parts: parts
                };
            }
        }
    }

    function listToStyles(list, options) {
        for (var styles = [], newStyles = {}, i = 0; i < list.length; i++) {
            var item = list[i], id = options.base ? item[0] + options.base : item[0], part = {
                css: item[1],
                media: item[2],
                sourceMap: item[3]
            };
            newStyles[id] ? newStyles[id].parts.push(part) : styles.push(newStyles[id] = {
                id: id,
                parts: [part]
            });
        }
        return styles;
    }

    function insertStyleElement(options, style) {
        var target = getElement(options.insertInto);
        if (!target) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
        if ("top" === options.insertAt) lastStyleElementInsertedAtTop ? lastStyleElementInsertedAtTop.nextSibling ? target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling) : target.appendChild(style) : target.insertBefore(style, target.firstChild),
            stylesInsertedAtTop.push(style); else if ("bottom" === options.insertAt) target.appendChild(style); else {
            if ("object" != typeof options.insertAt || !options.insertAt.before) throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
            var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
            target.insertBefore(style, nextSibling);
        }
    }

    function removeStyleElement(style) {
        if (null === style.parentNode) return !1;
        style.parentNode.removeChild(style);
        var idx = stylesInsertedAtTop.indexOf(style);
        idx >= 0 && stylesInsertedAtTop.splice(idx, 1);
    }

    function createStyleElement(options) {
        var style = document.createElement("style");
        return options.attrs.type = "text/css", addAttrs(style, options.attrs), insertStyleElement(options, style),
            style;
    }

    function createLinkElement(options) {
        var link = document.createElement("link");
        return options.attrs.type = "text/css", options.attrs.rel = "stylesheet", addAttrs(link, options.attrs),
            insertStyleElement(options, link), link;
    }

    function addAttrs(el, attrs) {
        Object.keys(attrs).forEach(function (key) {
            el.setAttribute(key, attrs[key]);
        });
    }

    function addStyle(obj, options) {
        var style, update, remove, result;
        if (options.transform && obj.css) {
            if (!(result = options.transform(obj.css))) return function () {
            };
            obj.css = result;
        }
        if (options.singleton) {
            var styleIndex = singletonCounter++;
            style = singleton || (singleton = createStyleElement(options)), update = applyToSingletonTag.bind(null, style, styleIndex, !1),
                remove = applyToSingletonTag.bind(null, style, styleIndex, !0);
        } else obj.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (style = createLinkElement(options),
            update = updateLink.bind(null, style, options), remove = function () {
            removeStyleElement(style), style.href && URL.revokeObjectURL(style.href);
        }) : (style = createStyleElement(options), update = applyToTag.bind(null, style),
            remove = function () {
                removeStyleElement(style);
            });
        return update(obj), function (newObj) {
            if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) return;
                update(obj = newObj);
            } else remove();
        };
    }

    function applyToSingletonTag(style, index, remove, obj) {
        var css = remove ? "" : obj.css;
        if (style.styleSheet) style.styleSheet.cssText = replaceText(index, css); else {
            var cssNode = document.createTextNode(css), childNodes = style.childNodes;
            childNodes[index] && style.removeChild(childNodes[index]), childNodes.length ? style.insertBefore(cssNode, childNodes[index]) : style.appendChild(cssNode);
        }
    }

    function applyToTag(style, obj) {
        var css = obj.css, media = obj.media;
        if (media && style.setAttribute("media", media), style.styleSheet) style.styleSheet.cssText = css; else {
            for (; style.firstChild;) style.removeChild(style.firstChild);
            style.appendChild(document.createTextNode(css));
        }
    }

    function updateLink(link, options, obj) {
        var css = obj.css, sourceMap = obj.sourceMap,
            autoFixUrls = void 0 === options.convertToAbsoluteUrls && sourceMap;
        (options.convertToAbsoluteUrls || autoFixUrls) && (css = fixUrls(css)), sourceMap && (css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */");
        var blob = new Blob([css], {
            type: "text/css"
        }), oldSrc = link.href;
        link.href = URL.createObjectURL(blob), oldSrc && URL.revokeObjectURL(oldSrc);
    }

    var stylesInDom = {}, isOldIE = function (fn) {
        var memo;
        return function () {
            return void 0 === memo && (memo = fn.apply(this, arguments)), memo;
        };
    }(function () {
        return window && document && document.all && !window.atob;
    }), getElement = function (fn) {
        var memo = {};
        return function (selector) {
            if (void 0 === memo[selector]) {
                var styleTarget = fn.call(this, selector);
                if (styleTarget instanceof window.HTMLIFrameElement) try {
                    styleTarget = styleTarget.contentDocument.head;
                } catch (e) {
                    styleTarget = null;
                }
                memo[selector] = styleTarget;
            }
            return memo[selector];
        };
    }(function (target) {
        return document.querySelector(target);
    }), singleton = null, singletonCounter = 0, stylesInsertedAtTop = [], fixUrls = __webpack_require__(8);
    module.exports = function (list, options) {
        if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document) throw new Error("The style-loader cannot be used in a non-browser environment");
        (options = options || {}).attrs = "object" == typeof options.attrs ? options.attrs : {},
        options.singleton || (options.singleton = isOldIE()), options.insertInto || (options.insertInto = "head"),
        options.insertAt || (options.insertAt = "bottom");
        var styles = listToStyles(list, options);
        return addStylesToDom(styles, options), function (newList) {
            for (var mayRemove = [], i = 0; i < styles.length; i++) {
                var item = styles[i];
                (domStyle = stylesInDom[item.id]).refs--, mayRemove.push(domStyle);
            }
            newList && addStylesToDom(listToStyles(newList, options), options);
            for (i = 0; i < mayRemove.length; i++) {
                var domStyle = mayRemove[i];
                if (0 === domStyle.refs) {
                    for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
                    delete stylesInDom[domStyle.id];
                }
            }
        };
    };
    var replaceText = function () {
        var textStore = [];
        return function (index, replacement) {
            return textStore[index] = replacement, textStore.filter(Boolean).join("\n");
        };
    }();
}, function (module, exports) {
    module.exports = function (css) {
        var location = "undefined" != typeof window && window.location;
        if (!location) throw new Error("fixUrls requires window.location");
        if (!css || "string" != typeof css) return css;
        var baseUrl = location.protocol + "//" + location.host,
            currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
        return css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
            var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
                return $1;
            }).replace(/^'(.*)'$/, function (o, $1) {
                return $1;
            });
            if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) return fullMatch;
            var newUrl;
            return newUrl = 0 === unquotedOrigUrl.indexOf("//") ? unquotedOrigUrl : 0 === unquotedOrigUrl.indexOf("/") ? baseUrl + unquotedOrigUrl : currentDir + unquotedOrigUrl.replace(/^\.\//, ""),
            "url(" + JSON.stringify(newUrl) + ")";
        });
    };
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function (factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(1)],
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function ($, Inputmask) {
        function isLeapYear(year) {
            return isNaN(year) || 29 === new Date(year, 2, 0).getDate();
        }

        return Inputmask.extendAliases({
            "dd/mm/yyyy": {
                mask: "1/2/y",
                placeholder: "dd/mm/yyyy",
                regex: {
                    val1pre: new RegExp("[0-3]"),
                    val1: new RegExp("0[1-9]|[12][0-9]|3[01]"),
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|[12][0-9]|3[01])" + escapedSeparator + "[01])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|[12][0-9])" + escapedSeparator + "(0[1-9]|1[012]))|(30" + escapedSeparator + "(0[13-9]|1[012]))|(31" + escapedSeparator + "(0[13578]|1[02]))");
                    }
                },
                leapday: "29/02/",
                separator: "/",
                yearrange: {
                    minyear: 1900,
                    maxyear: 2099
                },
                isInYearRange: function (chrs, minyear, maxyear) {
                    if (isNaN(chrs)) return !1;
                    var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length))),
                        enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));
                    return !isNaN(enteredyear) && (minyear <= enteredyear && enteredyear <= maxyear) || !isNaN(enteredyear2) && (minyear <= enteredyear2 && enteredyear2 <= maxyear);
                },
                determinebaseyear: function (minyear, maxyear, hint) {
                    var currentyear = new Date().getFullYear();
                    if (minyear > currentyear) return minyear;
                    if (maxyear < currentyear) {
                        for (var maxYearPrefix = maxyear.toString().slice(0, 2), maxYearPostfix = maxyear.toString().slice(2, 4); maxyear < maxYearPrefix + hint;) maxYearPrefix--;
                        var maxxYear = maxYearPrefix + maxYearPostfix;
                        return minyear > maxxYear ? minyear : maxxYear;
                    }
                    if (minyear <= currentyear && currentyear <= maxyear) {
                        for (var currentYearPrefix = currentyear.toString().slice(0, 2); maxyear < currentYearPrefix + hint;) currentYearPrefix--;
                        var currentYearAndHint = currentYearPrefix + hint;
                        return currentYearAndHint < minyear ? minyear : currentYearAndHint;
                    }
                    return currentyear;
                },
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString()),
                            $input.trigger("setvalue");
                    }
                },
                getFrontValue: function (mask, buffer, opts) {
                    for (var start = 0, length = 0, i = 0; i < mask.length && "2" !== mask.charAt(i); i++) {
                        var definition = opts.definitions[mask.charAt(i)];
                        definition ? (start += length, length = definition.cardinality) : length++;
                    }
                    return buffer.join("").substr(start, length);
                },
                postValidation: function (buffer, currentResult, opts) {
                    var dayMonthValue, year, bufferStr = buffer.join("");
                    return 0 === opts.mask.indexOf("y") ? (year = bufferStr.substr(0, 4), dayMonthValue = bufferStr.substring(4, 10)) : (year = bufferStr.substring(6, 10),
                        dayMonthValue = bufferStr.substr(0, 6)), currentResult && (dayMonthValue !== opts.leapday || isLeapYear(year));
                },
                definitions: {
                    "1": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.regex.val1.test(chrs);
                            return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val1.test("0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0",
                                {
                                    refreshFromBuffer: {
                                        start: pos - 1,
                                        end: pos
                                    },
                                    pos: pos,
                                    c: chrs.charAt(0)
                                });
                        },
                        cardinality: 2,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var pchrs = chrs;
                                isNaN(maskset.buffer[pos + 1]) || (pchrs += maskset.buffer[pos + 1]);
                                var isValid = 1 === pchrs.length ? opts.regex.val1pre.test(pchrs) : opts.regex.val1.test(pchrs);
                                if (isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")),
                                !strict && !isValid) {
                                    if (isValid = opts.regex.val1.test(chrs + "0")) return maskset.buffer[pos] = chrs,
                                        maskset.buffer[++pos] = "0", {
                                        pos: pos,
                                        c: "0"
                                    };
                                    if (isValid = opts.regex.val1.test("0" + chrs)) return maskset.buffer[pos] = "0",
                                        pos++, {
                                        pos: pos
                                    };
                                }
                                return isValid;
                            },
                            cardinality: 1
                        }]
                    },
                    "2": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
                            -1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
                            var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);
                            return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0",
                                {
                                    refreshFromBuffer: {
                                        start: pos - 1,
                                        end: pos
                                    },
                                    pos: pos,
                                    c: chrs.charAt(0)
                                });
                        },
                        cardinality: 2,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                isNaN(maskset.buffer[pos + 1]) || (chrs += maskset.buffer[pos + 1]);
                                var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
                                -1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
                                var isValid = 1 === chrs.length ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);
                                return isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")),
                                    strict || isValid || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                        pos++, {
                                        pos: pos
                                    });
                            },
                            cardinality: 1
                        }]
                    },
                    y: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                        },
                        cardinality: 4,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                                if (!strict && !isValid) {
                                    var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 1);
                                    if (isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
                                        {
                                            pos: pos
                                        };
                                    if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 2),
                                        isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
                                        maskset.buffer[pos++] = yearPrefix.charAt(1), {
                                        pos: pos
                                    };
                                }
                                return isValid;
                            },
                            cardinality: 1
                        }, {
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                                if (!strict && !isValid) {
                                    var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);
                                    if (isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(1),
                                        {
                                            pos: pos
                                        };
                                    if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2),
                                        isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos - 1] = yearPrefix.charAt(0),
                                        maskset.buffer[pos++] = yearPrefix.charAt(1), maskset.buffer[pos++] = chrs.charAt(0),
                                        {
                                            refreshFromBuffer: {
                                                start: pos - 3,
                                                end: pos
                                            },
                                            pos: pos
                                        };
                                }
                                return isValid;
                            },
                            cardinality: 2
                        }, {
                            validator: function (chrs, maskset, pos, strict, opts) {
                                return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                            },
                            cardinality: 3
                        }]
                    }
                },
                insertMode: !1,
                autoUnmask: !1
            },
            "mm/dd/yyyy": {
                placeholder: "mm/dd/yyyy",
                alias: "dd/mm/yyyy",
                regex: {
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                leapday: "02/29/",
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
                            $input.trigger("setvalue");
                    }
                }
            },
            "yyyy/mm/dd": {
                mask: "y/1/2",
                placeholder: "yyyy/mm/dd",
                alias: "mm/dd/yyyy",
                leapday: "/02/29",
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString()),
                            $input.trigger("setvalue");
                    }
                }
            },
            "dd.mm.yyyy": {
                mask: "1.2.y",
                placeholder: "dd.mm.yyyy",
                leapday: "29.02.",
                separator: ".",
                alias: "dd/mm/yyyy"
            },
            "dd-mm-yyyy": {
                mask: "1-2-y",
                placeholder: "dd-mm-yyyy",
                leapday: "29-02-",
                separator: "-",
                alias: "dd/mm/yyyy"
            },
            "mm.dd.yyyy": {
                mask: "1.2.y",
                placeholder: "mm.dd.yyyy",
                leapday: "02.29.",
                separator: ".",
                alias: "mm/dd/yyyy"
            },
            "mm-dd-yyyy": {
                mask: "1-2-y",
                placeholder: "mm-dd-yyyy",
                leapday: "02-29-",
                separator: "-",
                alias: "mm/dd/yyyy"
            },
            "yyyy.mm.dd": {
                mask: "y.1.2",
                placeholder: "yyyy.mm.dd",
                leapday: ".02.29",
                separator: ".",
                alias: "yyyy/mm/dd"
            },
            "yyyy-mm-dd": {
                mask: "y-1-2",
                placeholder: "yyyy-mm-dd",
                leapday: "-02-29",
                separator: "-",
                alias: "yyyy/mm/dd"
            },
            datetime: {
                mask: "1/2/y h:s",
                placeholder: "dd/mm/yyyy hh:mm",
                alias: "dd/mm/yyyy",
                regex: {
                    hrspre: new RegExp("[012]"),
                    hrs24: new RegExp("2[0-4]|1[3-9]"),
                    hrs: new RegExp("[01][0-9]|2[0-4]"),
                    ampm: new RegExp("^[a|p|A|P][m|M]"),
                    mspre: new RegExp("[0-5]"),
                    ms: new RegExp("[0-5][0-9]")
                },
                timeseparator: ":",
                hourFormat: "24",
                definitions: {
                    h: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            if ("24" === opts.hourFormat && 24 === parseInt(chrs, 10)) return maskset.buffer[pos - 1] = "0",
                                maskset.buffer[pos] = "0", {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                c: "0"
                            };
                            var isValid = opts.regex.hrs.test(chrs);
                            if (!strict && !isValid && (chrs.charAt(1) === opts.timeseparator || -1 !== "-.:".indexOf(chrs.charAt(1))) && (isValid = opts.regex.hrs.test("0" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = "0",
                                maskset.buffer[pos] = chrs.charAt(0), pos++, {
                                refreshFromBuffer: {
                                    start: pos - 2,
                                    end: pos
                                },
                                pos: pos,
                                c: opts.timeseparator
                            };
                            if (isValid && "24" !== opts.hourFormat && opts.regex.hrs24.test(chrs)) {
                                var tmp = parseInt(chrs, 10);
                                return 24 === tmp ? (maskset.buffer[pos + 5] = "a", maskset.buffer[pos + 6] = "m") : (maskset.buffer[pos + 5] = "p",
                                    maskset.buffer[pos + 6] = "m"), (tmp -= 12) < 10 ? (maskset.buffer[pos] = tmp.toString(),
                                    maskset.buffer[pos - 1] = "0") : (maskset.buffer[pos] = tmp.toString().charAt(1),
                                    maskset.buffer[pos - 1] = tmp.toString().charAt(0)), {
                                    refreshFromBuffer: {
                                        start: pos - 1,
                                        end: pos + 6
                                    },
                                    c: maskset.buffer[pos]
                                };
                            }
                            return isValid;
                        },
                        cardinality: 2,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var isValid = opts.regex.hrspre.test(chrs);
                                return strict || isValid || !(isValid = opts.regex.hrs.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                    pos++, {
                                    pos: pos
                                });
                            },
                            cardinality: 1
                        }]
                    },
                    s: {
                        validator: "[0-5][0-9]",
                        cardinality: 2,
                        prevalidator: [{
                            validator: function (chrs, maskset, pos, strict, opts) {
                                var isValid = opts.regex.mspre.test(chrs);
                                return strict || isValid || !(isValid = opts.regex.ms.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                    pos++, {
                                    pos: pos
                                });
                            },
                            cardinality: 1
                        }]
                    },
                    t: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            return opts.regex.ampm.test(chrs + "m");
                        },
                        casing: "lower",
                        cardinality: 1
                    }
                },
                insertMode: !1,
                autoUnmask: !1
            },
            datetime12: {
                mask: "1/2/y h:s t\\m",
                placeholder: "dd/mm/yyyy hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "mm/dd/yyyy hh:mm xm": {
                mask: "1/2/y h:s t\\m",
                placeholder: "mm/dd/yyyy hh:mm xm",
                alias: "datetime12",
                regex: {
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                leapday: "02/29/",
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                        var today = new Date();
                        $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
                            $input.trigger("setvalue");
                    }
                }
            },
            "hh:mm t": {
                mask: "h:s t\\m",
                placeholder: "hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "h:s t": {
                mask: "h:s t\\m",
                placeholder: "hh:mm xm",
                alias: "datetime",
                hourFormat: "12"
            },
            "hh:mm:ss": {
                mask: "h:s:s",
                placeholder: "hh:mm:ss",
                alias: "datetime",
                autoUnmask: !1
            },
            "hh:mm": {
                mask: "h:s",
                placeholder: "hh:mm",
                alias: "datetime",
                autoUnmask: !1
            },
            date: {
                alias: "dd/mm/yyyy"
            },
            "mm/yyyy": {
                mask: "1/y",
                placeholder: "mm/yyyy",
                leapday: "donotuse",
                separator: "/",
                alias: "mm/dd/yyyy"
            },
            shamsi: {
                regex: {
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "[0-3])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + escapedSeparator + "30)|((0[1-6])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                yearrange: {
                    minyear: 1300,
                    maxyear: 1499
                },
                mask: "y/1/2",
                leapday: "/12/30",
                placeholder: "yyyy/mm/dd",
                alias: "mm/dd/yyyy",
                clearIncomplete: !0
            },
            "yyyy-mm-dd hh:mm:ss": {
                mask: "y-1-2 h:s:s",
                placeholder: "yyyy-mm-dd hh:mm:ss",
                alias: "datetime",
                separator: "-",
                leapday: "-02-29",
                regex: {
                    val2pre: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                    },
                    val2: function (separator) {
                        var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                        return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                    },
                    val1pre: new RegExp("[01]"),
                    val1: new RegExp("0[1-9]|1[012]")
                },
                onKeyDown: function (e, buffer, caretPos, opts) {
                }
            }
        }), Inputmask;
    });
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
        return window;
    }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
        return document;
    }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function (factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(1)],
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function ($, Inputmask) {
        return Inputmask.extendDefinitions({
            A: {
                validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                cardinality: 1,
                casing: "upper"
            },
            "&": {
                validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
                cardinality: 1,
                casing: "upper"
            },
            "#": {
                validator: "[0-9A-Fa-f]",
                cardinality: 1,
                casing: "upper"
            }
        }), Inputmask.extendAliases({
            url: {
                definitions: {
                    i: {
                        validator: ".",
                        cardinality: 1
                    }
                },
                mask: "(\\http://)|(\\http\\s://)|(ftp://)|(ftp\\s://)i{+}",
                insertMode: !1,
                autoUnmask: !1,
                inputmode: "url"
            },
            ip: {
                mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]",
                definitions: {
                    i: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            return pos - 1 > -1 && "." !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs,
                                chrs = pos - 2 > -1 && "." !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : "0" + chrs) : chrs = "00" + chrs,
                                new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(chrs);
                        },
                        cardinality: 1
                    }
                },
                onUnMask: function (maskedValue, unmaskedValue, opts) {
                    return maskedValue;
                },
                inputmode: "numeric"
            },
            email: {
                mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
                greedy: !1,
                onBeforePaste: function (pastedValue, opts) {
                    return (pastedValue = pastedValue.toLowerCase()).replace("mailto:", "");
                },
                definitions: {
                    "*": {
                        validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]",
                        cardinality: 1,
                        casing: "lower"
                    },
                    "-": {
                        validator: "[0-9A-Za-z-]",
                        cardinality: 1,
                        casing: "lower"
                    }
                },
                onUnMask: function (maskedValue, unmaskedValue, opts) {
                    return maskedValue;
                },
                inputmode: "email"
            },
            mac: {
                mask: "##:##:##:##:##:##"
            },
            vin: {
                mask: "V{13}9{4}",
                definitions: {
                    V: {
                        validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                        cardinality: 1,
                        casing: "upper"
                    }
                },
                clearIncomplete: !0,
                autoUnmask: !0
            }
        }), Inputmask;
    });
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function (factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(1)],
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function ($, Inputmask, undefined) {
        function autoEscape(txt, opts) {
            for (var escapedTxt = "", i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += "\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);
            return escapedTxt;
        }

        return Inputmask.extendAliases({
            numeric: {
                mask: function (opts) {
                    if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat),
                        opts.repeat = 0, opts.groupSeparator === opts.radixPoint && ("." === opts.radixPoint ? opts.groupSeparator = "," : "," === opts.radixPoint ? opts.groupSeparator = "." : opts.groupSeparator = ""),
                    " " === opts.groupSeparator && (opts.skipOptionalPartCharacter = undefined), opts.autoGroup = opts.autoGroup && "" !== opts.groupSeparator,
                    opts.autoGroup && ("string" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)),
                        isFinite(opts.integerDigits))) {
                        var seps = Math.floor(opts.integerDigits / opts.groupSize),
                            mod = opts.integerDigits % opts.groupSize;
                        opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps),
                        opts.integerDigits < 1 && (opts.integerDigits = "*");
                    }
                    opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)),
                    "radixFocus" === opts.positionCaretOnClick && "" === opts.placeholder && !1 === opts.integerOptional && (opts.positionCaretOnClick = "lvp"),
                        opts.definitions[";"] = opts.definitions["~"], opts.definitions[";"].definitionSymbol = "~",
                    !0 === opts.numericInput && (opts.positionCaretOnClick = "radixFocus" === opts.positionCaretOnClick ? "lvp" : opts.positionCaretOnClick,
                        opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts.decimalProtect = !1);
                    var mask = "[+]";
                    if (mask += autoEscape(opts.prefix, opts), !0 === opts.integerOptional ? mask += "~{1," + opts.integerDigits + "}" : mask += "~{" + opts.integerDigits + "}",
                    opts.digits !== undefined) {
                        opts.radixPointDefinitionSymbol = opts.decimalProtect ? ":" : opts.radixPoint;
                        var dq = opts.digits.toString().split(",");
                        isFinite(dq[0] && dq[1] && isFinite(dq[1])) ? mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}" : (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (opts.digitsOptional ? mask += "[" + opts.radixPointDefinitionSymbol + ";{1," + opts.digits + "}]" : mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}");
                    }
                    return mask += autoEscape(opts.suffix, opts), mask += "[-]", opts.greedy = !1, mask;
                },
                placeholder: "",
                greedy: !1,
                digits: "*",
                digitsOptional: !0,
                enforceDigitsOnBlur: !1,
                radixPoint: ".",
                positionCaretOnClick: "radixFocus",
                groupSize: 3,
                groupSeparator: "",
                autoGroup: !1,
                allowMinus: !0,
                negationSymbol: {
                    front: "-",
                    back: ""
                },
                integerDigits: "+",
                integerOptional: !0,
                prefix: "",
                suffix: "",
                rightAlign: !0,
                decimalProtect: !0,
                min: null,
                max: null,
                step: 1,
                insertMode: !0,
                autoUnmask: !1,
                unmaskAsNumber: !1,
                inputmode: "numeric",
                preValidation: function (buffer, pos, c, isSelection, opts) {
                    if ("-" === c || c === opts.negationSymbol.front) return !0 === opts.allowMinus && (opts.isNegative = opts.isNegative === undefined || !opts.isNegative,
                    "" === buffer.join("") || {
                        caret: pos,
                        dopost: !0
                    });
                    if (!1 === isSelection && c === opts.radixPoint && opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {
                        var radixPos = $.inArray(opts.radixPoint, buffer);
                        if (-1 !== radixPos) return !0 === opts.numericInput ? pos === radixPos : {
                            caret: radixPos + 1
                        };
                    }
                    return !0;
                },
                postValidation: function (buffer, currentResult, opts) {
                    var suffix = opts.suffix.split(""), prefix = opts.prefix.split("");
                    if (currentResult.pos === undefined && currentResult.caret !== undefined && !0 !== currentResult.dopost) return currentResult;
                    var caretPos = currentResult.caret !== undefined ? currentResult.caret : currentResult.pos,
                        maskedValue = buffer.slice();
                    opts.numericInput && (caretPos = maskedValue.length - caretPos - 1, maskedValue = maskedValue.reverse());
                    var charAtPos = maskedValue[caretPos];
                    if (charAtPos === opts.groupSeparator && (charAtPos = maskedValue[caretPos += 1]),
                    caretPos === maskedValue.length - opts.suffix.length - 1 && charAtPos === opts.radixPoint) return currentResult;
                    charAtPos !== undefined && charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back && (maskedValue[caretPos] = "?",
                        opts.prefix.length > 0 && caretPos >= (!1 === opts.isNegative ? 1 : 0) && caretPos < opts.prefix.length - 1 + (!1 === opts.isNegative ? 1 : 0) ? prefix[caretPos - (!1 === opts.isNegative ? 1 : 0)] = "?" : opts.suffix.length > 0 && caretPos >= maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0) && (suffix[caretPos - (maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0))] = "?")),
                        prefix = prefix.join(""), suffix = suffix.join("");
                    var processValue = maskedValue.join("").replace(prefix, "");
                    if (processValue = processValue.replace(suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                        processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), ""),
                        processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
                    isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), "g"), "")),
                    processValue.length > 1 && 1 !== processValue.indexOf(opts.radixPoint) && ("0" === charAtPos && (processValue = processValue.replace(/^\?/g, "")),
                        processValue = processValue.replace(/^0/g, "")), processValue.charAt(0) === opts.radixPoint && "" !== opts.radixPoint && !0 !== opts.numericInput && (processValue = "0" + processValue),
                    "" !== processValue) {
                        if (processValue = processValue.split(""), (!opts.digitsOptional || opts.enforceDigitsOnBlur && "blur" === currentResult.event) && isFinite(opts.digits)) {
                            var radixPosition = $.inArray(opts.radixPoint, processValue),
                                rpb = $.inArray(opts.radixPoint, maskedValue);
                            -1 === radixPosition && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);
                            for (var i = 1; i <= opts.digits; i++) opts.digitsOptional && (!opts.enforceDigitsOnBlur || "blur" !== currentResult.event) || processValue[radixPosition + i] !== undefined && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? -1 !== rpb && maskedValue[rpb + i] !== undefined && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = currentResult.placeholder || opts.placeholder.charAt(0);
                        }
                        if (!0 !== opts.autoGroup || "" === opts.groupSeparator || charAtPos === opts.radixPoint && currentResult.pos === undefined && !currentResult.dopost) processValue = processValue.join(""); else {
                            var addRadix = processValue[processValue.length - 1] === opts.radixPoint && currentResult.c === opts.radixPoint;
                            processValue = Inputmask(function (buffer, opts) {
                                var postMask = "";
                                if (postMask += "(" + opts.groupSeparator + "*{" + opts.groupSize + "}){*}", "" !== opts.radixPoint) {
                                    var radixSplit = buffer.join("").split(opts.radixPoint);
                                    radixSplit[1] && (postMask += opts.radixPoint + "*{" + radixSplit[1].match(/^\d*\??\d*/)[0].length + "}");
                                }
                                return postMask;
                            }(processValue, opts), {
                                numericInput: !0,
                                jitMasking: !0,
                                definitions: {
                                    "*": {
                                        validator: "[0-9?]",
                                        cardinality: 1
                                    }
                                }
                            }).format(processValue.join("")), addRadix && (processValue += opts.radixPoint),
                            processValue.charAt(0) === opts.groupSeparator && processValue.substr(1);
                        }
                    }
                    if (opts.isNegative && "blur" === currentResult.event && (opts.isNegative = "0" !== processValue),
                        processValue = prefix + processValue, processValue += suffix, opts.isNegative && (processValue = opts.negationSymbol.front + processValue,
                        processValue += opts.negationSymbol.back), processValue = processValue.split(""),
                    charAtPos !== undefined) if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) (caretPos = $.inArray("?", processValue)) > -1 ? processValue[caretPos] = charAtPos : caretPos = currentResult.caret || 0; else if (charAtPos === opts.radixPoint || charAtPos === opts.negationSymbol.front || charAtPos === opts.negationSymbol.back) {
                        var newCaretPos = $.inArray(charAtPos, processValue);
                        -1 !== newCaretPos && (caretPos = newCaretPos);
                    }
                    opts.numericInput && (caretPos = processValue.length - caretPos - 1, processValue = processValue.reverse());
                    var rslt = {
                        caret: charAtPos === undefined || currentResult.pos !== undefined ? caretPos + (opts.numericInput ? -1 : 1) : caretPos,
                        buffer: processValue,
                        refreshFromBuffer: currentResult.dopost || buffer.join("") !== processValue.join("")
                    };
                    return rslt.refreshFromBuffer ? rslt : currentResult;
                },
                onBeforeWrite: function (e, buffer, caretPos, opts) {
                    if (e) switch (e.type) {
                        case "keydown":
                            return opts.postValidation(buffer, {
                                caret: caretPos,
                                dopost: !0
                            }, opts);

                        case "blur":
                        case "checkval":
                            var unmasked;
                            if (function (opts) {
                                opts.parseMinMaxOptions === undefined && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                                "," === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, ".")),
                                    opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)),
                                null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                                "," === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, ".")),
                                    opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)),
                                    opts.parseMinMaxOptions = "done");
                            }(opts), null !== opts.min || null !== opts.max) {
                                if (unmasked = opts.onUnMask(buffer.join(""), undefined, $.extend({}, opts, {
                                    unmaskAsNumber: !0
                                })), null !== opts.min && unmasked < opts.min) return opts.isNegative = opts.min < 0,
                                    opts.postValidation(opts.min.toString().replace(".", opts.radixPoint).split(""), {
                                        caret: caretPos,
                                        dopost: !0,
                                        placeholder: "0"
                                    }, opts);
                                if (null !== opts.max && unmasked > opts.max) return opts.isNegative = opts.max < 0,
                                    opts.postValidation(opts.max.toString().replace(".", opts.radixPoint).split(""), {
                                        caret: caretPos,
                                        dopost: !0,
                                        placeholder: "0"
                                    }, opts);
                            }
                            return opts.postValidation(buffer, {
                                caret: caretPos,
                                placeholder: "0",
                                event: "blur"
                            }, opts);

                        case "_checkval":
                            return {
                                caret: caretPos
                            };
                    }
                },
                regex: {
                    integerPart: function (opts, emptyCheck) {
                        return emptyCheck ? new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?") : new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?\\d+");
                    },
                    integerNPart: function (opts) {
                        return new RegExp("[\\d" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + "]+");
                    }
                },
                definitions: {
                    "~": {
                        validator: function (chrs, maskset, pos, strict, opts, isSelection) {
                            var isValid = strict ? new RegExp("[0-9" + Inputmask.escapeRegex(opts.groupSeparator) + "]").test(chrs) : new RegExp("[0-9]").test(chrs);
                            if (!0 === isValid) {
                                if (!0 !== opts.numericInput && maskset.validPositions[pos] !== undefined && "~" === maskset.validPositions[pos].match.def && !isSelection) {
                                    var processValue = maskset.buffer.join(""),
                                        pvRadixSplit = (processValue = (processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), "")).split(opts.radixPoint);
                                    pvRadixSplit.length > 1 && (pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g, opts.placeholder.charAt(0))),
                                    "0" === pvRadixSplit[0] && (pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g, opts.placeholder.charAt(0))),
                                        processValue = pvRadixSplit[0] + opts.radixPoint + pvRadixSplit[1] || "";
                                    var bufferTemplate = maskset._buffer.join("");
                                    for (processValue === opts.radixPoint && (processValue = bufferTemplate); null === processValue.match(Inputmask.escapeRegex(bufferTemplate) + "$");) bufferTemplate = bufferTemplate.slice(1);
                                    isValid = (processValue = (processValue = processValue.replace(bufferTemplate, "")).split(""))[pos] === undefined ? {
                                        pos: pos,
                                        remove: pos
                                    } : {
                                        pos: pos
                                    };
                                }
                            } else strict || chrs !== opts.radixPoint || maskset.validPositions[pos - 1] !== undefined || (maskset.buffer[pos] = "0",
                                isValid = {
                                    pos: pos + 1
                                });
                            return isValid;
                        },
                        cardinality: 1
                    },
                    "+": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            return opts.allowMinus && ("-" === chrs || chrs === opts.negationSymbol.front);
                        },
                        cardinality: 1,
                        placeholder: ""
                    },
                    "-": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            return opts.allowMinus && chrs === opts.negationSymbol.back;
                        },
                        cardinality: 1,
                        placeholder: ""
                    },
                    ":": {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var radix = "[" + Inputmask.escapeRegex(opts.radixPoint) + "]",
                                isValid = new RegExp(radix).test(chrs);
                            return isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {
                                caret: pos + 1
                            }), isValid;
                        },
                        cardinality: 1,
                        placeholder: function (opts) {
                            return opts.radixPoint;
                        }
                    }
                },
                onUnMask: function (maskedValue, unmaskedValue, opts) {
                    if ("" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;
                    var processValue = maskedValue.replace(opts.prefix, "");
                    return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                    "" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), "g"), "0")),
                        opts.unmaskAsNumber ? ("" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), ".")),
                            processValue = processValue.replace(new RegExp("^" + Inputmask.escapeRegex(opts.negationSymbol.front)), "-"),
                            processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
                            Number(processValue)) : processValue;
                },
                isComplete: function (buffer, opts) {
                    var maskedValue = buffer.join("");
                    if (buffer.slice().join("") !== maskedValue) return !1;
                    var processValue = maskedValue.replace(opts.prefix, "");
                    return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                    "," === opts.radixPoint && (processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".")),
                        isFinite(processValue);
                },
                onBeforeMask: function (initialValue, opts) {
                    if (opts.isNegative = undefined, initialValue = initialValue.toString().charAt(initialValue.length - 1) === opts.radixPoint ? initialValue.toString().substr(0, initialValue.length - 1) : initialValue.toString(),
                    "" !== opts.radixPoint && isFinite(initialValue)) {
                        var vs = initialValue.split("."),
                            groupSize = "" !== opts.groupSeparator ? parseInt(opts.groupSize) : 0;
                        2 === vs.length && (vs[0].length > groupSize || vs[1].length > groupSize || vs[0].length <= groupSize && vs[1].length < groupSize) && (initialValue = initialValue.replace(".", opts.radixPoint));
                    }
                    var kommaMatches = initialValue.match(/,/g), dotMatches = initialValue.match(/\./g);
                    if (initialValue = dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\./g, "")).replace(",", opts.radixPoint) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, "")).replace(".", opts.radixPoint) : initialValue.indexOf(".") < initialValue.indexOf(",") ? initialValue.replace(/\./g, "") : initialValue.replace(/,/g, "") : initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                    0 === opts.digits && (-1 !== initialValue.indexOf(".") ? initialValue = initialValue.substring(0, initialValue.indexOf(".")) : -1 !== initialValue.indexOf(",") && (initialValue = initialValue.substring(0, initialValue.indexOf(",")))),
                    "" !== opts.radixPoint && isFinite(opts.digits) && -1 !== initialValue.indexOf(opts.radixPoint)) {
                        var decPart = initialValue.split(opts.radixPoint)[1].match(new RegExp("\\d*"))[0];
                        if (parseInt(opts.digits) < decPart.toString().length) {
                            var digitsFactor = Math.pow(10, parseInt(opts.digits));
                            initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), "."),
                                initialValue = (initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor).toString().replace(".", opts.radixPoint);
                        }
                    }
                    return initialValue;
                },
                canClearPosition: function (maskset, position, lvp, strict, opts) {
                    var vp = maskset.validPositions[position],
                        canClear = vp.input !== opts.radixPoint || null !== maskset.validPositions[position].match.fn && !1 === opts.decimalProtect || vp.input === opts.radixPoint && maskset.validPositions[position + 1] && null === maskset.validPositions[position + 1].match.fn || isFinite(vp.input) || position === lvp || vp.input === opts.groupSeparator || vp.input === opts.negationSymbol.front || vp.input === opts.negationSymbol.back;
                    return !canClear || "+" !== vp.match.nativeDef && "-" !== vp.match.nativeDef || (opts.isNegative = !1),
                        canClear;
                },
                onKeyDown: function (e, buffer, caretPos, opts) {
                    var $input = $(this);
                    if (e.ctrlKey) switch (e.keyCode) {
                        case Inputmask.keyCode.UP:
                            $input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger("setvalue");
                            break;

                        case Inputmask.keyCode.DOWN:
                            $input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger("setvalue");
                    }
                }
            },
            currency: {
                prefix: "$ ",
                groupSeparator: ",",
                alias: "numeric",
                placeholder: "0",
                autoGroup: !0,
                digits: 2,
                digitsOptional: !1,
                clearMaskOnLostFocus: !1
            },
            decimal: {
                alias: "numeric"
            },
            integer: {
                alias: "numeric",
                digits: 0,
                radixPoint: ""
            },
            percentage: {
                alias: "numeric",
                digits: 2,
                digitsOptional: !0,
                radixPoint: ".",
                placeholder: "0",
                autoGroup: !1,
                min: 0,
                max: 100,
                suffix: " %",
                allowMinus: !1
            }
        }), Inputmask;
    });
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function (factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(1)],
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function ($, Inputmask) {
        function maskSort(a, b) {
            var maska = (a.mask || a).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""),
                maskb = (b.mask || b).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""),
                maskas = (a.mask || a).split("#")[0], maskbs = (b.mask || b).split("#")[0];
            return 0 === maskbs.indexOf(maskas) ? -1 : 0 === maskas.indexOf(maskbs) ? 1 : maska.localeCompare(maskb);
        }

        var analyseMaskBase = Inputmask.prototype.analyseMask;
        return Inputmask.prototype.analyseMask = function (mask, regexMask, opts) {
            function reduceVariations(masks, previousVariation, previousmaskGroup) {
                previousVariation = previousVariation || "", previousmaskGroup = previousmaskGroup || maskGroups,
                "" !== previousVariation && (previousmaskGroup[previousVariation] = {});
                for (var variation = "", maskGroup = previousmaskGroup[previousVariation] || previousmaskGroup, i = masks.length - 1; i >= 0; i--) maskGroup[variation = (mask = masks[i].mask || masks[i]).substr(0, 1)] = maskGroup[variation] || [],
                    maskGroup[variation].unshift(mask.substr(1)), masks.splice(i, 1);
                for (var ndx in maskGroup) maskGroup[ndx].length > 500 && reduceVariations(maskGroup[ndx].slice(), ndx, maskGroup);
            }

            function rebuild(maskGroup) {
                var mask = "", submasks = [];
                for (var ndx in maskGroup) $.isArray(maskGroup[ndx]) ? 1 === maskGroup[ndx].length ? submasks.push(ndx + maskGroup[ndx]) : submasks.push(ndx + opts.groupmarker.start + maskGroup[ndx].join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end) : submasks.push(ndx + rebuild(maskGroup[ndx]));
                return 1 === submasks.length ? mask += submasks[0] : mask += opts.groupmarker.start + submasks.join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end,
                    mask;
            }

            var maskGroups = {};
            return opts.phoneCodes && (opts.phoneCodes && opts.phoneCodes.length > 1e3 && (reduceVariations((mask = mask.substr(1, mask.length - 2)).split(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start)),
                mask = rebuild(maskGroups)), mask = mask.replace(/9/g, "\\9")), analyseMaskBase.call(this, mask, regexMask, opts);
        }, Inputmask.extendAliases({
            abstractphone: {
                groupmarker: {
                    start: "<",
                    end: ">"
                },
                countrycode: "",
                phoneCodes: [],
                mask: function (opts) {
                    return opts.definitions = {
                        "#": Inputmask.prototype.definitions[9]
                    }, opts.phoneCodes.sort(maskSort);
                },
                keepStatic: !0,
                onBeforeMask: function (value, opts) {
                    var processedValue = value.replace(/^0{1,2}/, "").replace(/[\s]/g, "");
                    return (processedValue.indexOf(opts.countrycode) > 1 || -1 === processedValue.indexOf(opts.countrycode)) && (processedValue = "+" + opts.countrycode + processedValue),
                        processedValue;
                },
                onUnMask: function (maskedValue, unmaskedValue, opts) {
                    return maskedValue.replace(/[()#-]/g, "");
                },
                inputmode: "tel"
            }
        }), Inputmask;
    });
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    "function" == typeof Symbol && Symbol.iterator;
    !function (factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(1)],
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function ($, Inputmask) {
        return Inputmask.extendAliases({
            Regex: {
                mask: "r",
                greedy: !1,
                repeat: "*",
                regex: null,
                regexTokens: null,
                tokenizer: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
                quantifierFilter: /[0-9]+[^,]/,
                isComplete: function (buffer, opts) {
                    return new RegExp(opts.regex, opts.casing ? "i" : "").test(buffer.join(""));
                },
                definitions: {
                    r: {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            function RegexToken(isGroup, isQuantifier) {
                                this.matches = [], this.isGroup = isGroup || !1, this.isQuantifier = isQuantifier || !1,
                                    this.quantifier = {
                                        min: 1,
                                        max: 1
                                    }, this.repeaterPart = void 0;
                            }

                            function validateRegexToken(token, fromGroup) {
                                var isvalid = !1;
                                fromGroup && (regexPart += "(", openGroupCount++);
                                for (var mndx = 0; mndx < token.matches.length; mndx++) {
                                    var matchToken = token.matches[mndx];
                                    if (!0 === matchToken.isGroup) isvalid = validateRegexToken(matchToken, !0); else if (!0 === matchToken.isQuantifier) {
                                        var crrntndx = $.inArray(matchToken, token.matches),
                                            matchGroup = token.matches[crrntndx - 1], regexPartBak = regexPart;
                                        if (isNaN(matchToken.quantifier.max)) {
                                            for (; matchToken.repeaterPart && matchToken.repeaterPart !== regexPart && matchToken.repeaterPart.length > regexPart.length && !(isvalid = validateRegexToken(matchGroup, !0));) ;
                                            (isvalid = isvalid || validateRegexToken(matchGroup, !0)) && (matchToken.repeaterPart = regexPart),
                                                regexPart = regexPartBak + matchToken.quantifier.max;
                                        } else {
                                            for (var i = 0, qm = matchToken.quantifier.max - 1; i < qm && !(isvalid = validateRegexToken(matchGroup, !0)); i++) ;
                                            regexPart = regexPartBak + "{" + matchToken.quantifier.min + "," + matchToken.quantifier.max + "}";
                                        }
                                    } else if (void 0 !== matchToken.matches) for (var k = 0; k < matchToken.length && !(isvalid = validateRegexToken(matchToken[k], fromGroup)); k++) ; else {
                                        var testExp;
                                        if ("[" == matchToken.charAt(0)) {
                                            testExp = regexPart, testExp += matchToken;
                                            for (j = 0; j < openGroupCount; j++) testExp += ")";
                                            isvalid = (exp = new RegExp("^(" + testExp + ")$", opts.casing ? "i" : "")).test(bufferStr);
                                        } else for (var l = 0, tl = matchToken.length; l < tl; l++) if ("\\" !== matchToken.charAt(l)) {
                                            testExp = regexPart, testExp = (testExp += matchToken.substr(0, l + 1)).replace(/\|$/, "");
                                            for (var j = 0; j < openGroupCount; j++) testExp += ")";
                                            var exp = new RegExp("^(" + testExp + ")$", opts.casing ? "i" : "");
                                            if (isvalid = exp.test(bufferStr)) break;
                                        }
                                        regexPart += matchToken;
                                    }
                                    if (isvalid) break;
                                }
                                return fromGroup && (regexPart += ")", openGroupCount--), isvalid;
                            }

                            var bufferStr, groupToken, cbuffer = maskset.buffer.slice(), regexPart = "", isValid = !1,
                                openGroupCount = 0;
                            null === opts.regexTokens && function () {
                                var match, m, currentToken = new RegexToken(), opengroups = [];
                                for (opts.regexTokens = []; match = opts.tokenizer.exec(opts.regex);) switch ((m = match[0]).charAt(0)) {
                                    case "(":
                                        opengroups.push(new RegexToken(!0));
                                        break;

                                    case ")":
                                        groupToken = opengroups.pop(), opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(groupToken) : currentToken.matches.push(groupToken);
                                        break;

                                    case "{":
                                    case "+":
                                    case "*":
                                        var quantifierToken = new RegexToken(!1, !0),
                                            mq = (m = m.replace(/[{}]/g, "")).split(","),
                                            mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                                            mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                                        if (quantifierToken.quantifier = {
                                            min: mq0,
                                            max: mq1
                                        }, opengroups.length > 0) {
                                            var matches = opengroups[opengroups.length - 1].matches;
                                            (match = matches.pop()).isGroup || ((groupToken = new RegexToken(!0)).matches.push(match),
                                                match = groupToken), matches.push(match), matches.push(quantifierToken);
                                        } else (match = currentToken.matches.pop()).isGroup || ((groupToken = new RegexToken(!0)).matches.push(match),
                                            match = groupToken), currentToken.matches.push(match), currentToken.matches.push(quantifierToken);
                                        break;

                                    default:
                                        opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(m) : currentToken.matches.push(m);
                                }
                                currentToken.matches.length > 0 && opts.regexTokens.push(currentToken);
                            }(), cbuffer.splice(pos, 0, chrs), bufferStr = cbuffer.join("");
                            for (var i = 0; i < opts.regexTokens.length; i++) {
                                var regexToken = opts.regexTokens[i];
                                if (isValid = validateRegexToken(regexToken, regexToken.isGroup)) break;
                            }
                            return isValid;
                        },
                        cardinality: 1
                    }
                }
            }
        }), Inputmask;
    });
}, function (module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__,
        _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
        } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    !function (factory) {
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(1)],
        void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }(function ($, Inputmask) {
        return void 0 === $.fn.inputmask && ($.fn.inputmask = function (fn, options) {
            var nptmask, input = this[0];
            if (void 0 === options && (options = {}), "string" == typeof fn) switch (fn) {
                case "unmaskedvalue":
                    return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();

                case "remove":
                    return this.each(function () {
                        this.inputmask && this.inputmask.remove();
                    });

                case "getemptymask":
                    return input && input.inputmask ? input.inputmask.getemptymask() : "";

                case "hasMaskedValue":
                    return !(!input || !input.inputmask) && input.inputmask.hasMaskedValue();

                case "isComplete":
                    return !input || !input.inputmask || input.inputmask.isComplete();

                case "getmetadata":
                    return input && input.inputmask ? input.inputmask.getmetadata() : void 0;

                case "setvalue":
                    $(input).val(options), input && void 0 === input.inputmask && $(input).triggerHandler("setvalue");
                    break;

                case "option":
                    if ("string" != typeof options) return this.each(function () {
                        if (void 0 !== this.inputmask) return this.inputmask.option(options);
                    });
                    if (input && void 0 !== input.inputmask) return input.inputmask.option(options);
                    break;

                default:
                    return options.alias = fn, nptmask = new Inputmask(options), this.each(function () {
                        nptmask.mask(this);
                    });
            } else {
                if ("object" == (void 0 === fn ? "undefined" : _typeof(fn))) return nptmask = new Inputmask(fn),
                    void 0 === fn.mask && void 0 === fn.alias ? this.each(function () {
                        if (void 0 !== this.inputmask) return this.inputmask.option(fn);
                        nptmask.mask(this);
                    }) : this.each(function () {
                        nptmask.mask(this);
                    });
                if (void 0 === fn) return this.each(function () {
                    (nptmask = new Inputmask(options)).mask(this);
                });
            }
        }), $.fn.inputmask;
    });
}]);
/*!
* inputmask.date.extensions.js
* https://github.com/RobinHerbots/Inputmask
* Copyright (c) 2010 - 2017 Robin Herbots
* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
* Version: 3.3.11
*/

!function (factory) {
    "function" == typeof define && define.amd ? define(["./dependencyLibs/inputmask.dependencyLib", "./inputmask"], factory) : "object" == typeof exports ? module.exports = factory(require("./dependencyLibs/inputmask.dependencyLib"), require("./inputmask")) : factory(window.dependencyLib || jQuery, window.Inputmask);
}(function ($, Inputmask) {
    function isLeapYear(year) {
        return isNaN(year) || 29 === new Date(year, 2, 0).getDate();
    }

    return Inputmask.extendAliases({
        "dd/mm/yyyy": {
            mask: "1/2/y",
            placeholder: "dd/mm/yyyy",
            regex: {
                val1pre: new RegExp("[0-3]"),
                val1: new RegExp("0[1-9]|[12][0-9]|3[01]"),
                val2pre: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[1-9]|[12][0-9]|3[01])" + escapedSeparator + "[01])");
                },
                val2: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[1-9]|[12][0-9])" + escapedSeparator + "(0[1-9]|1[012]))|(30" + escapedSeparator + "(0[13-9]|1[012]))|(31" + escapedSeparator + "(0[13578]|1[02]))");
                }
            },
            leapday: "29/02/",
            separator: "/",
            yearrange: {
                minyear: 1900,
                maxyear: 2099
            },
            isInYearRange: function (chrs, minyear, maxyear) {
                if (isNaN(chrs)) return !1;
                var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length))),
                    enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));
                return !isNaN(enteredyear) && (minyear <= enteredyear && enteredyear <= maxyear) || !isNaN(enteredyear2) && (minyear <= enteredyear2 && enteredyear2 <= maxyear);
            },
            determinebaseyear: function (minyear, maxyear, hint) {
                var currentyear = new Date().getFullYear();
                if (minyear > currentyear) return minyear;
                if (maxyear < currentyear) {
                    for (var maxYearPrefix = maxyear.toString().slice(0, 2), maxYearPostfix = maxyear.toString().slice(2, 4); maxyear < maxYearPrefix + hint;) maxYearPrefix--;
                    var maxxYear = maxYearPrefix + maxYearPostfix;
                    return minyear > maxxYear ? minyear : maxxYear;
                }
                if (minyear <= currentyear && currentyear <= maxyear) {
                    for (var currentYearPrefix = currentyear.toString().slice(0, 2); maxyear < currentYearPrefix + hint;) currentYearPrefix--;
                    var currentYearAndHint = currentYearPrefix + hint;
                    return currentYearAndHint < minyear ? minyear : currentYearAndHint;
                }
                return currentyear;
            },
            onKeyDown: function (e, buffer, caretPos, opts) {
                var $input = $(this);
                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                    var today = new Date();
                    $input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString()),
                        $input.trigger("setvalue");
                }
            },
            getFrontValue: function (mask, buffer, opts) {
                for (var start = 0, length = 0, i = 0; i < mask.length && "2" !== mask.charAt(i); i++) {
                    var definition = opts.definitions[mask.charAt(i)];
                    definition ? (start += length, length = definition.cardinality) : length++;
                }
                return buffer.join("").substr(start, length);
            },
            postValidation: function (buffer, currentResult, opts) {
                var dayMonthValue, year, bufferStr = buffer.join("");
                return 0 === opts.mask.indexOf("y") ? (year = bufferStr.substr(0, 4), dayMonthValue = bufferStr.substring(4, 10)) : (year = bufferStr.substring(6, 10),
                    dayMonthValue = bufferStr.substr(0, 6)), currentResult && (dayMonthValue !== opts.leapday || isLeapYear(year));
            },
            definitions: {
                "1": {
                    validator: function (chrs, maskset, pos, strict, opts) {
                        var isValid = opts.regex.val1.test(chrs);
                        return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val1.test("0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0",
                            {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                pos: pos,
                                c: chrs.charAt(0)
                            });
                    },
                    cardinality: 2,
                    prevalidator: [{
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var pchrs = chrs;
                            isNaN(maskset.buffer[pos + 1]) || (pchrs += maskset.buffer[pos + 1]);
                            var isValid = 1 === pchrs.length ? opts.regex.val1pre.test(pchrs) : opts.regex.val1.test(pchrs);
                            if (isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")),
                            !strict && !isValid) {
                                if (isValid = opts.regex.val1.test(chrs + "0")) return maskset.buffer[pos] = chrs,
                                    maskset.buffer[++pos] = "0", {
                                    pos: pos,
                                    c: "0"
                                };
                                if (isValid = opts.regex.val1.test("0" + chrs)) return maskset.buffer[pos] = "0",
                                    pos++, {
                                    pos: pos
                                };
                            }
                            return isValid;
                        },
                        cardinality: 1
                    }]
                },
                "2": {
                    validator: function (chrs, maskset, pos, strict, opts) {
                        var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
                        -1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
                        var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);
                        return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0",
                            {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos
                                },
                                pos: pos,
                                c: chrs.charAt(0)
                            });
                    },
                    cardinality: 2,
                    prevalidator: [{
                        validator: function (chrs, maskset, pos, strict, opts) {
                            isNaN(maskset.buffer[pos + 1]) || (chrs += maskset.buffer[pos + 1]);
                            var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
                            -1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
                            var isValid = 1 === chrs.length ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);
                            return isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")),
                                strict || isValid || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                    pos++, {
                                    pos: pos
                                });
                        },
                        cardinality: 1
                    }]
                },
                y: {
                    validator: function (chrs, maskset, pos, strict, opts) {
                        return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                    },
                    cardinality: 4,
                    prevalidator: [{
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                            if (!strict && !isValid) {
                                var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 1);
                                if (isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
                                    {
                                        pos: pos
                                    };
                                if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 2),
                                    isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
                                    maskset.buffer[pos++] = yearPrefix.charAt(1), {
                                    pos: pos
                                };
                            }
                            return isValid;
                        },
                        cardinality: 1
                    }, {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                            if (!strict && !isValid) {
                                var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);
                                if (isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(1),
                                    {
                                        pos: pos
                                    };
                                if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2),
                                    isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos - 1] = yearPrefix.charAt(0),
                                    maskset.buffer[pos++] = yearPrefix.charAt(1), maskset.buffer[pos++] = chrs.charAt(0),
                                    {
                                        refreshFromBuffer: {
                                            start: pos - 3,
                                            end: pos
                                        },
                                        pos: pos
                                    };
                            }
                            return isValid;
                        },
                        cardinality: 2
                    }, {
                        validator: function (chrs, maskset, pos, strict, opts) {
                            return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                        },
                        cardinality: 3
                    }]
                }
            },
            insertMode: !1,
            autoUnmask: !1
        },
        "mm/dd/yyyy": {
            placeholder: "mm/dd/yyyy",
            alias: "dd/mm/yyyy",
            regex: {
                val2pre: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                },
                val2: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                },
                val1pre: new RegExp("[01]"),
                val1: new RegExp("0[1-9]|1[012]")
            },
            leapday: "02/29/",
            onKeyDown: function (e, buffer, caretPos, opts) {
                var $input = $(this);
                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                    var today = new Date();
                    $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
                        $input.trigger("setvalue");
                }
            }
        },
        "yyyy/mm/dd": {
            mask: "y/1/2",
            placeholder: "yyyy/mm/dd",
            alias: "mm/dd/yyyy",
            leapday: "/02/29",
            onKeyDown: function (e, buffer, caretPos, opts) {
                var $input = $(this);
                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                    var today = new Date();
                    $input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString()),
                        $input.trigger("setvalue");
                }
            }
        },
        "dd.mm.yyyy": {
            mask: "1.2.y",
            placeholder: "dd.mm.yyyy",
            leapday: "29.02.",
            separator: ".",
            alias: "dd/mm/yyyy"
        },
        "dd-mm-yyyy": {
            mask: "1-2-y",
            placeholder: "dd-mm-yyyy",
            leapday: "29-02-",
            separator: "-",
            alias: "dd/mm/yyyy"
        },
        "mm.dd.yyyy": {
            mask: "1.2.y",
            placeholder: "mm.dd.yyyy",
            leapday: "02.29.",
            separator: ".",
            alias: "mm/dd/yyyy"
        },
        "mm-dd-yyyy": {
            mask: "1-2-y",
            placeholder: "mm-dd-yyyy",
            leapday: "02-29-",
            separator: "-",
            alias: "mm/dd/yyyy"
        },
        "yyyy.mm.dd": {
            mask: "y.1.2",
            placeholder: "yyyy.mm.dd",
            leapday: ".02.29",
            separator: ".",
            alias: "yyyy/mm/dd"
        },
        "yyyy-mm-dd": {
            mask: "y-1-2",
            placeholder: "yyyy-mm-dd",
            leapday: "-02-29",
            separator: "-",
            alias: "yyyy/mm/dd"
        },
        datetime: {
            mask: "1/2/y h:s",
            placeholder: "dd/mm/yyyy hh:mm",
            alias: "dd/mm/yyyy",
            regex: {
                hrspre: new RegExp("[012]"),
                hrs24: new RegExp("2[0-4]|1[3-9]"),
                hrs: new RegExp("[01][0-9]|2[0-4]"),
                ampm: new RegExp("^[a|p|A|P][m|M]"),
                mspre: new RegExp("[0-5]"),
                ms: new RegExp("[0-5][0-9]")
            },
            timeseparator: ":",
            hourFormat: "24",
            definitions: {
                h: {
                    validator: function (chrs, maskset, pos, strict, opts) {
                        if ("24" === opts.hourFormat && 24 === parseInt(chrs, 10)) return maskset.buffer[pos - 1] = "0",
                            maskset.buffer[pos] = "0", {
                            refreshFromBuffer: {
                                start: pos - 1,
                                end: pos
                            },
                            c: "0"
                        };
                        var isValid = opts.regex.hrs.test(chrs);
                        if (!strict && !isValid && (chrs.charAt(1) === opts.timeseparator || -1 !== "-.:".indexOf(chrs.charAt(1))) && (isValid = opts.regex.hrs.test("0" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = "0",
                            maskset.buffer[pos] = chrs.charAt(0), pos++, {
                            refreshFromBuffer: {
                                start: pos - 2,
                                end: pos
                            },
                            pos: pos,
                            c: opts.timeseparator
                        };
                        if (isValid && "24" !== opts.hourFormat && opts.regex.hrs24.test(chrs)) {
                            var tmp = parseInt(chrs, 10);
                            return 24 === tmp ? (maskset.buffer[pos + 5] = "a", maskset.buffer[pos + 6] = "m") : (maskset.buffer[pos + 5] = "p",
                                maskset.buffer[pos + 6] = "m"), (tmp -= 12) < 10 ? (maskset.buffer[pos] = tmp.toString(),
                                maskset.buffer[pos - 1] = "0") : (maskset.buffer[pos] = tmp.toString().charAt(1),
                                maskset.buffer[pos - 1] = tmp.toString().charAt(0)), {
                                refreshFromBuffer: {
                                    start: pos - 1,
                                    end: pos + 6
                                },
                                c: maskset.buffer[pos]
                            };
                        }
                        return isValid;
                    },
                    cardinality: 2,
                    prevalidator: [{
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.regex.hrspre.test(chrs);
                            return strict || isValid || !(isValid = opts.regex.hrs.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                pos++, {
                                pos: pos
                            });
                        },
                        cardinality: 1
                    }]
                },
                s: {
                    validator: "[0-5][0-9]",
                    cardinality: 2,
                    prevalidator: [{
                        validator: function (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.regex.mspre.test(chrs);
                            return strict || isValid || !(isValid = opts.regex.ms.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
                                pos++, {
                                pos: pos
                            });
                        },
                        cardinality: 1
                    }]
                },
                t: {
                    validator: function (chrs, maskset, pos, strict, opts) {
                        return opts.regex.ampm.test(chrs + "m");
                    },
                    casing: "lower",
                    cardinality: 1
                }
            },
            insertMode: !1,
            autoUnmask: !1
        },
        datetime12: {
            mask: "1/2/y h:s t\\m",
            placeholder: "dd/mm/yyyy hh:mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "mm/dd/yyyy hh:mm xm": {
            mask: "1/2/y h:s t\\m",
            placeholder: "mm/dd/yyyy hh:mm xm",
            alias: "datetime12",
            regex: {
                val2pre: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                },
                val2: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                },
                val1pre: new RegExp("[01]"),
                val1: new RegExp("0[1-9]|1[012]")
            },
            leapday: "02/29/",
            onKeyDown: function (e, buffer, caretPos, opts) {
                var $input = $(this);
                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                    var today = new Date();
                    $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
                        $input.trigger("setvalue");
                }
            }
        },
        "hh:mm t": {
            mask: "h:s t\\m",
            placeholder: "hh:mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "h:s t": {
            mask: "h:s t\\m",
            placeholder: "hh:mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "hh:mm:ss": {
            mask: "h:s:s",
            placeholder: "hh:mm:ss",
            alias: "datetime",
            autoUnmask: !1
        },
        "hh:mm": {
            mask: "h:s",
            placeholder: "hh:mm",
            alias: "datetime",
            autoUnmask: !1
        },
        date: {
            alias: "dd/mm/yyyy"
        },
        "mm/yyyy": {
            mask: "1/y",
            placeholder: "mm/yyyy",
            leapday: "donotuse",
            separator: "/",
            alias: "mm/dd/yyyy"
        },
        shamsi: {
            regex: {
                val2pre: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "[0-3])");
                },
                val2: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + escapedSeparator + "30)|((0[1-6])" + escapedSeparator + "31)");
                },
                val1pre: new RegExp("[01]"),
                val1: new RegExp("0[1-9]|1[012]")
            },
            yearrange: {
                minyear: 1300,
                maxyear: 1499
            },
            mask: "y/1/2",
            leapday: "/12/30",
            placeholder: "yyyy/mm/dd",
            alias: "mm/dd/yyyy",
            clearIncomplete: !0
        },
        "yyyy-mm-dd hh:mm:ss": {
            mask: "y-1-2 h:s:s",
            placeholder: "yyyy-mm-dd hh:mm:ss",
            alias: "datetime",
            separator: "-",
            leapday: "-02-29",
            regex: {
                val2pre: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
                },
                val2: function (separator) {
                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
                    return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
                },
                val1pre: new RegExp("[01]"),
                val1: new RegExp("0[1-9]|1[012]")
            },
            onKeyDown: function (e, buffer, caretPos, opts) {
            }
        }
    }), Inputmask;
});
/*!
* inputmask.numeric.extensions.js
* https://github.com/RobinHerbots/Inputmask
* Copyright (c) 2010 - 2017 Robin Herbots
* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
* Version: 3.3.11
*/

!function (factory) {
    "function" == typeof define && define.amd ? define(["./dependencyLibs/inputmask.dependencyLib", "./inputmask"], factory) : "object" == typeof exports ? module.exports = factory(require("./dependencyLibs/inputmask.dependencyLib"), require("./inputmask")) : factory(window.dependencyLib || jQuery, window.Inputmask);
}(function ($, Inputmask, undefined) {
    function autoEscape(txt, opts) {
        for (var escapedTxt = "", i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += "\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);
        return escapedTxt;
    }

    return Inputmask.extendAliases({
        numeric: {
            mask: function (opts) {
                if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat),
                    opts.repeat = 0, opts.groupSeparator === opts.radixPoint && ("." === opts.radixPoint ? opts.groupSeparator = "," : "," === opts.radixPoint ? opts.groupSeparator = "." : opts.groupSeparator = ""),
                " " === opts.groupSeparator && (opts.skipOptionalPartCharacter = undefined), opts.autoGroup = opts.autoGroup && "" !== opts.groupSeparator,
                opts.autoGroup && ("string" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)),
                    isFinite(opts.integerDigits))) {
                    var seps = Math.floor(opts.integerDigits / opts.groupSize),
                        mod = opts.integerDigits % opts.groupSize;
                    opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps),
                    opts.integerDigits < 1 && (opts.integerDigits = "*");
                }
                opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)),
                "radixFocus" === opts.positionCaretOnClick && "" === opts.placeholder && !1 === opts.integerOptional && (opts.positionCaretOnClick = "lvp"),
                    opts.definitions[";"] = opts.definitions["~"], opts.definitions[";"].definitionSymbol = "~",
                !0 === opts.numericInput && (opts.positionCaretOnClick = "radixFocus" === opts.positionCaretOnClick ? "lvp" : opts.positionCaretOnClick,
                    opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts.decimalProtect = !1);
                var mask = "[+]";
                if (mask += autoEscape(opts.prefix, opts), !0 === opts.integerOptional ? mask += "~{1," + opts.integerDigits + "}" : mask += "~{" + opts.integerDigits + "}",
                opts.digits !== undefined) {
                    opts.radixPointDefinitionSymbol = opts.decimalProtect ? ":" : opts.radixPoint;
                    var dq = opts.digits.toString().split(",");
                    isFinite(dq[0] && dq[1] && isFinite(dq[1])) ? mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}" : (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (opts.digitsOptional ? mask += "[" + opts.radixPointDefinitionSymbol + ";{1," + opts.digits + "}]" : mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}");
                }
                return mask += autoEscape(opts.suffix, opts), mask += "[-]", opts.greedy = !1, mask;
            },
            placeholder: "",
            greedy: !1,
            digits: "*",
            digitsOptional: !0,
            enforceDigitsOnBlur: !1,
            radixPoint: ".",
            positionCaretOnClick: "radixFocus",
            groupSize: 3,
            groupSeparator: "",
            autoGroup: !1,
            allowMinus: !0,
            negationSymbol: {
                front: "-",
                back: ""
            },
            integerDigits: "+",
            integerOptional: !0,
            prefix: "",
            suffix: "",
            rightAlign: !0,
            decimalProtect: !0,
            min: null,
            max: null,
            step: 1,
            insertMode: !0,
            autoUnmask: !1,
            unmaskAsNumber: !1,
            inputmode: "numeric",
            preValidation: function (buffer, pos, c, isSelection, opts) {
                if ("-" === c || c === opts.negationSymbol.front) return !0 === opts.allowMinus && (opts.isNegative = opts.isNegative === undefined || !opts.isNegative,
                "" === buffer.join("") || {
                    caret: pos,
                    dopost: !0
                });
                if (!1 === isSelection && c === opts.radixPoint && opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {
                    var radixPos = $.inArray(opts.radixPoint, buffer);
                    if (-1 !== radixPos) return !0 === opts.numericInput ? pos === radixPos : {
                        caret: radixPos + 1
                    };
                }
                return !0;
            },
            postValidation: function (buffer, currentResult, opts) {
                var suffix = opts.suffix.split(""), prefix = opts.prefix.split("");
                if (currentResult.pos === undefined && currentResult.caret !== undefined && !0 !== currentResult.dopost) return currentResult;
                var caretPos = currentResult.caret !== undefined ? currentResult.caret : currentResult.pos,
                    maskedValue = buffer.slice();
                opts.numericInput && (caretPos = maskedValue.length - caretPos - 1, maskedValue = maskedValue.reverse());
                var charAtPos = maskedValue[caretPos];
                if (charAtPos === opts.groupSeparator && (charAtPos = maskedValue[caretPos += 1]),
                caretPos === maskedValue.length - opts.suffix.length - 1 && charAtPos === opts.radixPoint) return currentResult;
                charAtPos !== undefined && charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back && (maskedValue[caretPos] = "?",
                    opts.prefix.length > 0 && caretPos >= (!1 === opts.isNegative ? 1 : 0) && caretPos < opts.prefix.length - 1 + (!1 === opts.isNegative ? 1 : 0) ? prefix[caretPos - (!1 === opts.isNegative ? 1 : 0)] = "?" : opts.suffix.length > 0 && caretPos >= maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0) && (suffix[caretPos - (maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0))] = "?")),
                    prefix = prefix.join(""), suffix = suffix.join("");
                var processValue = maskedValue.join("").replace(prefix, "");
                if (processValue = processValue.replace(suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                    processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), ""),
                    processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
                isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), "g"), "")),
                processValue.length > 1 && 1 !== processValue.indexOf(opts.radixPoint) && ("0" === charAtPos && (processValue = processValue.replace(/^\?/g, "")),
                    processValue = processValue.replace(/^0/g, "")), processValue.charAt(0) === opts.radixPoint && "" !== opts.radixPoint && !0 !== opts.numericInput && (processValue = "0" + processValue),
                "" !== processValue) {
                    if (processValue = processValue.split(""), (!opts.digitsOptional || opts.enforceDigitsOnBlur && "blur" === currentResult.event) && isFinite(opts.digits)) {
                        var radixPosition = $.inArray(opts.radixPoint, processValue),
                            rpb = $.inArray(opts.radixPoint, maskedValue);
                        -1 === radixPosition && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);
                        for (var i = 1; i <= opts.digits; i++) opts.digitsOptional && (!opts.enforceDigitsOnBlur || "blur" !== currentResult.event) || processValue[radixPosition + i] !== undefined && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? -1 !== rpb && maskedValue[rpb + i] !== undefined && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = currentResult.placeholder || opts.placeholder.charAt(0);
                    }
                    if (!0 !== opts.autoGroup || "" === opts.groupSeparator || charAtPos === opts.radixPoint && currentResult.pos === undefined && !currentResult.dopost) processValue = processValue.join(""); else {
                        var addRadix = processValue[processValue.length - 1] === opts.radixPoint && currentResult.c === opts.radixPoint;
                        processValue = Inputmask(function (buffer, opts) {
                            var postMask = "";
                            if (postMask += "(" + opts.groupSeparator + "*{" + opts.groupSize + "}){*}", "" !== opts.radixPoint) {
                                var radixSplit = buffer.join("").split(opts.radixPoint);
                                radixSplit[1] && (postMask += opts.radixPoint + "*{" + radixSplit[1].match(/^\d*\??\d*/)[0].length + "}");
                            }
                            return postMask;
                        }(processValue, opts), {
                            numericInput: !0,
                            jitMasking: !0,
                            definitions: {
                                "*": {
                                    validator: "[0-9?]",
                                    cardinality: 1
                                }
                            }
                        }).format(processValue.join("")), addRadix && (processValue += opts.radixPoint),
                        processValue.charAt(0) === opts.groupSeparator && processValue.substr(1);
                    }
                }
                if (opts.isNegative && "blur" === currentResult.event && (opts.isNegative = "0" !== processValue),
                    processValue = prefix + processValue, processValue += suffix, opts.isNegative && (processValue = opts.negationSymbol.front + processValue,
                    processValue += opts.negationSymbol.back), processValue = processValue.split(""),
                charAtPos !== undefined) if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) (caretPos = $.inArray("?", processValue)) > -1 ? processValue[caretPos] = charAtPos : caretPos = currentResult.caret || 0; else if (charAtPos === opts.radixPoint || charAtPos === opts.negationSymbol.front || charAtPos === opts.negationSymbol.back) {
                    var newCaretPos = $.inArray(charAtPos, processValue);
                    -1 !== newCaretPos && (caretPos = newCaretPos);
                }
                opts.numericInput && (caretPos = processValue.length - caretPos - 1, processValue = processValue.reverse());
                var rslt = {
                    caret: charAtPos === undefined || currentResult.pos !== undefined ? caretPos + (opts.numericInput ? -1 : 1) : caretPos,
                    buffer: processValue,
                    refreshFromBuffer: currentResult.dopost || buffer.join("") !== processValue.join("")
                };
                return rslt.refreshFromBuffer ? rslt : currentResult;
            },
            onBeforeWrite: function (e, buffer, caretPos, opts) {
                if (e) switch (e.type) {
                    case "keydown":
                        return opts.postValidation(buffer, {
                            caret: caretPos,
                            dopost: !0
                        }, opts);

                    case "blur":
                    case "checkval":
                        var unmasked;
                        if (function (opts) {
                            opts.parseMinMaxOptions === undefined && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                            "," === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, ".")),
                                opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)),
                            null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                            "," === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, ".")),
                                opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)),
                                opts.parseMinMaxOptions = "done");
                        }(opts), null !== opts.min || null !== opts.max) {
                            if (unmasked = opts.onUnMask(buffer.join(""), undefined, $.extend({}, opts, {
                                unmaskAsNumber: !0
                            })), null !== opts.min && unmasked < opts.min) return opts.isNegative = opts.min < 0,
                                opts.postValidation(opts.min.toString().replace(".", opts.radixPoint).split(""), {
                                    caret: caretPos,
                                    dopost: !0,
                                    placeholder: "0"
                                }, opts);
                            if (null !== opts.max && unmasked > opts.max) return opts.isNegative = opts.max < 0,
                                opts.postValidation(opts.max.toString().replace(".", opts.radixPoint).split(""), {
                                    caret: caretPos,
                                    dopost: !0,
                                    placeholder: "0"
                                }, opts);
                        }
                        return opts.postValidation(buffer, {
                            caret: caretPos,
                            placeholder: "0",
                            event: "blur"
                        }, opts);

                    case "_checkval":
                        return {
                            caret: caretPos
                        };
                }
            },
            regex: {
                integerPart: function (opts, emptyCheck) {
                    return emptyCheck ? new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?") : new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?\\d+");
                },
                integerNPart: function (opts) {
                    return new RegExp("[\\d" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + "]+");
                }
            },
            definitions: {
                "~": {
                    validator: function (chrs, maskset, pos, strict, opts, isSelection) {
                        var isValid = strict ? new RegExp("[0-9" + Inputmask.escapeRegex(opts.groupSeparator) + "]").test(chrs) : new RegExp("[0-9]").test(chrs);
                        if (!0 === isValid) {
                            if (!0 !== opts.numericInput && maskset.validPositions[pos] !== undefined && "~" === maskset.validPositions[pos].match.def && !isSelection) {
                                var processValue = maskset.buffer.join(""),
                                    pvRadixSplit = (processValue = (processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), "")).split(opts.radixPoint);
                                pvRadixSplit.length > 1 && (pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g, opts.placeholder.charAt(0))),
                                "0" === pvRadixSplit[0] && (pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g, opts.placeholder.charAt(0))),
                                    processValue = pvRadixSplit[0] + opts.radixPoint + pvRadixSplit[1] || "";
                                var bufferTemplate = maskset._buffer.join("");
                                for (processValue === opts.radixPoint && (processValue = bufferTemplate); null === processValue.match(Inputmask.escapeRegex(bufferTemplate) + "$");) bufferTemplate = bufferTemplate.slice(1);
                                isValid = (processValue = (processValue = processValue.replace(bufferTemplate, "")).split(""))[pos] === undefined ? {
                                    pos: pos,
                                    remove: pos
                                } : {
                                    pos: pos
                                };
                            }
                        } else strict || chrs !== opts.radixPoint || maskset.validPositions[pos - 1] !== undefined || (maskset.buffer[pos] = "0",
                            isValid = {
                                pos: pos + 1
                            });
                        return isValid;
                    },
                    cardinality: 1
                },
                "+": {
                    validator: function (chrs, maskset, pos, strict, opts) {
                        return opts.allowMinus && ("-" === chrs || chrs === opts.negationSymbol.front);
                    },
                    cardinality: 1,
                    placeholder: ""
                },
                "-": {
                    validator: function (chrs, maskset, pos, strict, opts) {
                        return opts.allowMinus && chrs === opts.negationSymbol.back;
                    },
                    cardinality: 1,
                    placeholder: ""
                },
                ":": {
                    validator: function (chrs, maskset, pos, strict, opts) {
                        var radix = "[" + Inputmask.escapeRegex(opts.radixPoint) + "]",
                            isValid = new RegExp(radix).test(chrs);
                        return isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {
                            caret: pos + 1
                        }), isValid;
                    },
                    cardinality: 1,
                    placeholder: function (opts) {
                        return opts.radixPoint;
                    }
                }
            },
            onUnMask: function (maskedValue, unmaskedValue, opts) {
                if ("" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;
                var processValue = maskedValue.replace(opts.prefix, "");
                return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                "" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), "g"), "0")),
                    opts.unmaskAsNumber ? ("" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), ".")),
                        processValue = processValue.replace(new RegExp("^" + Inputmask.escapeRegex(opts.negationSymbol.front)), "-"),
                        processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
                        Number(processValue)) : processValue;
            },
            isComplete: function (buffer, opts) {
                var maskedValue = buffer.join("");
                if (buffer.slice().join("") !== maskedValue) return !1;
                var processValue = maskedValue.replace(opts.prefix, "");
                return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                "," === opts.radixPoint && (processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".")),
                    isFinite(processValue);
            },
            onBeforeMask: function (initialValue, opts) {
                if (opts.isNegative = undefined, initialValue = initialValue.toString().charAt(initialValue.length - 1) === opts.radixPoint ? initialValue.toString().substr(0, initialValue.length - 1) : initialValue.toString(),
                "" !== opts.radixPoint && isFinite(initialValue)) {
                    var vs = initialValue.split("."),
                        groupSize = "" !== opts.groupSeparator ? parseInt(opts.groupSize) : 0;
                    2 === vs.length && (vs[0].length > groupSize || vs[1].length > groupSize || vs[0].length <= groupSize && vs[1].length < groupSize) && (initialValue = initialValue.replace(".", opts.radixPoint));
                }
                var kommaMatches = initialValue.match(/,/g), dotMatches = initialValue.match(/\./g);
                if (initialValue = dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\./g, "")).replace(",", opts.radixPoint) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, "")).replace(".", opts.radixPoint) : initialValue.indexOf(".") < initialValue.indexOf(",") ? initialValue.replace(/\./g, "") : initialValue.replace(/,/g, "") : initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
                0 === opts.digits && (-1 !== initialValue.indexOf(".") ? initialValue = initialValue.substring(0, initialValue.indexOf(".")) : -1 !== initialValue.indexOf(",") && (initialValue = initialValue.substring(0, initialValue.indexOf(",")))),
                "" !== opts.radixPoint && isFinite(opts.digits) && -1 !== initialValue.indexOf(opts.radixPoint)) {
                    var decPart = initialValue.split(opts.radixPoint)[1].match(new RegExp("\\d*"))[0];
                    if (parseInt(opts.digits) < decPart.toString().length) {
                        var digitsFactor = Math.pow(10, parseInt(opts.digits));
                        initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), "."),
                            initialValue = (initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor).toString().replace(".", opts.radixPoint);
                    }
                }
                return initialValue;
            },
            canClearPosition: function (maskset, position, lvp, strict, opts) {
                var vp = maskset.validPositions[position],
                    canClear = vp.input !== opts.radixPoint || null !== maskset.validPositions[position].match.fn && !1 === opts.decimalProtect || vp.input === opts.radixPoint && maskset.validPositions[position + 1] && null === maskset.validPositions[position + 1].match.fn || isFinite(vp.input) || position === lvp || vp.input === opts.groupSeparator || vp.input === opts.negationSymbol.front || vp.input === opts.negationSymbol.back;
                return !canClear || "+" !== vp.match.nativeDef && "-" !== vp.match.nativeDef || (opts.isNegative = !1),
                    canClear;
            },
            onKeyDown: function (e, buffer, caretPos, opts) {
                var $input = $(this);
                if (e.ctrlKey) switch (e.keyCode) {
                    case Inputmask.keyCode.UP:
                        $input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger("setvalue");
                        break;

                    case Inputmask.keyCode.DOWN:
                        $input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger("setvalue");
                }
            }
        },
        currency: {
            prefix: "$ ",
            groupSeparator: ",",
            alias: "numeric",
            placeholder: "0",
            autoGroup: !0,
            digits: 2,
            digitsOptional: !1,
            clearMaskOnLostFocus: !1
        },
        decimal: {
            alias: "numeric"
        },
        integer: {
            alias: "numeric",
            digits: 0,
            radixPoint: ""
        },
        percentage: {
            alias: "numeric",
            digits: 2,
            digitsOptional: !0,
            radixPoint: ".",
            placeholder: "0",
            autoGroup: !1,
            min: 0,
            max: 100,
            suffix: " %",
            allowMinus: !1
        }
    }), Inputmask;
});
/*!
* inputmask.phone.extensions.js
* https://github.com/RobinHerbots/Inputmask
* Copyright (c) 2010 - 2017 Robin Herbots
* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
* Version: 3.3.11
*/

!function (factory) {
    "function" == typeof define && define.amd ? define(["./dependencyLibs/inputmask.dependencyLib", "./inputmask"], factory) : "object" == typeof exports ? module.exports = factory(require("./dependencyLibs/inputmask.dependencyLib"), require("./inputmask")) : factory(window.dependencyLib || jQuery, window.Inputmask);
}(function ($, Inputmask) {
    function maskSort(a, b) {
        var maska = (a.mask || a).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""),
            maskb = (b.mask || b).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""),
            maskas = (a.mask || a).split("#")[0], maskbs = (b.mask || b).split("#")[0];
        return 0 === maskbs.indexOf(maskas) ? -1 : 0 === maskas.indexOf(maskbs) ? 1 : maska.localeCompare(maskb);
    }

    var analyseMaskBase = Inputmask.prototype.analyseMask;
    return Inputmask.prototype.analyseMask = function (mask, regexMask, opts) {
        function reduceVariations(masks, previousVariation, previousmaskGroup) {
            previousVariation = previousVariation || "", previousmaskGroup = previousmaskGroup || maskGroups,
            "" !== previousVariation && (previousmaskGroup[previousVariation] = {});
            for (var variation = "", maskGroup = previousmaskGroup[previousVariation] || previousmaskGroup, i = masks.length - 1; i >= 0; i--) maskGroup[variation = (mask = masks[i].mask || masks[i]).substr(0, 1)] = maskGroup[variation] || [],
                maskGroup[variation].unshift(mask.substr(1)), masks.splice(i, 1);
            for (var ndx in maskGroup) maskGroup[ndx].length > 500 && reduceVariations(maskGroup[ndx].slice(), ndx, maskGroup);
        }

        function rebuild(maskGroup) {
            var mask = "", submasks = [];
            for (var ndx in maskGroup) $.isArray(maskGroup[ndx]) ? 1 === maskGroup[ndx].length ? submasks.push(ndx + maskGroup[ndx]) : submasks.push(ndx + opts.groupmarker.start + maskGroup[ndx].join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end) : submasks.push(ndx + rebuild(maskGroup[ndx]));
            return 1 === submasks.length ? mask += submasks[0] : mask += opts.groupmarker.start + submasks.join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end,
                mask;
        }

        var maskGroups = {};
        return opts.phoneCodes && (opts.phoneCodes && opts.phoneCodes.length > 1e3 && (reduceVariations((mask = mask.substr(1, mask.length - 2)).split(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start)),
            mask = rebuild(maskGroups)), mask = mask.replace(/9/g, "\\9")), analyseMaskBase.call(this, mask, regexMask, opts);
    }, Inputmask.extendAliases({
        abstractphone: {
            groupmarker: {
                start: "<",
                end: ">"
            },
            countrycode: "",
            phoneCodes: [],
            mask: function (opts) {
                return opts.definitions = {
                    "#": Inputmask.prototype.definitions[9]
                }, opts.phoneCodes.sort(maskSort);
            },
            keepStatic: !0,
            onBeforeMask: function (value, opts) {
                var processedValue = value.replace(/^0{1,2}/, "").replace(/[\s]/g, "");
                return (processedValue.indexOf(opts.countrycode) > 1 || -1 === processedValue.indexOf(opts.countrycode)) && (processedValue = "+" + opts.countrycode + processedValue),
                    processedValue;
            },
            onUnMask: function (maskedValue, unmaskedValue, opts) {
                return maskedValue.replace(/[()#-]/g, "");
            },
            inputmode: "tel"
        }
    }), Inputmask;
});
/*! nouislider - 10.1.0 - 2017-07-28 17:11:18 */

(function (factory) {

    if (typeof define === 'function' && define.amd) {

        // AMD. Register as an anonymous module.
        define([], factory);

    } else if (typeof exports === 'object') {

        // Node/CommonJS
        module.exports = factory();

    } else {

        // Browser globals
        window.noUiSlider = factory();
    }

}(function () {

    'use strict';

    var VERSION = '10.1.0';


    function isValidFormatter(entry) {
        return typeof entry === 'object' && typeof entry.to === 'function' && typeof entry.from === 'function';
    }

    function removeElement(el) {
        el.parentElement.removeChild(el);
    }

    // Bindable version
    function preventDefault(e) {
        e.preventDefault();
    }

    // Removes duplicates from an array.
    function unique(array) {
        return array.filter(function (a) {
            return !this[a] ? this[a] = true : false;
        }, {});
    }

    // Round a value to the closest 'to'.
    function closest(value, to) {
        return Math.round(value / to) * to;
    }

    // Current position of an element relative to the document.
    function offset(elem, orientation) {

        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc);

        // getBoundingClientRect contains left scroll in Chrome on Android.
        // I haven't found a feature detection that proves this. Worst case
        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.
        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
            pageOffset.x = 0;
        }

        return orientation ? (rect.top + pageOffset.y - docElem.clientTop) : (rect.left + pageOffset.x - docElem.clientLeft);
    }

    // Checks whether a value is numerical.
    function isNumeric(a) {
        return typeof a === 'number' && !isNaN(a) && isFinite(a);
    }

    // Sets a class and removes it after [duration] ms.
    function addClassFor(element, className, duration) {
        if (duration > 0) {
            addClass(element, className);
            setTimeout(function () {
                removeClass(element, className);
            }, duration);
        }
    }

    // Limits a value to 0 - 100
    function limit(a) {
        return Math.max(Math.min(a, 100), 0);
    }

    // Wraps a variable as an array, if it isn't one yet.
    // Note that an input array is returned by reference!
    function asArray(a) {
        return Array.isArray(a) ? a : [a];
    }

    // Counts decimals
    function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
    }

    // http://youmightnotneedjquery.com/#add_class
    function addClass(el, className) {
        if (el.classList) {
            el.classList.add(className);
        } else {
            el.className += ' ' + className;
        }
    }

    // http://youmightnotneedjquery.com/#remove_class
    function removeClass(el, className) {
        if (el.classList) {
            el.classList.remove(className);
        } else {
            el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
        }
    }

    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/
    function hasClass(el, className) {
        return el.classList ? el.classList.contains(className) : new RegExp('\\b' + className + '\\b').test(el.className);
    }

    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes
    function getPageOffset(doc) {

        var supportPageOffset = window.pageXOffset !== undefined;
        var isCSS1Compat = ((doc.compatMode || "") === "CSS1Compat");
        var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
        var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;

        return {
            x: x,
            y: y
        };
    }

    // we provide a function to compute constants instead
    // of accessing window.* as soon as the module needs it
    // so that we do not compute anything if not needed
    function getActions() {

        // Determine the events to bind. IE11 implements pointerEvents without
        // a prefix, which breaks compatibility with the IE10 implementation.
        return window.navigator.pointerEnabled ? {
            start: 'pointerdown',
            move: 'pointermove',
            end: 'pointerup'
        } : window.navigator.msPointerEnabled ? {
            start: 'MSPointerDown',
            move: 'MSPointerMove',
            end: 'MSPointerUp'
        } : {
            start: 'mousedown touchstart',
            move: 'mousemove touchmove',
            end: 'mouseup touchend'
        };
    }

    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    // Issue #785
    function getSupportsPassive() {

        var supportsPassive = false;

        try {

            var opts = Object.defineProperty({}, 'passive', {
                get: function () {
                    supportsPassive = true;
                }
            });

            window.addEventListener('test', null, opts);

        } catch (e) {
        }

        return supportsPassive;
    }

    function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports('touch-action', 'none');
    }


// Value calculation

    // Determine the size of a sub-range in relation to a full range.
    function subRangeRatio(pa, pb) {
        return (100 / (pb - pa));
    }

    // (percentage) How many percent is this value of this range?
    function fromPercentage(range, value) {
        return (value * 100) / (range[1] - range[0]);
    }

    // (percentage) Where is this value on this range?
    function toPercentage(range, value) {
        return fromPercentage(range, range[0] < 0 ?
            value + Math.abs(range[0]) :
            value - range[0]);
    }

    // (value) How much is this percentage on this range?
    function isPercentage(range, value) {
        return ((value * (range[1] - range[0])) / 100) + range[0];
    }


// Range conversion

    function getJ(value, arr) {

        var j = 1;

        while (value >= arr[j]) {
            j += 1;
        }

        return j;
    }

    // (percentage) Input a value, find where, on a scale of 0-100, it applies.
    function toStepping(xVal, xPct, value) {

        if (value >= xVal.slice(-1)[0]) {
            return 100;
        }

        var j = getJ(value, xVal), va, vb, pa, pb;

        va = xVal[j - 1];
        vb = xVal[j];
        pa = xPct[j - 1];
        pb = xPct[j];

        return pa + (toPercentage([va, vb], value) / subRangeRatio(pa, pb));
    }

    // (value) Input a percentage, find where it is on the specified range.
    function fromStepping(xVal, xPct, value) {

        // There is no range group that fits 100
        if (value >= 100) {
            return xVal.slice(-1)[0];
        }

        var j = getJ(value, xPct), va, vb, pa, pb;

        va = xVal[j - 1];
        vb = xVal[j];
        pa = xPct[j - 1];
        pb = xPct[j];

        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
    }

    // (percentage) Get the step that applies at a certain value.
    function getStep(xPct, xSteps, snap, value) {

        if (value === 100) {
            return value;
        }

        var j = getJ(value, xPct), a, b;

        // If 'snap' is set, steps are used as fixed points on the slider.
        if (snap) {

            a = xPct[j - 1];
            b = xPct[j];

            // Find the closest position, a or b.
            if ((value - a) > ((b - a) / 2)) {
                return b;
            }

            return a;
        }

        if (!xSteps[j - 1]) {
            return value;
        }

        return xPct[j - 1] + closest(
            value - xPct[j - 1],
            xSteps[j - 1]
        );
    }


// Entry parsing

    function handleEntryPoint(index, value, that) {

        var percentage;

        // Wrap numerical input in an array.
        if (typeof value === "number") {
            value = [value];
        }

        // Reject any invalid input, by testing whether value is an array.
        if (Object.prototype.toString.call(value) !== '[object Array]') {
            throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.");
        }

        // Covert min/max syntax to 0 and 100.
        if (index === 'min') {
            percentage = 0;
        } else if (index === 'max') {
            percentage = 100;
        } else {
            percentage = parseFloat(index);
        }

        // Check for correct input.
        if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.");
        }

        // Store values.
        that.xPct.push(percentage);
        that.xVal.push(value[0]);

        // NaN will evaluate to false too, but to keep
        // logging clear, set step explicitly. Make sure
        // not to override the 'step' setting with false.
        if (!percentage) {
            if (!isNaN(value[1])) {
                that.xSteps[0] = value[1];
            }
        } else {
            that.xSteps.push(isNaN(value[1]) ? false : value[1]);
        }

        that.xHighestCompleteStep.push(0);
    }

    function handleStepPoint(i, n, that) {

        // Ignore 'false' stepping.
        if (!n) {
            return true;
        }

        // Factor to range ratio
        that.xSteps[i] = fromPercentage([
            that.xVal[i]
            , that.xVal[i + 1]
        ], n) / subRangeRatio(
            that.xPct[i],
            that.xPct[i + 1]);

        var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];
        var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
        var step = that.xVal[i] + (that.xNumSteps[i] * highestStep);

        that.xHighestCompleteStep[i] = step;
    }


// Interface

    function Spectrum(entry, snap, singleStep) {

        this.xPct = [];
        this.xVal = [];
        this.xSteps = [singleStep || false];
        this.xNumSteps = [false];
        this.xHighestCompleteStep = [];

        this.snap = snap;

        var index, ordered = [/* [0, 'min'], [1, '50%'], [2, 'max'] */];

        // Map the object keys to an array.
        for (index in entry) {
            if (entry.hasOwnProperty(index)) {
                ordered.push([entry[index], index]);
            }
        }

        // Sort all entries by value (numeric sort).
        if (ordered.length && typeof ordered[0][0] === "object") {
            ordered.sort(function (a, b) {
                return a[0][0] - b[0][0];
            });
        } else {
            ordered.sort(function (a, b) {
                return a[0] - b[0];
            });
        }


        // Convert all entries to subranges.
        for (index = 0; index < ordered.length; index++) {
            handleEntryPoint(ordered[index][1], ordered[index][0], this);
        }

        // Store the actual step values.
        // xSteps is sorted in the same order as xPct and xVal.
        this.xNumSteps = this.xSteps.slice(0);

        // Convert all numeric steps to the percentage of the subrange they represent.
        for (index = 0; index < this.xNumSteps.length; index++) {
            handleStepPoint(index, this.xNumSteps[index], this);
        }
    }

    Spectrum.prototype.getMargin = function (value) {

        var step = this.xNumSteps[0];

        if (step && ((value / step) % 1) !== 0) {
            throw new Error("noUiSlider (" + VERSION + "): 'limit', 'margin' and 'padding' must be divisible by step.");
        }

        return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;
    };

    Spectrum.prototype.toStepping = function (value) {

        value = toStepping(this.xVal, this.xPct, value);

        return value;
    };

    Spectrum.prototype.fromStepping = function (value) {

        return fromStepping(this.xVal, this.xPct, value);
    };

    Spectrum.prototype.getStep = function (value) {

        value = getStep(this.xPct, this.xSteps, this.snap, value);

        return value;
    };

    Spectrum.prototype.getNearbySteps = function (value) {

        var j = getJ(value, this.xPct);

        return {
            stepBefore: {
                startValue: this.xVal[j - 2],
                step: this.xNumSteps[j - 2],
                highestStep: this.xHighestCompleteStep[j - 2]
            },
            thisStep: {
                startValue: this.xVal[j - 1],
                step: this.xNumSteps[j - 1],
                highestStep: this.xHighestCompleteStep[j - 1]
            },
            stepAfter: {
                startValue: this.xVal[j - 0],
                step: this.xNumSteps[j - 0],
                highestStep: this.xHighestCompleteStep[j - 0]
            }
        };
    };

    Spectrum.prototype.countStepDecimals = function () {
        var stepDecimals = this.xNumSteps.map(countDecimals);
        return Math.max.apply(null, stepDecimals);
    };

    // Outside testing
    Spectrum.prototype.convert = function (value) {
        return this.getStep(this.toStepping(value));
    };

    /*	Every input option is tested and parsed. This'll prevent
	endless validation in internal methods. These tests are
	structured with an item for every option available. An
	option can be marked as required by setting the 'r' flag.
	The testing function is provided with three arguments:
		- The provided value for the option;
		- A reference to the options object;
		- The name for the option;

	The testing function returns false when an error is detected,
	or true when everything is OK. It can also modify the option
	object, to make sure all values can be correctly looped elsewhere. */

    var defaultFormatter = {
        'to': function (value) {
            return value !== undefined && value.toFixed(2);
        }, 'from': Number
    };

    function validateFormat(entry) {

        // Any object with a to and from method is supported.
        if (isValidFormatter(entry)) {
            return true;
        }

        throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.");
    }

    function testStep(parsed, entry) {

        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.");
        }

        // The step option can still be used to set stepping
        // for linear sliders. Overwritten if set in 'range'.
        parsed.singleStep = entry;
    }

    function testRange(parsed, entry) {

        // Filter incorrect input.
        if (typeof entry !== 'object' || Array.isArray(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.");
        }

        // Catch missing start or end.
        if (entry.min === undefined || entry.max === undefined) {
            throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.");
        }

        // Catch equal start or end.
        if (entry.min === entry.max) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.");
        }

        parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);
    }

    function testStart(parsed, entry) {

        entry = asArray(entry);

        // Validate input. Values aren't tested, as the public .val method
        // will always provide a valid location.
        if (!Array.isArray(entry) || !entry.length) {
            throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.");
        }

        // Store the number of handles.
        parsed.handles = entry.length;

        // When the slider is initialized, the .val method will
        // be called with the start options.
        parsed.start = entry;
    }

    function testSnap(parsed, entry) {

        // Enforce 100% stepping within subranges.
        parsed.snap = entry;

        if (typeof entry !== 'boolean') {
            throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.");
        }
    }

    function testAnimate(parsed, entry) {

        // Enforce 100% stepping within subranges.
        parsed.animate = entry;

        if (typeof entry !== 'boolean') {
            throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.");
        }
    }

    function testAnimationDuration(parsed, entry) {

        parsed.animationDuration = entry;

        if (typeof entry !== 'number') {
            throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.");
        }
    }

    function testConnect(parsed, entry) {

        var connect = [false];
        var i;

        // Map legacy options
        if (entry === 'lower') {
            entry = [true, false];
        }

        else if (entry === 'upper') {
            entry = [false, true];
        }

        // Handle boolean options
        if (entry === true || entry === false) {

            for (i = 1; i < parsed.handles; i++) {
                connect.push(entry);
            }

            connect.push(false);
        }

        // Reject invalid input
        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
            throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.");
        }

        else {
            connect = entry;
        }

        parsed.connect = connect;
    }

    function testOrientation(parsed, entry) {

        // Set orientation to an a numerical value for easy
        // array selection.
        switch (entry) {
            case 'horizontal':
                parsed.ort = 0;
                break;
            case 'vertical':
                parsed.ort = 1;
                break;
            default:
                throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.");
        }
    }

    function testMargin(parsed, entry) {

        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.");
        }

        // Issue #582
        if (entry === 0) {
            return;
        }

        parsed.margin = parsed.spectrum.getMargin(entry);

        if (!parsed.margin) {
            throw new Error("noUiSlider (" + VERSION + "): 'margin' option is only supported on linear sliders.");
        }
    }

    function testLimit(parsed, entry) {

        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.");
        }

        parsed.limit = parsed.spectrum.getMargin(entry);

        if (!parsed.limit || parsed.handles < 2) {
            throw new Error("noUiSlider (" + VERSION + "): 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
    }

    function testPadding(parsed, entry) {

        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be numeric.");
        }

        if (entry === 0) {
            return;
        }

        parsed.padding = parsed.spectrum.getMargin(entry);

        if (!parsed.padding) {
            throw new Error("noUiSlider (" + VERSION + "): 'padding' option is only supported on linear sliders.");
        }

        if (parsed.padding < 0) {
            throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number.");
        }

        if (parsed.padding >= 50) {
            throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be less than half the range.");
        }
    }

    function testDirection(parsed, entry) {

        // Set direction as a numerical value for easy parsing.
        // Invert connection for RTL sliders, so that the proper
        // handles get the connect/background classes.
        switch (entry) {
            case 'ltr':
                parsed.dir = 0;
                break;
            case 'rtl':
                parsed.dir = 1;
                break;
            default:
                throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.");
        }
    }

    function testBehaviour(parsed, entry) {

        // Make sure the input is a string.
        if (typeof entry !== 'string') {
            throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.");
        }

        // Check if the string contains any keywords.
        // None are required.
        var tap = entry.indexOf('tap') >= 0;
        var drag = entry.indexOf('drag') >= 0;
        var fixed = entry.indexOf('fixed') >= 0;
        var snap = entry.indexOf('snap') >= 0;
        var hover = entry.indexOf('hover') >= 0;

        if (fixed) {

            if (parsed.handles !== 2) {
                throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles");
            }

            // Use margin to enforce fixed state
            testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }

        parsed.events = {
            tap: tap || snap,
            drag: drag,
            fixed: fixed,
            snap: snap,
            hover: hover
        };
    }

    function testMultitouch(parsed, entry) {
        parsed.multitouch = entry;

        if (typeof entry !== 'boolean') {
            throw new Error("noUiSlider (" + VERSION + "): 'multitouch' option must be a boolean.");
        }
    }

    function testTooltips(parsed, entry) {

        if (entry === false) {
            return;
        }

        else if (entry === true) {

            parsed.tooltips = [];

            for (var i = 0; i < parsed.handles; i++) {
                parsed.tooltips.push(true);
            }
        }

        else {

            parsed.tooltips = asArray(entry);

            if (parsed.tooltips.length !== parsed.handles) {
                throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");
            }

            parsed.tooltips.forEach(function (formatter) {
                if (typeof formatter !== 'boolean' && (typeof formatter !== 'object' || typeof formatter.to !== 'function')) {
                    throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.");
                }
            });
        }
    }

    function testAriaFormat(parsed, entry) {
        parsed.ariaFormat = entry;
        validateFormat(entry);
    }

    function testFormat(parsed, entry) {
        parsed.format = entry;
        validateFormat(entry);
    }

    function testCssPrefix(parsed, entry) {

        if (entry !== undefined && typeof entry !== 'string' && entry !== false) {
            throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.");
        }

        parsed.cssPrefix = entry;
    }

    function testCssClasses(parsed, entry) {

        if (entry !== undefined && typeof entry !== 'object') {
            throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.");
        }

        if (typeof parsed.cssPrefix === 'string') {
            parsed.cssClasses = {};

            for (var key in entry) {
                if (!entry.hasOwnProperty(key)) {
                    continue;
                }

                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
            }
        } else {
            parsed.cssClasses = entry;
        }
    }

    function testUseRaf(parsed, entry) {
        if (entry === true || entry === false) {
            parsed.useRequestAnimationFrame = entry;
        } else {
            throw new Error("noUiSlider (" + VERSION + "): 'useRequestAnimationFrame' option should be true (default) or false.");
        }
    }

    // Test all developer settings and parse to assumption-safe values.
    function testOptions(options) {

        // To prove a fix for #537, freeze options here.
        // If the object is modified, an error will be thrown.
        // Object.freeze(options);

        var parsed = {
            margin: 0,
            limit: 0,
            padding: 0,
            animate: true,
            animationDuration: 300,
            ariaFormat: defaultFormatter,
            format: defaultFormatter
        };

        // Tests are executed in the order they are presented here.
        var tests = {
            'step': {r: false, t: testStep},
            'start': {r: true, t: testStart},
            'connect': {r: true, t: testConnect},
            'direction': {r: true, t: testDirection},
            'snap': {r: false, t: testSnap},
            'animate': {r: false, t: testAnimate},
            'animationDuration': {r: false, t: testAnimationDuration},
            'range': {r: true, t: testRange},
            'orientation': {r: false, t: testOrientation},
            'margin': {r: false, t: testMargin},
            'limit': {r: false, t: testLimit},
            'padding': {r: false, t: testPadding},
            'behaviour': {r: true, t: testBehaviour},
            'multitouch': {r: true, t: testMultitouch},
            'ariaFormat': {r: false, t: testAriaFormat},
            'format': {r: false, t: testFormat},
            'tooltips': {r: false, t: testTooltips},
            'cssPrefix': {r: false, t: testCssPrefix},
            'cssClasses': {r: false, t: testCssClasses},
            'useRequestAnimationFrame': {r: false, t: testUseRaf}
        };

        var defaults = {
            'connect': false,
            'direction': 'ltr',
            'behaviour': 'tap',
            'multitouch': false,
            'orientation': 'horizontal',
            'cssPrefix': 'noUi-',
            'cssClasses': {
                target: 'target',
                base: 'base',
                origin: 'origin',
                handle: 'handle',
                handleLower: 'handle-lower',
                handleUpper: 'handle-upper',
                horizontal: 'horizontal',
                vertical: 'vertical',
                background: 'background',
                connect: 'connect',
                ltr: 'ltr',
                rtl: 'rtl',
                draggable: 'draggable',
                drag: 'state-drag',
                tap: 'state-tap',
                active: 'active',
                tooltip: 'tooltip',
                pips: 'pips',
                pipsHorizontal: 'pips-horizontal',
                pipsVertical: 'pips-vertical',
                marker: 'marker',
                markerHorizontal: 'marker-horizontal',
                markerVertical: 'marker-vertical',
                markerNormal: 'marker-normal',
                markerLarge: 'marker-large',
                markerSub: 'marker-sub',
                value: 'value',
                valueHorizontal: 'value-horizontal',
                valueVertical: 'value-vertical',
                valueNormal: 'value-normal',
                valueLarge: 'value-large',
                valueSub: 'value-sub'
            },
            'useRequestAnimationFrame': true
        };

        // AriaFormat defaults to regular format, if any.
        if (options.format && !options.ariaFormat) {
            options.ariaFormat = options.format;
        }

        // Run all options through a testing mechanism to ensure correct
        // input. It should be noted that options might get modified to
        // be handled properly. E.g. wrapping integers in arrays.
        Object.keys(tests).forEach(function (name) {

            // If the option isn't set, but it is required, throw an error.
            if (options[name] === undefined && defaults[name] === undefined) {

                if (tests[name].r) {
                    throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.");
                }

                return true;
            }

            tests[name].t(parsed, options[name] === undefined ? defaults[name] : options[name]);
        });

        // Forward pips options
        parsed.pips = options.pips;

        var styles = [['left', 'top'], ['right', 'bottom']];

        // Pre-define the styles.
        parsed.style = styles[parsed.dir][parsed.ort];
        parsed.styleOposite = styles[parsed.dir ? 0 : 1][parsed.ort];

        return parsed;
    }


    function closure(target, options, originalOptions) {

        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive();

        // All variables local to 'closure' are prefixed with 'scope_'
        var scope_Target = target;
        var scope_Locations = [];
        var scope_Base;
        var scope_Handles;
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Connects;
        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Events = {};
        var scope_Self;
        var scope_Pips;
        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = scope_Document.documentElement;
        var scope_Body = scope_Document.body;


        // Creates a node, adds it to target, returns the new node.
        function addNodeTo(target, className) {

            var div = scope_Document.createElement('div');

            if (className) {
                addClass(div, className);
            }

            target.appendChild(div);

            return div;
        }

        // Append a origin to the base
        function addOrigin(base, handleNumber) {

            var origin = addNodeTo(base, options.cssClasses.origin);
            var handle = addNodeTo(origin, options.cssClasses.handle);

            handle.setAttribute('data-handle', handleNumber);

            // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
            // 0 = focusable and reachable
            handle.setAttribute('tabindex', '0');
            handle.setAttribute('role', 'slider');
            handle.setAttribute('aria-orientation', options.ort ? 'vertical' : 'horizontal');

            if (handleNumber === 0) {
                addClass(handle, options.cssClasses.handleLower);
            }

            else if (handleNumber === options.handles - 1) {
                addClass(handle, options.cssClasses.handleUpper);
            }

            return origin;
        }

        // Insert nodes for connect elements
        function addConnect(base, add) {

            if (!add) {
                return false;
            }

            return addNodeTo(base, options.cssClasses.connect);
        }

        // Add handles to the slider base.
        function addElements(connectOptions, base) {

            scope_Handles = [];
            scope_Connects = [];

            scope_Connects.push(addConnect(base, connectOptions[0]));

            // [::::O====O====O====]
            // connectOptions = [0, 1, 1, 1]

            for (var i = 0; i < options.handles; i++) {
                // Keep a list of all added handles.
                scope_Handles.push(addOrigin(base, i));
                scope_HandleNumbers[i] = i;
                scope_Connects.push(addConnect(base, connectOptions[i + 1]));
            }
        }

        // Initialize a single slider.
        function addSlider(target) {

            // Apply classes and data to the target.
            addClass(target, options.cssClasses.target);

            if (options.dir === 0) {
                addClass(target, options.cssClasses.ltr);
            } else {
                addClass(target, options.cssClasses.rtl);
            }

            if (options.ort === 0) {
                addClass(target, options.cssClasses.horizontal);
            } else {
                addClass(target, options.cssClasses.vertical);
            }

            scope_Base = addNodeTo(target, options.cssClasses.base);
        }


        function addTooltip(handle, handleNumber) {

            if (!options.tooltips[handleNumber]) {
                return false;
            }

            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }

        // The tooltips option is a shorthand for using the 'update' event.
        function tooltips() {

            // Tooltips are added with options.tooltips in original order.
            var tips = scope_Handles.map(addTooltip);

            bindEvent('update', function (values, handleNumber, unencoded) {

                if (!tips[handleNumber]) {
                    return;
                }

                var formattedValue = values[handleNumber];

                if (options.tooltips[handleNumber] !== true) {
                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
                }

                tips[handleNumber].innerHTML = formattedValue;
            });
        }


        function aria() {

            bindEvent('update', function (values, handleNumber, unencoded, tap, positions) {

                // Update Aria Values for all handles, as a change in one changes min and max values for the next.
                scope_HandleNumbers.forEach(function (handleNumber) {

                    var handle = scope_Handles[handleNumber];

                    var min = checkHandlePosition(scope_Locations, handleNumber, 0, true, true, true);
                    var max = checkHandlePosition(scope_Locations, handleNumber, 100, true, true, true);

                    var now = positions[handleNumber];
                    var text = options.ariaFormat.to(unencoded[handleNumber]);

                    handle.children[0].setAttribute('aria-valuemin', min.toFixed(1));
                    handle.children[0].setAttribute('aria-valuemax', max.toFixed(1));
                    handle.children[0].setAttribute('aria-valuenow', now.toFixed(1));
                    handle.children[0].setAttribute('aria-valuetext', text);
                });
            });
        }


        function getGroup(mode, values, stepped) {

            // Use the range.
            if (mode === 'range' || mode === 'steps') {
                return scope_Spectrum.xVal;
            }

            if (mode === 'count') {

                if (!values) {
                    throw new Error("noUiSlider (" + VERSION + "): 'values' required for mode 'count'.");
                }

                // Divide 0 - 100 in 'count' parts.
                var spread = (100 / (values - 1));
                var v;
                var i = 0;

                values = [];

                // List these parts and have them handled as 'positions'.
                while ((v = i++ * spread) <= 100) {
                    values.push(v);
                }

                mode = 'positions';
            }

            if (mode === 'positions') {

                // Map all percentages to on-range values.
                return values.map(function (value) {
                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
                });
            }

            if (mode === 'values') {

                // If the value must be stepped, it needs to be converted to a percentage first.
                if (stepped) {

                    return values.map(function (value) {

                        // Convert to percentage, apply step, return to value.
                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                    });

                }

                // Otherwise, we can simply use the values.
                return values;
            }
        }

        function generateSpread(density, mode, group) {

            function safeIncrement(value, increment) {
                // Avoid floating point variance by dropping the smallest decimal places.
                return (value + increment).toFixed(7) / 1;
            }

            var indexes = {};
            var firstInRange = scope_Spectrum.xVal[0];
            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
            var ignoreFirst = false;
            var ignoreLast = false;
            var prevPct = 0;

            // Create a copy of the group, sort it and filter away all duplicates.
            group = unique(group.slice().sort(function (a, b) {
                return a - b;
            }));

            // Make sure the range starts with the first element.
            if (group[0] !== firstInRange) {
                group.unshift(firstInRange);
                ignoreFirst = true;
            }

            // Likewise for the last one.
            if (group[group.length - 1] !== lastInRange) {
                group.push(lastInRange);
                ignoreLast = true;
            }

            group.forEach(function (current, index) {

                // Get the current step and the lower + upper positions.
                var step;
                var i;
                var q;
                var low = current;
                var high = group[index + 1];
                var newPct;
                var pctDifference;
                var pctPos;
                var type;
                var steps;
                var realSteps;
                var stepsize;

                // When using 'steps' mode, use the provided steps.
                // Otherwise, we'll step on to the next subrange.
                if (mode === 'steps') {
                    step = scope_Spectrum.xNumSteps[index];
                }

                // Default to a 'full' step.
                if (!step) {
                    step = high - low;
                }

                // Low can be 0, so test for false. If high is undefined,
                // we are at the last subrange. Index 0 is already handled.
                if (low === false || high === undefined) {
                    return;
                }

                // Make sure step isn't 0, which would cause an infinite loop (#654)
                step = Math.max(step, 0.0000001);

                // Find all steps in the subrange.
                for (i = low; i <= high; i = safeIncrement(i, step)) {

                    // Get the percentage value for the current step,
                    // calculate the size for the subrange.
                    newPct = scope_Spectrum.toStepping(i);
                    pctDifference = newPct - prevPct;

                    steps = pctDifference / density;
                    realSteps = Math.round(steps);

                    // This ratio represents the ammount of percentage-space a point indicates.
                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-devided.
                    // Round the percentage offset to an even number, then divide by two
                    // to spread the offset on both sides of the range.
                    stepsize = pctDifference / realSteps;

                    // Divide all points evenly, adding the correct number to this subrange.
                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.
                    for (q = 1; q <= realSteps; q += 1) {

                        // The ratio between the rounded value and the actual size might be ~1% off.
                        // Correct the percentage offset by the number of points
                        // per subrange. density = 1 will result in 100 points on the
                        // full range, 2 for 50, 4 for 25, etc.
                        pctPos = prevPct + (q * stepsize);
                        indexes[pctPos.toFixed(5)] = ['x', 0];
                    }

                    // Determine the point type.
                    type = (group.indexOf(i) > -1) ? 1 : (mode === 'steps' ? 2 : 0);

                    // Enforce the 'ignoreFirst' option by overwriting the type for 0.
                    if (!index && ignoreFirst) {
                        type = 0;
                    }

                    if (!(i === high && ignoreLast)) {
                        // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
                        indexes[newPct.toFixed(5)] = [i, type];
                    }

                    // Update the percentage count.
                    prevPct = newPct;
                }
            });

            return indexes;
        }

        function addMarking(spread, filterFunc, formatter) {

            var element = scope_Document.createElement('div');

            var valueSizeClasses = [
                options.cssClasses.valueNormal,
                options.cssClasses.valueLarge,
                options.cssClasses.valueSub
            ];
            var markerSizeClasses = [
                options.cssClasses.markerNormal,
                options.cssClasses.markerLarge,
                options.cssClasses.markerSub
            ];
            var valueOrientationClasses = [
                options.cssClasses.valueHorizontal,
                options.cssClasses.valueVertical
            ];
            var markerOrientationClasses = [
                options.cssClasses.markerHorizontal,
                options.cssClasses.markerVertical
            ];

            addClass(element, options.cssClasses.pips);
            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);

            function getClasses(type, source) {
                var a = source === options.cssClasses.value;
                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;

                return source + ' ' + orientationClasses[options.ort] + ' ' + sizeClasses[type];
            }

            function addSpread(offset, values) {

                // Apply the filter function, if it is set.
                values[1] = (values[1] && filterFunc) ? filterFunc(values[0], values[1]) : values[1];

                // Add a marker for every point
                var node = addNodeTo(element, false);
                node.className = getClasses(values[1], options.cssClasses.marker);
                node.style[options.style] = offset + '%';

                // Values are only appended for points marked '1' or '2'.
                if (values[1]) {
                    node = addNodeTo(element, false);
                    node.className = getClasses(values[1], options.cssClasses.value);
                    node.style[options.style] = offset + '%';
                    node.innerText = formatter.to(values[0]);
                }
            }

            // Append all points.
            Object.keys(spread).forEach(function (a) {
                addSpread(a, spread[a]);
            });

            return element;
        }

        function removePips() {
            if (scope_Pips) {
                removeElement(scope_Pips);
                scope_Pips = null;
            }
        }

        function pips(grid) {

            // Fix #669
            removePips();

            var mode = grid.mode;
            var density = grid.density || 1;
            var filter = grid.filter || false;
            var values = grid.values || false;
            var stepped = grid.stepped || false;
            var group = getGroup(mode, values, stepped);
            var spread = generateSpread(density, mode, group);
            var format = grid.format || {
                to: Math.round
            };

            scope_Pips = scope_Target.appendChild(addMarking(
                spread,
                filter,
                format
            ));

            return scope_Pips;
        }


        // Shorthand for base dimensions.
        function baseSize() {
            var rect = scope_Base.getBoundingClientRect(), alt = 'offset' + ['Width', 'Height'][options.ort];
            return options.ort === 0 ? (rect.width || scope_Base[alt]) : (rect.height || scope_Base[alt]);
        }

        // Handler for attaching events trough a proxy.
        function attachEvent(events, element, callback, data) {

            // This function can be used to 'filter' events to the slider.
            // element is a node, not a nodeList

            var method = function (e) {

                if (scope_Target.hasAttribute('disabled')) {
                    return false;
                }

                // Stop if an active 'tap' transition is taking place.
                if (hasClass(scope_Target, options.cssClasses.tap)) {
                    return false;
                }

                e = fixEvent(e, data.pageOffset, data.target || element);

                // Handle reject of multitouch
                if (!e) {
                    return false;
                }

                // Ignore right or middle clicks on start #454
                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {
                    return false;
                }

                // Ignore right or middle clicks on start #454
                if (data.hover && e.buttons) {
                    return false;
                }

                // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
                // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
                // touch-action: manipulation, but that allows panning, which breaks
                // sliders after zooming/on non-responsive pages.
                // See: https://bugs.webkit.org/show_bug.cgi?id=133112
                if (!supportsPassive) {
                    e.preventDefault();
                }

                e.calcPoint = e.points[options.ort];

                // Call the event handler with the event [ and additional data ].
                callback(e, data);
            };

            var methods = [];

            // Bind a closure on the target for every event type.
            events.split(' ').forEach(function (eventName) {
                element.addEventListener(eventName, method, supportsPassive ? {passive: true} : false);
                methods.push([eventName, method]);
            });

            return methods;
        }

        // Provide a clean event with standardized offset values.
        function fixEvent(e, pageOffset, target) {

            // Filter the event to register the type, which can be
            // touch, mouse or pointer. Offset changes need to be
            // made on an event specific basis.
            var touch = e.type.indexOf('touch') === 0;
            var mouse = e.type.indexOf('mouse') === 0;
            var pointer = e.type.indexOf('pointer') === 0;

            var x;
            var y;

            // IE10 implemented pointer events with a prefix;
            if (e.type.indexOf('MSPointer') === 0) {
                pointer = true;
            }


            // In the event that multitouch is activated, the only thing one handle should be concerned
            // about is the touches that originated on top of it.
            if (touch && options.multitouch) {
                // Returns true if a touch originated on the target.
                var isTouchOnTarget = function (touch) {
                    return touch.target === target || target.contains(touch.target);
                };
                // In the case of touchstart events, we need to make sure there is still no more than one
                // touch on the target so we look amongst all touches.
                if (e.type === 'touchstart') {
                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
                    // Do not support more than one touch per handle.
                    if (targetTouches.length > 1) {
                        return false;
                    }
                    x = targetTouches[0].pageX;
                    y = targetTouches[0].pageY;
                } else {
                    // In the other cases, find on changedTouches is enough.
                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
                    // Cancel if the target touch has not moved.
                    if (!targetTouch) {
                        return false;
                    }
                    x = targetTouch.pageX;
                    y = targetTouch.pageY;
                }
            } else if (touch) {
                // Fix bug when user touches with two or more fingers on mobile devices.
                // It's useful when you have two or more sliders on one page,
                // that can be touched simultaneously.
                // #649, #663, #668
                if (e.touches.length > 1) {
                    return false;
                }

                // noUiSlider supports one movement at a time,
                // so we can select the first 'changedTouch'.
                x = e.changedTouches[0].pageX;
                y = e.changedTouches[0].pageY;
            }

            pageOffset = pageOffset || getPageOffset(scope_Document);

            if (mouse || pointer) {
                x = e.clientX + pageOffset.x;
                y = e.clientY + pageOffset.y;
            }

            e.pageOffset = pageOffset;
            e.points = [x, y];
            e.cursor = mouse || pointer; // Fix #435

            return e;
        }

        // Translate a coordinate in the document to a percentage on the slider
        function calcPointToPercentage(calcPoint) {
            var location = calcPoint - offset(scope_Base, options.ort);
            var proposal = (location * 100) / baseSize();
            return options.dir ? 100 - proposal : proposal;
        }

        // Find handle closest to a certain percentage on the slider
        function getClosestHandle(proposal) {

            var closest = 100;
            var handleNumber = false;

            scope_Handles.forEach(function (handle, index) {

                // Disabled handles are ignored
                if (handle.hasAttribute('disabled')) {
                    return;
                }

                var pos = Math.abs(scope_Locations[index] - proposal);

                if (pos < closest) {
                    handleNumber = index;
                    closest = pos;
                }
            });

            return handleNumber;
        }

        // Moves handle(s) by a percentage
        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])
        function moveHandles(upward, proposal, locations, handleNumbers) {

            var proposals = locations.slice();

            var b = [!upward, upward];
            var f = [upward, !upward];

            // Copy handleNumbers so we don't change the dataset
            handleNumbers = handleNumbers.slice();

            // Check to see which handle is 'leading'.
            // If that one can't move the second can't either.
            if (upward) {
                handleNumbers.reverse();
            }

            // Step 1: get the maximum percentage that any of the handles can move
            if (handleNumbers.length > 1) {

                handleNumbers.forEach(function (handleNumber, o) {

                    var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false);

                    // Stop if one of the handles can't move.
                    if (to === false) {
                        proposal = 0;
                    } else {
                        proposal = to - proposals[handleNumber];
                        proposals[handleNumber] = to;
                    }
                });
            }

            // If using one handle, check backward AND forward
            else {
                b = f = [true];
            }

            var state = false;

            // Step 2: Try to set the handles with the found percentage
            handleNumbers.forEach(function (handleNumber, o) {
                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
            });

            // Step 3: If a handle moved, fire events
            if (state) {
                handleNumbers.forEach(function (handleNumber) {
                    fireEvent('update', handleNumber);
                    fireEvent('slide', handleNumber);
                });
            }
        }

        // External event handling
        function fireEvent(eventName, handleNumber, tap) {

            Object.keys(scope_Events).forEach(function (targetEvent) {

                var eventType = targetEvent.split('.')[0];

                if (eventName === eventType) {
                    scope_Events[targetEvent].forEach(function (callback) {

                        callback.call(
                            // Use the slider public API as the scope ('this')
                            scope_Self,
                            // Return values as array, so arg_1[arg_2] is always valid.
                            scope_Values.map(options.format.to),
                            // Handle index, 0 or 1
                            handleNumber,
                            // Unformatted slider values
                            scope_Values.slice(),
                            // Event is fired by tap, true or false
                            tap || false,
                            // Left offset of the handle, in relation to the slider
                            scope_Locations.slice()
                        );
                    });
                }
            });
        }


        // Fire 'end' when a mouse or pen leaves the document.
        function documentLeave(event, data) {
            if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
                eventEnd(event, data);
            }
        }

        // Handle movement on document for handle and range drag.
        function eventMove(event, data) {

            // Fix #498
            // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
            // IE9 has .buttons and .which zero on mousemove.
            // Firefox breaks the spec MDN defines.
            if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
                return eventEnd(event, data);
            }

            // Check if we are moving up or down
            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);

            // Convert the movement into a percentage of the slider width/height
            var proposal = (movement * 100) / data.baseSize;

            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);
        }

        // Unbind move events on document, call callbacks.
        function eventEnd(event, data) {

            // The handle is no longer active, so remove the class.
            if (data.handle) {
                removeClass(data.handle, options.cssClasses.active);
                scope_ActiveHandlesCount -= 1;
            }

            // Unbind the move and end events, which are added on 'start'.
            data.listeners.forEach(function (c) {
                scope_DocumentElement.removeEventListener(c[0], c[1]);
            });

            if (scope_ActiveHandlesCount === 0) {
                // Remove dragging class.
                removeClass(scope_Target, options.cssClasses.drag);
                setZindex();

                // Remove cursor styles and text-selection events bound to the body.
                if (event.cursor) {
                    scope_Body.style.cursor = '';
                    scope_Body.removeEventListener('selectstart', preventDefault);
                }
            }

            data.handleNumbers.forEach(function (handleNumber) {
                fireEvent('change', handleNumber);
                fireEvent('set', handleNumber);
                fireEvent('end', handleNumber);
            });
        }

        // Bind move events on document.
        function eventStart(event, data) {

            var handle;
            if (data.handleNumbers.length === 1) {

                var handleOrigin = scope_Handles[data.handleNumbers[0]];

                // Ignore 'disabled' handles
                if (handleOrigin.hasAttribute('disabled')) {
                    return false;
                }

                handle = handleOrigin.children[0];
                scope_ActiveHandlesCount += 1;

                // Mark the handle as 'active' so it can be styled.
                addClass(handle, options.cssClasses.active);
            }

            // A drag should never propagate up to the 'tap' event.
            event.stopPropagation();

            // Record the event listeners.
            var listeners = [];

            // Attach the move and end events.
            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                // The event target has changed so we need to propagate the original one so that we keep
                // relying on it to extract target touches.
                target: event.target,
                handle: handle,
                listeners: listeners,
                startCalcPoint: event.calcPoint,
                baseSize: baseSize(),
                pageOffset: event.pageOffset,
                handleNumbers: data.handleNumbers,
                buttonsProperty: event.buttons,
                locations: scope_Locations.slice()
            });

            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                target: event.target,
                handle: handle,
                listeners: listeners,
                handleNumbers: data.handleNumbers
            });

            var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                target: event.target,
                handle: handle,
                listeners: listeners,
                handleNumbers: data.handleNumbers
            });

            // We want to make sure we pushed the listeners in the listener list rather than creating
            // a new one as it has already been passed to the event handlers.
            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));

            // Text selection isn't an issue on touch devices,
            // so adding cursor styles can be skipped.
            if (event.cursor) {

                // Prevent the 'I' cursor and extend the range-drag cursor.
                scope_Body.style.cursor = getComputedStyle(event.target).cursor;

                // Mark the target with a dragging state.
                if (scope_Handles.length > 1) {
                    addClass(scope_Target, options.cssClasses.drag);
                }

                // Prevent text selection when dragging the handles.
                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
                // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
                // The 'cursor' flag is false.
                // See: http://caniuse.com/#search=selectstart
                scope_Body.addEventListener('selectstart', preventDefault, false);
            }

            data.handleNumbers.forEach(function (handleNumber) {
                fireEvent('start', handleNumber);
            });
        }

        // Move closest handle to tapped location.
        function eventTap(event) {

            // The tap event shouldn't propagate up
            event.stopPropagation();

            var proposal = calcPointToPercentage(event.calcPoint);
            var handleNumber = getClosestHandle(proposal);

            // Tackle the case that all handles are 'disabled'.
            if (handleNumber === false) {
                return false;
            }

            // Flag the slider as it is now in a transitional state.
            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.
            if (!options.events.snap) {
                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }

            setHandle(handleNumber, proposal, true, true);

            setZindex();

            fireEvent('slide', handleNumber, true);
            fireEvent('update', handleNumber, true);
            fireEvent('change', handleNumber, true);
            fireEvent('set', handleNumber, true);

            if (options.events.snap) {
                eventStart(event, {handleNumbers: [handleNumber]});
            }
        }

        // Fires a 'hover' event for a hovered mouse/pen position.
        function eventHover(event) {

            var proposal = calcPointToPercentage(event.calcPoint);

            var to = scope_Spectrum.getStep(proposal);
            var value = scope_Spectrum.fromStepping(to);

            Object.keys(scope_Events).forEach(function (targetEvent) {
                if ('hover' === targetEvent.split('.')[0]) {
                    scope_Events[targetEvent].forEach(function (callback) {
                        callback.call(scope_Self, value);
                    });
                }
            });
        }

        // Attach events to several slider parts.
        function bindSliderEvents(behaviour) {

            // Attach the standard drag event to the handles.
            if (!behaviour.fixed) {

                scope_Handles.forEach(function (handle, index) {

                    // These events are only bound to the visual handle
                    // element, not the 'real' origin element.
                    attachEvent(actions.start, handle.children[0], eventStart, {
                        handleNumbers: [index]
                    });
                });
            }

            // Attach the tap event to the slider base.
            if (behaviour.tap) {
                attachEvent(actions.start, scope_Base, eventTap, {});
            }

            // Fire hover events
            if (behaviour.hover) {
                attachEvent(actions.move, scope_Base, eventHover, {hover: true});
            }

            // Make the range draggable.
            if (behaviour.drag) {

                scope_Connects.forEach(function (connect, index) {

                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {
                        return;
                    }

                    var handleBefore = scope_Handles[index - 1];
                    var handleAfter = scope_Handles[index];
                    var eventHolders = [connect];

                    addClass(connect, options.cssClasses.draggable);

                    // When the range is fixed, the entire range can
                    // be dragged by the handles. The handle in the first
                    // origin will propagate the start event upward,
                    // but it needs to be bound manually on the other.
                    if (behaviour.fixed) {
                        eventHolders.push(handleBefore.children[0]);
                        eventHolders.push(handleAfter.children[0]);
                    }

                    eventHolders.forEach(function (eventHolder) {
                        attachEvent(actions.start, eventHolder, eventStart, {
                            handles: [handleBefore, handleAfter],
                            handleNumbers: [index - 1, index]
                        });
                    });
                });
            }
        }


        // Split out the handle positioning logic so the Move event can use it, too
        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {

            // For sliders with multiple handles, limit movement to the other handle.
            // Apply the margin option by adding it to the handle positions.
            if (scope_Handles.length > 1) {

                if (lookBackward && handleNumber > 0) {
                    to = Math.max(to, reference[handleNumber - 1] + options.margin);
                }

                if (lookForward && handleNumber < scope_Handles.length - 1) {
                    to = Math.min(to, reference[handleNumber + 1] - options.margin);
                }
            }

            // The limit option has the opposite effect, limiting handles to a
            // maximum distance from another. Limit must be > 0, as otherwise
            // handles would be unmoveable.
            if (scope_Handles.length > 1 && options.limit) {

                if (lookBackward && handleNumber > 0) {
                    to = Math.min(to, reference[handleNumber - 1] + options.limit);
                }

                if (lookForward && handleNumber < scope_Handles.length - 1) {
                    to = Math.max(to, reference[handleNumber + 1] - options.limit);
                }
            }

            // The padding option keeps the handles a certain distance from the
            // edges of the slider. Padding must be > 0.
            if (options.padding) {

                if (handleNumber === 0) {
                    to = Math.max(to, options.padding);
                }

                if (handleNumber === scope_Handles.length - 1) {
                    to = Math.min(to, 100 - options.padding);
                }
            }

            to = scope_Spectrum.getStep(to);

            // Limit percentage to the 0 - 100 range
            to = limit(to);

            // Return false if handle can't move
            if (to === reference[handleNumber] && !getValue) {
                return false;
            }

            return to;
        }

        function toPct(pct) {
            return pct + '%';
        }

        // Updates scope_Locations and scope_Values, updates visual state
        function updateHandlePosition(handleNumber, to) {

            // Update locations.
            scope_Locations[handleNumber] = to;

            // Convert the value to the slider stepping/range.
            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);

            // Called synchronously or on the next animationFrame
            var stateUpdate = function () {
                scope_Handles[handleNumber].style[options.style] = toPct(to);
                updateConnect(handleNumber);
                updateConnect(handleNumber + 1);
            };

            // Set the handle to the new position.
            // Use requestAnimationFrame for efficient painting.
            // No significant effect in Chrome, Edge sees dramatic performace improvements.
            // Option to disable is useful for unit tests, and single-step debugging.
            if (window.requestAnimationFrame && options.useRequestAnimationFrame) {
                window.requestAnimationFrame(stateUpdate);
            } else {
                stateUpdate();
            }
        }

        function setZindex() {

            scope_HandleNumbers.forEach(function (handleNumber) {
                // Handles before the slider middle are stacked later = higher,
                // Handles after the middle later is lower
                // [[7] [8] .......... | .......... [5] [4]
                var dir = (scope_Locations[handleNumber] > 50 ? -1 : 1);
                var zIndex = 3 + (scope_Handles.length + (dir * handleNumber));
                scope_Handles[handleNumber].childNodes[0].style.zIndex = zIndex;
            });
        }

        // Test suggested values and apply margin, step.
        function setHandle(handleNumber, to, lookBackward, lookForward) {

            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);

            if (to === false) {
                return false;
            }

            updateHandlePosition(handleNumber, to);

            return true;
        }

        // Updates style attribute for connect nodes
        function updateConnect(index) {

            // Skip connects set to false
            if (!scope_Connects[index]) {
                return;
            }

            var l = 0;
            var h = 100;

            if (index !== 0) {
                l = scope_Locations[index - 1];
            }

            if (index !== scope_Connects.length - 1) {
                h = scope_Locations[index];
            }

            scope_Connects[index].style[options.style] = toPct(l);
            scope_Connects[index].style[options.styleOposite] = toPct(100 - h);
        }

        // ...
        function setValue(to, handleNumber) {

            // Setting with null indicates an 'ignore'.
            // Inputting 'false' is invalid.
            if (to === null || to === false) {
                return;
            }

            // If a formatted number was passed, attemt to decode it.
            if (typeof to === 'number') {
                to = String(to);
            }

            to = options.format.from(to);

            // Request an update for all links if the value was invalid.
            // Do so too if setting the handle fails.
            if (to !== false && !isNaN(to)) {
                setHandle(handleNumber, scope_Spectrum.toStepping(to), false, false);
            }
        }

        // Set the slider value.
        function valueSet(input, fireSetEvent) {

            var values = asArray(input);
            var isInit = scope_Locations[0] === undefined;

            // Event fires by default
            fireSetEvent = (fireSetEvent === undefined ? true : !!fireSetEvent);

            values.forEach(setValue);

            // Animation is optional.
            // Make sure the initial values were set before using animated placement.
            if (options.animate && !isInit) {
                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }

            // Now that all base values are set, apply constraints
            scope_HandleNumbers.forEach(function (handleNumber) {
                setHandle(handleNumber, scope_Locations[handleNumber], true, false);
            });

            setZindex();

            scope_HandleNumbers.forEach(function (handleNumber) {

                fireEvent('update', handleNumber);

                // Fire the event only for handles that received a new value, as per #579
                if (values[handleNumber] !== null && fireSetEvent) {
                    fireEvent('set', handleNumber);
                }
            });
        }

        // Reset slider to initial values
        function valueReset(fireSetEvent) {
            valueSet(options.start, fireSetEvent);
        }

        // Get the slider value.
        function valueGet() {

            var values = scope_Values.map(options.format.to);

            // If only one handle is used, return a single value.
            if (values.length === 1) {
                return values[0];
            }

            return values;
        }

        // Removes classes from the root and empties it.
        function destroy() {

            for (var key in options.cssClasses) {
                if (!options.cssClasses.hasOwnProperty(key)) {
                    continue;
                }
                removeClass(scope_Target, options.cssClasses[key]);
            }

            while (scope_Target.firstChild) {
                scope_Target.removeChild(scope_Target.firstChild);
            }

            delete scope_Target.noUiSlider;
        }

        // Get the current step size for the slider.
        function getCurrentStep() {

            // Check all locations, map them to their stepping point.
            // Get the step point, then find it in the input list.
            return scope_Locations.map(function (location, index) {

                var nearbySteps = scope_Spectrum.getNearbySteps(location);
                var value = scope_Values[index];
                var increment = nearbySteps.thisStep.step;
                var decrement = null;

                // If the next value in this step moves into the next step,
                // the increment is the start of the next step - the current value
                if (increment !== false) {
                    if (value + increment > nearbySteps.stepAfter.startValue) {
                        increment = nearbySteps.stepAfter.startValue - value;
                    }
                }


                // If the value is beyond the starting point
                if (value > nearbySteps.thisStep.startValue) {
                    decrement = nearbySteps.thisStep.step;
                }

                else if (nearbySteps.stepBefore.step === false) {
                    decrement = false;
                }

                // If a handle is at the start of a step, it always steps back into the previous step first
                else {
                    decrement = value - nearbySteps.stepBefore.highestStep;
                }


                // Now, if at the slider edges, there is not in/decrement
                if (location === 100) {
                    increment = null;
                }

                else if (location === 0) {
                    decrement = null;
                }

                // As per #391, the comparison for the decrement step can have some rounding issues.
                var stepDecimals = scope_Spectrum.countStepDecimals();

                // Round per #391
                if (increment !== null && increment !== false) {
                    increment = Number(increment.toFixed(stepDecimals));
                }

                if (decrement !== null && decrement !== false) {
                    decrement = Number(decrement.toFixed(stepDecimals));
                }

                return [decrement, increment];
            });
        }

        // Attach an event to this slider, possibly including a namespace
        function bindEvent(namespacedEvent, callback) {
            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
            scope_Events[namespacedEvent].push(callback);

            // If the event bound is 'update,' fire it immediately for all handles.
            if (namespacedEvent.split('.')[0] === 'update') {
                scope_Handles.forEach(function (a, index) {
                    fireEvent('update', index);
                });
            }
        }

        // Undo attachment of event
        function removeEvent(namespacedEvent) {

            var event = namespacedEvent && namespacedEvent.split('.')[0];
            var namespace = event && namespacedEvent.substring(event.length);

            Object.keys(scope_Events).forEach(function (bind) {

                var tEvent = bind.split('.')[0],
                    tNamespace = bind.substring(tEvent.length);

                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
                    delete scope_Events[bind];
                }
            });
        }

        // Updateable: margin, limit, padding, step, range, animate, snap
        function updateOptions(optionsToUpdate, fireSetEvent) {

            // Spectrum is created using the range, snap, direction and step options.
            // 'snap' and 'step' can be updated.
            // If 'snap' and 'step' are not passed, they should remain unchanged.
            var v = valueGet();

            var updateAble = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format'];

            // Only change options that we're actually passed to update.
            updateAble.forEach(function (name) {
                if (optionsToUpdate[name] !== undefined) {
                    originalOptions[name] = optionsToUpdate[name];
                }
            });

            var newOptions = testOptions(originalOptions);

            // Load new options into the slider state
            updateAble.forEach(function (name) {
                if (optionsToUpdate[name] !== undefined) {
                    options[name] = newOptions[name];
                }
            });

            scope_Spectrum = newOptions.spectrum;

            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)
            options.margin = newOptions.margin;
            options.limit = newOptions.limit;
            options.padding = newOptions.padding;

            // Update pips, removes existing.
            if (options.pips) {
                pips(options.pips);
            }

            // Invalidate the current positioning so valueSet forces an update.
            scope_Locations = [];
            valueSet(optionsToUpdate.start || v, fireSetEvent);
        }

        // Throw an error if the slider was already initialized.
        if (scope_Target.noUiSlider) {
            throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");
        }

        // Create the base element, initialise HTML and set classes.
        // Add handles and connect elements.
        addSlider(scope_Target);
        addElements(options.connect, scope_Base);

        scope_Self = {
            destroy: destroy,
            steps: getCurrentStep,
            on: bindEvent,
            off: removeEvent,
            get: valueGet,
            set: valueSet,
            reset: valueReset,
            // Exposed for unit testing, don't use this in your application.
            __moveHandles: function (a, b, c) {
                moveHandles(a, b, scope_Locations, c);
            },
            options: originalOptions, // Issue #600, #678
            updateOptions: updateOptions,
            target: scope_Target, // Issue #597
            removePips: removePips,
            pips: pips // Issue #594
        };

        // Attach user events.
        bindSliderEvents(options.events);

        // Use the public value method to set the start values.
        valueSet(options.start);

        if (options.pips) {
            pips(options.pips);
        }

        if (options.tooltips) {
            tooltips();
        }

        aria();

        return scope_Self;

    }


    // Run the standard initializer
    function initialize(target, originalOptions) {

        if (!target || !target.nodeName) {
            throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);
        }

        // Test the options and create the slider environment;
        var options = testOptions(originalOptions, target);
        var api = closure(target, options, originalOptions);

        target.noUiSlider = api;

        return api;
    }

    // Use an object instead of a function for future expansibility;
    return {
        version: VERSION,
        create: initialize
    };

}));
/**
 * Owl Carousel v2.3.4
 * Copyright 2013-2018 David Deutsch
 * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
 */
/**
 * Owl carousel
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 * @todo Lazy Load Icon
 * @todo prevent animationend bubling
 * @todo itemsScaleUp
 * @todo Test Zepto
 * @todo stagePadding calculate wrong active classes
 */
;(function ($, window, document, undefined) {

    /**
     * Creates a carousel.
     * @class The Owl Carousel.
     * @public
     * @param {HTMLElement|jQuery} element - The element to create the carousel for.
     * @param {Object} [options] - The options
     */
    function Owl(element, options) {

        /**
         * Current settings for the carousel.
         * @public
         */
        this.settings = null;

        /**
         * Current options set by the caller including defaults.
         * @public
         */
        this.options = $.extend({}, Owl.Defaults, options);

        /**
         * Plugin element.
         * @public
         */
        this.$element = $(element);

        /**
         * Proxied event handlers.
         * @protected
         */
        this._handlers = {};

        /**
         * References to the running plugins of this carousel.
         * @protected
         */
        this._plugins = {};

        /**
         * Currently suppressed events to prevent them from being retriggered.
         * @protected
         */
        this._supress = {};

        /**
         * Absolute current position.
         * @protected
         */
        this._current = null;

        /**
         * Animation speed in milliseconds.
         * @protected
         */
        this._speed = null;

        /**
         * Coordinates of all items in pixel.
         * @todo The name of this member is missleading.
         * @protected
         */
        this._coordinates = [];

        /**
         * Current breakpoint.
         * @todo Real media queries would be nice.
         * @protected
         */
        this._breakpoint = null;

        /**
         * Current width of the plugin element.
         */
        this._width = null;

        /**
         * All real items.
         * @protected
         */
        this._items = [];

        /**
         * All cloned items.
         * @protected
         */
        this._clones = [];

        /**
         * Merge values of all items.
         * @todo Maybe this could be part of a plugin.
         * @protected
         */
        this._mergers = [];

        /**
         * Widths of all items.
         */
        this._widths = [];

        /**
         * Invalidated parts within the update process.
         * @protected
         */
        this._invalidated = {};

        /**
         * Ordered list of workers for the update process.
         * @protected
         */
        this._pipe = [];

        /**
         * Current state information for the drag operation.
         * @todo #261
         * @protected
         */
        this._drag = {
            time: null,
            target: null,
            pointer: null,
            stage: {
                start: null,
                current: null
            },
            direction: null
        };

        /**
         * Current state information and their tags.
         * @type {Object}
         * @protected
         */
        this._states = {
            current: {},
            tags: {
                'initializing': ['busy'],
                'animating': ['busy'],
                'dragging': ['interacting']
            }
        };

        $.each(['onResize', 'onThrottledResize'], $.proxy(function (i, handler) {
            this._handlers[handler] = $.proxy(this[handler], this);
        }, this));

        $.each(Owl.Plugins, $.proxy(function (key, plugin) {
            this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]
                = new plugin(this);
        }, this));

        $.each(Owl.Workers, $.proxy(function (priority, worker) {
            this._pipe.push({
                'filter': worker.filter,
                'run': $.proxy(worker.run, this)
            });
        }, this));

        this.setup();
        this.initialize();
    }

    /**
     * Default options for the carousel.
     * @public
     */
    Owl.Defaults = {
        items: 3,
        loop: false,
        center: false,
        rewind: false,
        checkVisibility: true,

        mouseDrag: true,
        touchDrag: true,
        pullDrag: true,
        freeDrag: false,

        margin: 0,
        stagePadding: 0,

        merge: false,
        mergeFit: true,
        autoWidth: false,

        startPosition: 0,
        rtl: false,

        smartSpeed: 250,
        fluidSpeed: false,
        dragEndSpeed: false,

        responsive: {},
        responsiveRefreshRate: 200,
        responsiveBaseElement: window,

        fallbackEasing: 'swing',
        slideTransition: '',

        info: false,

        nestedItemSelector: false,
        itemElement: 'div',
        stageElement: 'div',

        refreshClass: 'owl-refresh',
        loadedClass: 'owl-loaded',
        loadingClass: 'owl-loading',
        rtlClass: 'owl-rtl',
        responsiveClass: 'owl-responsive',
        dragClass: 'owl-drag',
        itemClass: 'owl-item',
        stageClass: 'owl-stage',
        stageOuterClass: 'owl-stage-outer',
        grabClass: 'owl-grab'
    };

    /**
     * Enumeration for width.
     * @public
     * @readonly
     * @enum {String}
     */
    Owl.Width = {
        Default: 'default',
        Inner: 'inner',
        Outer: 'outer'
    };

    /**
     * Enumeration for types.
     * @public
     * @readonly
     * @enum {String}
     */
    Owl.Type = {
        Event: 'event',
        State: 'state'
    };

    /**
     * Contains all registered plugins.
     * @public
     */
    Owl.Plugins = {};

    /**
     * List of workers involved in the update process.
     */
    Owl.Workers = [{
        filter: ['width', 'settings'],
        run: function () {
            this._width = this.$element.width();
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function (cache) {
            cache.current = this._items && this._items[this.relative(this._current)];
        }
    }, {
        filter: ['items', 'settings'],
        run: function () {
            this.$stage.children('.cloned').remove();
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function (cache) {
            var margin = this.settings.margin || '',
                grid = !this.settings.autoWidth,
                rtl = this.settings.rtl,
                css = {
                    'width': 'auto',
                    'margin-left': rtl ? margin : '',
                    'margin-right': rtl ? '' : margin
                };

            !grid && this.$stage.children().css(css);

            cache.css = css;
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function (cache) {
            var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
                merge = null,
                iterator = this._items.length,
                grid = !this.settings.autoWidth,
                widths = [];

            cache.items = {
                merge: false,
                width: width
            };

            while (iterator--) {
                merge = this._mergers[iterator];
                merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;

                cache.items.merge = merge > 1 || cache.items.merge;

                widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
            }

            this._widths = widths;
        }
    }, {
        filter: ['items', 'settings'],
        run: function () {
            var clones = [],
                items = this._items,
                settings = this.settings,
                // TODO: Should be computed from number of min width items in stage
                view = Math.max(settings.items * 2, 4),
                size = Math.ceil(items.length / 2) * 2,
                repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
                append = '',
                prepend = '';

            repeat /= 2;

            while (repeat > 0) {
                // Switch to only using appended clones
                clones.push(this.normalize(clones.length / 2, true));
                append = append + items[clones[clones.length - 1]][0].outerHTML;
                clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
                prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
                repeat -= 1;
            }

            this._clones = clones;

            $(append).addClass('cloned').appendTo(this.$stage);
            $(prepend).addClass('cloned').prependTo(this.$stage);
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function () {
            var rtl = this.settings.rtl ? 1 : -1,
                size = this._clones.length + this._items.length,
                iterator = -1,
                previous = 0,
                current = 0,
                coordinates = [];

            while (++iterator < size) {
                previous = coordinates[iterator - 1] || 0;
                current = this._widths[this.relative(iterator)] + this.settings.margin;
                coordinates.push(previous + current * rtl);
            }

            this._coordinates = coordinates;
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function () {
            var padding = this.settings.stagePadding,
                coordinates = this._coordinates,
                css = {
                    'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
                    'padding-left': padding || '',
                    'padding-right': padding || ''
                };

            this.$stage.css(css);
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function (cache) {
            var iterator = this._coordinates.length,
                grid = !this.settings.autoWidth,
                items = this.$stage.children();

            if (grid && cache.items.merge) {
                while (iterator--) {
                    cache.css.width = this._widths[this.relative(iterator)];
                    items.eq(iterator).css(cache.css);
                }
            } else if (grid) {
                cache.css.width = cache.items.width;
                items.css(cache.css);
            }
        }
    }, {
        filter: ['items'],
        run: function () {
            this._coordinates.length < 1 && this.$stage.removeAttr('style');
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function (cache) {
            cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
            cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
            this.reset(cache.current);
        }
    }, {
        filter: ['position'],
        run: function () {
            this.animate(this.coordinates(this._current));
        }
    }, {
        filter: ['width', 'position', 'items', 'settings'],
        run: function () {
            var rtl = this.settings.rtl ? 1 : -1,
                padding = this.settings.stagePadding * 2,
                begin = this.coordinates(this.current()) + padding,
                end = begin + this.width() * rtl,
                inner, outer, matches = [], i, n;

            for (i = 0, n = this._coordinates.length; i < n; i++) {
                inner = this._coordinates[i - 1] || 0;
                outer = Math.abs(this._coordinates[i]) + padding * rtl;

                if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
                    || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
                    matches.push(i);
                }
            }

            this.$stage.children('.active').removeClass('active');
            this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');

            this.$stage.children('.center').removeClass('center');
            if (this.settings.center) {
                this.$stage.children().eq(this.current()).addClass('center');
            }
        }
    }];

    /**
     * Create the stage DOM element
     */
    Owl.prototype.initializeStage = function () {
        this.$stage = this.$element.find('.' + this.settings.stageClass);

        // if the stage is already in the DOM, grab it and skip stage initialization
        if (this.$stage.length) {
            return;
        }

        this.$element.addClass(this.options.loadingClass);

        // create stage
        this.$stage = $('<' + this.settings.stageElement + '>', {
            "class": this.settings.stageClass
        }).wrap($('<div/>', {
            "class": this.settings.stageOuterClass
        }));

        // append stage
        this.$element.append(this.$stage.parent());
    };

    /**
     * Create item DOM elements
     */
    Owl.prototype.initializeItems = function () {
        var $items = this.$element.find('.owl-item');

        // if the items are already in the DOM, grab them and skip item initialization
        if ($items.length) {
            this._items = $items.get().map(function (item) {
                return $(item);
            });

            this._mergers = this._items.map(function () {
                return 1;
            });

            this.refresh();

            return;
        }

        // append content
        this.replace(this.$element.children().not(this.$stage.parent()));

        // check visibility
        if (this.isVisible()) {
            // update view
            this.refresh();
        } else {
            // invalidate width
            this.invalidate('width');
        }

        this.$element
            .removeClass(this.options.loadingClass)
            .addClass(this.options.loadedClass);
    };

    /**
     * Initializes the carousel.
     * @protected
     */
    Owl.prototype.initialize = function () {
        this.enter('initializing');
        this.trigger('initialize');

        this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

        if (this.settings.autoWidth && !this.is('pre-loading')) {
            var imgs, nestedSelector, width;
            imgs = this.$element.find('img');
            nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
            width = this.$element.children(nestedSelector).width();

            if (imgs.length && width <= 0) {
                this.preloadAutoWidthImages(imgs);
            }
        }

        this.initializeStage();
        this.initializeItems();

        // register event handlers
        this.registerEventHandlers();

        this.leave('initializing');
        this.trigger('initialized');
    };

    /**
     * @returns {Boolean} visibility of $element
     *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to
     *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does
     */
    Owl.prototype.isVisible = function () {
        return this.settings.checkVisibility
            ? this.$element.is(':visible')
            : true;
    };

    /**
     * Setups the current settings.
     * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
     * @todo Support for media queries by using `matchMedia` would be nice.
     * @public
     */
    Owl.prototype.setup = function () {
        var viewport = this.viewport(),
            overwrites = this.options.responsive,
            match = -1,
            settings = null;

        if (!overwrites) {
            settings = $.extend({}, this.options);
        } else {
            $.each(overwrites, function (breakpoint) {
                if (breakpoint <= viewport && breakpoint > match) {
                    match = Number(breakpoint);
                }
            });

            settings = $.extend({}, this.options, overwrites[match]);
            if (typeof settings.stagePadding === 'function') {
                settings.stagePadding = settings.stagePadding();
            }
            delete settings.responsive;

            // responsive class
            if (settings.responsiveClass) {
                this.$element.attr('class',
                    this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match)
                );
            }
        }

        this.trigger('change', {property: {name: 'settings', value: settings}});
        this._breakpoint = match;
        this.settings = settings;
        this.invalidate('settings');
        this.trigger('changed', {property: {name: 'settings', value: this.settings}});
    };

    /**
     * Updates option logic if necessery.
     * @protected
     */
    Owl.prototype.optionsLogic = function () {
        if (this.settings.autoWidth) {
            this.settings.stagePadding = false;
            this.settings.merge = false;
        }
    };

    /**
     * Prepares an item before add.
     * @todo Rename event parameter `content` to `item`.
     * @protected
     * @returns {jQuery|HTMLElement} - The item container.
     */
    Owl.prototype.prepare = function (item) {
        var event = this.trigger('prepare', {content: item});

        if (!event.data) {
            event.data = $('<' + this.settings.itemElement + '/>')
                .addClass(this.options.itemClass).append(item)
        }

        this.trigger('prepared', {content: event.data});

        return event.data;
    };

    /**
     * Updates the view.
     * @public
     */
    Owl.prototype.update = function () {
        var i = 0,
            n = this._pipe.length,
            filter = $.proxy(function (p) {
                return this[p]
            }, this._invalidated),
            cache = {};

        while (i < n) {
            if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
                this._pipe[i].run(cache);
            }
            i++;
        }

        this._invalidated = {};

        !this.is('valid') && this.enter('valid');
    };

    /**
     * Gets the width of the view.
     * @public
     * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
     * @returns {Number} - The width of the view in pixel.
     */
    Owl.prototype.width = function (dimension) {
        dimension = dimension || Owl.Width.Default;
        switch (dimension) {
            case Owl.Width.Inner:
            case Owl.Width.Outer:
                return this._width;
            default:
                return this._width - this.settings.stagePadding * 2 + this.settings.margin;
        }
    };

    /**
     * Refreshes the carousel primarily for adaptive purposes.
     * @public
     */
    Owl.prototype.refresh = function () {
        this.enter('refreshing');
        this.trigger('refresh');

        this.setup();

        this.optionsLogic();

        this.$element.addClass(this.options.refreshClass);

        this.update();

        this.$element.removeClass(this.options.refreshClass);

        this.leave('refreshing');
        this.trigger('refreshed');
    };

    /**
     * Checks window `resize` event.
     * @protected
     */
    Owl.prototype.onThrottledResize = function () {
        window.clearTimeout(this.resizeTimer);
        this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
    };

    /**
     * Checks window `resize` event.
     * @protected
     */
    Owl.prototype.onResize = function () {
        if (!this._items.length) {
            return false;
        }

        if (this._width === this.$element.width()) {
            return false;
        }

        if (!this.isVisible()) {
            return false;
        }

        this.enter('resizing');

        if (this.trigger('resize').isDefaultPrevented()) {
            this.leave('resizing');
            return false;
        }

        this.invalidate('width');

        this.refresh();

        this.leave('resizing');
        this.trigger('resized');
    };

    /**
     * Registers event handlers.
     * @todo Check `msPointerEnabled`
     * @todo #261
     * @protected
     */
    Owl.prototype.registerEventHandlers = function () {
        if ($.support.transition) {
            this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
        }

        if (this.settings.responsive !== false) {
            this.on(window, 'resize', this._handlers.onThrottledResize);
        }

        if (this.settings.mouseDrag) {
            this.$element.addClass(this.options.dragClass);
            this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
            this.$stage.on('dragstart.owl.core selectstart.owl.core', function () {
                return false
            });
        }

        if (this.settings.touchDrag) {
            this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
            this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
        }
    };

    /**
     * Handles `touchstart` and `mousedown` events.
     * @todo Horizontal swipe threshold as option
     * @todo #261
     * @protected
     * @param {Event} event - The event arguments.
     */
    Owl.prototype.onDragStart = function (event) {
        var stage = null;

        if (event.which === 3) {
            return;
        }

        if ($.support.transform) {
            stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
            stage = {
                x: stage[stage.length === 16 ? 12 : 4],
                y: stage[stage.length === 16 ? 13 : 5]
            };
        } else {
            stage = this.$stage.position();
            stage = {
                x: this.settings.rtl ?
                    stage.left + this.$stage.width() - this.width() + this.settings.margin :
                    stage.left,
                y: stage.top
            };
        }

        if (this.is('animating')) {
            $.support.transform ? this.animate(stage.x) : this.$stage.stop()
            this.invalidate('position');
        }

        this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');

        this.speed(0);

        this._drag.time = new Date().getTime();
        this._drag.target = $(event.target);
        this._drag.stage.start = stage;
        this._drag.stage.current = stage;
        this._drag.pointer = this.pointer(event);

        $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));

        $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function (event) {
            var delta = this.difference(this._drag.pointer, this.pointer(event));

            $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

            if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
                return;
            }

            event.preventDefault();

            this.enter('dragging');
            this.trigger('drag');
        }, this));
    };

    /**
     * Handles the `touchmove` and `mousemove` events.
     * @todo #261
     * @protected
     * @param {Event} event - The event arguments.
     */
    Owl.prototype.onDragMove = function (event) {
        var minimum = null,
            maximum = null,
            pull = null,
            delta = this.difference(this._drag.pointer, this.pointer(event)),
            stage = this.difference(this._drag.stage.start, delta);

        if (!this.is('dragging')) {
            return;
        }

        event.preventDefault();

        if (this.settings.loop) {
            minimum = this.coordinates(this.minimum());
            maximum = this.coordinates(this.maximum() + 1) - minimum;
            stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
        } else {
            minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
            maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
            pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
            stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
        }

        this._drag.stage.current = stage;

        this.animate(stage.x);
    };

    /**
     * Handles the `touchend` and `mouseup` events.
     * @todo #261
     * @todo Threshold for click event
     * @protected
     * @param {Event} event - The event arguments.
     */
    Owl.prototype.onDragEnd = function (event) {
        var delta = this.difference(this._drag.pointer, this.pointer(event)),
            stage = this._drag.stage.current,
            direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';

        $(document).off('.owl.core');

        this.$element.removeClass(this.options.grabClass);

        if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
            this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
            this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
            this.invalidate('position');
            this.update();

            this._drag.direction = direction;

            if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
                this._drag.target.one('click.owl.core', function () {
                    return false;
                });
            }
        }

        if (!this.is('dragging')) {
            return;
        }

        this.leave('dragging');
        this.trigger('dragged');
    };

    /**
     * Gets absolute position of the closest item for a coordinate.
     * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
     * @protected
     * @param {Number} coordinate - The coordinate in pixel.
     * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
     * @return {Number} - The absolute position of the closest item.
     */
    Owl.prototype.closest = function (coordinate, direction) {
        var position = -1,
            pull = 30,
            width = this.width(),
            coordinates = this.coordinates();

        if (!this.settings.freeDrag) {
            // check closest item
            $.each(coordinates, $.proxy(function (index, value) {
                // on a left pull, check on current index
                if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
                    position = index;
                    // on a right pull, check on previous index
                    // to do so, subtract width from value and set position = index + 1
                } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
                    position = index + 1;
                } else if (this.op(coordinate, '<', value)
                    && this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {
                    position = direction === 'left' ? index + 1 : index;
                }
                return position === -1;
            }, this));
        }

        if (!this.settings.loop) {
            // non loop boundries
            if (this.op(coordinate, '>', coordinates[this.minimum()])) {
                position = coordinate = this.minimum();
            } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
                position = coordinate = this.maximum();
            }
        }

        return position;
    };

    /**
     * Animates the stage.
     * @todo #270
     * @public
     * @param {Number} coordinate - The coordinate in pixels.
     */
    Owl.prototype.animate = function (coordinate) {
        var animate = this.speed() > 0;

        this.is('animating') && this.onTransitionEnd();

        if (animate) {
            this.enter('animating');
            this.trigger('translate');
        }

        if ($.support.transform3d && $.support.transition) {
            this.$stage.css({
                transform: 'translate3d(' + coordinate + 'px,0px,0px)',
                transition: (this.speed() / 1000) + 's' + (
                    this.settings.slideTransition ? ' ' + this.settings.slideTransition : ''
                )
            });
        } else if (animate) {
            this.$stage.animate({
                left: coordinate + 'px'
            }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
        } else {
            this.$stage.css({
                left: coordinate + 'px'
            });
        }
    };

    /**
     * Checks whether the carousel is in a specific state or not.
     * @param {String} state - The state to check.
     * @returns {Boolean} - The flag which indicates if the carousel is busy.
     */
    Owl.prototype.is = function (state) {
        return this._states.current[state] && this._states.current[state] > 0;
    };

    /**
     * Sets the absolute position of the current item.
     * @public
     * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
     * @returns {Number} - The absolute position of the current item.
     */
    Owl.prototype.current = function (position) {
        if (position === undefined) {
            return this._current;
        }

        if (this._items.length === 0) {
            return undefined;
        }

        position = this.normalize(position);

        if (this._current !== position) {
            var event = this.trigger('change', {property: {name: 'position', value: position}});

            if (event.data !== undefined) {
                position = this.normalize(event.data);
            }

            this._current = position;

            this.invalidate('position');

            this.trigger('changed', {property: {name: 'position', value: this._current}});
        }

        return this._current;
    };

    /**
     * Invalidates the given part of the update routine.
     * @param {String} [part] - The part to invalidate.
     * @returns {Array.<String>} - The invalidated parts.
     */
    Owl.prototype.invalidate = function (part) {
        if ($.type(part) === 'string') {
            this._invalidated[part] = true;
            this.is('valid') && this.leave('valid');
        }
        return $.map(this._invalidated, function (v, i) {
            return i
        });
    };

    /**
     * Resets the absolute position of the current item.
     * @public
     * @param {Number} position - The absolute position of the new item.
     */
    Owl.prototype.reset = function (position) {
        position = this.normalize(position);

        if (position === undefined) {
            return;
        }

        this._speed = 0;
        this._current = position;

        this.suppress(['translate', 'translated']);

        this.animate(this.coordinates(position));

        this.release(['translate', 'translated']);
    };

    /**
     * Normalizes an absolute or a relative position of an item.
     * @public
     * @param {Number} position - The absolute or relative position to normalize.
     * @param {Boolean} [relative=false] - Whether the given position is relative or not.
     * @returns {Number} - The normalized position.
     */
    Owl.prototype.normalize = function (position, relative) {
        var n = this._items.length,
            m = relative ? 0 : this._clones.length;

        if (!this.isNumeric(position) || n < 1) {
            position = undefined;
        } else if (position < 0 || position >= n + m) {
            position = ((position - m / 2) % n + n) % n + m / 2;
        }

        return position;
    };

    /**
     * Converts an absolute position of an item into a relative one.
     * @public
     * @param {Number} position - The absolute position to convert.
     * @returns {Number} - The converted position.
     */
    Owl.prototype.relative = function (position) {
        position -= this._clones.length / 2;
        return this.normalize(position, true);
    };

    /**
     * Gets the maximum position for the current item.
     * @public
     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
     * @returns {Number}
     */
    Owl.prototype.maximum = function (relative) {
        var settings = this.settings,
            maximum = this._coordinates.length,
            iterator,
            reciprocalItemsWidth,
            elementWidth;

        if (settings.loop) {
            maximum = this._clones.length / 2 + this._items.length - 1;
        } else if (settings.autoWidth || settings.merge) {
            iterator = this._items.length;
            if (iterator) {
                reciprocalItemsWidth = this._items[--iterator].width();
                elementWidth = this.$element.width();
                while (iterator--) {
                    reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
                    if (reciprocalItemsWidth > elementWidth) {
                        break;
                    }
                }
            }
            maximum = iterator + 1;
        } else if (settings.center) {
            maximum = this._items.length - 1;
        } else {
            maximum = this._items.length - settings.items;
        }

        if (relative) {
            maximum -= this._clones.length / 2;
        }

        return Math.max(maximum, 0);
    };

    /**
     * Gets the minimum position for the current item.
     * @public
     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
     * @returns {Number}
     */
    Owl.prototype.minimum = function (relative) {
        return relative ? 0 : this._clones.length / 2;
    };

    /**
     * Gets an item at the specified relative position.
     * @public
     * @param {Number} [position] - The relative position of the item.
     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
     */
    Owl.prototype.items = function (position) {
        if (position === undefined) {
            return this._items.slice();
        }

        position = this.normalize(position, true);
        return this._items[position];
    };

    /**
     * Gets an item at the specified relative position.
     * @public
     * @param {Number} [position] - The relative position of the item.
     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
     */
    Owl.prototype.mergers = function (position) {
        if (position === undefined) {
            return this._mergers.slice();
        }

        position = this.normalize(position, true);
        return this._mergers[position];
    };

    /**
     * Gets the absolute positions of clones for an item.
     * @public
     * @param {Number} [position] - The relative position of the item.
     * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
     */
    Owl.prototype.clones = function (position) {
        var odd = this._clones.length / 2,
            even = odd + this._items.length,
            map = function (index) {
                return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2
            };

        if (position === undefined) {
            return $.map(this._clones, function (v, i) {
                return map(i)
            });
        }

        return $.map(this._clones, function (v, i) {
            return v === position ? map(i) : null
        });
    };

    /**
     * Sets the current animation speed.
     * @public
     * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
     * @returns {Number} - The current animation speed in milliseconds.
     */
    Owl.prototype.speed = function (speed) {
        if (speed !== undefined) {
            this._speed = speed;
        }

        return this._speed;
    };

    /**
     * Gets the coordinate of an item.
     * @todo The name of this method is missleanding.
     * @public
     * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
     * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
     */
    Owl.prototype.coordinates = function (position) {
        var multiplier = 1,
            newPosition = position - 1,
            coordinate;

        if (position === undefined) {
            return $.map(this._coordinates, $.proxy(function (coordinate, index) {
                return this.coordinates(index);
            }, this));
        }

        if (this.settings.center) {
            if (this.settings.rtl) {
                multiplier = -1;
                newPosition = position + 1;
            }

            coordinate = this._coordinates[position];
            coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
        } else {
            coordinate = this._coordinates[newPosition] || 0;
        }

        coordinate = Math.ceil(coordinate);

        return coordinate;
    };

    /**
     * Calculates the speed for a translation.
     * @protected
     * @param {Number} from - The absolute position of the start item.
     * @param {Number} to - The absolute position of the target item.
     * @param {Number} [factor=undefined] - The time factor in milliseconds.
     * @returns {Number} - The time in milliseconds for the translation.
     */
    Owl.prototype.duration = function (from, to, factor) {
        if (factor === 0) {
            return 0;
        }

        return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
    };

    /**
     * Slides to the specified item.
     * @public
     * @param {Number} position - The position of the item.
     * @param {Number} [speed] - The time in milliseconds for the transition.
     */
    Owl.prototype.to = function (position, speed) {
        var current = this.current(),
            revert = null,
            distance = position - this.relative(current),
            direction = (distance > 0) - (distance < 0),
            items = this._items.length,
            minimum = this.minimum(),
            maximum = this.maximum();

        if (this.settings.loop) {
            if (!this.settings.rewind && Math.abs(distance) > items / 2) {
                distance += direction * -1 * items;
            }

            position = current + distance;
            revert = ((position - minimum) % items + items) % items + minimum;

            if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
                current = revert - distance;
                position = revert;
                this.reset(current);
            }
        } else if (this.settings.rewind) {
            maximum += 1;
            position = (position % maximum + maximum) % maximum;
        } else {
            position = Math.max(minimum, Math.min(maximum, position));
        }

        this.speed(this.duration(current, position, speed));
        this.current(position);

        if (this.isVisible()) {
            this.update();
        }
    };

    /**
     * Slides to the next item.
     * @public
     * @param {Number} [speed] - The time in milliseconds for the transition.
     */
    Owl.prototype.next = function (speed) {
        speed = speed || false;
        this.to(this.relative(this.current()) + 1, speed);
    };

    /**
     * Slides to the previous item.
     * @public
     * @param {Number} [speed] - The time in milliseconds for the transition.
     */
    Owl.prototype.prev = function (speed) {
        speed = speed || false;
        this.to(this.relative(this.current()) - 1, speed);
    };

    /**
     * Handles the end of an animation.
     * @protected
     * @param {Event} event - The event arguments.
     */
    Owl.prototype.onTransitionEnd = function (event) {

        // if css2 animation then event object is undefined
        if (event !== undefined) {
            event.stopPropagation();

            // Catch only owl-stage transitionEnd event
            if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
                return false;
            }
        }

        this.leave('animating');
        this.trigger('translated');
    };

    /**
     * Gets viewport width.
     * @protected
     * @return {Number} - The width in pixel.
     */
    Owl.prototype.viewport = function () {
        var width;
        if (this.options.responsiveBaseElement !== window) {
            width = $(this.options.responsiveBaseElement).width();
        } else if (window.innerWidth) {
            width = window.innerWidth;
        } else if (document.documentElement && document.documentElement.clientWidth) {
            width = document.documentElement.clientWidth;
        } else {
            console.warn('Can not detect viewport width.');
        }
        return width;
    };

    /**
     * Replaces the current content.
     * @public
     * @param {HTMLElement|jQuery|String} content - The new content.
     */
    Owl.prototype.replace = function (content) {
        this.$stage.empty();
        this._items = [];

        if (content) {
            content = (content instanceof jQuery) ? content : $(content);
        }

        if (this.settings.nestedItemSelector) {
            content = content.find('.' + this.settings.nestedItemSelector);
        }

        content.filter(function () {
            return this.nodeType === 1;
        }).each($.proxy(function (index, item) {
            item = this.prepare(item);
            this.$stage.append(item);
            this._items.push(item);
            this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
        }, this));

        this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

        this.invalidate('items');
    };

    /**
     * Adds an item.
     * @todo Use `item` instead of `content` for the event arguments.
     * @public
     * @param {HTMLElement|jQuery|String} content - The item content to add.
     * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
     */
    Owl.prototype.add = function (content, position) {
        var current = this.relative(this._current);

        position = position === undefined ? this._items.length : this.normalize(position, true);
        content = content instanceof jQuery ? content : $(content);

        this.trigger('add', {content: content, position: position});

        content = this.prepare(content);

        if (this._items.length === 0 || position === this._items.length) {
            this._items.length === 0 && this.$stage.append(content);
            this._items.length !== 0 && this._items[position - 1].after(content);
            this._items.push(content);
            this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
        } else {
            this._items[position].before(content);
            this._items.splice(position, 0, content);
            this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
        }

        this._items[current] && this.reset(this._items[current].index());

        this.invalidate('items');

        this.trigger('added', {content: content, position: position});
    };

    /**
     * Removes an item by its position.
     * @todo Use `item` instead of `content` for the event arguments.
     * @public
     * @param {Number} position - The relative position of the item to remove.
     */
    Owl.prototype.remove = function (position) {
        position = this.normalize(position, true);

        if (position === undefined) {
            return;
        }

        this.trigger('remove', {content: this._items[position], position: position});

        this._items[position].remove();
        this._items.splice(position, 1);
        this._mergers.splice(position, 1);

        this.invalidate('items');

        this.trigger('removed', {content: null, position: position});
    };

    /**
     * Preloads images with auto width.
     * @todo Replace by a more generic approach
     * @protected
     */
    Owl.prototype.preloadAutoWidthImages = function (images) {
        images.each($.proxy(function (i, element) {
            this.enter('pre-loading');
            element = $(element);
            $(new Image()).one('load', $.proxy(function (e) {
                element.attr('src', e.target.src);
                element.css('opacity', 1);
                this.leave('pre-loading');
                !this.is('pre-loading') && !this.is('initializing') && this.refresh();
            }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
        }, this));
    };

    /**
     * Destroys the carousel.
     * @public
     */
    Owl.prototype.destroy = function () {

        this.$element.off('.owl.core');
        this.$stage.off('.owl.core');
        $(document).off('.owl.core');

        if (this.settings.responsive !== false) {
            window.clearTimeout(this.resizeTimer);
            this.off(window, 'resize', this._handlers.onThrottledResize);
        }

        for (var i in this._plugins) {
            this._plugins[i].destroy();
        }

        this.$stage.children('.cloned').remove();

        this.$stage.unwrap();
        this.$stage.children().contents().unwrap();
        this.$stage.children().unwrap();
        this.$stage.remove();
        this.$element
            .removeClass(this.options.refreshClass)
            .removeClass(this.options.loadingClass)
            .removeClass(this.options.loadedClass)
            .removeClass(this.options.rtlClass)
            .removeClass(this.options.dragClass)
            .removeClass(this.options.grabClass)
            .attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), ''))
            .removeData('owl.carousel');
    };

    /**
     * Operators to calculate right-to-left and left-to-right.
     * @protected
     * @param {Number} [a] - The left side operand.
     * @param {String} [o] - The operator.
     * @param {Number} [b] - The right side operand.
     */
    Owl.prototype.op = function (a, o, b) {
        var rtl = this.settings.rtl;
        switch (o) {
            case '<':
                return rtl ? a > b : a < b;
            case '>':
                return rtl ? a < b : a > b;
            case '>=':
                return rtl ? a <= b : a >= b;
            case '<=':
                return rtl ? a >= b : a <= b;
            default:
                break;
        }
    };

    /**
     * Attaches to an internal event.
     * @protected
     * @param {HTMLElement} element - The event source.
     * @param {String} event - The event name.
     * @param {Function} listener - The event handler to attach.
     * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
     */
    Owl.prototype.on = function (element, event, listener, capture) {
        if (element.addEventListener) {
            element.addEventListener(event, listener, capture);
        } else if (element.attachEvent) {
            element.attachEvent('on' + event, listener);
        }
    };

    /**
     * Detaches from an internal event.
     * @protected
     * @param {HTMLElement} element - The event source.
     * @param {String} event - The event name.
     * @param {Function} listener - The attached event handler to detach.
     * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
     */
    Owl.prototype.off = function (element, event, listener, capture) {
        if (element.removeEventListener) {
            element.removeEventListener(event, listener, capture);
        } else if (element.detachEvent) {
            element.detachEvent('on' + event, listener);
        }
    };

    /**
     * Triggers a public event.
     * @todo Remove `status`, `relatedTarget` should be used instead.
     * @protected
     * @param {String} name - The event name.
     * @param {*} [data=null] - The event data.
     * @param {String} [namespace=carousel] - The event namespace.
     * @param {String} [state] - The state which is associated with the event.
     * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
     * @returns {Event} - The event arguments.
     */
    Owl.prototype.trigger = function (name, data, namespace, state, enter) {
        var status = {
            item: {count: this._items.length, index: this.current()}
        }, handler = $.camelCase(
            $.grep(['on', name, namespace], function (v) {
                return v
            })
                .join('-').toLowerCase()
        ), event = $.Event(
            [name, 'owl', namespace || 'carousel'].join('.').toLowerCase(),
            $.extend({relatedTarget: this}, status, data)
        );

        if (!this._supress[name]) {
            $.each(this._plugins, function (name, plugin) {
                if (plugin.onTrigger) {
                    plugin.onTrigger(event);
                }
            });

            this.register({type: Owl.Type.Event, name: name});
            this.$element.trigger(event);

            if (this.settings && typeof this.settings[handler] === 'function') {
                this.settings[handler].call(this, event);
            }
        }

        return event;
    };

    /**
     * Enters a state.
     * @param name - The state name.
     */
    Owl.prototype.enter = function (name) {
        $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
            if (this._states.current[name] === undefined) {
                this._states.current[name] = 0;
            }

            this._states.current[name]++;
        }, this));
    };

    /**
     * Leaves a state.
     * @param name - The state name.
     */
    Owl.prototype.leave = function (name) {
        $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
            this._states.current[name]--;
        }, this));
    };

    /**
     * Registers an event or state.
     * @public
     * @param {Object} object - The event or state to register.
     */
    Owl.prototype.register = function (object) {
        if (object.type === Owl.Type.Event) {
            if (!$.event.special[object.name]) {
                $.event.special[object.name] = {};
            }

            if (!$.event.special[object.name].owl) {
                var _default = $.event.special[object.name]._default;
                $.event.special[object.name]._default = function (e) {
                    if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
                        return _default.apply(this, arguments);
                    }
                    return e.namespace && e.namespace.indexOf('owl') > -1;
                };
                $.event.special[object.name].owl = true;
            }
        } else if (object.type === Owl.Type.State) {
            if (!this._states.tags[object.name]) {
                this._states.tags[object.name] = object.tags;
            } else {
                this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
            }

            this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {
                return $.inArray(tag, this._states.tags[object.name]) === i;
            }, this));
        }
    };

    /**
     * Suppresses events.
     * @protected
     * @param {Array.<String>} events - The events to suppress.
     */
    Owl.prototype.suppress = function (events) {
        $.each(events, $.proxy(function (index, event) {
            this._supress[event] = true;
        }, this));
    };

    /**
     * Releases suppressed events.
     * @protected
     * @param {Array.<String>} events - The events to release.
     */
    Owl.prototype.release = function (events) {
        $.each(events, $.proxy(function (index, event) {
            delete this._supress[event];
        }, this));
    };

    /**
     * Gets unified pointer coordinates from event.
     * @todo #261
     * @protected
     * @param {Event} - The `mousedown` or `touchstart` event.
     * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
     */
    Owl.prototype.pointer = function (event) {
        var result = {x: null, y: null};

        event = event.originalEvent || event || window.event;

        event = event.touches && event.touches.length ?
            event.touches[0] : event.changedTouches && event.changedTouches.length ?
                event.changedTouches[0] : event;

        if (event.pageX) {
            result.x = event.pageX;
            result.y = event.pageY;
        } else {
            result.x = event.clientX;
            result.y = event.clientY;
        }

        return result;
    };

    /**
     * Determines if the input is a Number or something that can be coerced to a Number
     * @protected
     * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
     * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
     */
    Owl.prototype.isNumeric = function (number) {
        return !isNaN(parseFloat(number));
    };

    /**
     * Gets the difference of two vectors.
     * @todo #261
     * @protected
     * @param {Object} - The first vector.
     * @param {Object} - The second vector.
     * @returns {Object} - The difference.
     */
    Owl.prototype.difference = function (first, second) {
        return {
            x: first.x - second.x,
            y: first.y - second.y
        };
    };

    /**
     * The jQuery Plugin for the Owl Carousel
     * @todo Navigation plugin `next` and `prev`
     * @public
     */
    $.fn.owlCarousel = function (option) {
        var args = Array.prototype.slice.call(arguments, 1);

        return this.each(function () {
            var $this = $(this),
                data = $this.data('owl.carousel');

            if (!data) {
                data = new Owl(this, typeof option == 'object' && option);
                $this.data('owl.carousel', data);

                $.each([
                    'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'
                ], function (i, event) {
                    data.register({type: Owl.Type.Event, name: event});
                    data.$element.on(event + '.owl.carousel.core', $.proxy(function (e) {
                        if (e.namespace && e.relatedTarget !== this) {
                            this.suppress([event]);
                            data[event].apply(this, [].slice.call(arguments, 1));
                            this.release([event]);
                        }
                    }, data));
                });
            }

            if (typeof option == 'string' && option.charAt(0) !== '_') {
                data[option].apply(data, args);
            }
        });
    };

    /**
     * The constructor for the jQuery Plugin
     * @public
     */
    $.fn.owlCarousel.Constructor = Owl;

})(window.Zepto || window.jQuery, window, document);

/**
 * AutoRefresh Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {

    /**
     * Creates the auto refresh plugin.
     * @class The Auto Refresh Plugin
     * @param {Owl} carousel - The Owl Carousel
     */
    var AutoRefresh = function (carousel) {
        /**
         * Reference to the core.
         * @protected
         * @type {Owl}
         */
        this._core = carousel;

        /**
         * Refresh interval.
         * @protected
         * @type {number}
         */
        this._interval = null;

        /**
         * Whether the element is currently visible or not.
         * @protected
         * @type {Boolean}
         */
        this._visible = null;

        /**
         * All event handlers.
         * @protected
         * @type {Object}
         */
        this._handlers = {
            'initialized.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.autoRefresh) {
                    this.watch();
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);

        // register event handlers
        this._core.$element.on(this._handlers);
    };

    /**
     * Default options.
     * @public
     */
    AutoRefresh.Defaults = {
        autoRefresh: true,
        autoRefreshInterval: 500
    };

    /**
     * Watches the element.
     */
    AutoRefresh.prototype.watch = function () {
        if (this._interval) {
            return;
        }

        this._visible = this._core.isVisible();
        this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
    };

    /**
     * Refreshes the element.
     */
    AutoRefresh.prototype.refresh = function () {
        if (this._core.isVisible() === this._visible) {
            return;
        }

        this._visible = !this._visible;

        this._core.$element.toggleClass('owl-hidden', !this._visible);

        this._visible && (this._core.invalidate('width') && this._core.refresh());
    };

    /**
     * Destroys the plugin.
     */
    AutoRefresh.prototype.destroy = function () {
        var handler, property;

        window.clearInterval(this._interval);

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    };

    $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;

})(window.Zepto || window.jQuery, window, document);

/**
 * Lazy Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {

    /**
     * Creates the lazy plugin.
     * @class The Lazy Plugin
     * @param {Owl} carousel - The Owl Carousel
     */
    var Lazy = function (carousel) {

        /**
         * Reference to the core.
         * @protected
         * @type {Owl}
         */
        this._core = carousel;

        /**
         * Already loaded items.
         * @protected
         * @type {Array.<jQuery>}
         */
        this._loaded = [];

        /**
         * Event handlers.
         * @protected
         * @type {Object}
         */
        this._handlers = {
            'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function (e) {
                if (!e.namespace) {
                    return;
                }

                if (!this._core.settings || !this._core.settings.lazyLoad) {
                    return;
                }

                if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
                    var settings = this._core.settings,
                        n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
                        i = ((settings.center && n * -1) || 0),
                        position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
                        clones = this._core.clones().length,
                        load = $.proxy(function (i, v) {
                            this.load(v)
                        }, this);
                    //TODO: Need documentation for this new option
                    if (settings.lazyLoadEager > 0) {
                        n += settings.lazyLoadEager;
                        // If the carousel is looping also preload images that are to the "left"
                        if (settings.loop) {
                            position -= settings.lazyLoadEager;
                            n++;
                        }
                    }

                    while (i++ < n) {
                        this.load(clones / 2 + this._core.relative(position));
                        clones && $.each(this._core.clones(this._core.relative(position)), load);
                        position++;
                    }
                }
            }, this)
        };

        // set the default options
        this._core.options = $.extend({}, Lazy.Defaults, this._core.options);

        // register event handler
        this._core.$element.on(this._handlers);
    };

    /**
     * Default options.
     * @public
     */
    Lazy.Defaults = {
        lazyLoad: false,
        lazyLoadEager: 0
    };

    /**
     * Loads all resources of an item at the specified position.
     * @param {Number} position - The absolute position of the item.
     * @protected
     */
    Lazy.prototype.load = function (position) {
        var $item = this._core.$stage.children().eq(position),
            $elements = $item && $item.find('.owl-lazy');

        if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
            return;
        }

        $elements.each($.proxy(function (index, element) {
            var $element = $(element), image,
                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');

            this._core.trigger('load', {element: $element, url: url}, 'lazy');

            if ($element.is('img')) {
                $element.one('load.owl.lazy', $.proxy(function () {
                    $element.css('opacity', 1);
                    this._core.trigger('loaded', {element: $element, url: url}, 'lazy');
                }, this)).attr('src', url);
            } else if ($element.is('source')) {
                $element.one('load.owl.lazy', $.proxy(function () {
                    this._core.trigger('loaded', {element: $element, url: url}, 'lazy');
                }, this)).attr('srcset', url);
            } else {
                image = new Image();
                image.onload = $.proxy(function () {
                    $element.css({
                        'background-image': 'url("' + url + '")',
                        'opacity': '1'
                    });
                    this._core.trigger('loaded', {element: $element, url: url}, 'lazy');
                }, this);
                image.src = url;
            }
        }, this));

        this._loaded.push($item.get(0));
    };

    /**
     * Destroys the plugin.
     * @public
     */
    Lazy.prototype.destroy = function () {
        var handler, property;

        for (handler in this.handlers) {
            this._core.$element.off(handler, this.handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    };

    $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;

})(window.Zepto || window.jQuery, window, document);

/**
 * AutoHeight Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {

    /**
     * Creates the auto height plugin.
     * @class The Auto Height Plugin
     * @param {Owl} carousel - The Owl Carousel
     */
    var AutoHeight = function (carousel) {
        /**
         * Reference to the core.
         * @protected
         * @type {Owl}
         */
        this._core = carousel;

        this._previousHeight = null;

        /**
         * All event handlers.
         * @protected
         * @type {Object}
         */
        this._handlers = {
            'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.autoHeight) {
                    this.update();
                }
            }, this),
            'changed.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position') {
                    this.update();
                }
            }, this),
            'loaded.owl.lazy': $.proxy(function (e) {
                if (e.namespace && this._core.settings.autoHeight
                    && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
                    this.update();
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);

        // register event handlers
        this._core.$element.on(this._handlers);
        this._intervalId = null;
        var refThis = this;

        // These changes have been taken from a PR by gavrochelegnou proposed in #1575
        // and have been made compatible with the latest jQuery version
        $(window).on('load', function () {
            if (refThis._core.settings.autoHeight) {
                refThis.update();
            }
        });

        // Autoresize the height of the carousel when window is resized
        // When carousel has images, the height is dependent on the width
        // and should also change on resize
        $(window).resize(function () {
            if (refThis._core.settings.autoHeight) {
                if (refThis._intervalId != null) {
                    clearTimeout(refThis._intervalId);
                }

                refThis._intervalId = setTimeout(function () {
                    refThis.update();
                }, 250);
            }
        });

    };

    /**
     * Default options.
     * @public
     */
    AutoHeight.Defaults = {
        autoHeight: false,
        autoHeightClass: 'owl-height'
    };

    /**
     * Updates the view.
     */
    AutoHeight.prototype.update = function () {
        var start = this._core._current,
            end = start + this._core.settings.items,
            lazyLoadEnabled = this._core.settings.lazyLoad,
            visible = this._core.$stage.children().toArray().slice(start, end),
            heights = [],
            maxheight = 0;

        $.each(visible, function (index, item) {
            heights.push($(item).height());
        });

        maxheight = Math.max.apply(null, heights);

        if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
            maxheight = this._previousHeight;
        }

        this._previousHeight = maxheight;

        this._core.$stage.parent()
            .height(maxheight)
            .addClass(this._core.settings.autoHeightClass);
    };

    AutoHeight.prototype.destroy = function () {
        var handler, property;

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] !== 'function' && (this[property] = null);
        }
    };

    $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;

})(window.Zepto || window.jQuery, window, document);

/**
 * Video Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {

    /**
     * Creates the video plugin.
     * @class The Video Plugin
     * @param {Owl} carousel - The Owl Carousel
     */
    var Video = function (carousel) {
        /**
         * Reference to the core.
         * @protected
         * @type {Owl}
         */
        this._core = carousel;

        /**
         * Cache all video URLs.
         * @protected
         * @type {Object}
         */
        this._videos = {};

        /**
         * Current playing item.
         * @protected
         * @type {jQuery}
         */
        this._playing = null;

        /**
         * All event handlers.
         * @todo The cloned content removale is too late
         * @protected
         * @type {Object}
         */
        this._handlers = {
            'initialized.owl.carousel': $.proxy(function (e) {
                if (e.namespace) {
                    this._core.register({type: 'state', name: 'playing', tags: ['interacting']});
                }
            }, this),
            'resize.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
                    e.preventDefault();
                }
            }, this),
            'refreshed.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.is('resizing')) {
                    this._core.$stage.find('.cloned .owl-video-frame').remove();
                }
            }, this),
            'changed.owl.carousel': $.proxy(function (e) {
                if (e.namespace && e.property.name === 'position' && this._playing) {
                    this.stop();
                }
            }, this),
            'prepared.owl.carousel': $.proxy(function (e) {
                if (!e.namespace) {
                    return;
                }

                var $element = $(e.content).find('.owl-video');

                if ($element.length) {
                    $element.css('display', 'none');
                    this.fetch($element, $(e.content));
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, Video.Defaults, this._core.options);

        // register event handlers
        this._core.$element.on(this._handlers);

        this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function (e) {
            this.play(e);
        }, this));
    };

    /**
     * Default options.
     * @public
     */
    Video.Defaults = {
        video: false,
        videoHeight: false,
        videoWidth: false
    };

    /**
     * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
     * @protected
     * @param {jQuery} target - The target containing the video data.
     * @param {jQuery} item - The item containing the video.
     */
    Video.prototype.fetch = function (target, item) {
        var type = (function () {
                if (target.attr('data-vimeo-id')) {
                    return 'vimeo';
                } else if (target.attr('data-vzaar-id')) {
                    return 'vzaar'
                } else {
                    return 'youtube';
                }
            })(),
            id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
            width = target.attr('data-width') || this._core.settings.videoWidth,
            height = target.attr('data-height') || this._core.settings.videoHeight,
            url = target.attr('href');

        if (url) {

            /*
					Parses the id's out of the following urls (and probably more):
					https://www.youtube.com/watch?v=:id
					https://youtu.be/:id
					https://vimeo.com/:id
					https://vimeo.com/channels/:channel/:id
					https://vimeo.com/groups/:group/videos/:id
					https://app.vzaar.com/videos/:id

					Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
			*/

            id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

            if (id[3].indexOf('youtu') > -1) {
                type = 'youtube';
            } else if (id[3].indexOf('vimeo') > -1) {
                type = 'vimeo';
            } else if (id[3].indexOf('vzaar') > -1) {
                type = 'vzaar';
            } else {
                throw new Error('Video URL not supported.');
            }
            id = id[6];
        } else {
            throw new Error('Missing video URL.');
        }

        this._videos[url] = {
            type: type,
            id: id,
            width: width,
            height: height
        };

        item.attr('data-video', url);

        this.thumbnail(target, this._videos[url]);
    };

    /**
     * Creates video thumbnail.
     * @protected
     * @param {jQuery} target - The target containing the video data.
     * @param {Object} info - The video info object.
     * @see `fetch`
     */
    Video.prototype.thumbnail = function (target, video) {
        var tnLink,
            icon,
            path,
            dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',
            customTn = target.find('img'),
            srcType = 'src',
            lazyClass = '',
            settings = this._core.settings,
            create = function (path) {
                icon = '<div class="owl-video-play-icon"></div>';

                if (settings.lazyLoad) {
                    tnLink = $('<div/>', {
                        "class": 'owl-video-tn ' + lazyClass,
                        "srcType": path
                    });
                } else {
                    tnLink = $('<div/>', {
                        "class": "owl-video-tn",
                        "style": 'opacity:1;background-image:url(' + path + ')'
                    });
                }
                target.after(tnLink);
                target.after(icon);
            };

        // wrap video content into owl-video-wrapper div
        target.wrap($('<div/>', {
            "class": "owl-video-wrapper",
            "style": dimensions
        }));

        if (this._core.settings.lazyLoad) {
            srcType = 'data-src';
            lazyClass = 'owl-lazy';
        }

        // custom thumbnail
        if (customTn.length) {
            create(customTn.attr(srcType));
            customTn.remove();
            return false;
        }

        if (video.type === 'youtube') {
            path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
            create(path);
        } else if (video.type === 'vimeo') {
            $.ajax({
                type: 'GET',
                url: '//vimeo.com/api/v2/video/' + video.id + '.json',
                jsonp: 'callback',
                dataType: 'jsonp',
                success: function (data) {
                    path = data[0].thumbnail_large;
                    create(path);
                }
            });
        } else if (video.type === 'vzaar') {
            $.ajax({
                type: 'GET',
                url: '//vzaar.com/api/videos/' + video.id + '.json',
                jsonp: 'callback',
                dataType: 'jsonp',
                success: function (data) {
                    path = data.framegrab_url;
                    create(path);
                }
            });
        }
    };

    /**
     * Stops the current video.
     * @public
     */
    Video.prototype.stop = function () {
        this._core.trigger('stop', null, 'video');
        this._playing.find('.owl-video-frame').remove();
        this._playing.removeClass('owl-video-playing');
        this._playing = null;
        this._core.leave('playing');
        this._core.trigger('stopped', null, 'video');
    };

    /**
     * Starts the current video.
     * @public
     * @param {Event} event - The event arguments.
     */
    Video.prototype.play = function (event) {
        var target = $(event.target),
            item = target.closest('.' + this._core.settings.itemClass),
            video = this._videos[item.attr('data-video')],
            width = video.width || '100%',
            height = video.height || this._core.$stage.height(),
            html,
            iframe;

        if (this._playing) {
            return;
        }

        this._core.enter('playing');
        this._core.trigger('play', null, 'video');

        item = this._core.items(this._core.relative(item.index()));

        this._core.reset(item.index());

        html = $('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>');
        html.attr('height', height);
        html.attr('width', width);
        if (video.type === 'youtube') {
            html.attr('src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id);
        } else if (video.type === 'vimeo') {
            html.attr('src', '//player.vimeo.com/video/' + video.id + '?autoplay=1');
        } else if (video.type === 'vzaar') {
            html.attr('src', '//view.vzaar.com/' + video.id + '/player?autoplay=true');
        }

        iframe = $(html).wrap('<div class="owl-video-frame" />').insertAfter(item.find('.owl-video'));

        this._playing = item.addClass('owl-video-playing');
    };

    /**
     * Checks whether an video is currently in full screen mode or not.
     * @todo Bad style because looks like a readonly method but changes members.
     * @protected
     * @returns {Boolean}
     */
    Video.prototype.isInFullScreen = function () {
        var element = document.fullscreenElement || document.mozFullScreenElement ||
            document.webkitFullscreenElement;

        return element && $(element).parent().hasClass('owl-video-frame');
    };

    /**
     * Destroys the plugin.
     */
    Video.prototype.destroy = function () {
        var handler, property;

        this._core.$element.off('click.owl.video');

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    };

    $.fn.owlCarousel.Constructor.Plugins.Video = Video;

})(window.Zepto || window.jQuery, window, document);

/**
 * Animate Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {

    /**
     * Creates the animate plugin.
     * @class The Navigation Plugin
     * @param {Owl} scope - The Owl Carousel
     */
    var Animate = function (scope) {
        this.core = scope;
        this.core.options = $.extend({}, Animate.Defaults, this.core.options);
        this.swapping = true;
        this.previous = undefined;
        this.next = undefined;

        this.handlers = {
            'change.owl.carousel': $.proxy(function (e) {
                if (e.namespace && e.property.name == 'position') {
                    this.previous = this.core.current();
                    this.next = e.property.value;
                }
            }, this),
            'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function (e) {
                if (e.namespace) {
                    this.swapping = e.type == 'translated';
                }
            }, this),
            'translate.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
                    this.swap();
                }
            }, this)
        };

        this.core.$element.on(this.handlers);
    };

    /**
     * Default options.
     * @public
     */
    Animate.Defaults = {
        animateOut: false,
        animateIn: false
    };

    /**
     * Toggles the animation classes whenever an translations starts.
     * @protected
     * @returns {Boolean|undefined}
     */
    Animate.prototype.swap = function () {

        if (this.core.settings.items !== 1) {
            return;
        }

        if (!$.support.animation || !$.support.transition) {
            return;
        }

        this.core.speed(0);

        var left,
            clear = $.proxy(this.clear, this),
            previous = this.core.$stage.children().eq(this.previous),
            next = this.core.$stage.children().eq(this.next),
            incoming = this.core.settings.animateIn,
            outgoing = this.core.settings.animateOut;

        if (this.core.current() === this.previous) {
            return;
        }

        if (outgoing) {
            left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
            previous.one($.support.animation.end, clear)
                .css({'left': left + 'px'})
                .addClass('animated owl-animated-out')
                .addClass(outgoing);
        }

        if (incoming) {
            next.one($.support.animation.end, clear)
                .addClass('animated owl-animated-in')
                .addClass(incoming);
        }
    };

    Animate.prototype.clear = function (e) {
        $(e.target).css({'left': ''})
            .removeClass('animated owl-animated-out owl-animated-in')
            .removeClass(this.core.settings.animateIn)
            .removeClass(this.core.settings.animateOut);
        this.core.onTransitionEnd();
    };

    /**
     * Destroys the plugin.
     * @public
     */
    Animate.prototype.destroy = function () {
        var handler, property;

        for (handler in this.handlers) {
            this.core.$element.off(handler, this.handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    };

    $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;

})(window.Zepto || window.jQuery, window, document);

/**
 * Autoplay Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author Artus Kolanowski
 * @author David Deutsch
 * @author Tom De Caluwé
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {

    /**
     * Creates the autoplay plugin.
     * @class The Autoplay Plugin
     * @param {Owl} scope - The Owl Carousel
     */
    var Autoplay = function (carousel) {
        /**
         * Reference to the core.
         * @protected
         * @type {Owl}
         */
        this._core = carousel;

        /**
         * The autoplay timeout id.
         * @type {Number}
         */
        this._call = null;

        /**
         * Depending on the state of the plugin, this variable contains either
         * the start time of the timer or the current timer value if it's
         * paused. Since we start in a paused state we initialize the timer
         * value.
         * @type {Number}
         */
        this._time = 0;

        /**
         * Stores the timeout currently used.
         * @type {Number}
         */
        this._timeout = 0;

        /**
         * Indicates whenever the autoplay is paused.
         * @type {Boolean}
         */
        this._paused = true;

        /**
         * All event handlers.
         * @protected
         * @type {Object}
         */
        this._handlers = {
            'changed.owl.carousel': $.proxy(function (e) {
                if (e.namespace && e.property.name === 'settings') {
                    if (this._core.settings.autoplay) {
                        this.play();
                    } else {
                        this.stop();
                    }
                } else if (e.namespace && e.property.name === 'position' && this._paused) {
                    // Reset the timer. This code is triggered when the position
                    // of the carousel was changed through user interaction.
                    this._time = 0;
                }
            }, this),
            'initialized.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.autoplay) {
                    this.play();
                }
            }, this),
            'play.owl.autoplay': $.proxy(function (e, t, s) {
                if (e.namespace) {
                    this.play(t, s);
                }
            }, this),
            'stop.owl.autoplay': $.proxy(function (e) {
                if (e.namespace) {
                    this.stop();
                }
            }, this),
            'mouseover.owl.autoplay': $.proxy(function () {
                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                    this.pause();
                }
            }, this),
            'mouseleave.owl.autoplay': $.proxy(function () {
                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                    this.play();
                }
            }, this),
            'touchstart.owl.core': $.proxy(function () {
                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                    this.pause();
                }
            }, this),
            'touchend.owl.core': $.proxy(function () {
                if (this._core.settings.autoplayHoverPause) {
                    this.play();
                }
            }, this)
        };

        // register event handlers
        this._core.$element.on(this._handlers);

        // set default options
        this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
    };

    /**
     * Default options.
     * @public
     */
    Autoplay.Defaults = {
        autoplay: false,
        autoplayTimeout: 5000,
        autoplayHoverPause: false,
        autoplaySpeed: false
    };

    /**
     * Transition to the next slide and set a timeout for the next transition.
     * @private
     * @param {Number} [speed] - The animation speed for the animations.
     */
    Autoplay.prototype._next = function (speed) {
        this._call = window.setTimeout(
            $.proxy(this._next, this, speed),
            this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()
        );

        if (this._core.is('interacting') || document.hidden) {
            return;
        }
        this._core.next(speed || this._core.settings.autoplaySpeed);
    }

    /**
     * Reads the current timer value when the timer is playing.
     * @public
     */
    Autoplay.prototype.read = function () {
        return new Date().getTime() - this._time;
    };

    /**
     * Starts the autoplay.
     * @public
     * @param {Number} [timeout] - The interval before the next animation starts.
     * @param {Number} [speed] - The animation speed for the animations.
     */
    Autoplay.prototype.play = function (timeout, speed) {
        var elapsed;

        if (!this._core.is('rotating')) {
            this._core.enter('rotating');
        }

        timeout = timeout || this._core.settings.autoplayTimeout;

        // Calculate the elapsed time since the last transition. If the carousel
        // wasn't playing this calculation will yield zero.
        elapsed = Math.min(this._time % (this._timeout || timeout), timeout);

        if (this._paused) {
            // Start the clock.
            this._time = this.read();
            this._paused = false;
        } else {
            // Clear the active timeout to allow replacement.
            window.clearTimeout(this._call);
        }

        // Adjust the origin of the timer to match the new timeout value.
        this._time += this.read() % timeout - elapsed;

        this._timeout = timeout;
        this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);
    };

    /**
     * Stops the autoplay.
     * @public
     */
    Autoplay.prototype.stop = function () {
        if (this._core.is('rotating')) {
            // Reset the clock.
            this._time = 0;
            this._paused = true;

            window.clearTimeout(this._call);
            this._core.leave('rotating');
        }
    };

    /**
     * Pauses the autoplay.
     * @public
     */
    Autoplay.prototype.pause = function () {
        if (this._core.is('rotating') && !this._paused) {
            // Pause the clock.
            this._time = this.read();
            this._paused = true;

            window.clearTimeout(this._call);
        }
    };

    /**
     * Destroys the plugin.
     */
    Autoplay.prototype.destroy = function () {
        var handler, property;

        this.stop();

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    };

    $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

})(window.Zepto || window.jQuery, window, document);

/**
 * Navigation Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {
    'use strict';

    /**
     * Creates the navigation plugin.
     * @class The Navigation Plugin
     * @param {Owl} carousel - The Owl Carousel.
     */
    var Navigation = function (carousel) {
        /**
         * Reference to the core.
         * @protected
         * @type {Owl}
         */
        this._core = carousel;

        /**
         * Indicates whether the plugin is initialized or not.
         * @protected
         * @type {Boolean}
         */
        this._initialized = false;

        /**
         * The current paging indexes.
         * @protected
         * @type {Array}
         */
        this._pages = [];

        /**
         * All DOM elements of the user interface.
         * @protected
         * @type {Object}
         */
        this._controls = {};

        /**
         * Markup for an indicator.
         * @protected
         * @type {Array.<String>}
         */
        this._templates = [];

        /**
         * The carousel element.
         * @type {jQuery}
         */
        this.$element = this._core.$element;

        /**
         * Overridden methods of the carousel.
         * @protected
         * @type {Object}
         */
        this._overrides = {
            next: this._core.next,
            prev: this._core.prev,
            to: this._core.to
        };

        /**
         * All event handlers.
         * @protected
         * @type {Object}
         */
        this._handlers = {
            'prepared.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.dotsData) {
                    this._templates.push('<div class="' + this._core.settings.dotClass + '">' +
                        $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
                }
            }, this),
            'added.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.dotsData) {
                    this._templates.splice(e.position, 0, this._templates.pop());
                }
            }, this),
            'remove.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.dotsData) {
                    this._templates.splice(e.position, 1);
                }
            }, this),
            'changed.owl.carousel': $.proxy(function (e) {
                if (e.namespace && e.property.name == 'position') {
                    this.draw();
                }
            }, this),
            'initialized.owl.carousel': $.proxy(function (e) {
                if (e.namespace && !this._initialized) {
                    this._core.trigger('initialize', null, 'navigation');
                    this.initialize();
                    this.update();
                    this.draw();
                    this._initialized = true;
                    this._core.trigger('initialized', null, 'navigation');
                }
            }, this),
            'refreshed.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._initialized) {
                    this._core.trigger('refresh', null, 'navigation');
                    this.update();
                    this.draw();
                    this._core.trigger('refreshed', null, 'navigation');
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, Navigation.Defaults, this._core.options);

        // register event handlers
        this.$element.on(this._handlers);
    };

    /**
     * Default options.
     * @public
     * @todo Rename `slideBy` to `navBy`
     */
    Navigation.Defaults = {
        nav: false,
        navText: [
            '<span aria-label="' + 'Previous' + '">&#x2039;</span>',
            '<span aria-label="' + 'Next' + '">&#x203a;</span>'
        ],
        navSpeed: false,
        navElement: 'button type="button" role="presentation"',
        navContainer: false,
        navContainerClass: 'owl-nav',
        navClass: [
            'owl-prev',
            'owl-next'
        ],
        slideBy: 1,
        dotClass: 'owl-dot',
        dotsClass: 'owl-dots',
        dots: true,
        dotsEach: false,
        dotsData: false,
        dotsSpeed: false,
        dotsContainer: false
    };

    /**
     * Initializes the layout of the plugin and extends the carousel.
     * @protected
     */
    Navigation.prototype.initialize = function () {
        var override,
            settings = this._core.settings;

        // create DOM structure for relative navigation
        this._controls.$relative = (settings.navContainer ? $(settings.navContainer)
            : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');

        this._controls.$previous = $('<' + settings.navElement + '>')
            .addClass(settings.navClass[0])
            .html(settings.navText[0])
            .prependTo(this._controls.$relative)
            .on('click', $.proxy(function (e) {
                this.prev(settings.navSpeed);
            }, this));
        this._controls.$next = $('<' + settings.navElement + '>')
            .addClass(settings.navClass[1])
            .html(settings.navText[1])
            .appendTo(this._controls.$relative)
            .on('click', $.proxy(function (e) {
                this.next(settings.navSpeed);
            }, this));

        // create DOM structure for absolute navigation
        if (!settings.dotsData) {
            this._templates = [$('<button role="button">')
                .addClass(settings.dotClass)
                .append($('<span>'))
                .prop('outerHTML')];
        }

        this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)
            : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

        this._controls.$absolute.on('click', 'button', $.proxy(function (e) {
            var index = $(e.target).parent().is(this._controls.$absolute)
                ? $(e.target).index() : $(e.target).parent().index();

            e.preventDefault();

            this.to(index, settings.dotsSpeed);
        }, this));

        /*$el.on('focusin', function() {
			$(document).off(".carousel");

			$(document).on('keydown.carousel', function(e) {
				if(e.keyCode == 37) {
					$el.trigger('prev.owl')
				}
				if(e.keyCode == 39) {
					$el.trigger('next.owl')
				}
			});
		});*/

        // override public methods of the carousel
        for (override in this._overrides) {
            this._core[override] = $.proxy(this[override], this);
        }
    };

    /**
     * Destroys the plugin.
     * @protected
     */
    Navigation.prototype.destroy = function () {
        var handler, control, property, override, settings;
        settings = this._core.settings;

        for (handler in this._handlers) {
            this.$element.off(handler, this._handlers[handler]);
        }
        for (control in this._controls) {
            if (control === '$relative' && settings.navContainer) {
                this._controls[control].html('');
            } else {
                this._controls[control].remove();
            }
        }
        for (override in this.overides) {
            this._core[override] = this._overrides[override];
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    };

    /**
     * Updates the internal state.
     * @protected
     */
    Navigation.prototype.update = function () {
        var i, j, k,
            lower = this._core.clones().length / 2,
            upper = lower + this._core.items().length,
            maximum = this._core.maximum(true),
            settings = this._core.settings,
            size = settings.center || settings.autoWidth || settings.dotsData
                ? 1 : settings.dotsEach || settings.items;

        if (settings.slideBy !== 'page') {
            settings.slideBy = Math.min(settings.slideBy, settings.items);
        }

        if (settings.dots || settings.slideBy == 'page') {
            this._pages = [];

            for (i = lower, j = 0, k = 0; i < upper; i++) {
                if (j >= size || j === 0) {
                    this._pages.push({
                        start: Math.min(maximum, i - lower),
                        end: i - lower + size - 1
                    });
                    if (Math.min(maximum, i - lower) === maximum) {
                        break;
                    }
                    j = 0, ++k;
                }
                j += this._core.mergers(this._core.relative(i));
            }
        }
    };

    /**
     * Draws the user interface.
     * @todo The option `dotsData` wont work.
     * @protected
     */
    Navigation.prototype.draw = function () {
        var difference,
            settings = this._core.settings,
            disabled = this._core.items().length <= settings.items,
            index = this._core.relative(this._core.current()),
            loop = settings.loop || settings.rewind;

        this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

        if (settings.nav) {
            this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
            this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
        }

        this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

        if (settings.dots) {
            difference = this._pages.length - this._controls.$absolute.children().length;

            if (settings.dotsData && difference !== 0) {
                this._controls.$absolute.html(this._templates.join(''));
            } else if (difference > 0) {
                this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
            } else if (difference < 0) {
                this._controls.$absolute.children().slice(difference).remove();
            }

            this._controls.$absolute.find('.active').removeClass('active');
            this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
        }
    };

    /**
     * Extends event data.
     * @protected
     * @param {Event} event - The event object which gets thrown.
     */
    Navigation.prototype.onTrigger = function (event) {
        var settings = this._core.settings;

        event.page = {
            index: $.inArray(this.current(), this._pages),
            count: this._pages.length,
            size: settings && (settings.center || settings.autoWidth || settings.dotsData
                ? 1 : settings.dotsEach || settings.items)
        };
    };

    /**
     * Gets the current page position of the carousel.
     * @protected
     * @returns {Number}
     */
    Navigation.prototype.current = function () {
        var current = this._core.relative(this._core.current());
        return $.grep(this._pages, $.proxy(function (page, index) {
            return page.start <= current && page.end >= current;
        }, this)).pop();
    };

    /**
     * Gets the current succesor/predecessor position.
     * @protected
     * @returns {Number}
     */
    Navigation.prototype.getPosition = function (successor) {
        var position, length,
            settings = this._core.settings;

        if (settings.slideBy == 'page') {
            position = $.inArray(this.current(), this._pages);
            length = this._pages.length;
            successor ? ++position : --position;
            position = this._pages[((position % length) + length) % length].start;
        } else {
            position = this._core.relative(this._core.current());
            length = this._core.items().length;
            successor ? position += settings.slideBy : position -= settings.slideBy;
        }

        return position;
    };

    /**
     * Slides to the next item or page.
     * @public
     * @param {Number} [speed=false] - The time in milliseconds for the transition.
     */
    Navigation.prototype.next = function (speed) {
        $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
    };

    /**
     * Slides to the previous item or page.
     * @public
     * @param {Number} [speed=false] - The time in milliseconds for the transition.
     */
    Navigation.prototype.prev = function (speed) {
        $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
    };

    /**
     * Slides to the specified item or page.
     * @public
     * @param {Number} position - The position of the item or page.
     * @param {Number} [speed] - The time in milliseconds for the transition.
     * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
     */
    Navigation.prototype.to = function (position, speed, standard) {
        var length;

        if (!standard && this._pages.length) {
            length = this._pages.length;
            $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
        } else {
            $.proxy(this._overrides.to, this._core)(position, speed);
        }
    };

    $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;

})(window.Zepto || window.jQuery, window, document);

/**
 * Hash Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {
    'use strict';

    /**
     * Creates the hash plugin.
     * @class The Hash Plugin
     * @param {Owl} carousel - The Owl Carousel
     */
    var Hash = function (carousel) {
        /**
         * Reference to the core.
         * @protected
         * @type {Owl}
         */
        this._core = carousel;

        /**
         * Hash index for the items.
         * @protected
         * @type {Object}
         */
        this._hashes = {};

        /**
         * The carousel element.
         * @type {jQuery}
         */
        this.$element = this._core.$element;

        /**
         * All event handlers.
         * @protected
         * @type {Object}
         */
        this._handlers = {
            'initialized.owl.carousel': $.proxy(function (e) {
                if (e.namespace && this._core.settings.startPosition === 'URLHash') {
                    $(window).trigger('hashchange.owl.navigation');
                }
            }, this),
            'prepared.owl.carousel': $.proxy(function (e) {
                if (e.namespace) {
                    var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

                    if (!hash) {
                        return;
                    }

                    this._hashes[hash] = e.content;
                }
            }, this),
            'changed.owl.carousel': $.proxy(function (e) {
                if (e.namespace && e.property.name === 'position') {
                    var current = this._core.items(this._core.relative(this._core.current())),
                        hash = $.map(this._hashes, function (item, hash) {
                            return item === current ? hash : null;
                        }).join();

                    if (!hash || window.location.hash.slice(1) === hash) {
                        return;
                    }

                    window.location.hash = hash;
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, Hash.Defaults, this._core.options);

        // register the event handlers
        this.$element.on(this._handlers);

        // register event listener for hash navigation
        $(window).on('hashchange.owl.navigation', $.proxy(function (e) {
            var hash = window.location.hash.substring(1),
                items = this._core.$stage.children(),
                position = this._hashes[hash] && items.index(this._hashes[hash]);

            if (position === undefined || position === this._core.current()) {
                return;
            }

            this._core.to(this._core.relative(position), false, true);
        }, this));
    };

    /**
     * Default options.
     * @public
     */
    Hash.Defaults = {
        URLhashListener: false
    };

    /**
     * Destroys the plugin.
     * @public
     */
    Hash.prototype.destroy = function () {
        var handler, property;

        $(window).off('hashchange.owl.navigation');

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    };

    $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;

})(window.Zepto || window.jQuery, window, document);

/**
 * Support Plugin
 *
 * @version 2.3.4
 * @author Vivid Planet Software GmbH
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function ($, window, document, undefined) {

    var style = $('<support>').get(0).style,
        prefixes = 'Webkit Moz O ms'.split(' '),
        events = {
            transition: {
                end: {
                    WebkitTransition: 'webkitTransitionEnd',
                    MozTransition: 'transitionend',
                    OTransition: 'oTransitionEnd',
                    transition: 'transitionend'
                }
            },
            animation: {
                end: {
                    WebkitAnimation: 'webkitAnimationEnd',
                    MozAnimation: 'animationend',
                    OAnimation: 'oAnimationEnd',
                    animation: 'animationend'
                }
            }
        },
        tests = {
            csstransforms: function () {
                return !!test('transform');
            },
            csstransforms3d: function () {
                return !!test('perspective');
            },
            csstransitions: function () {
                return !!test('transition');
            },
            cssanimations: function () {
                return !!test('animation');
            }
        };

    function test(property, prefixed) {
        var result = false,
            upper = property.charAt(0).toUpperCase() + property.slice(1);

        $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function (i, property) {
            if (style[property] !== undefined) {
                result = prefixed ? property : true;
                return false;
            }
        });

        return result;
    }

    function prefixed(property) {
        return test(property, true);
    }

    if (tests.csstransitions()) {
        /* jshint -W053 */
        $.support.transition = new String(prefixed('transition'))
        $.support.transition.end = events.transition.end[$.support.transition];
    }

    if (tests.cssanimations()) {
        /* jshint -W053 */
        $.support.animation = new String(prefixed('animation'))
        $.support.animation.end = events.animation.end[$.support.animation];
    }

    if (tests.csstransforms()) {
        /* jshint -W053 */
        $.support.transform = new String(prefixed('transform'));
        $.support.transform3d = tests.csstransforms3d();
    }

})(window.Zepto || window.jQuery, window, document);

/*!
	autosize 4.0.2
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define(['module', 'exports'], factory);
    } else if (typeof exports !== "undefined") {
        factory(module, exports);
    } else {
        var mod = {
            exports: {}
        };
        factory(mod, mod.exports);
        global.autosize = mod.exports;
    }
})(this, function (module, exports) {
    'use strict';

    var map = typeof Map === "function" ? new Map() : function () {
        var keys = [];
        var values = [];

        return {
            has: function has(key) {
                return keys.indexOf(key) > -1;
            },
            get: function get(key) {
                return values[keys.indexOf(key)];
            },
            set: function set(key, value) {
                if (keys.indexOf(key) === -1) {
                    keys.push(key);
                    values.push(value);
                }
            },
            delete: function _delete(key) {
                var index = keys.indexOf(key);
                if (index > -1) {
                    keys.splice(index, 1);
                    values.splice(index, 1);
                }
            }
        };
    }();

    var createEvent = function createEvent(name) {
        return new Event(name, {bubbles: true});
    };
    try {
        new Event('test');
    } catch (e) {
        // IE does not support `new Event()`
        createEvent = function createEvent(name) {
            var evt = document.createEvent('Event');
            evt.initEvent(name, true, false);
            return evt;
        };
    }

    function assign(ta) {
        if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

        var heightOffset = null;
        var clientWidth = null;
        var cachedHeight = null;

        function init() {
            var style = window.getComputedStyle(ta, null);

            if (style.resize === 'vertical') {
                ta.style.resize = 'none';
            } else if (style.resize === 'both') {
                ta.style.resize = 'horizontal';
            }

            if (style.boxSizing === 'content-box') {
                heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
            } else {
                heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
            }
            // Fix when a textarea is not on document body and heightOffset is Not a Number
            if (isNaN(heightOffset)) {
                heightOffset = 0;
            }

            update();
        }

        function changeOverflow(value) {
            {
                // Chrome/Safari-specific fix:
                // When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
                // made available by removing the scrollbar. The following forces the necessary text reflow.
                var width = ta.style.width;
                ta.style.width = '0px';
                // Force reflow:
                /* jshint ignore:start */
                ta.offsetWidth;
                /* jshint ignore:end */
                ta.style.width = width;
            }

            ta.style.overflowY = value;
        }

        function getParentOverflows(el) {
            var arr = [];

            while (el && el.parentNode && el.parentNode instanceof Element) {
                if (el.parentNode.scrollTop) {
                    arr.push({
                        node: el.parentNode,
                        scrollTop: el.parentNode.scrollTop
                    });
                }
                el = el.parentNode;
            }

            return arr;
        }

        function resize() {
            if (ta.scrollHeight === 0) {
                // If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
                return;
            }

            var overflows = getParentOverflows(ta);
            var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

            ta.style.height = '';
            ta.style.height = ta.scrollHeight + heightOffset + 'px';

            // used to check if an update is actually necessary on window.resize
            clientWidth = ta.clientWidth;

            // prevents scroll-position jumping
            overflows.forEach(function (el) {
                el.node.scrollTop = el.scrollTop;
            });

            if (docTop) {
                document.documentElement.scrollTop = docTop;
            }
        }

        function update() {
            resize();

            var styleHeight = Math.round(parseFloat(ta.style.height));
            var computed = window.getComputedStyle(ta, null);

            // Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
            var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

            // The actual height not matching the style height (set via the resize method) indicates that
            // the max-height has been exceeded, in which case the overflow should be allowed.
            if (actualHeight < styleHeight) {
                if (computed.overflowY === 'hidden') {
                    changeOverflow('scroll');
                    resize();
                    actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
                }
            } else {
                // Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
                if (computed.overflowY !== 'hidden') {
                    changeOverflow('hidden');
                    resize();
                    actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
                }
            }

            if (cachedHeight !== actualHeight) {
                cachedHeight = actualHeight;
                var evt = createEvent('autosize:resized');
                try {
                    ta.dispatchEvent(evt);
                } catch (err) {
                    // Firefox will throw an error on dispatchEvent for a detached element
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=889376
                }
            }
        }

        var pageResize = function pageResize() {
            if (ta.clientWidth !== clientWidth) {
                update();
            }
        };

        var destroy = function (style) {
            window.removeEventListener('resize', pageResize, false);
            ta.removeEventListener('input', update, false);
            ta.removeEventListener('keyup', update, false);
            ta.removeEventListener('autosize:destroy', destroy, false);
            ta.removeEventListener('autosize:update', update, false);

            Object.keys(style).forEach(function (key) {
                ta.style[key] = style[key];
            });

            map.delete(ta);
        }.bind(ta, {
            height: ta.style.height,
            resize: ta.style.resize,
            overflowY: ta.style.overflowY,
            overflowX: ta.style.overflowX,
            wordWrap: ta.style.wordWrap
        });

        ta.addEventListener('autosize:destroy', destroy, false);

        // IE9 does not fire onpropertychange or oninput for deletions,
        // so binding to onkeyup to catch most of those events.
        // There is no way that I know of to detect something like 'cut' in IE9.
        if ('onpropertychange' in ta && 'oninput' in ta) {
            ta.addEventListener('keyup', update, false);
        }

        window.addEventListener('resize', pageResize, false);
        ta.addEventListener('input', update, false);
        ta.addEventListener('autosize:update', update, false);
        ta.style.overflowX = 'hidden';
        ta.style.wordWrap = 'break-word';

        map.set(ta, {
            destroy: destroy,
            update: update
        });

        init();
    }

    function destroy(ta) {
        var methods = map.get(ta);
        if (methods) {
            methods.destroy();
        }
    }

    function update(ta) {
        var methods = map.get(ta);
        if (methods) {
            methods.update();
        }
    }

    var autosize = null;

    // Do nothing in Node.js environment and IE8 (or lower)
    if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
        autosize = function autosize(el) {
            return el;
        };
        autosize.destroy = function (el) {
            return el;
        };
        autosize.update = function (el) {
            return el;
        };
    } else {
        autosize = function autosize(el, options) {
            if (el) {
                Array.prototype.forEach.call(el.length ? el : [el], function (x) {
                    return assign(x, options);
                });
            }
            return el;
        };
        autosize.destroy = function (el) {
            if (el) {
                Array.prototype.forEach.call(el.length ? el : [el], destroy);
            }
            return el;
        };
        autosize.update = function (el) {
            if (el) {
                Array.prototype.forEach.call(el.length ? el : [el], update);
            }
            return el;
        };
    }

    exports.default = autosize;
    module.exports = exports['default'];
});
/*!
 * clipboard.js v1.7.1
 * https://zenorocha.github.io/clipboard.js
 *
 * Licensed MIT © Zeno Rocha
 */
!function (t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else {
        var e;
        e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, e.Clipboard = t()
    }
}(function () {
    var t, e, n;
    return function t(e, n, o) {
        function i(a, c) {
            if (!n[a]) {
                if (!e[a]) {
                    var l = "function" == typeof require && require;
                    if (!c && l) return l(a, !0);
                    if (r) return r(a, !0);
                    var s = new Error("Cannot find module '" + a + "'");
                    throw s.code = "MODULE_NOT_FOUND", s
                }
                var u = n[a] = {exports: {}};
                e[a][0].call(u.exports, function (t) {
                    var n = e[a][1][t];
                    return i(n || t)
                }, u, u.exports, t, e, n, o)
            }
            return n[a].exports
        }

        for (var r = "function" == typeof require && require, a = 0; a < o.length; a++) i(o[a]);
        return i
    }({
        1: [function (t, e, n) {
            function o(t, e) {
                for (; t && t.nodeType !== i;) {
                    if ("function" == typeof t.matches && t.matches(e)) return t;
                    t = t.parentNode
                }
            }

            var i = 9;
            if ("undefined" != typeof Element && !Element.prototype.matches) {
                var r = Element.prototype;
                r.matches = r.matchesSelector || r.mozMatchesSelector || r.msMatchesSelector || r.oMatchesSelector || r.webkitMatchesSelector
            }
            e.exports = o
        }, {}], 2: [function (t, e, n) {
            function o(t, e, n, o, r) {
                var a = i.apply(this, arguments);
                return t.addEventListener(n, a, r), {
                    destroy: function () {
                        t.removeEventListener(n, a, r)
                    }
                }
            }

            function i(t, e, n, o) {
                return function (n) {
                    n.delegateTarget = r(n.target, e), n.delegateTarget && o.call(t, n)
                }
            }

            var r = t("./closest");
            e.exports = o
        }, {"./closest": 1}], 3: [function (t, e, n) {
            n.node = function (t) {
                return void 0 !== t && t instanceof HTMLElement && 1 === t.nodeType
            }, n.nodeList = function (t) {
                var e = Object.prototype.toString.call(t);
                return void 0 !== t && ("[object NodeList]" === e || "[object HTMLCollection]" === e) && "length" in t && (0 === t.length || n.node(t[0]))
            }, n.string = function (t) {
                return "string" == typeof t || t instanceof String
            }, n.fn = function (t) {
                return "[object Function]" === Object.prototype.toString.call(t)
            }
        }, {}], 4: [function (t, e, n) {
            function o(t, e, n) {
                if (!t && !e && !n) throw new Error("Missing required arguments");
                if (!c.string(e)) throw new TypeError("Second argument must be a String");
                if (!c.fn(n)) throw new TypeError("Third argument must be a Function");
                if (c.node(t)) return i(t, e, n);
                if (c.nodeList(t)) return r(t, e, n);
                if (c.string(t)) return a(t, e, n);
                throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList")
            }

            function i(t, e, n) {
                return t.addEventListener(e, n), {
                    destroy: function () {
                        t.removeEventListener(e, n)
                    }
                }
            }

            function r(t, e, n) {
                return Array.prototype.forEach.call(t, function (t) {
                    t.addEventListener(e, n)
                }), {
                    destroy: function () {
                        Array.prototype.forEach.call(t, function (t) {
                            t.removeEventListener(e, n)
                        })
                    }
                }
            }

            function a(t, e, n) {
                return l(document.body, t, e, n)
            }

            var c = t("./is"), l = t("delegate");
            e.exports = o
        }, {"./is": 3, delegate: 2}], 5: [function (t, e, n) {
            function o(t) {
                var e;
                if ("SELECT" === t.nodeName) t.focus(), e = t.value; else if ("INPUT" === t.nodeName || "TEXTAREA" === t.nodeName) {
                    var n = t.hasAttribute("readonly");
                    n || t.setAttribute("readonly", ""), t.select(), t.setSelectionRange(0, t.value.length), n || t.removeAttribute("readonly"), e = t.value
                } else {
                    t.hasAttribute("contenteditable") && t.focus();
                    var o = window.getSelection(), i = document.createRange();
                    i.selectNodeContents(t), o.removeAllRanges(), o.addRange(i), e = o.toString()
                }
                return e
            }

            e.exports = o
        }, {}], 6: [function (t, e, n) {
            function o() {
            }

            o.prototype = {
                on: function (t, e, n) {
                    var o = this.e || (this.e = {});
                    return (o[t] || (o[t] = [])).push({fn: e, ctx: n}), this
                }, once: function (t, e, n) {
                    function o() {
                        i.off(t, o), e.apply(n, arguments)
                    }

                    var i = this;
                    return o._ = e, this.on(t, o, n)
                }, emit: function (t) {
                    var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), o = 0,
                        i = n.length;
                    for (o; o < i; o++) n[o].fn.apply(n[o].ctx, e);
                    return this
                }, off: function (t, e) {
                    var n = this.e || (this.e = {}), o = n[t], i = [];
                    if (o && e) for (var r = 0, a = o.length; r < a; r++) o[r].fn !== e && o[r].fn._ !== e && i.push(o[r]);
                    return i.length ? n[t] = i : delete n[t], this
                }
            }, e.exports = o
        }, {}], 7: [function (e, n, o) {
            !function (i, r) {
                if ("function" == typeof t && t.amd) t(["module", "select"], r); else if (void 0 !== o) r(n, e("select")); else {
                    var a = {exports: {}};
                    r(a, i.select), i.clipboardAction = a.exports
                }
            }(this, function (t, e) {
                "use strict";

                function n(t) {
                    return t && t.__esModule ? t : {default: t}
                }

                function o(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                var i = n(e), r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t
                } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                }, a = function () {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var o = e[n];
                            o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o)
                        }
                    }

                    return function (e, n, o) {
                        return n && t(e.prototype, n), o && t(e, o), e
                    }
                }(), c = function () {
                    function t(e) {
                        o(this, t), this.resolveOptions(e), this.initSelection()
                    }

                    return a(t, [{
                        key: "resolveOptions", value: function t() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this.action = e.action, this.container = e.container, this.emitter = e.emitter, this.target = e.target, this.text = e.text, this.trigger = e.trigger, this.selectedText = ""
                        }
                    }, {
                        key: "initSelection", value: function t() {
                            this.text ? this.selectFake() : this.target && this.selectTarget()
                        }
                    }, {
                        key: "selectFake", value: function t() {
                            var e = this, n = "rtl" == document.documentElement.getAttribute("dir");
                            this.removeFake(), this.fakeHandlerCallback = function () {
                                return e.removeFake()
                            }, this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || !0, this.fakeElem = document.createElement("textarea"), this.fakeElem.style.fontSize = "12pt", this.fakeElem.style.border = "0", this.fakeElem.style.padding = "0", this.fakeElem.style.margin = "0", this.fakeElem.style.position = "absolute", this.fakeElem.style[n ? "right" : "left"] = "-9999px";
                            var o = window.pageYOffset || document.documentElement.scrollTop;
                            this.fakeElem.style.top = o + "px", this.fakeElem.setAttribute("readonly", ""), this.fakeElem.value = this.text, this.container.appendChild(this.fakeElem), this.selectedText = (0, i.default)(this.fakeElem), this.copyText()
                        }
                    }, {
                        key: "removeFake", value: function t() {
                            this.fakeHandler && (this.container.removeEventListener("click", this.fakeHandlerCallback), this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem && (this.container.removeChild(this.fakeElem), this.fakeElem = null)
                        }
                    }, {
                        key: "selectTarget", value: function t() {
                            this.selectedText = (0, i.default)(this.target), this.copyText()
                        }
                    }, {
                        key: "copyText", value: function t() {
                            var e = void 0;
                            try {
                                e = document.execCommand(this.action)
                            } catch (t) {
                                e = !1
                            }
                            this.handleResult(e)
                        }
                    }, {
                        key: "handleResult", value: function t(e) {
                            this.emitter.emit(e ? "success" : "error", {
                                action: this.action,
                                text: this.selectedText,
                                trigger: this.trigger,
                                clearSelection: this.clearSelection.bind(this)
                            })
                        }
                    }, {
                        key: "clearSelection", value: function t() {
                            this.trigger && this.trigger.focus(), window.getSelection().removeAllRanges()
                        }
                    }, {
                        key: "destroy", value: function t() {
                            this.removeFake()
                        }
                    }, {
                        key: "action", set: function t() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "copy";
                            if (this._action = e, "copy" !== this._action && "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"')
                        }, get: function t() {
                            return this._action
                        }
                    }, {
                        key: "target", set: function t(e) {
                            if (void 0 !== e) {
                                if (!e || "object" !== (void 0 === e ? "undefined" : r(e)) || 1 !== e.nodeType) throw new Error('Invalid "target" value, use a valid Element');
                                if ("copy" === this.action && e.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                                if ("cut" === this.action && (e.hasAttribute("readonly") || e.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                                this._target = e
                            }
                        }, get: function t() {
                            return this._target
                        }
                    }]), t
                }();
                t.exports = c
            })
        }, {select: 5}], 8: [function (e, n, o) {
            !function (i, r) {
                if ("function" == typeof t && t.amd) t(["module", "./clipboard-action", "tiny-emitter", "good-listener"], r); else if (void 0 !== o) r(n, e("./clipboard-action"), e("tiny-emitter"), e("good-listener")); else {
                    var a = {exports: {}};
                    r(a, i.clipboardAction, i.tinyEmitter, i.goodListener), i.clipboard = a.exports
                }
            }(this, function (t, e, n, o) {
                "use strict";

                function i(t) {
                    return t && t.__esModule ? t : {default: t}
                }

                function r(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function a(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != typeof e && "function" != typeof e ? t : e
                }

                function c(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }

                function l(t, e) {
                    var n = "data-clipboard-" + t;
                    if (e.hasAttribute(n)) return e.getAttribute(n)
                }

                var s = i(e), u = i(n), f = i(o),
                    d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    }, h = function () {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var o = e[n];
                                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o)
                            }
                        }

                        return function (e, n, o) {
                            return n && t(e.prototype, n), o && t(e, o), e
                        }
                    }(), p = function (t) {
                        function e(t, n) {
                            r(this, e);
                            var o = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                            return o.resolveOptions(n), o.listenClick(t), o
                        }

                        return c(e, t), h(e, [{
                            key: "resolveOptions", value: function t() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                this.action = "function" == typeof e.action ? e.action : this.defaultAction, this.target = "function" == typeof e.target ? e.target : this.defaultTarget, this.text = "function" == typeof e.text ? e.text : this.defaultText, this.container = "object" === d(e.container) ? e.container : document.body
                            }
                        }, {
                            key: "listenClick", value: function t(e) {
                                var n = this;
                                this.listener = (0, f.default)(e, "click", function (t) {
                                    return n.onClick(t)
                                })
                            }
                        }, {
                            key: "onClick", value: function t(e) {
                                var n = e.delegateTarget || e.currentTarget;
                                this.clipboardAction && (this.clipboardAction = null), this.clipboardAction = new s.default({
                                    action: this.action(n),
                                    target: this.target(n),
                                    text: this.text(n),
                                    container: this.container,
                                    trigger: n,
                                    emitter: this
                                })
                            }
                        }, {
                            key: "defaultAction", value: function t(e) {
                                return l("action", e)
                            }
                        }, {
                            key: "defaultTarget", value: function t(e) {
                                var n = l("target", e);
                                if (n) return document.querySelector(n)
                            }
                        }, {
                            key: "defaultText", value: function t(e) {
                                return l("text", e)
                            }
                        }, {
                            key: "destroy", value: function t() {
                                this.listener.destroy(), this.clipboardAction && (this.clipboardAction.destroy(), this.clipboardAction = null)
                            }
                        }], [{
                            key: "isSupported", value: function t() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ["copy", "cut"],
                                    n = "string" == typeof e ? [e] : e, o = !!document.queryCommandSupported;
                                return n.forEach(function (t) {
                                    o = o && !!document.queryCommandSupported(t)
                                }), o
                            }
                        }]), e
                    }(u.default);
                t.exports = p
            })
        }, {"./clipboard-action": 7, "good-listener": 4, "tiny-emitter": 6}]
    }, {}, [8])(8)
});
"use strict";

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

/*
 *
 * More info at [www.dropzonejs.com](http://www.dropzonejs.com)
 *
 * Copyright (c) 2012, Matias Meno
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

// The Emitter class provides the ability to call `.on()` on Dropzone to listen
// to events.
// It is strongly based on component's emitter class, and I removed the
// functionality because of the dependency hell with different frameworks.
var Emitter = function () {
    function Emitter() {
        _classCallCheck(this, Emitter);
    }

    _createClass(Emitter, [{
        key: "on",

        // Add an event listener for given event
        value: function on(event, fn) {
            this._callbacks = this._callbacks || {};
            // Create namespace for this event
            if (!this._callbacks[event]) {
                this._callbacks[event] = [];
            }
            this._callbacks[event].push(fn);
            return this;
        }
    }, {
        key: "emit",
        value: function emit(event) {
            this._callbacks = this._callbacks || {};
            var callbacks = this._callbacks[event];

            if (callbacks) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }

                for (var _iterator = callbacks, _isArray = true, _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;

                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done) break;
                        _ref = _i.value;
                    }

                    var callback = _ref;

                    callback.apply(this, args);
                }
            }

            return this;
        }

        // Remove event listener for given event. If fn is not provided, all event
        // listeners for that event will be removed. If neither is provided, all
        // event listeners will be removed.

    }, {
        key: "off",
        value: function off(event, fn) {
            if (!this._callbacks || arguments.length === 0) {
                this._callbacks = {};
                return this;
            }

            // specific event
            var callbacks = this._callbacks[event];
            if (!callbacks) {
                return this;
            }

            // remove all handlers
            if (arguments.length === 1) {
                delete this._callbacks[event];
                return this;
            }

            // remove specific handler
            for (var i = 0; i < callbacks.length; i++) {
                var callback = callbacks[i];
                if (callback === fn) {
                    callbacks.splice(i, 1);
                    break;
                }
            }

            return this;
        }
    }]);

    return Emitter;
}();

var Dropzone = function (_Emitter) {
    _inherits(Dropzone, _Emitter);

    _createClass(Dropzone, null, [{
        key: "initClass",
        value: function initClass() {

            // Exposing the emitter class, mainly for tests
            this.prototype.Emitter = Emitter;

            /*
       This is a list of all available events you can register on a dropzone object.
        You can register an event handler like this:
        dropzone.on("dragEnter", function() { });
        */
            this.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];

            this.prototype.defaultOptions = {
                /**
                 * Has to be specified on elements other than form (or when the form
                 * doesn't have an `action` attribute). You can also
                 * provide a function that will be called with `files` and
                 * must return the url (since `v3.12.0`)
                 */
                url: null,

                /**
                 * Can be changed to `"put"` if necessary. You can also provide a function
                 * that will be called with `files` and must return the method (since `v3.12.0`).
                 */
                method: "post",

                /**
                 * Will be set on the XHRequest.
                 */
                withCredentials: false,

                /**
                 * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
                 */
                timeout: 30000,

                /**
                 * How many file uploads to process in parallel (See the
                 * Enqueuing file uploads* documentation section for more info)
                 */
                parallelUploads: 2,

                /**
                 * Whether to send multiple files in one request. If
                 * this it set to true, then the fallback file input element will
                 * have the `multiple` attribute as well. This option will
                 * also trigger additional events (like `processingmultiple`). See the events
                 * documentation section for more information.
                 */
                uploadMultiple: false,

                /**
                 * Whether you want files to be uploaded in chunks to your server. This can't be
                 * used in combination with `uploadMultiple`.
                 *
                 * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
                 */
                chunking: false,

                /**
                 * If `chunking` is enabled, this defines whether **every** file should be chunked,
                 * even if the file size is below chunkSize. This means, that the additional chunk
                 * form data will be submitted and the `chunksUploaded` callback will be invoked.
                 */
                forceChunking: false,

                /**
                 * If `chunking` is `true`, then this defines the chunk size in bytes.
                 */
                chunkSize: 2000000,

                /**
                 * If `true`, the individual chunks of a file are being uploaded simultaneously.
                 */
                parallelChunkUploads: false,

                /**
                 * Whether a chunk should be retried if it fails.
                 */
                retryChunks: false,

                /**
                 * If `retryChunks` is true, how many times should it be retried.
                 */
                retryChunksLimit: 3,

                /**
                 * If not `null` defines how many files this Dropzone handles. If it exceeds,
                 * the event `maxfilesexceeded` will be called. The dropzone element gets the
                 * class `dz-max-files-reached` accordingly so you can provide visual feedback.
                 */
                maxFilesize: 256,

                /**
                 * The name of the file param that gets transferred.
                 * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
                 * Dropzone will append `[]` to the name.
                 */
                paramName: "file",

                /**
                 * Whether thumbnails for images should be generated
                 */
                createImageThumbnails: true,

                /**
                 * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
                 */
                maxThumbnailFilesize: 10,

                /**
                 * If `null`, the ratio of the image will be used to calculate it.
                 */
                thumbnailWidth: 120,

                /**
                 * The same as `thumbnailWidth`. If both are null, images will not be resized.
                 */
                thumbnailHeight: 120,

                /**
                 * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
                 * Can be either `contain` or `crop`.
                 */
                thumbnailMethod: 'crop',

                /**
                 * If set, images will be resized to these dimensions before being **uploaded**.
                 * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
                 * ratio of the file will be preserved.
                 *
                 * The `options.transformFile` function uses these options, so if the `transformFile` function
                 * is overridden, these options don't do anything.
                 */
                resizeWidth: null,

                /**
                 * See `resizeWidth`.
                 */
                resizeHeight: null,

                /**
                 * The mime type of the resized image (before it gets uploaded to the server).
                 * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
                 * See `resizeWidth` for more information.
                 */
                resizeMimeType: null,

                /**
                 * The quality of the resized images. See `resizeWidth`.
                 */
                resizeQuality: 0.8,

                /**
                 * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
                 * Can be either `contain` or `crop`.
                 */
                resizeMethod: 'contain',

                /**
                 * The base that is used to calculate the filesize. You can change this to
                 * 1024 if you would rather display kibibytes, mebibytes, etc...
                 * 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte` not `1 kilobyte`.
                 * You can change this to `1024` if you don't care about validity.
                 */
                filesizeBase: 1000,

                /**
                 * Can be used to limit the maximum number of files that will be handled by this Dropzone
                 */
                maxFiles: null,

                /**
                 * An optional object to send additional headers to the server. Eg:
                 * `{ "My-Awesome-Header": "header value" }`
                 */
                headers: null,

                /**
                 * If `true`, the dropzone element itself will be clickable, if `false`
                 * nothing will be clickable.
                 *
                 * You can also pass an HTML element, a CSS selector (for multiple elements)
                 * or an array of those. In that case, all of those elements will trigger an
                 * upload when clicked.
                 */
                clickable: true,

                /**
                 * Whether hidden files in directories should be ignored.
                 */
                ignoreHiddenFiles: true,

                /**
                 * The default implementation of `accept` checks the file's mime type or
                 * extension against this list. This is a comma separated list of mime
                 * types or file extensions.
                 *
                 * Eg.: `image/*,application/pdf,.psd`
                 *
                 * If the Dropzone is `clickable` this option will also be used as
                 * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
                 * parameter on the hidden file input as well.
                 */
                acceptedFiles: null,

                /**
                 * **Deprecated!**
                 * Use acceptedFiles instead.
                 */
                acceptedMimeTypes: null,

                /**
                 * If false, files will be added to the queue but the queue will not be
                 * processed automatically.
                 * This can be useful if you need some additional user input before sending
                 * files (or if you want want all files sent at once).
                 * If you're ready to send the file simply call `myDropzone.processQueue()`.
                 *
                 * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
                 * section for more information.
                 */
                autoProcessQueue: true,

                /**
                 * If false, files added to the dropzone will not be queued by default.
                 * You'll have to call `enqueueFile(file)` manually.
                 */
                autoQueue: true,

                /**
                 * If `true`, this will add a link to every file preview to remove or cancel (if
                 * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
                 * and `dictRemoveFile` options are used for the wording.
                 */
                addRemoveLinks: false,

                /**
                 * Defines where to display the file previews – if `null` the
                 * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
                 * selector. The element should have the `dropzone-previews` class so
                 * the previews are displayed properly.
                 */
                previewsContainer: null,

                /**
                 * This is the element the hidden input field (which is used when clicking on the
                 * dropzone to trigger file selection) will be appended to. This might
                 * be important in case you use frameworks to switch the content of your page.
                 *
                 * Can be a selector string, or an element directly.
                 */
                hiddenInputContainer: "body",

                /**
                 * If null, no capture type will be specified
                 * If camera, mobile devices will skip the file selection and choose camera
                 * If microphone, mobile devices will skip the file selection and choose the microphone
                 * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
                 * On apple devices multiple must be set to false.  AcceptedFiles may need to
                 * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
                 */
                capture: null,

                /**
                 * **Deprecated**. Use `renameFile` instead.
                 */
                renameFilename: null,

                /**
                 * A function that is invoked before the file is uploaded to the server and renames the file.
                 * This function gets the `File` as argument and can use the `file.name`. The actual name of the
                 * file that gets used during the upload can be accessed through `file.upload.filename`.
                 */
                renameFile: null,

                /**
                 * If `true` the fallback will be forced. This is very useful to test your server
                 * implementations first and make sure that everything works as
                 * expected without dropzone if you experience problems, and to test
                 * how your fallbacks will look.
                 */
                forceFallback: false,

                /**
                 * The text used before any files are dropped.
                 */
                dictDefaultMessage: "Drop files here to upload",

                /**
                 * The text that replaces the default message text it the browser is not supported.
                 */
                dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",

                /**
                 * The text that will be added before the fallback form.
                 * If you provide a  fallback element yourself, or if this option is `null` this will
                 * be ignored.
                 */
                dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",

                /**
                 * If the filesize is too big.
                 * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
                 */
                dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",

                /**
                 * If the file doesn't match the file type.
                 */
                dictInvalidFileType: "You can't upload files of this type.",

                /**
                 * If the server response was invalid.
                 * `{{statusCode}}` will be replaced with the servers status code.
                 */
                dictResponseError: "Server responded with {{statusCode}} code.",

                /**
                 * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
                 */
                dictCancelUpload: "Cancel upload",

                /**
                 * The text that is displayed if an upload was manually canceled
                 */
                dictUploadCanceled: "Upload canceled.",

                /**
                 * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
                 */
                dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",

                /**
                 * If `addRemoveLinks` is true, the text to be used to remove a file.
                 */
                dictRemoveFile: "Remove file",

                /**
                 * If this is not null, then the user will be prompted before removing a file.
                 */
                dictRemoveFileConfirmation: null,

                /**
                 * Displayed if `maxFiles` is st and exceeded.
                 * The string `{{maxFiles}}` will be replaced by the configuration value.
                 */
                dictMaxFilesExceeded: "You can not upload any more files.",

                /**
                 * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
                 * `b` for bytes.
                 */
                dictFileSizeUnits: {tb: "TB", gb: "GB", mb: "MB", kb: "KB", b: "b"},
                /**
                 * Called when dropzone initialized
                 * You can add event listeners here
                 */
                init: function init() {
                },


                /**
                 * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
                 * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
                 * of a function, this needs to return a map.
                 *
                 * The default implementation does nothing for normal uploads, but adds relevant information for
                 * chunked uploads.
                 *
                 * This is the same as adding hidden input fields in the form element.
                 */
                params: function params(files, xhr, chunk) {
                    if (chunk) {
                        return {
                            dzuuid: chunk.file.upload.uuid,
                            dzchunkindex: chunk.index,
                            dztotalfilesize: chunk.file.size,
                            dzchunksize: this.options.chunkSize,
                            dztotalchunkcount: chunk.file.upload.totalChunkCount,
                            dzchunkbyteoffset: chunk.index * this.options.chunkSize
                        };
                    }
                },


                /**
                 * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
                 * and a `done` function as parameters.
                 *
                 * If the done function is invoked without arguments, the file is "accepted" and will
                 * be processed. If you pass an error message, the file is rejected, and the error
                 * message will be displayed.
                 * This function will not be called if the file is too big or doesn't match the mime types.
                 */
                accept: function accept(file, done) {
                    return done();
                },


                /**
                 * The callback that will be invoked when all chunks have been uploaded for a file.
                 * It gets the file for which the chunks have been uploaded as the first parameter,
                 * and the `done` function as second. `done()` needs to be invoked when everything
                 * needed to finish the upload process is done.
                 */
                chunksUploaded: function chunksUploaded(file, done) {
                    done();
                },

                /**
                 * Gets called when the browser is not supported.
                 * The default implementation shows the fallback input field and adds
                 * a text.
                 */
                fallback: function fallback() {
                    // This code should pass in IE7... :(
                    var messageElement = void 0;
                    this.element.className = this.element.className + " dz-browser-not-supported";

                    for (var _iterator2 = this.element.getElementsByTagName("div"), _isArray2 = true, _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;

                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done) break;
                            _ref2 = _i2.value;
                        }

                        var child = _ref2;

                        if (/(^| )dz-message($| )/.test(child.className)) {
                            messageElement = child;
                            child.className = "dz-message"; // Removes the 'dz-default' class
                            break;
                        }
                    }
                    if (!messageElement) {
                        messageElement = Dropzone.createElement("<div class=\"dz-message\"><span></span></div>");
                        this.element.appendChild(messageElement);
                    }

                    var span = messageElement.getElementsByTagName("span")[0];
                    if (span) {
                        if (span.textContent != null) {
                            span.textContent = this.options.dictFallbackMessage;
                        } else if (span.innerText != null) {
                            span.innerText = this.options.dictFallbackMessage;
                        }
                    }

                    return this.element.appendChild(this.getFallbackForm());
                },


                /**
                 * Gets called to calculate the thumbnail dimensions.
                 *
                 * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
                 *
                 *  - `srcWidth` & `srcHeight` (required)
                 *  - `trgWidth` & `trgHeight` (required)
                 *  - `srcX` & `srcY` (optional, default `0`)
                 *  - `trgX` & `trgY` (optional, default `0`)
                 *
                 * Those values are going to be used by `ctx.drawImage()`.
                 */
                resize: function resize(file, width, height, resizeMethod) {
                    var info = {
                        srcX: 0,
                        srcY: 0,
                        srcWidth: file.width,
                        srcHeight: file.height
                    };

                    var srcRatio = file.width / file.height;

                    // Automatically calculate dimensions if not specified
                    if (width == null && height == null) {
                        width = info.srcWidth;
                        height = info.srcHeight;
                    } else if (width == null) {
                        width = height * srcRatio;
                    } else if (height == null) {
                        height = width / srcRatio;
                    }

                    // Make sure images aren't upscaled
                    width = Math.min(width, info.srcWidth);
                    height = Math.min(height, info.srcHeight);

                    var trgRatio = width / height;

                    if (info.srcWidth > width || info.srcHeight > height) {
                        // Image is bigger and needs rescaling
                        if (resizeMethod === 'crop') {
                            if (srcRatio > trgRatio) {
                                info.srcHeight = file.height;
                                info.srcWidth = info.srcHeight * trgRatio;
                            } else {
                                info.srcWidth = file.width;
                                info.srcHeight = info.srcWidth / trgRatio;
                            }
                        } else if (resizeMethod === 'contain') {
                            // Method 'contain'
                            if (srcRatio > trgRatio) {
                                height = width / srcRatio;
                            } else {
                                width = height * srcRatio;
                            }
                        } else {
                            throw new Error("Unknown resizeMethod '" + resizeMethod + "'");
                        }
                    }

                    info.srcX = (file.width - info.srcWidth) / 2;
                    info.srcY = (file.height - info.srcHeight) / 2;

                    info.trgWidth = width;
                    info.trgHeight = height;

                    return info;
                },


                /**
                 * Can be used to transform the file (for example, resize an image if necessary).
                 *
                 * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
                 * images according to those dimensions.
                 *
                 * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
                 * to be invoked with the file when the transformation is done.
                 */
                transformFile: function transformFile(file, done) {
                    if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {
                        return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
                    } else {
                        return done(file);
                    }
                },


                /**
                 * A string that contains the template used for each dropped
                 * file. Change it to fulfill your needs but make sure to properly
                 * provide all elements.
                 *
                 * If you want to use an actual HTML element instead of providing a String
                 * as a config option, you could create a div with the id `tpl`,
                 * put the template inside it and provide the element like this:
                 *
                 *     document
                 *       .querySelector('#tpl')
                 *       .innerHTML
                 *
                 */
                previewTemplate: "<div class=\"dz-preview dz-file-preview\">\n  <div class=\"dz-image\"><img data-dz-thumbnail /></div>\n  <div class=\"dz-details\">\n    <div class=\"dz-size\"><span data-dz-size></span></div>\n    <div class=\"dz-filename\"><span data-dz-name></span></div>\n  </div>\n  <div class=\"dz-progress\"><span class=\"dz-upload\" data-dz-uploadprogress></span></div>\n  <div class=\"dz-error-message\"><span data-dz-errormessage></span></div>\n  <div class=\"dz-success-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Check</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <path d=\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" stroke-opacity=\"0.198794158\" stroke=\"#747474\" fill-opacity=\"0.816519475\" fill=\"#FFFFFF\" sketch:type=\"MSShapeGroup\"></path>\n      </g>\n    </svg>\n  </div>\n  <div class=\"dz-error-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Error</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <g id=\"Check-+-Oval-2\" sketch:type=\"MSLayerGroup\" stroke=\"#747474\" stroke-opacity=\"0.198794158\" fill=\"#FFFFFF\" fill-opacity=\"0.816519475\">\n          <path d=\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" sketch:type=\"MSShapeGroup\"></path>\n        </g>\n      </g>\n    </svg>\n  </div>\n</div>",

                // END OPTIONS
                // (Required by the dropzone documentation parser)


                /*
         Those functions register themselves to the events on init and handle all
         the user interface specific stuff. Overwriting them won't break the upload
         but can break the way it's displayed.
         You can overwrite them if you don't like the default behavior. If you just
         want to add an additional event handler, register it on the dropzone object
         and don't overwrite those options.
         */

                // Those are self explanatory and simply concern the DragnDrop.
                drop: function drop(e) {
                    return this.element.classList.remove("dz-drag-hover");
                },
                dragstart: function dragstart(e) {
                },
                dragend: function dragend(e) {
                    return this.element.classList.remove("dz-drag-hover");
                },
                dragenter: function dragenter(e) {
                    return this.element.classList.add("dz-drag-hover");
                },
                dragover: function dragover(e) {
                    return this.element.classList.add("dz-drag-hover");
                },
                dragleave: function dragleave(e) {
                    return this.element.classList.remove("dz-drag-hover");
                },
                paste: function paste(e) {
                },


                // Called whenever there are no files left in the dropzone anymore, and the
                // dropzone should be displayed as if in the initial state.
                reset: function reset() {
                    return this.element.classList.remove("dz-started");
                },


                // Called when a file is added to the queue
                // Receives `file`
                addedfile: function addedfile(file) {
                    var _this2 = this;

                    if (this.element === this.previewsContainer) {
                        this.element.classList.add("dz-started");
                    }

                    if (this.previewsContainer) {
                        file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());
                        file.previewTemplate = file.previewElement; // Backwards compatibility

                        this.previewsContainer.appendChild(file.previewElement);
                        for (var _iterator3 = file.previewElement.querySelectorAll("[data-dz-name]"), _isArray3 = true, _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;

                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                _i3 = _iterator3.next();
                                if (_i3.done) break;
                                _ref3 = _i3.value;
                            }

                            var node = _ref3;

                            node.textContent = file.name;
                        }
                        for (var _iterator4 = file.previewElement.querySelectorAll("[data-dz-size]"), _isArray4 = true, _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            if (_isArray4) {
                                if (_i4 >= _iterator4.length) break;
                                node = _iterator4[_i4++];
                            } else {
                                _i4 = _iterator4.next();
                                if (_i4.done) break;
                                node = _i4.value;
                            }

                            node.innerHTML = this.filesize(file.size);
                        }

                        if (this.options.addRemoveLinks) {
                            file._removeLink = Dropzone.createElement("<a class=\"dz-remove\" href=\"javascript:undefined;\" data-dz-remove>" + this.options.dictRemoveFile + "</a>");
                            file.previewElement.appendChild(file._removeLink);
                        }

                        var removeFileEvent = function removeFileEvent(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (file.status === Dropzone.UPLOADING) {
                                return Dropzone.confirm(_this2.options.dictCancelUploadConfirmation, function () {
                                    return _this2.removeFile(file);
                                });
                            } else {
                                if (_this2.options.dictRemoveFileConfirmation) {
                                    return Dropzone.confirm(_this2.options.dictRemoveFileConfirmation, function () {
                                        return _this2.removeFile(file);
                                    });
                                } else {
                                    return _this2.removeFile(file);
                                }
                            }
                        };

                        for (var _iterator5 = file.previewElement.querySelectorAll("[data-dz-remove]"), _isArray5 = true, _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref4;

                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref4 = _iterator5[_i5++];
                            } else {
                                _i5 = _iterator5.next();
                                if (_i5.done) break;
                                _ref4 = _i5.value;
                            }

                            var removeLink = _ref4;

                            removeLink.addEventListener("click", removeFileEvent);
                        }
                    }
                },


                // Called whenever a file is removed.
                removedfile: function removedfile(file) {
                    if (file.previewElement != null && file.previewElement.parentNode != null) {
                        file.previewElement.parentNode.removeChild(file.previewElement);
                    }
                    return this._updateMaxFilesReachedClass();
                },


                // Called when a thumbnail has been generated
                // Receives `file` and `dataUrl`
                thumbnail: function thumbnail(file, dataUrl) {
                    if (file.previewElement) {
                        file.previewElement.classList.remove("dz-file-preview");
                        for (var _iterator6 = file.previewElement.querySelectorAll("[data-dz-thumbnail]"), _isArray6 = true, _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref5;

                            if (_isArray6) {
                                if (_i6 >= _iterator6.length) break;
                                _ref5 = _iterator6[_i6++];
                            } else {
                                _i6 = _iterator6.next();
                                if (_i6.done) break;
                                _ref5 = _i6.value;
                            }

                            var thumbnailElement = _ref5;

                            thumbnailElement.alt = file.name;
                            thumbnailElement.src = dataUrl;
                        }

                        return setTimeout(function () {
                            return file.previewElement.classList.add("dz-image-preview");
                        }, 1);
                    }
                },


                // Called whenever an error occurs
                // Receives `file` and `message`
                error: function error(file, message) {
                    if (file.previewElement) {
                        file.previewElement.classList.add("dz-error");
                        if (typeof message !== "String" && message.error) {
                            message = message.error;
                        }
                        for (var _iterator7 = file.previewElement.querySelectorAll("[data-dz-errormessage]"), _isArray7 = true, _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                            var _ref6;

                            if (_isArray7) {
                                if (_i7 >= _iterator7.length) break;
                                _ref6 = _iterator7[_i7++];
                            } else {
                                _i7 = _iterator7.next();
                                if (_i7.done) break;
                                _ref6 = _i7.value;
                            }

                            var node = _ref6;

                            node.textContent = message;
                        }
                    }
                },
                errormultiple: function errormultiple() {
                },


                // Called when a file gets processed. Since there is a cue, not all added
                // files are processed immediately.
                // Receives `file`
                processing: function processing(file) {
                    if (file.previewElement) {
                        file.previewElement.classList.add("dz-processing");
                        if (file._removeLink) {
                            return file._removeLink.innerHTML = this.options.dictCancelUpload;
                        }
                    }
                },
                processingmultiple: function processingmultiple() {
                },


                // Called whenever the upload progress gets updated.
                // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
                // To get the total number of bytes of the file, use `file.size`
                uploadprogress: function uploadprogress(file, progress, bytesSent) {
                    if (file.previewElement) {
                        for (var _iterator8 = file.previewElement.querySelectorAll("[data-dz-uploadprogress]"), _isArray8 = true, _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                            var _ref7;

                            if (_isArray8) {
                                if (_i8 >= _iterator8.length) break;
                                _ref7 = _iterator8[_i8++];
                            } else {
                                _i8 = _iterator8.next();
                                if (_i8.done) break;
                                _ref7 = _i8.value;
                            }

                            var node = _ref7;

                            node.nodeName === 'PROGRESS' ? node.value = progress : node.style.width = progress + "%";
                        }
                    }
                },


                // Called whenever the total upload progress gets updated.
                // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
                totaluploadprogress: function totaluploadprogress() {
                },


                // Called just before the file is sent. Gets the `xhr` object as second
                // parameter, so you can modify it (for example to add a CSRF token) and a
                // `formData` object to add additional information.
                sending: function sending() {
                },
                sendingmultiple: function sendingmultiple() {
                },


                // When the complete upload is finished and successful
                // Receives `file`
                success: function success(file) {
                    if (file.previewElement) {
                        return file.previewElement.classList.add("dz-success");
                    }
                },
                successmultiple: function successmultiple() {
                },


                // When the upload is canceled.
                canceled: function canceled(file) {
                    return this.emit("error", file, this.options.dictUploadCanceled);
                },
                canceledmultiple: function canceledmultiple() {
                },


                // When the upload is finished, either with success or an error.
                // Receives `file`
                complete: function complete(file) {
                    if (file._removeLink) {
                        file._removeLink.innerHTML = this.options.dictRemoveFile;
                    }
                    if (file.previewElement) {
                        return file.previewElement.classList.add("dz-complete");
                    }
                },
                completemultiple: function completemultiple() {
                },
                maxfilesexceeded: function maxfilesexceeded() {
                },
                maxfilesreached: function maxfilesreached() {
                },
                queuecomplete: function queuecomplete() {
                },
                addedfiles: function addedfiles() {
                }
            };

            this.prototype._thumbnailQueue = [];
            this.prototype._processingThumbnail = false;
        }

        // global utility

    }, {
        key: "extend",
        value: function extend(target) {
            for (var _len2 = arguments.length, objects = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                objects[_key2 - 1] = arguments[_key2];
            }

            for (var _iterator9 = objects, _isArray9 = true, _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                var _ref8;

                if (_isArray9) {
                    if (_i9 >= _iterator9.length) break;
                    _ref8 = _iterator9[_i9++];
                } else {
                    _i9 = _iterator9.next();
                    if (_i9.done) break;
                    _ref8 = _i9.value;
                }

                var object = _ref8;

                for (var key in object) {
                    var val = object[key];
                    target[key] = val;
                }
            }
            return target;
        }
    }]);

    function Dropzone(el, options) {
        _classCallCheck(this, Dropzone);

        var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this));

        var fallback = void 0,
            left = void 0;
        _this.element = el;
        // For backwards compatibility since the version was in the prototype previously
        _this.version = Dropzone.version;

        _this.defaultOptions.previewTemplate = _this.defaultOptions.previewTemplate.replace(/\n*/g, "");

        _this.clickableElements = [];
        _this.listeners = [];
        _this.files = []; // All files

        if (typeof _this.element === "string") {
            _this.element = document.querySelector(_this.element);
        }

        // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.
        if (!_this.element || _this.element.nodeType == null) {
            throw new Error("Invalid dropzone element.");
        }

        if (_this.element.dropzone) {
            throw new Error("Dropzone already attached.");
        }

        // Now add this dropzone to the instances.
        Dropzone.instances.push(_this);

        // Put the dropzone inside the element itself.
        _this.element.dropzone = _this;

        var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};

        _this.options = Dropzone.extend({}, _this.defaultOptions, elementOptions, options != null ? options : {});

        // If the browser failed, just call the fallback and leave
        if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) {
            var _ret;

            return _ret = _this.options.fallback.call(_this), _possibleConstructorReturn(_this, _ret);
        }

        // @options.url = @element.getAttribute "action" unless @options.url?
        if (_this.options.url == null) {
            _this.options.url = _this.element.getAttribute("action");
        }

        if (!_this.options.url) {
            throw new Error("No URL provided.");
        }

        if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) {
            throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
        }

        if (_this.options.uploadMultiple && _this.options.chunking) {
            throw new Error('You cannot set both: uploadMultiple and chunking.');
        }

        // Backwards compatibility
        if (_this.options.acceptedMimeTypes) {
            _this.options.acceptedFiles = _this.options.acceptedMimeTypes;
            delete _this.options.acceptedMimeTypes;
        }

        // Backwards compatibility
        if (_this.options.renameFilename != null) {
            _this.options.renameFile = function (file) {
                return _this.options.renameFilename.call(_this, file.name, file);
            };
        }

        _this.options.method = _this.options.method.toUpperCase();

        if ((fallback = _this.getExistingFallback()) && fallback.parentNode) {
            // Remove the fallback
            fallback.parentNode.removeChild(fallback);
        }

        // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false
        if (_this.options.previewsContainer !== false) {
            if (_this.options.previewsContainer) {
                _this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, "previewsContainer");
            } else {
                _this.previewsContainer = _this.element;
            }
        }

        if (_this.options.clickable) {
            if (_this.options.clickable === true) {
                _this.clickableElements = [_this.element];
            } else {
                _this.clickableElements = Dropzone.getElements(_this.options.clickable, "clickable");
            }
        }

        _this.init();
        return _this;
    }

    // Returns all files that have been accepted


    _createClass(Dropzone, [{
        key: "getAcceptedFiles",
        value: function getAcceptedFiles() {
            return this.files.filter(function (file) {
                return file.accepted;
            }).map(function (file) {
                return file;
            });
        }

        // Returns all files that have been rejected
        // Not sure when that's going to be useful, but added for completeness.

    }, {
        key: "getRejectedFiles",
        value: function getRejectedFiles() {
            return this.files.filter(function (file) {
                return !file.accepted;
            }).map(function (file) {
                return file;
            });
        }
    }, {
        key: "getFilesWithStatus",
        value: function getFilesWithStatus(status) {
            return this.files.filter(function (file) {
                return file.status === status;
            }).map(function (file) {
                return file;
            });
        }

        // Returns all files that are in the queue

    }, {
        key: "getQueuedFiles",
        value: function getQueuedFiles() {
            return this.getFilesWithStatus(Dropzone.QUEUED);
        }
    }, {
        key: "getUploadingFiles",
        value: function getUploadingFiles() {
            return this.getFilesWithStatus(Dropzone.UPLOADING);
        }
    }, {
        key: "getAddedFiles",
        value: function getAddedFiles() {
            return this.getFilesWithStatus(Dropzone.ADDED);
        }

        // Files that are either queued or uploading

    }, {
        key: "getActiveFiles",
        value: function getActiveFiles() {
            return this.files.filter(function (file) {
                return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;
            }).map(function (file) {
                return file;
            });
        }

        // The function that gets called when Dropzone is initialized. You
        // can (and should) setup event listeners inside this function.

    }, {
        key: "init",
        value: function init() {
            var _this3 = this;

            // In case it isn't set already
            if (this.element.tagName === "form") {
                this.element.setAttribute("enctype", "multipart/form-data");
            }

            if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {
                this.element.appendChild(Dropzone.createElement("<div class=\"dz-default dz-message\"><span>" + this.options.dictDefaultMessage + "</span></div>"));
            }

            if (this.clickableElements.length) {
                var setupHiddenFileInput = function setupHiddenFileInput() {
                    if (_this3.hiddenFileInput) {
                        _this3.hiddenFileInput.parentNode.removeChild(_this3.hiddenFileInput);
                    }
                    _this3.hiddenFileInput = document.createElement("input");
                    _this3.hiddenFileInput.setAttribute("type", "file");
                    if (_this3.options.maxFiles === null || _this3.options.maxFiles > 1) {
                        _this3.hiddenFileInput.setAttribute("multiple", "multiple");
                    }
                    _this3.hiddenFileInput.className = "dz-hidden-input";

                    if (_this3.options.acceptedFiles !== null) {
                        _this3.hiddenFileInput.setAttribute("accept", _this3.options.acceptedFiles);
                    }
                    if (_this3.options.capture !== null) {
                        _this3.hiddenFileInput.setAttribute("capture", _this3.options.capture);
                    }

                    // Not setting `display="none"` because some browsers don't accept clicks
                    // on elements that aren't displayed.
                    _this3.hiddenFileInput.style.visibility = "hidden";
                    _this3.hiddenFileInput.style.position = "absolute";
                    _this3.hiddenFileInput.style.top = "0";
                    _this3.hiddenFileInput.style.left = "0";
                    _this3.hiddenFileInput.style.height = "0";
                    _this3.hiddenFileInput.style.width = "0";
                    Dropzone.getElement(_this3.options.hiddenInputContainer, 'hiddenInputContainer').appendChild(_this3.hiddenFileInput);
                    return _this3.hiddenFileInput.addEventListener("change", function () {
                        var files = _this3.hiddenFileInput.files;

                        if (files.length) {
                            for (var _iterator10 = files, _isArray10 = true, _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                                var _ref9;

                                if (_isArray10) {
                                    if (_i10 >= _iterator10.length) break;
                                    _ref9 = _iterator10[_i10++];
                                } else {
                                    _i10 = _iterator10.next();
                                    if (_i10.done) break;
                                    _ref9 = _i10.value;
                                }

                                var file = _ref9;

                                _this3.addFile(file);
                            }
                        }
                        _this3.emit("addedfiles", files);
                        return setupHiddenFileInput();
                    });
                };
                setupHiddenFileInput();
            }

            this.URL = window.URL !== null ? window.URL : window.webkitURL;

            // Setup all event listeners on the Dropzone object itself.
            // They're not in @setupEventListeners() because they shouldn't be removed
            // again when the dropzone gets disabled.
            for (var _iterator11 = this.events, _isArray11 = true, _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                var _ref10;

                if (_isArray11) {
                    if (_i11 >= _iterator11.length) break;
                    _ref10 = _iterator11[_i11++];
                } else {
                    _i11 = _iterator11.next();
                    if (_i11.done) break;
                    _ref10 = _i11.value;
                }

                var eventName = _ref10;

                this.on(eventName, this.options[eventName]);
            }

            this.on("uploadprogress", function () {
                return _this3.updateTotalUploadProgress();
            });

            this.on("removedfile", function () {
                return _this3.updateTotalUploadProgress();
            });

            this.on("canceled", function (file) {
                return _this3.emit("complete", file);
            });

            // Emit a `queuecomplete` event if all files finished uploading.
            this.on("complete", function (file) {
                if (_this3.getAddedFiles().length === 0 && _this3.getUploadingFiles().length === 0 && _this3.getQueuedFiles().length === 0) {
                    // This needs to be deferred so that `queuecomplete` really triggers after `complete`
                    return setTimeout(function () {
                        return _this3.emit("queuecomplete");
                    }, 0);
                }
            });

            var noPropagation = function noPropagation(e) {
                e.stopPropagation();
                if (e.preventDefault) {
                    return e.preventDefault();
                } else {
                    return e.returnValue = false;
                }
            };

            // Create the listeners
            this.listeners = [{
                element: this.element,
                events: {
                    "dragstart": function dragstart(e) {
                        return _this3.emit("dragstart", e);
                    },
                    "dragenter": function dragenter(e) {
                        noPropagation(e);
                        return _this3.emit("dragenter", e);
                    },
                    "dragover": function dragover(e) {
                        // Makes it possible to drag files from chrome's download bar
                        // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
                        // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
                        var efct = void 0;
                        try {
                            efct = e.dataTransfer.effectAllowed;
                        } catch (error) {
                        }
                        e.dataTransfer.dropEffect = 'move' === efct || 'linkMove' === efct ? 'move' : 'copy';

                        noPropagation(e);
                        return _this3.emit("dragover", e);
                    },
                    "dragleave": function dragleave(e) {
                        return _this3.emit("dragleave", e);
                    },
                    "drop": function drop(e) {
                        noPropagation(e);
                        return _this3.drop(e);
                    },
                    "dragend": function dragend(e) {
                        return _this3.emit("dragend", e);
                    }

                    // This is disabled right now, because the browsers don't implement it properly.
                    // "paste": (e) =>
                    //   noPropagation e
                    //   @paste e
                }
            }];

            this.clickableElements.forEach(function (clickableElement) {
                return _this3.listeners.push({
                    element: clickableElement,
                    events: {
                        "click": function click(evt) {
                            // Only the actual dropzone or the message element should trigger file selection
                            if (clickableElement !== _this3.element || evt.target === _this3.element || Dropzone.elementInside(evt.target, _this3.element.querySelector(".dz-message"))) {
                                _this3.hiddenFileInput.click(); // Forward the click
                            }
                            return true;
                        }
                    }
                });
            });

            this.enable();

            return this.options.init.call(this);
        }

        // Not fully tested yet

    }, {
        key: "destroy",
        value: function destroy() {
            this.disable();
            this.removeAllFiles(true);
            if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
                this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
                this.hiddenFileInput = null;
            }
            delete this.element.dropzone;
            return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);
        }
    }, {
        key: "updateTotalUploadProgress",
        value: function updateTotalUploadProgress() {
            var totalUploadProgress = void 0;
            var totalBytesSent = 0;
            var totalBytes = 0;

            var activeFiles = this.getActiveFiles();

            if (activeFiles.length) {
                for (var _iterator12 = this.getActiveFiles(), _isArray12 = true, _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                    var _ref11;

                    if (_isArray12) {
                        if (_i12 >= _iterator12.length) break;
                        _ref11 = _iterator12[_i12++];
                    } else {
                        _i12 = _iterator12.next();
                        if (_i12.done) break;
                        _ref11 = _i12.value;
                    }

                    var file = _ref11;

                    totalBytesSent += file.upload.bytesSent;
                    totalBytes += file.upload.total;
                }
                totalUploadProgress = 100 * totalBytesSent / totalBytes;
            } else {
                totalUploadProgress = 100;
            }

            return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
        }

        // @options.paramName can be a function taking one parameter rather than a string.
        // A parameter name for a file is obtained simply by calling this with an index number.

    }, {
        key: "_getParamName",
        value: function _getParamName(n) {
            if (typeof this.options.paramName === "function") {
                return this.options.paramName(n);
            } else {
                return "" + this.options.paramName + (this.options.uploadMultiple ? "[" + n + "]" : "");
            }
        }

        // If @options.renameFile is a function,
        // the function will be used to rename the file.name before appending it to the formData

    }, {
        key: "_renameFile",
        value: function _renameFile(file) {
            if (typeof this.options.renameFile !== "function") {
                return file.name;
            }
            return this.options.renameFile(file);
        }

        // Returns a form that can be used as fallback if the browser does not support DragnDrop
        //
        // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
        // This code has to pass in IE7 :(

    }, {
        key: "getFallbackForm",
        value: function getFallbackForm() {
            var existingFallback = void 0,
                form = void 0;
            if (existingFallback = this.getExistingFallback()) {
                return existingFallback;
            }

            var fieldsString = "<div class=\"dz-fallback\">";
            if (this.options.dictFallbackText) {
                fieldsString += "<p>" + this.options.dictFallbackText + "</p>";
            }
            fieldsString += "<input type=\"file\" name=\"" + this._getParamName(0) + "\" " + (this.options.uploadMultiple ? 'multiple="multiple"' : undefined) + " /><input type=\"submit\" value=\"Upload!\"></div>";

            var fields = Dropzone.createElement(fieldsString);
            if (this.element.tagName !== "FORM") {
                form = Dropzone.createElement("<form action=\"" + this.options.url + "\" enctype=\"multipart/form-data\" method=\"" + this.options.method + "\"></form>");
                form.appendChild(fields);
            } else {
                // Make sure that the enctype and method attributes are set properly
                this.element.setAttribute("enctype", "multipart/form-data");
                this.element.setAttribute("method", this.options.method);
            }
            return form != null ? form : fields;
        }

        // Returns the fallback elements if they exist already
        //
        // This code has to pass in IE7 :(

    }, {
        key: "getExistingFallback",
        value: function getExistingFallback() {
            var getFallback = function getFallback(elements) {
                for (var _iterator13 = elements, _isArray13 = true, _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                    var _ref12;

                    if (_isArray13) {
                        if (_i13 >= _iterator13.length) break;
                        _ref12 = _iterator13[_i13++];
                    } else {
                        _i13 = _iterator13.next();
                        if (_i13.done) break;
                        _ref12 = _i13.value;
                    }

                    var el = _ref12;

                    if (/(^| )fallback($| )/.test(el.className)) {
                        return el;
                    }
                }
            };

            var _arr = ["div", "form"];
            for (var _i14 = 0; _i14 < _arr.length; _i14++) {
                var tagName = _arr[_i14];
                var fallback;
                if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {
                    return fallback;
                }
            }
        }

        // Activates all listeners stored in @listeners

    }, {
        key: "setupEventListeners",
        value: function setupEventListeners() {
            return this.listeners.map(function (elementListeners) {
                return function () {
                    var result = [];
                    for (var event in elementListeners.events) {
                        var listener = elementListeners.events[event];
                        result.push(elementListeners.element.addEventListener(event, listener, false));
                    }
                    return result;
                }();
            });
        }

        // Deactivates all listeners stored in @listeners

    }, {
        key: "removeEventListeners",
        value: function removeEventListeners() {
            return this.listeners.map(function (elementListeners) {
                return function () {
                    var result = [];
                    for (var event in elementListeners.events) {
                        var listener = elementListeners.events[event];
                        result.push(elementListeners.element.removeEventListener(event, listener, false));
                    }
                    return result;
                }();
            });
        }

        // Removes all event listeners and cancels all files in the queue or being processed.

    }, {
        key: "disable",
        value: function disable() {
            var _this4 = this;

            this.clickableElements.forEach(function (element) {
                return element.classList.remove("dz-clickable");
            });
            this.removeEventListeners();
            this.disabled = true;

            return this.files.map(function (file) {
                return _this4.cancelUpload(file);
            });
        }
    }, {
        key: "enable",
        value: function enable() {
            delete this.disabled;
            this.clickableElements.forEach(function (element) {
                return element.classList.add("dz-clickable");
            });
            return this.setupEventListeners();
        }

        // Returns a nicely formatted filesize

    }, {
        key: "filesize",
        value: function filesize(size) {
            var selectedSize = 0;
            var selectedUnit = "b";

            if (size > 0) {
                var units = ['tb', 'gb', 'mb', 'kb', 'b'];

                for (var i = 0; i < units.length; i++) {
                    var unit = units[i];
                    var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;

                    if (size >= cutoff) {
                        selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
                        selectedUnit = unit;
                        break;
                    }
                }

                selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
            }

            return "<strong>" + selectedSize + "</strong> " + this.options.dictFileSizeUnits[selectedUnit];
        }

        // Adds or removes the `dz-max-files-reached` class from the form.

    }, {
        key: "_updateMaxFilesReachedClass",
        value: function _updateMaxFilesReachedClass() {
            if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
                if (this.getAcceptedFiles().length === this.options.maxFiles) {
                    this.emit('maxfilesreached', this.files);
                }
                return this.element.classList.add("dz-max-files-reached");
            } else {
                return this.element.classList.remove("dz-max-files-reached");
            }
        }
    }, {
        key: "drop",
        value: function drop(e) {
            if (!e.dataTransfer) {
                return;
            }
            this.emit("drop", e);

            // Convert the FileList to an Array
            // This is necessary for IE11
            var files = [];
            for (var i = 0; i < e.dataTransfer.files.length; i++) {
                files[i] = e.dataTransfer.files[i];
            }

            this.emit("addedfiles", files);

            // Even if it's a folder, files.length will contain the folders.
            if (files.length) {
                var items = e.dataTransfer.items;

                if (items && items.length && items[0].webkitGetAsEntry != null) {
                    // The browser supports dropping of folders, so handle items instead of files
                    this._addFilesFromItems(items);
                } else {
                    this.handleFiles(files);
                }
            }
        }
    }, {
        key: "paste",
        value: function paste(e) {
            if (__guard__(e != null ? e.clipboardData : undefined, function (x) {
                return x.items;
            }) == null) {
                return;
            }

            this.emit("paste", e);
            var items = e.clipboardData.items;


            if (items.length) {
                return this._addFilesFromItems(items);
            }
        }
    }, {
        key: "handleFiles",
        value: function handleFiles(files) {
            for (var _iterator14 = files, _isArray14 = true, _i15 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator](); ;) {
                var _ref13;

                if (_isArray14) {
                    if (_i15 >= _iterator14.length) break;
                    _ref13 = _iterator14[_i15++];
                } else {
                    _i15 = _iterator14.next();
                    if (_i15.done) break;
                    _ref13 = _i15.value;
                }

                var file = _ref13;

                this.addFile(file);
            }
        }

        // When a folder is dropped (or files are pasted), items must be handled
        // instead of files.

    }, {
        key: "_addFilesFromItems",
        value: function _addFilesFromItems(items) {
            var _this5 = this;

            return function () {
                var result = [];
                for (var _iterator15 = items, _isArray15 = true, _i16 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator](); ;) {
                    var _ref14;

                    if (_isArray15) {
                        if (_i16 >= _iterator15.length) break;
                        _ref14 = _iterator15[_i16++];
                    } else {
                        _i16 = _iterator15.next();
                        if (_i16.done) break;
                        _ref14 = _i16.value;
                    }

                    var item = _ref14;

                    var entry;
                    if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
                        if (entry.isFile) {
                            result.push(_this5.addFile(item.getAsFile()));
                        } else if (entry.isDirectory) {
                            // Append all files from that directory to files
                            result.push(_this5._addFilesFromDirectory(entry, entry.name));
                        } else {
                            result.push(undefined);
                        }
                    } else if (item.getAsFile != null) {
                        if (item.kind == null || item.kind === "file") {
                            result.push(_this5.addFile(item.getAsFile()));
                        } else {
                            result.push(undefined);
                        }
                    } else {
                        result.push(undefined);
                    }
                }
                return result;
            }();
        }

        // Goes through the directory, and adds each file it finds recursively

    }, {
        key: "_addFilesFromDirectory",
        value: function _addFilesFromDirectory(directory, path) {
            var _this6 = this;

            var dirReader = directory.createReader();

            var errorHandler = function errorHandler(error) {
                return __guardMethod__(console, 'log', function (o) {
                    return o.log(error);
                });
            };

            var readEntries = function readEntries() {
                return dirReader.readEntries(function (entries) {
                    if (entries.length > 0) {
                        for (var _iterator16 = entries, _isArray16 = true, _i17 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator](); ;) {
                            var _ref15;

                            if (_isArray16) {
                                if (_i17 >= _iterator16.length) break;
                                _ref15 = _iterator16[_i17++];
                            } else {
                                _i17 = _iterator16.next();
                                if (_i17.done) break;
                                _ref15 = _i17.value;
                            }

                            var entry = _ref15;

                            if (entry.isFile) {
                                entry.file(function (file) {
                                    if (_this6.options.ignoreHiddenFiles && file.name.substring(0, 1) === '.') {
                                        return;
                                    }
                                    file.fullPath = path + "/" + file.name;
                                    return _this6.addFile(file);
                                });
                            } else if (entry.isDirectory) {
                                _this6._addFilesFromDirectory(entry, path + "/" + entry.name);
                            }
                        }

                        // Recursively call readEntries() again, since browser only handle
                        // the first 100 entries.
                        // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
                        readEntries();
                    }
                    return null;
                }, errorHandler);
            };

            return readEntries();
        }

        // If `done()` is called without argument the file is accepted
        // If you call it with an error message, the file is rejected
        // (This allows for asynchronous validation)
        //
        // This function checks the filesize, and if the file.type passes the
        // `acceptedFiles` check.

    }, {
        key: "accept",
        value: function accept(file, done) {
            if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1024 * 1024) {
                return done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
            } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {
                return done(this.options.dictInvalidFileType);
            } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
                done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
                return this.emit("maxfilesexceeded", file);
            } else {
                return this.options.accept.call(this, file, done);
            }
        }
    }, {
        key: "addFile",
        value: function addFile(file) {
            var _this7 = this;

            file.upload = {
                uuid: Dropzone.uuidv4(),
                progress: 0,
                // Setting the total upload size to file.size for the beginning
                // It's actual different than the size to be transmitted.
                total: file.size,
                bytesSent: 0,
                filename: this._renameFile(file),
                chunked: this.options.chunking && (this.options.forceChunking || file.size > this.options.chunkSize),
                totalChunkCount: Math.ceil(file.size / this.options.chunkSize)
            };
            this.files.push(file);

            file.status = Dropzone.ADDED;

            this.emit("addedfile", file);

            this._enqueueThumbnail(file);

            return this.accept(file, function (error) {
                if (error) {
                    file.accepted = false;
                    _this7._errorProcessing([file], error); // Will set the file.status
                } else {
                    file.accepted = true;
                    if (_this7.options.autoQueue) {
                        _this7.enqueueFile(file);
                    } // Will set .accepted = true
                }
                return _this7._updateMaxFilesReachedClass();
            });
        }

        // Wrapper for enqueueFile

    }, {
        key: "enqueueFiles",
        value: function enqueueFiles(files) {
            for (var _iterator17 = files, _isArray17 = true, _i18 = 0, _iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator](); ;) {
                var _ref16;

                if (_isArray17) {
                    if (_i18 >= _iterator17.length) break;
                    _ref16 = _iterator17[_i18++];
                } else {
                    _i18 = _iterator17.next();
                    if (_i18.done) break;
                    _ref16 = _i18.value;
                }

                var file = _ref16;

                this.enqueueFile(file);
            }
            return null;
        }
    }, {
        key: "enqueueFile",
        value: function enqueueFile(file) {
            var _this8 = this;

            if (file.status === Dropzone.ADDED && file.accepted === true) {
                file.status = Dropzone.QUEUED;
                if (this.options.autoProcessQueue) {
                    return setTimeout(function () {
                        return _this8.processQueue();
                    }, 0); // Deferring the call
                }
            } else {
                throw new Error("This file can't be queued because it has already been processed or was rejected.");
            }
        }
    }, {
        key: "_enqueueThumbnail",
        value: function _enqueueThumbnail(file) {
            var _this9 = this;

            if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {
                this._thumbnailQueue.push(file);
                return setTimeout(function () {
                    return _this9._processThumbnailQueue();
                }, 0); // Deferring the call
            }
        }
    }, {
        key: "_processThumbnailQueue",
        value: function _processThumbnailQueue() {
            var _this10 = this;

            if (this._processingThumbnail || this._thumbnailQueue.length === 0) {
                return;
            }

            this._processingThumbnail = true;
            var file = this._thumbnailQueue.shift();
            return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (dataUrl) {
                _this10.emit("thumbnail", file, dataUrl);
                _this10._processingThumbnail = false;
                return _this10._processThumbnailQueue();
            });
        }

        // Can be called by the user to remove a file

    }, {
        key: "removeFile",
        value: function removeFile(file) {
            if (file.status === Dropzone.UPLOADING) {
                this.cancelUpload(file);
            }
            this.files = without(this.files, file);

            this.emit("removedfile", file);
            if (this.files.length === 0) {
                return this.emit("reset");
            }
        }

        // Removes all files that aren't currently processed from the list

    }, {
        key: "removeAllFiles",
        value: function removeAllFiles(cancelIfNecessary) {
            // Create a copy of files since removeFile() changes the @files array.
            if (cancelIfNecessary == null) {
                cancelIfNecessary = false;
            }
            for (var _iterator18 = this.files.slice(), _isArray18 = true, _i19 = 0, _iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator](); ;) {
                var _ref17;

                if (_isArray18) {
                    if (_i19 >= _iterator18.length) break;
                    _ref17 = _iterator18[_i19++];
                } else {
                    _i19 = _iterator18.next();
                    if (_i19.done) break;
                    _ref17 = _i19.value;
                }

                var file = _ref17;

                if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {
                    this.removeFile(file);
                }
            }
            return null;
        }

        // Resizes an image before it gets sent to the server. This function is the default behavior of
        // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
        // the resized blob.

    }, {
        key: "resizeImage",
        value: function resizeImage(file, width, height, resizeMethod, callback) {
            var _this11 = this;

            return this.createThumbnail(file, width, height, resizeMethod, true, function (dataUrl, canvas) {
                if (canvas == null) {
                    // The image has not been resized
                    return callback(file);
                } else {
                    var resizeMimeType = _this11.options.resizeMimeType;

                    if (resizeMimeType == null) {
                        resizeMimeType = file.type;
                    }
                    var resizedDataURL = canvas.toDataURL(resizeMimeType, _this11.options.resizeQuality);
                    if (resizeMimeType === 'image/jpeg' || resizeMimeType === 'image/jpg') {
                        // Now add the original EXIF information
                        resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);
                    }
                    return callback(Dropzone.dataURItoBlob(resizedDataURL));
                }
            });
        }
    }, {
        key: "createThumbnail",
        value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
            var _this12 = this;

            var fileReader = new FileReader();

            fileReader.onload = function () {

                file.dataURL = fileReader.result;

                // Don't bother creating a thumbnail for SVG images since they're vector
                if (file.type === "image/svg+xml") {
                    if (callback != null) {
                        callback(fileReader.result);
                    }
                    return;
                }

                return _this12.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
            };

            return fileReader.readAsDataURL(file);
        }
    }, {
        key: "createThumbnailFromUrl",
        value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
            var _this13 = this;

            // Not using `new Image` here because of a bug in latest Chrome versions.
            // See https://github.com/enyo/dropzone/pull/226
            var img = document.createElement("img");

            if (crossOrigin) {
                img.crossOrigin = crossOrigin;
            }

            img.onload = function () {
                var loadExif = function loadExif(callback) {
                    return callback(1);
                };
                if (typeof EXIF !== 'undefined' && EXIF !== null && fixOrientation) {
                    loadExif = function loadExif(callback) {
                        return EXIF.getData(img, function () {
                            return callback(EXIF.getTag(this, 'Orientation'));
                        });
                    };
                }

                return loadExif(function (orientation) {
                    file.width = img.width;
                    file.height = img.height;

                    var resizeInfo = _this13.options.resize.call(_this13, file, width, height, resizeMethod);

                    var canvas = document.createElement("canvas");
                    var ctx = canvas.getContext("2d");

                    canvas.width = resizeInfo.trgWidth;
                    canvas.height = resizeInfo.trgHeight;

                    if (orientation > 4) {
                        canvas.width = resizeInfo.trgHeight;
                        canvas.height = resizeInfo.trgWidth;
                    }

                    switch (orientation) {
                        case 2:
                            // horizontal flip
                            ctx.translate(canvas.width, 0);
                            ctx.scale(-1, 1);
                            break;
                        case 3:
                            // 180° rotate left
                            ctx.translate(canvas.width, canvas.height);
                            ctx.rotate(Math.PI);
                            break;
                        case 4:
                            // vertical flip
                            ctx.translate(0, canvas.height);
                            ctx.scale(1, -1);
                            break;
                        case 5:
                            // vertical flip + 90 rotate right
                            ctx.rotate(0.5 * Math.PI);
                            ctx.scale(1, -1);
                            break;
                        case 6:
                            // 90° rotate right
                            ctx.rotate(0.5 * Math.PI);
                            ctx.translate(0, -canvas.width);
                            break;
                        case 7:
                            // horizontal flip + 90 rotate right
                            ctx.rotate(0.5 * Math.PI);
                            ctx.translate(canvas.height, -canvas.width);
                            ctx.scale(-1, 1);
                            break;
                        case 8:
                            // 90° rotate left
                            ctx.rotate(-0.5 * Math.PI);
                            ctx.translate(-canvas.height, 0);
                            break;
                    }

                    // This is a bugfix for iOS' scaling bug.
                    drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);

                    var thumbnail = canvas.toDataURL("image/png");

                    if (callback != null) {
                        return callback(thumbnail, canvas);
                    }
                });
            };

            if (callback != null) {
                img.onerror = callback;
            }

            return img.src = file.dataURL;
        }

        // Goes through the queue and processes files if there aren't too many already.

    }, {
        key: "processQueue",
        value: function processQueue() {
            var parallelUploads = this.options.parallelUploads;

            var processingLength = this.getUploadingFiles().length;
            var i = processingLength;

            // There are already at least as many files uploading than should be
            if (processingLength >= parallelUploads) {
                return;
            }

            var queuedFiles = this.getQueuedFiles();

            if (!(queuedFiles.length > 0)) {
                return;
            }

            if (this.options.uploadMultiple) {
                // The files should be uploaded in one request
                return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
            } else {
                while (i < parallelUploads) {
                    if (!queuedFiles.length) {
                        return;
                    } // Nothing left to process
                    this.processFile(queuedFiles.shift());
                    i++;
                }
            }
        }

        // Wrapper for `processFiles`

    }, {
        key: "processFile",
        value: function processFile(file) {
            return this.processFiles([file]);
        }

        // Loads the file, then calls finishedLoading()

    }, {
        key: "processFiles",
        value: function processFiles(files) {
            for (var _iterator19 = files, _isArray19 = true, _i20 = 0, _iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator](); ;) {
                var _ref18;

                if (_isArray19) {
                    if (_i20 >= _iterator19.length) break;
                    _ref18 = _iterator19[_i20++];
                } else {
                    _i20 = _iterator19.next();
                    if (_i20.done) break;
                    _ref18 = _i20.value;
                }

                var file = _ref18;

                file.processing = true; // Backwards compatibility
                file.status = Dropzone.UPLOADING;

                this.emit("processing", file);
            }

            if (this.options.uploadMultiple) {
                this.emit("processingmultiple", files);
            }

            return this.uploadFiles(files);
        }
    }, {
        key: "_getFilesWithXhr",
        value: function _getFilesWithXhr(xhr) {
            var files = void 0;
            return files = this.files.filter(function (file) {
                return file.xhr === xhr;
            }).map(function (file) {
                return file;
            });
        }

        // Cancels the file upload and sets the status to CANCELED
        // **if** the file is actually being uploaded.
        // If it's still in the queue, the file is being removed from it and the status
        // set to CANCELED.

    }, {
        key: "cancelUpload",
        value: function cancelUpload(file) {
            if (file.status === Dropzone.UPLOADING) {
                var groupedFiles = this._getFilesWithXhr(file.xhr);
                for (var _iterator20 = groupedFiles, _isArray20 = true, _i21 = 0, _iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator](); ;) {
                    var _ref19;

                    if (_isArray20) {
                        if (_i21 >= _iterator20.length) break;
                        _ref19 = _iterator20[_i21++];
                    } else {
                        _i21 = _iterator20.next();
                        if (_i21.done) break;
                        _ref19 = _i21.value;
                    }

                    var groupedFile = _ref19;

                    groupedFile.status = Dropzone.CANCELED;
                }
                if (typeof file.xhr !== 'undefined') {
                    file.xhr.abort();
                }
                for (var _iterator21 = groupedFiles, _isArray21 = true, _i22 = 0, _iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator](); ;) {
                    var _ref20;

                    if (_isArray21) {
                        if (_i22 >= _iterator21.length) break;
                        _ref20 = _iterator21[_i22++];
                    } else {
                        _i22 = _iterator21.next();
                        if (_i22.done) break;
                        _ref20 = _i22.value;
                    }

                    var _groupedFile = _ref20;

                    this.emit("canceled", _groupedFile);
                }
                if (this.options.uploadMultiple) {
                    this.emit("canceledmultiple", groupedFiles);
                }
            } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {
                file.status = Dropzone.CANCELED;
                this.emit("canceled", file);
                if (this.options.uploadMultiple) {
                    this.emit("canceledmultiple", [file]);
                }
            }

            if (this.options.autoProcessQueue) {
                return this.processQueue();
            }
        }
    }, {
        key: "resolveOption",
        value: function resolveOption(option) {
            if (typeof option === 'function') {
                for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                    args[_key3 - 1] = arguments[_key3];
                }

                return option.apply(this, args);
            }
            return option;
        }
    }, {
        key: "uploadFile",
        value: function uploadFile(file) {
            return this.uploadFiles([file]);
        }
    }, {
        key: "uploadFiles",
        value: function uploadFiles(files) {
            var _this14 = this;

            this._transformFiles(files, function (transformedFiles) {
                if (files[0].upload.chunked) {
                    // This file should be sent in chunks!

                    // If the chunking option is set, we **know** that there can only be **one** file, since
                    // uploadMultiple is not allowed with this option.
                    var file = files[0];
                    var transformedFile = transformedFiles[0];
                    var startedChunkCount = 0;

                    file.upload.chunks = [];

                    var handleNextChunk = function handleNextChunk() {
                        var chunkIndex = 0;

                        // Find the next item in file.upload.chunks that is not defined yet.
                        while (file.upload.chunks[chunkIndex] !== undefined) {
                            chunkIndex++;
                        }

                        // This means, that all chunks have already been started.
                        if (chunkIndex >= file.upload.totalChunkCount) return;

                        startedChunkCount++;

                        var start = chunkIndex * _this14.options.chunkSize;
                        var end = Math.min(start + _this14.options.chunkSize, file.size);

                        var dataBlock = {
                            name: _this14._getParamName(0),
                            data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),
                            filename: file.upload.filename,
                            chunkIndex: chunkIndex
                        };

                        file.upload.chunks[chunkIndex] = {
                            file: file,
                            index: chunkIndex,
                            dataBlock: dataBlock, // In case we want to retry.
                            status: Dropzone.UPLOADING,
                            progress: 0,
                            retries: 0 // The number of times this block has been retried.
                        };

                        _this14._uploadData(files, [dataBlock]);
                    };

                    file.upload.finishedChunkUpload = function (chunk) {
                        var allFinished = true;
                        chunk.status = Dropzone.SUCCESS;

                        // Clear the data from the chunk
                        chunk.dataBlock = null;
                        // Leaving this reference to xhr intact here will cause memory leaks in some browsers
                        chunk.xhr = null;

                        for (var i = 0; i < file.upload.totalChunkCount; i++) {
                            if (file.upload.chunks[i] === undefined) {
                                return handleNextChunk();
                            }
                            if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {
                                allFinished = false;
                            }
                        }

                        if (allFinished) {
                            _this14.options.chunksUploaded(file, function () {
                                _this14._finished(files, '', null);
                            });
                        }
                    };

                    if (_this14.options.parallelChunkUploads) {
                        for (var i = 0; i < file.upload.totalChunkCount; i++) {
                            handleNextChunk();
                        }
                    } else {
                        handleNextChunk();
                    }
                } else {
                    var dataBlocks = [];
                    for (var _i23 = 0; _i23 < files.length; _i23++) {
                        dataBlocks[_i23] = {
                            name: _this14._getParamName(_i23),
                            data: transformedFiles[_i23],
                            filename: files[_i23].upload.filename
                        };
                    }
                    _this14._uploadData(files, dataBlocks);
                }
            });
        }

        /// Returns the right chunk for given file and xhr

    }, {
        key: "_getChunk",
        value: function _getChunk(file, xhr) {
            for (var i = 0; i < file.upload.totalChunkCount; i++) {
                if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {
                    return file.upload.chunks[i];
                }
            }
        }

        // This function actually uploads the file(s) to the server.
        // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed
        // files, or individual chunks for chunked upload).

    }, {
        key: "_uploadData",
        value: function _uploadData(files, dataBlocks) {
            var _this15 = this;

            var xhr = new XMLHttpRequest();

            // Put the xhr object in the file objects to be able to reference it later.
            for (var _iterator22 = files, _isArray22 = true, _i24 = 0, _iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator](); ;) {
                var _ref21;

                if (_isArray22) {
                    if (_i24 >= _iterator22.length) break;
                    _ref21 = _iterator22[_i24++];
                } else {
                    _i24 = _iterator22.next();
                    if (_i24.done) break;
                    _ref21 = _i24.value;
                }

                var file = _ref21;

                file.xhr = xhr;
            }
            if (files[0].upload.chunked) {
                // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk
                files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
            }

            var method = this.resolveOption(this.options.method, files);
            var url = this.resolveOption(this.options.url, files);
            xhr.open(method, url, true);

            // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8
            xhr.timeout = this.resolveOption(this.options.timeout, files);

            // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179
            xhr.withCredentials = !!this.options.withCredentials;

            xhr.onload = function (e) {
                _this15._finishedUploading(files, xhr, e);
            };

            xhr.onerror = function () {
                _this15._handleUploadError(files, xhr);
            };

            // Some browsers do not have the .upload property
            var progressObj = xhr.upload != null ? xhr.upload : xhr;
            progressObj.onprogress = function (e) {
                return _this15._updateFilesUploadProgress(files, xhr, e);
            };

            var headers = {
                "Accept": "application/json",
                "Cache-Control": "no-cache",
                "X-Requested-With": "XMLHttpRequest"
            };

            if (this.options.headers) {
                Dropzone.extend(headers, this.options.headers);
            }

            for (var headerName in headers) {
                var headerValue = headers[headerName];
                if (headerValue) {
                    xhr.setRequestHeader(headerName, headerValue);
                }
            }

            var formData = new FormData();

            // Adding all @options parameters
            if (this.options.params) {
                var additionalParams = this.options.params;
                if (typeof additionalParams === 'function') {
                    additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
                }

                for (var key in additionalParams) {
                    var value = additionalParams[key];
                    formData.append(key, value);
                }
            }

            // Let the user add additional data if necessary
            for (var _iterator23 = files, _isArray23 = true, _i25 = 0, _iterator23 = _isArray23 ? _iterator23 : _iterator23[Symbol.iterator](); ;) {
                var _ref22;

                if (_isArray23) {
                    if (_i25 >= _iterator23.length) break;
                    _ref22 = _iterator23[_i25++];
                } else {
                    _i25 = _iterator23.next();
                    if (_i25.done) break;
                    _ref22 = _i25.value;
                }

                var _file = _ref22;

                this.emit("sending", _file, xhr, formData);
            }
            if (this.options.uploadMultiple) {
                this.emit("sendingmultiple", files, xhr, formData);
            }

            this._addFormElementData(formData);

            // Finally add the files
            // Has to be last because some servers (eg: S3) expect the file to be the last parameter
            for (var i = 0; i < dataBlocks.length; i++) {
                var dataBlock = dataBlocks[i];
                formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
            }

            this.submitRequest(xhr, formData, files);
        }

        // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.

    }, {
        key: "_transformFiles",
        value: function _transformFiles(files, done) {
            var _this16 = this;

            var transformedFiles = [];
            // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.
            var doneCounter = 0;

            var _loop = function _loop(i) {
                _this16.options.transformFile.call(_this16, files[i], function (transformedFile) {
                    transformedFiles[i] = transformedFile;
                    if (++doneCounter === files.length) {
                        done(transformedFiles);
                    }
                });
            };

            for (var i = 0; i < files.length; i++) {
                _loop(i);
            }
        }

        // Takes care of adding other input elements of the form to the AJAX request

    }, {
        key: "_addFormElementData",
        value: function _addFormElementData(formData) {
            // Take care of other input elements
            if (this.element.tagName === "FORM") {
                for (var _iterator24 = this.element.querySelectorAll("input, textarea, select, button"), _isArray24 = true, _i26 = 0, _iterator24 = _isArray24 ? _iterator24 : _iterator24[Symbol.iterator](); ;) {
                    var _ref23;

                    if (_isArray24) {
                        if (_i26 >= _iterator24.length) break;
                        _ref23 = _iterator24[_i26++];
                    } else {
                        _i26 = _iterator24.next();
                        if (_i26.done) break;
                        _ref23 = _i26.value;
                    }

                    var input = _ref23;

                    var inputName = input.getAttribute("name");
                    var inputType = input.getAttribute("type");
                    if (inputType) inputType = inputType.toLowerCase();

                    // If the input doesn't have a name, we can't use it.
                    if (typeof inputName === 'undefined' || inputName === null) continue;

                    if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
                        // Possibly multiple values
                        for (var _iterator25 = input.options, _isArray25 = true, _i27 = 0, _iterator25 = _isArray25 ? _iterator25 : _iterator25[Symbol.iterator](); ;) {
                            var _ref24;

                            if (_isArray25) {
                                if (_i27 >= _iterator25.length) break;
                                _ref24 = _iterator25[_i27++];
                            } else {
                                _i27 = _iterator25.next();
                                if (_i27.done) break;
                                _ref24 = _i27.value;
                            }

                            var option = _ref24;

                            if (option.selected) {
                                formData.append(inputName, option.value);
                            }
                        }
                    } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) {
                        formData.append(inputName, input.value);
                    }
                }
            }
        }

        // Invoked when there is new progress information about given files.
        // If e is not provided, it is assumed that the upload is finished.

    }, {
        key: "_updateFilesUploadProgress",
        value: function _updateFilesUploadProgress(files, xhr, e) {
            var progress = void 0;
            if (typeof e !== 'undefined') {
                progress = 100 * e.loaded / e.total;

                if (files[0].upload.chunked) {
                    var file = files[0];
                    // Since this is a chunked upload, we need to update the appropriate chunk progress.
                    var chunk = this._getChunk(file, xhr);
                    chunk.progress = progress;
                    chunk.total = e.total;
                    chunk.bytesSent = e.loaded;
                    var fileProgress = 0,
                        fileTotal = void 0,
                        fileBytesSent = void 0;
                    file.upload.progress = 0;
                    file.upload.total = 0;
                    file.upload.bytesSent = 0;
                    for (var i = 0; i < file.upload.totalChunkCount; i++) {
                        if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].progress !== undefined) {
                            file.upload.progress += file.upload.chunks[i].progress;
                            file.upload.total += file.upload.chunks[i].total;
                            file.upload.bytesSent += file.upload.chunks[i].bytesSent;
                        }
                    }
                    file.upload.progress = file.upload.progress / file.upload.totalChunkCount;
                } else {
                    for (var _iterator26 = files, _isArray26 = true, _i28 = 0, _iterator26 = _isArray26 ? _iterator26 : _iterator26[Symbol.iterator](); ;) {
                        var _ref25;

                        if (_isArray26) {
                            if (_i28 >= _iterator26.length) break;
                            _ref25 = _iterator26[_i28++];
                        } else {
                            _i28 = _iterator26.next();
                            if (_i28.done) break;
                            _ref25 = _i28.value;
                        }

                        var _file2 = _ref25;

                        _file2.upload.progress = progress;
                        _file2.upload.total = e.total;
                        _file2.upload.bytesSent = e.loaded;
                    }
                }
                for (var _iterator27 = files, _isArray27 = true, _i29 = 0, _iterator27 = _isArray27 ? _iterator27 : _iterator27[Symbol.iterator](); ;) {
                    var _ref26;

                    if (_isArray27) {
                        if (_i29 >= _iterator27.length) break;
                        _ref26 = _iterator27[_i29++];
                    } else {
                        _i29 = _iterator27.next();
                        if (_i29.done) break;
                        _ref26 = _i29.value;
                    }

                    var _file3 = _ref26;

                    this.emit("uploadprogress", _file3, _file3.upload.progress, _file3.upload.bytesSent);
                }
            } else {
                // Called when the file finished uploading

                var allFilesFinished = true;

                progress = 100;

                for (var _iterator28 = files, _isArray28 = true, _i30 = 0, _iterator28 = _isArray28 ? _iterator28 : _iterator28[Symbol.iterator](); ;) {
                    var _ref27;

                    if (_isArray28) {
                        if (_i30 >= _iterator28.length) break;
                        _ref27 = _iterator28[_i30++];
                    } else {
                        _i30 = _iterator28.next();
                        if (_i30.done) break;
                        _ref27 = _i30.value;
                    }

                    var _file4 = _ref27;

                    if (_file4.upload.progress !== 100 || _file4.upload.bytesSent !== _file4.upload.total) {
                        allFilesFinished = false;
                    }
                    _file4.upload.progress = progress;
                    _file4.upload.bytesSent = _file4.upload.total;
                }

                // Nothing to do, all files already at 100%
                if (allFilesFinished) {
                    return;
                }

                for (var _iterator29 = files, _isArray29 = true, _i31 = 0, _iterator29 = _isArray29 ? _iterator29 : _iterator29[Symbol.iterator](); ;) {
                    var _ref28;

                    if (_isArray29) {
                        if (_i31 >= _iterator29.length) break;
                        _ref28 = _iterator29[_i31++];
                    } else {
                        _i31 = _iterator29.next();
                        if (_i31.done) break;
                        _ref28 = _i31.value;
                    }

                    var _file5 = _ref28;

                    this.emit("uploadprogress", _file5, progress, _file5.upload.bytesSent);
                }
            }
        }
    }, {
        key: "_finishedUploading",
        value: function _finishedUploading(files, xhr, e) {
            var response = void 0;

            if (files[0].status === Dropzone.CANCELED) {
                return;
            }

            if (xhr.readyState !== 4) {
                return;
            }

            if (xhr.responseType !== 'arraybuffer' && xhr.responseType !== 'blob') {
                response = xhr.responseText;

                if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {
                    try {
                        response = JSON.parse(response);
                    } catch (error) {
                        e = error;
                        response = "Invalid JSON response from server.";
                    }
                }
            }

            this._updateFilesUploadProgress(files);

            if (!(200 <= xhr.status && xhr.status < 300)) {
                this._handleUploadError(files, xhr, response);
            } else {
                if (files[0].upload.chunked) {
                    files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr));
                } else {
                    this._finished(files, response, e);
                }
            }
        }
    }, {
        key: "_handleUploadError",
        value: function _handleUploadError(files, xhr, response) {
            if (files[0].status === Dropzone.CANCELED) {
                return;
            }

            if (files[0].upload.chunked && this.options.retryChunks) {
                var chunk = this._getChunk(files[0], xhr);
                if (chunk.retries++ < this.options.retryChunksLimit) {
                    this._uploadData(files, [chunk.dataBlock]);
                    return;
                } else {
                    console.warn('Retried this chunk too often. Giving up.');
                }
            }

            for (var _iterator30 = files, _isArray30 = true, _i32 = 0, _iterator30 = _isArray30 ? _iterator30 : _iterator30[Symbol.iterator](); ;) {
                var _ref29;

                if (_isArray30) {
                    if (_i32 >= _iterator30.length) break;
                    _ref29 = _iterator30[_i32++];
                } else {
                    _i32 = _iterator30.next();
                    if (_i32.done) break;
                    _ref29 = _i32.value;
                }

                var file = _ref29;

                this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
            }
        }
    }, {
        key: "submitRequest",
        value: function submitRequest(xhr, formData, files) {
            xhr.send(formData);
        }

        // Called internally when processing is finished.
        // Individual callbacks have to be called in the appropriate sections.

    }, {
        key: "_finished",
        value: function _finished(files, responseText, e) {
            for (var _iterator31 = files, _isArray31 = true, _i33 = 0, _iterator31 = _isArray31 ? _iterator31 : _iterator31[Symbol.iterator](); ;) {
                var _ref30;

                if (_isArray31) {
                    if (_i33 >= _iterator31.length) break;
                    _ref30 = _iterator31[_i33++];
                } else {
                    _i33 = _iterator31.next();
                    if (_i33.done) break;
                    _ref30 = _i33.value;
                }

                var file = _ref30;

                file.status = Dropzone.SUCCESS;
                this.emit("success", file, responseText, e);
                this.emit("complete", file);
            }
            if (this.options.uploadMultiple) {
                this.emit("successmultiple", files, responseText, e);
                this.emit("completemultiple", files);
            }

            if (this.options.autoProcessQueue) {
                return this.processQueue();
            }
        }

        // Called internally when processing is finished.
        // Individual callbacks have to be called in the appropriate sections.

    }, {
        key: "_errorProcessing",
        value: function _errorProcessing(files, message, xhr) {
            for (var _iterator32 = files, _isArray32 = true, _i34 = 0, _iterator32 = _isArray32 ? _iterator32 : _iterator32[Symbol.iterator](); ;) {
                var _ref31;

                if (_isArray32) {
                    if (_i34 >= _iterator32.length) break;
                    _ref31 = _iterator32[_i34++];
                } else {
                    _i34 = _iterator32.next();
                    if (_i34.done) break;
                    _ref31 = _i34.value;
                }

                var file = _ref31;

                file.status = Dropzone.ERROR;
                this.emit("error", file, message, xhr);
                this.emit("complete", file);
            }
            if (this.options.uploadMultiple) {
                this.emit("errormultiple", files, message, xhr);
                this.emit("completemultiple", files);
            }

            if (this.options.autoProcessQueue) {
                return this.processQueue();
            }
        }
    }], [{
        key: "uuidv4",
        value: function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0,
                    v = c === 'x' ? r : r & 0x3 | 0x8;
                return v.toString(16);
            });
        }
    }]);

    return Dropzone;
}(Emitter);

Dropzone.initClass();

Dropzone.version = "5.5.1";

// This is a map of options for your different dropzones. Add configurations
// to this object for your different dropzone elemens.
//
// Example:
//
//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
//
// To disable autoDiscover for a specific element, you can set `false` as an option:
//
//     Dropzone.options.myDisabledElementId = false;
//
// And in html:
//
//     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>
Dropzone.options = {};

// Returns the options for an element or undefined if none available.
Dropzone.optionsForElement = function (element) {
    // Get the `Dropzone.options.elementId` for this element if it exists
    if (element.getAttribute("id")) {
        return Dropzone.options[camelize(element.getAttribute("id"))];
    } else {
        return undefined;
    }
};

// Holds a list of all dropzone instances
Dropzone.instances = [];

// Returns the dropzone for given element if any
Dropzone.forElement = function (element) {
    if (typeof element === "string") {
        element = document.querySelector(element);
    }
    if ((element != null ? element.dropzone : undefined) == null) {
        throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
    }
    return element.dropzone;
};

// Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.
Dropzone.autoDiscover = true;

// Looks for all .dropzone elements and creates a dropzone for them
Dropzone.discover = function () {
    var dropzones = void 0;
    if (document.querySelectorAll) {
        dropzones = document.querySelectorAll(".dropzone");
    } else {
        dropzones = [];
        // IE :(
        var checkElements = function checkElements(elements) {
            return function () {
                var result = [];
                for (var _iterator33 = elements, _isArray33 = true, _i35 = 0, _iterator33 = _isArray33 ? _iterator33 : _iterator33[Symbol.iterator](); ;) {
                    var _ref32;

                    if (_isArray33) {
                        if (_i35 >= _iterator33.length) break;
                        _ref32 = _iterator33[_i35++];
                    } else {
                        _i35 = _iterator33.next();
                        if (_i35.done) break;
                        _ref32 = _i35.value;
                    }

                    var el = _ref32;

                    if (/(^| )dropzone($| )/.test(el.className)) {
                        result.push(dropzones.push(el));
                    } else {
                        result.push(undefined);
                    }
                }
                return result;
            }();
        };
        checkElements(document.getElementsByTagName("div"));
        checkElements(document.getElementsByTagName("form"));
    }

    return function () {
        var result = [];
        for (var _iterator34 = dropzones, _isArray34 = true, _i36 = 0, _iterator34 = _isArray34 ? _iterator34 : _iterator34[Symbol.iterator](); ;) {
            var _ref33;

            if (_isArray34) {
                if (_i36 >= _iterator34.length) break;
                _ref33 = _iterator34[_i36++];
            } else {
                _i36 = _iterator34.next();
                if (_i36.done) break;
                _ref33 = _i36.value;
            }

            var dropzone = _ref33;

            // Create a dropzone unless auto discover has been disabled for specific element
            if (Dropzone.optionsForElement(dropzone) !== false) {
                result.push(new Dropzone(dropzone));
            } else {
                result.push(undefined);
            }
        }
        return result;
    }();
};

// Since the whole Drag'n'Drop API is pretty new, some browsers implement it,
// but not correctly.
// So I created a blacklist of userAgents. Yes, yes. Browser sniffing, I know.
// But what to do when browsers *theoretically* support an API, but crash
// when using it.
//
// This is a list of regular expressions tested against navigator.userAgent
//
// ** It should only be used on browser that *do* support the API, but
// incorrectly **
//
Dropzone.blacklistedBrowsers = [
// The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
    /opera.*(Macintosh|Windows Phone).*version\/12/i];

// Checks if the browser is supported
Dropzone.isBrowserSupported = function () {
    var capableBrowser = true;

    if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
        if (!("classList" in document.createElement("a"))) {
            capableBrowser = false;
        } else {
            // The browser supports the API, but may be blacklisted.
            for (var _iterator35 = Dropzone.blacklistedBrowsers, _isArray35 = true, _i37 = 0, _iterator35 = _isArray35 ? _iterator35 : _iterator35[Symbol.iterator](); ;) {
                var _ref34;

                if (_isArray35) {
                    if (_i37 >= _iterator35.length) break;
                    _ref34 = _iterator35[_i37++];
                } else {
                    _i37 = _iterator35.next();
                    if (_i37.done) break;
                    _ref34 = _i37.value;
                }

                var regex = _ref34;

                if (regex.test(navigator.userAgent)) {
                    capableBrowser = false;
                    continue;
                }
            }
        }
    } else {
        capableBrowser = false;
    }

    return capableBrowser;
};

Dropzone.dataURItoBlob = function (dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    var byteString = atob(dataURI.split(',')[1]);

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {
        ia[i] = byteString.charCodeAt(i);
    }

    // write the ArrayBuffer to a blob
    return new Blob([ab], {type: mimeString});
};

// Returns an array without the rejected item
var without = function without(list, rejectedItem) {
    return list.filter(function (item) {
        return item !== rejectedItem;
    }).map(function (item) {
        return item;
    });
};

// abc-def_ghi -> abcDefGhi
var camelize = function camelize(str) {
    return str.replace(/[\-_](\w)/g, function (match) {
        return match.charAt(1).toUpperCase();
    });
};

// Creates an element from string
Dropzone.createElement = function (string) {
    var div = document.createElement("div");
    div.innerHTML = string;
    return div.childNodes[0];
};

// Tests if given element is inside (or simply is) the container
Dropzone.elementInside = function (element, container) {
    if (element === container) {
        return true;
    } // Coffeescript doesn't support do/while loops
    while (element = element.parentNode) {
        if (element === container) {
            return true;
        }
    }
    return false;
};

Dropzone.getElement = function (el, name) {
    var element = void 0;
    if (typeof el === "string") {
        element = document.querySelector(el);
    } else if (el.nodeType != null) {
        element = el;
    }
    if (element == null) {
        throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector or a plain HTML element.");
    }
    return element;
};

Dropzone.getElements = function (els, name) {
    var el = void 0,
        elements = void 0;
    if (els instanceof Array) {
        elements = [];
        try {
            for (var _iterator36 = els, _isArray36 = true, _i38 = 0, _iterator36 = _isArray36 ? _iterator36 : _iterator36[Symbol.iterator](); ;) {
                if (_isArray36) {
                    if (_i38 >= _iterator36.length) break;
                    el = _iterator36[_i38++];
                } else {
                    _i38 = _iterator36.next();
                    if (_i38.done) break;
                    el = _i38.value;
                }

                elements.push(this.getElement(el, name));
            }
        } catch (e) {
            elements = null;
        }
    } else if (typeof els === "string") {
        elements = [];
        for (var _iterator37 = document.querySelectorAll(els), _isArray37 = true, _i39 = 0, _iterator37 = _isArray37 ? _iterator37 : _iterator37[Symbol.iterator](); ;) {
            if (_isArray37) {
                if (_i39 >= _iterator37.length) break;
                el = _iterator37[_i39++];
            } else {
                _i39 = _iterator37.next();
                if (_i39.done) break;
                el = _i39.value;
            }

            elements.push(el);
        }
    } else if (els.nodeType != null) {
        elements = [els];
    }

    if (elements == null || !elements.length) {
        throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");
    }

    return elements;
};

// Asks the user the question and calls accepted or rejected accordingly
//
// The default implementation just uses `window.confirm` and then calls the
// appropriate callback.
Dropzone.confirm = function (question, accepted, rejected) {
    if (window.confirm(question)) {
        return accepted();
    } else if (rejected != null) {
        return rejected();
    }
};

// Validates the mime type like this:
//
// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept
Dropzone.isValidFile = function (file, acceptedFiles) {
    if (!acceptedFiles) {
        return true;
    } // If there are no accepted mime types, it's OK
    acceptedFiles = acceptedFiles.split(",");

    var mimeType = file.type;
    var baseMimeType = mimeType.replace(/\/.*$/, "");

    for (var _iterator38 = acceptedFiles, _isArray38 = true, _i40 = 0, _iterator38 = _isArray38 ? _iterator38 : _iterator38[Symbol.iterator](); ;) {
        var _ref35;

        if (_isArray38) {
            if (_i40 >= _iterator38.length) break;
            _ref35 = _iterator38[_i40++];
        } else {
            _i40 = _iterator38.next();
            if (_i40.done) break;
            _ref35 = _i40.value;
        }

        var validType = _ref35;

        validType = validType.trim();
        if (validType.charAt(0) === ".") {
            if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {
                return true;
            }
        } else if (/\/\*$/.test(validType)) {
            // This is something like a image/* mime type
            if (baseMimeType === validType.replace(/\/.*$/, "")) {
                return true;
            }
        } else {
            if (mimeType === validType) {
                return true;
            }
        }
    }

    return false;
};

// Augment jQuery
if (typeof jQuery !== 'undefined' && jQuery !== null) {
    jQuery.fn.dropzone = function (options) {
        return this.each(function () {
            return new Dropzone(this, options);
        });
    };
}

if (typeof module !== 'undefined' && module !== null) {
    module.exports = Dropzone;
} else {
    window.Dropzone = Dropzone;
}

// Dropzone file status codes
Dropzone.ADDED = "added";

Dropzone.QUEUED = "queued";
// For backwards compatibility. Now, if a file is accepted, it's either queued
// or uploading.
Dropzone.ACCEPTED = Dropzone.QUEUED;

Dropzone.UPLOADING = "uploading";
Dropzone.PROCESSING = Dropzone.UPLOADING; // alias

Dropzone.CANCELED = "canceled";
Dropzone.ERROR = "error";
Dropzone.SUCCESS = "success";

/*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */

// Detecting vertical squash in loaded image.
// Fixes a bug which squash image vertically while drawing into canvas for some images.
// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
var detectVerticalSquash = function detectVerticalSquash(img) {
    var iw = img.naturalWidth;
    var ih = img.naturalHeight;
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = ih;
    var ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),
        data = _ctx$getImageData.data;

    // search image edge pixel position in case it is squashed vertically.


    var sy = 0;
    var ey = ih;
    var py = ih;
    while (py > sy) {
        var alpha = data[(py - 1) * 4 + 3];

        if (alpha === 0) {
            ey = py;
        } else {
            sy = py;
        }

        py = ey + sy >> 1;
    }
    var ratio = py / ih;

    if (ratio === 0) {
        return 1;
    } else {
        return ratio;
    }
};

// A replacement for context.drawImage
// (args are for source and destination).
var drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
    var vertSquashRatio = detectVerticalSquash(img);
    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
};

// Based on MinifyJpeg
// Source: http://www.perry.cz/files/ExifRestorer.js
// http://elicon.blog57.fc2.com/blog-entry-206.html

var ExifRestore = function () {
    function ExifRestore() {
        _classCallCheck(this, ExifRestore);
    }

    _createClass(ExifRestore, null, [{
        key: "initClass",
        value: function initClass() {
            this.KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        }
    }, {
        key: "encode64",
        value: function encode64(input) {
            var output = '';
            var chr1 = undefined;
            var chr2 = undefined;
            var chr3 = '';
            var enc1 = undefined;
            var enc2 = undefined;
            var enc3 = undefined;
            var enc4 = '';
            var i = 0;
            while (true) {
                chr1 = input[i++];
                chr2 = input[i++];
                chr3 = input[i++];
                enc1 = chr1 >> 2;
                enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                enc4 = chr3 & 63;
                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }
                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
                if (!(i < input.length)) {
                    break;
                }
            }
            return output;
        }
    }, {
        key: "restore",
        value: function restore(origFileBase64, resizedFileBase64) {
            if (!origFileBase64.match('data:image/jpeg;base64,')) {
                return resizedFileBase64;
            }
            var rawImage = this.decode64(origFileBase64.replace('data:image/jpeg;base64,', ''));
            var segments = this.slice2Segments(rawImage);
            var image = this.exifManipulation(resizedFileBase64, segments);
            return "data:image/jpeg;base64," + this.encode64(image);
        }
    }, {
        key: "exifManipulation",
        value: function exifManipulation(resizedFileBase64, segments) {
            var exifArray = this.getExifArray(segments);
            var newImageArray = this.insertExif(resizedFileBase64, exifArray);
            var aBuffer = new Uint8Array(newImageArray);
            return aBuffer;
        }
    }, {
        key: "getExifArray",
        value: function getExifArray(segments) {
            var seg = undefined;
            var x = 0;
            while (x < segments.length) {
                seg = segments[x];
                if (seg[0] === 255 & seg[1] === 225) {
                    return seg;
                }
                x++;
            }
            return [];
        }
    }, {
        key: "insertExif",
        value: function insertExif(resizedFileBase64, exifArray) {
            var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', '');
            var buf = this.decode64(imageData);
            var separatePoint = buf.indexOf(255, 3);
            var mae = buf.slice(0, separatePoint);
            var ato = buf.slice(separatePoint);
            var array = mae;
            array = array.concat(exifArray);
            array = array.concat(ato);
            return array;
        }
    }, {
        key: "slice2Segments",
        value: function slice2Segments(rawImageArray) {
            var head = 0;
            var segments = [];
            while (true) {
                var length;
                if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
                    break;
                }
                if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
                    head += 2;
                } else {
                    length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
                    var endPoint = head + length + 2;
                    var seg = rawImageArray.slice(head, endPoint);
                    segments.push(seg);
                    head = endPoint;
                }
                if (head > rawImageArray.length) {
                    break;
                }
            }
            return segments;
        }
    }, {
        key: "decode64",
        value: function decode64(input) {
            var output = '';
            var chr1 = undefined;
            var chr2 = undefined;
            var chr3 = '';
            var enc1 = undefined;
            var enc2 = undefined;
            var enc3 = undefined;
            var enc4 = '';
            var i = 0;
            var buf = [];
            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            var base64test = /[^A-Za-z0-9\+\/\=]/g;
            if (base64test.exec(input)) {
                console.warn('There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\nExpect errors in decoding.');
            }
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
            while (true) {
                enc1 = this.KEY_STR.indexOf(input.charAt(i++));
                enc2 = this.KEY_STR.indexOf(input.charAt(i++));
                enc3 = this.KEY_STR.indexOf(input.charAt(i++));
                enc4 = this.KEY_STR.indexOf(input.charAt(i++));
                chr1 = enc1 << 2 | enc2 >> 4;
                chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                chr3 = (enc3 & 3) << 6 | enc4;
                buf.push(chr1);
                if (enc3 !== 64) {
                    buf.push(chr2);
                }
                if (enc4 !== 64) {
                    buf.push(chr3);
                }
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
                if (!(i < input.length)) {
                    break;
                }
            }
            return buf;
        }
    }]);

    return ExifRestore;
}();

ExifRestore.initClass();

/*
 * contentloaded.js
 *
 * Author: Diego Perini (diego.perini at gmail.com)
 * Summary: cross-browser wrapper for DOMContentLoaded
 * Updated: 20101020
 * License: MIT
 * Version: 1.2
 *
 * URL:
 * http://javascript.nwbox.com/ContentLoaded/
 * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
 */

// @win window reference
// @fn function reference
var contentLoaded = function contentLoaded(win, fn) {
    var done = false;
    var top = true;
    var doc = win.document;
    var root = doc.documentElement;
    var add = doc.addEventListener ? "addEventListener" : "attachEvent";
    var rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
    var pre = doc.addEventListener ? "" : "on";
    var init = function init(e) {
        if (e.type === "readystatechange" && doc.readyState !== "complete") {
            return;
        }
        (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
        if (!done && (done = true)) {
            return fn.call(win, e.type || e);
        }
    };

    var poll = function poll() {
        try {
            root.doScroll("left");
        } catch (e) {
            setTimeout(poll, 50);
            return;
        }
        return init("poll");
    };

    if (doc.readyState !== "complete") {
        if (doc.createEventObject && root.doScroll) {
            try {
                top = !win.frameElement;
            } catch (error) {
            }
            if (top) {
                poll();
            }
        }
        doc[add](pre + "DOMContentLoaded", init, false);
        doc[add](pre + "readystatechange", init, false);
        return win[add](pre + "load", init, false);
    }
};

// As a single function to be able to write tests.
Dropzone._autoDiscoverFunction = function () {
    if (Dropzone.autoDiscover) {
        return Dropzone.discover();
    }
};
contentLoaded(window, Dropzone._autoDiscoverFunction);

function __guard__(value, transform) {
    return typeof value !== 'undefined' && value !== null ? transform(value) : undefined;
}

function __guardMethod__(obj, methodName, transform) {
    if (typeof obj !== 'undefined' && obj !== null && typeof obj[methodName] === 'function') {
        return transform(obj, methodName);
    } else {
        return undefined;
    }
}

/**
 * Super simple wysiwyg editor v0.8.10
 * https://summernote.org
 *
 * Copyright 2013- Alan Hong. and other contributors
 * summernote may be freely distributed under the MIT license.
 *
 * Date: 2018-02-20T00:34Z
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('jquery')) :
        typeof define === 'function' && define.amd ? define(['jquery'], factory) :
            (factory(global.jQuery));
}(this, (function ($$1) {
    'use strict';

    $$1 = $$1 && $$1.hasOwnProperty('default') ? $$1['default'] : $$1;

    var Renderer = /** @class */ (function () {
        function Renderer(markup, children, options, callback) {
            this.markup = markup;
            this.children = children;
            this.options = options;
            this.callback = callback;
        }

        Renderer.prototype.render = function ($parent) {
            var $node = $$1(this.markup);
            if (this.options && this.options.contents) {
                $node.html(this.options.contents);
            }
            if (this.options && this.options.className) {
                $node.addClass(this.options.className);
            }
            if (this.options && this.options.data) {
                $$1.each(this.options.data, function (k, v) {
                    $node.attr('data-' + k, v);
                });
            }
            if (this.options && this.options.click) {
                $node.on('click', this.options.click);
            }
            if (this.children) {
                var $container_1 = $node.find('.note-children-container');
                this.children.forEach(function (child) {
                    child.render($container_1.length ? $container_1 : $node);
                });
            }
            if (this.callback) {
                this.callback($node, this.options);
            }
            if (this.options && this.options.callback) {
                this.options.callback($node);
            }
            if ($parent) {
                $parent.append($node);
            }
            return $node;
        };
        return Renderer;
    }());
    var renderer = {
        create: function (markup, callback) {
            return function () {
                var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];
                var children = $$1.isArray(arguments[0]) ? arguments[0] : [];
                if (options && options.children) {
                    children = options.children;
                }
                return new Renderer(markup, children, options, callback);
            };
        }
    };

    var editor = renderer.create('<div class="note-editor note-frame panel"/>');
    var toolbar = renderer.create('<div class="note-toolbar-wrapper panel-default"><div class="note-toolbar panel-heading" role="toolbar"></div></div>');
    var editingArea = renderer.create('<div class="note-editing-area"/>');
    var codable = renderer.create('<textarea class="note-codable" role="textbox" aria-multiline="true"/>');
    var editable = renderer.create('<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"/>');
    var statusbar = renderer.create([
        '<output class="note-status-output" aria-live="polite"/>',
        '<div class="note-statusbar" role="status">',
        '  <div class="note-resizebar" role="seperator" aria-orientation="horizontal" aria-label="Resize">',
        '    <div class="note-icon-bar"/>',
        '    <div class="note-icon-bar"/>',
        '    <div class="note-icon-bar"/>',
        '  </div>',
        '</div>'
    ].join(''));
    var airEditor = renderer.create('<div class="note-editor"/>');
    var airEditable = renderer.create([
        '  <output class="note-status-output" aria-live="polite"/>',
        '<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"/>'
    ].join(''));
    var buttonGroup = renderer.create('<div class="note-btn-group btn-group">');
    var dropdown = renderer.create('<ul class="dropdown-menu" role="list">', function ($node, options) {
        var markup = $$1.isArray(options.items) ? options.items.map(function (item) {
            var value = (typeof item === 'string') ? item : (item.value || '');
            var content = options.template ? options.template(item) : item;
            var option = (typeof item === 'object') ? item.option : undefined;
            var dataValue = 'data-value="' + value + '"';
            var dataOption = (option !== undefined) ? ' data-option="' + option + '"' : '';
            return '<li role="listitem" aria-label="' + item + '"><a href="#" ' + (dataValue + dataOption) + '>' + content + '</a></li>';
        }).join('') : options.items;
        $node.html(markup).attr({'aria-label': options.title});
    });
    var dropdownButtonContents = function (contents, options) {
        return contents + ' ' + icon(options.icons.caret, 'span');
    };
    var dropdownCheck = renderer.create('<ul class="dropdown-menu note-check" role="list">', function ($node, options) {
        var markup = $$1.isArray(options.items) ? options.items.map(function (item) {
            var value = (typeof item === 'string') ? item : (item.value || '');
            var content = options.template ? options.template(item) : item;
            return '<li role="listitem" aria-label="' + item + '"><a href="#" data-value="' + value + '">' + icon(options.checkClassName) + ' ' + content + '</a></li>';
        }).join('') : options.items;
        $node.html(markup).attr({'aria-label': options.title});
    });
    var palette = renderer.create('<div class="note-color-palette"/>', function ($node, options) {
        var contents = [];
        for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {
            var eventName = options.eventName;
            var colors = options.colors[row];
            var colorsName = options.colorsName[row];
            var buttons = [];
            for (var col = 0, colSize = colors.length; col < colSize; col++) {
                var color = colors[col];
                var colorName = colorsName[col];
                buttons.push([
                    '<button type="button" class="note-color-btn"',
                    'style="background-color:', color, '" ',
                    'data-event="', eventName, '" ',
                    'data-value="', color, '" ',
                    'title="', colorName, '" ',
                    'aria-label="', colorName, '" ',
                    'data-toggle="button" tabindex="-1"></button>'
                ].join(''));
            }
            contents.push('<div class="note-color-row">' + buttons.join('') + '</div>');
        }
        $node.html(contents.join(''));
        if (options.tooltip) {
            $node.find('.note-color-btn').tooltip({
                container: options.container,
                trigger: 'hover',
                placement: 'bottom'
            });
        }
    });
    var dialog = renderer.create('<div class="modal" aria-hidden="false" tabindex="-1" role="dialog"/>', function ($node, options) {
        if (options.fade) {
            $node.addClass('fade');
        }
        $node.attr({
            'aria-label': options.title
        });
        $node.html([
            '<div class="modal-dialog">',
            '  <div class="modal-content">',
            (options.title
                ? '    <div class="modal-header">' +
                '      <button type="button" class="close" data-dismiss="modal" aria-label="Close" aria-hidden="true">&times;</button>' +
                '      <h4 class="modal-title">' + options.title + '</h4>' +
                '    </div>' : ''),
            '    <div class="modal-body">' + options.body + '</div>',
            (options.footer
                ? '    <div class="modal-footer">' + options.footer + '</div>' : ''),
            '  </div>',
            '</div>'
        ].join(''));
    });
    var popover = renderer.create([
        '<div class="note-popover popover in">',
        '  <div class="arrow"/>',
        '  <div class="popover-content note-children-container"/>',
        '</div>'
    ].join(''), function ($node, options) {
        var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';
        $node.addClass(direction);
        if (options.hideArrow) {
            $node.find('.arrow').hide();
        }
    });
    var checkbox = renderer.create('<div class="checkbox"></div>', function ($node, options) {
        $node.html([
            ' <label' + (options.id ? ' for="' + options.id + '"' : '') + '>',
            ' <input role="checkbox" type="checkbox"' + (options.id ? ' id="' + options.id + '"' : ''),
            (options.checked ? ' checked' : ''),
            ' aria-checked="' + (options.checked ? 'true' : 'false') + '"/>',
            (options.text ? options.text : ''),
            '</label>'
        ].join(''));
    });
    var icon = function (iconClassName, tagName) {
        tagName = tagName || 'i';
        return '<' + tagName + ' class="' + iconClassName + '"/>';
    };
    var ui = {
        editor: editor,
        toolbar: toolbar,
        editingArea: editingArea,
        codable: codable,
        editable: editable,
        statusbar: statusbar,
        airEditor: airEditor,
        airEditable: airEditable,
        buttonGroup: buttonGroup,
        dropdown: dropdown,
        dropdownButtonContents: dropdownButtonContents,
        dropdownCheck: dropdownCheck,
        palette: palette,
        dialog: dialog,
        popover: popover,
        checkbox: checkbox,
        icon: icon,
        options: {},
        button: function ($node, options) {
            return renderer.create('<button type="button" class="note-btn btn btn-default btn-sm" role="button" tabindex="-1">', function ($node, options) {
                if (options && options.tooltip) {
                    $node.attr({
                        title: options.tooltip,
                        'aria-label': options.tooltip
                    }).tooltip({
                        container: options.container,
                        trigger: 'hover',
                        placement: 'bottom'
                    });
                }
            })($node, options);
        },
        toggleBtn: function ($btn, isEnable) {
            $btn.toggleClass('disabled', !isEnable);
            $btn.attr('disabled', !isEnable);
        },
        toggleBtnActive: function ($btn, isActive) {
            $btn.toggleClass('active', isActive);
        },
        onDialogShown: function ($dialog, handler) {
            $dialog.one('shown.bs.modal', handler);
        },
        onDialogHidden: function ($dialog, handler) {
            $dialog.one('hidden.bs.modal', handler);
        },
        showDialog: function ($dialog) {
            $dialog.modal('show');
        },
        hideDialog: function ($dialog) {
            $dialog.modal('hide');
        },
        createLayout: function ($note, options) {
            var $editor = (options.airMode ? ui.airEditor([
                ui.editingArea([
                    ui.airEditable()
                ])
            ]) : ui.editor([
                ui.toolbar(),
                ui.editingArea([
                    ui.codable(),
                    ui.editable()
                ]),
                ui.statusbar()
            ])).render();
            $editor.insertAfter($note);
            return {
                note: $note,
                editor: $editor,
                toolbar: $editor.find('.note-toolbar'),
                editingArea: $editor.find('.note-editing-area'),
                editable: $editor.find('.note-editable'),
                codable: $editor.find('.note-codable'),
                statusbar: $editor.find('.note-statusbar')
            };
        },
        removeLayout: function ($note, layoutInfo) {
            $note.html(layoutInfo.editable.html());
            layoutInfo.editor.remove();
            $note.show();
        }
    };

    /**
     * @class core.func
     *
     * func utils (for high-order func's arg)
     *
     * @singleton
     * @alternateClassName func
     */
    function eq(itemA) {
        return function (itemB) {
            return itemA === itemB;
        };
    }

    function eq2(itemA, itemB) {
        return itemA === itemB;
    }

    function peq2(propName) {
        return function (itemA, itemB) {
            return itemA[propName] === itemB[propName];
        };
    }

    function ok() {
        return true;
    }

    function fail() {
        return false;
    }

    function not(f) {
        return function () {
            return !f.apply(f, arguments);
        };
    }

    function and(fA, fB) {
        return function (item) {
            return fA(item) && fB(item);
        };
    }

    function self(a) {
        return a;
    }

    function invoke(obj, method) {
        return function () {
            return obj[method].apply(obj, arguments);
        };
    }

    var idCounter = 0;

    /**
     * generate a globally-unique id
     *
     * @param {String} [prefix]
     */
    function uniqueId(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    }

    /**
     * returns bnd (bounds) from rect
     *
     * - IE Compatibility Issue: http://goo.gl/sRLOAo
     * - Scroll Issue: http://goo.gl/sNjUc
     *
     * @param {Rect} rect
     * @return {Object} bounds
     * @return {Number} bounds.top
     * @return {Number} bounds.left
     * @return {Number} bounds.width
     * @return {Number} bounds.height
     */
    function rect2bnd(rect) {
        var $document = $(document);
        return {
            top: rect.top + $document.scrollTop(),
            left: rect.left + $document.scrollLeft(),
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
        };
    }

    /**
     * returns a copy of the object where the keys have become the values and the values the keys.
     * @param {Object} obj
     * @return {Object}
     */
    function invertObject(obj) {
        var inverted = {};
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                inverted[obj[key]] = key;
            }
        }
        return inverted;
    }

    /**
     * @param {String} namespace
     * @param {String} [prefix]
     * @return {String}
     */
    function namespaceToCamel(namespace, prefix) {
        prefix = prefix || '';
        return prefix + namespace.split('.').map(function (name) {
            return name.substring(0, 1).toUpperCase() + name.substring(1);
        }).join('');
    }

    /**
     * Returns a function, that, as long as it continues to be invoked, will not
     * be triggered. The function will be called after it stops being called for
     * N milliseconds. If `immediate` is passed, trigger the function on the
     * leading edge, instead of the trailing.
     * @param {Function} func
     * @param {Number} wait
     * @param {Boolean} immediate
     * @return {Function}
     */
    function debounce(func, wait, immediate) {
        var _this = this;
        var timeout;
        return function () {
            var context = _this;
            var args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) {
                    func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) {
                func.apply(context, args);
            }
        };
    }

    var func = {
        eq: eq,
        eq2: eq2,
        peq2: peq2,
        ok: ok,
        fail: fail,
        self: self,
        not: not,
        and: and,
        invoke: invoke,
        uniqueId: uniqueId,
        rect2bnd: rect2bnd,
        invertObject: invertObject,
        namespaceToCamel: namespaceToCamel,
        debounce: debounce
    };

    /**
     * returns the first item of an array.
     *
     * @param {Array} array
     */
    function head(array) {
        return array[0];
    }

    /**
     * returns the last item of an array.
     *
     * @param {Array} array
     */
    function last(array) {
        return array[array.length - 1];
    }

    /**
     * returns everything but the last entry of the array.
     *
     * @param {Array} array
     */
    function initial(array) {
        return array.slice(0, array.length - 1);
    }

    /**
     * returns the rest of the items in an array.
     *
     * @param {Array} array
     */
    function tail(array) {
        return array.slice(1);
    }

    /**
     * returns item of array
     */
    function find(array, pred) {
        for (var idx = 0, len = array.length; idx < len; idx++) {
            var item = array[idx];
            if (pred(item)) {
                return item;
            }
        }
    }

    /**
     * returns true if all of the values in the array pass the predicate truth test.
     */
    function all(array, pred) {
        for (var idx = 0, len = array.length; idx < len; idx++) {
            if (!pred(array[idx])) {
                return false;
            }
        }
        return true;
    }

    /**
     * returns index of item
     */
    function indexOf(array, item) {
        return $$1.inArray(item, array);
    }

    /**
     * returns true if the value is present in the list.
     */
    function contains(array, item) {
        return indexOf(array, item) !== -1;
    }

    /**
     * get sum from a list
     *
     * @param {Array} array - array
     * @param {Function} fn - iterator
     */
    function sum(array, fn) {
        fn = fn || func.self;
        return array.reduce(function (memo, v) {
            return memo + fn(v);
        }, 0);
    }

    /**
     * returns a copy of the collection with array type.
     * @param {Collection} collection - collection eg) node.childNodes, ...
     */
    function from(collection) {
        var result = [];
        var length = collection.length;
        var idx = -1;
        while (++idx < length) {
            result[idx] = collection[idx];
        }
        return result;
    }

    /**
     * returns whether list is empty or not
     */
    function isEmpty$1(array) {
        return !array || !array.length;
    }

    /**
     * cluster elements by predicate function.
     *
     * @param {Array} array - array
     * @param {Function} fn - predicate function for cluster rule
     * @param {Array[]}
     */
    function clusterBy(array, fn) {
        if (!array.length) {
            return [];
        }
        var aTail = tail(array);
        return aTail.reduce(function (memo, v) {
            var aLast = last(memo);
            if (fn(last(aLast), v)) {
                aLast[aLast.length] = v;
            }
            else {
                memo[memo.length] = [v];
            }
            return memo;
        }, [[head(array)]]);
    }

    /**
     * returns a copy of the array with all false values removed
     *
     * @param {Array} array - array
     * @param {Function} fn - predicate function for cluster rule
     */
    function compact(array) {
        var aResult = [];
        for (var idx = 0, len = array.length; idx < len; idx++) {
            if (array[idx]) {
                aResult.push(array[idx]);
            }
        }
        return aResult;
    }

    /**
     * produces a duplicate-free version of the array
     *
     * @param {Array} array
     */
    function unique(array) {
        var results = [];
        for (var idx = 0, len = array.length; idx < len; idx++) {
            if (!contains(results, array[idx])) {
                results.push(array[idx]);
            }
        }
        return results;
    }

    /**
     * returns next item.
     * @param {Array} array
     */
    function next(array, item) {
        var idx = indexOf(array, item);
        if (idx === -1) {
            return null;
        }
        return array[idx + 1];
    }

    /**
     * returns prev item.
     * @param {Array} array
     */
    function prev(array, item) {
        var idx = indexOf(array, item);
        if (idx === -1) {
            return null;
        }
        return array[idx - 1];
    }

    /**
     * @class core.list
     *
     * list utils
     *
     * @singleton
     * @alternateClassName list
     */
    var lists = {
        head: head,
        last: last,
        initial: initial,
        tail: tail,
        prev: prev,
        next: next,
        find: find,
        contains: contains,
        all: all,
        sum: sum,
        from: from,
        isEmpty: isEmpty$1,
        clusterBy: clusterBy,
        compact: compact,
        unique: unique
    };

    var isSupportAmd = typeof define === 'function' && define.amd; // eslint-disable-line
    /**
     * returns whether font is installed or not.
     *
     * @param {String} fontName
     * @return {Boolean}
     */
    function isFontInstalled(fontName) {
        var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
        var $tester = $$1('<div>').css({
            position: 'absolute',
            left: '-9999px',
            top: '-9999px',
            fontSize: '200px'
        }).text('mmmmmmmmmwwwwwww').appendTo(document.body);
        var originalWidth = $tester.css('fontFamily', testFontName).width();
        var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();
        $tester.remove();
        return originalWidth !== width;
    }

    var userAgent = navigator.userAgent;
    var isMSIE = /MSIE|Trident/i.test(userAgent);
    var browserVersion;
    if (isMSIE) {
        var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);
        if (matches) {
            browserVersion = parseFloat(matches[1]);
        }
        matches = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(userAgent);
        if (matches) {
            browserVersion = parseFloat(matches[1]);
        }
    }
    var isEdge = /Edge\/\d+/.test(userAgent);
    var hasCodeMirror = !!window.CodeMirror;
    if (!hasCodeMirror && isSupportAmd) {
        // Webpack
        if (typeof __webpack_require__ === 'function') {
            try {
                // If CodeMirror can't be resolved, `require.resolve` will throw an
                // exception and `hasCodeMirror` won't be set to `true`.
                require.resolve('codemirror');
                hasCodeMirror = true;
            }
            catch (e) {
                // do nothing
            }
        }
        else if (typeof require !== 'undefined') {
            // Browserify
            if (typeof require.resolve !== 'undefined') {
                try {
                    // If CodeMirror can't be resolved, `require.resolve` will throw an
                    // exception and `hasCodeMirror` won't be set to `true`.
                    require.resolve('codemirror');
                    hasCodeMirror = true;
                }
                catch (e) {
                    // do nothing
                }
                // Almond/Require
            }
            else if (typeof require.specified !== 'undefined') {
                hasCodeMirror = require.specified('codemirror');
            }
        }
    }
    var isSupportTouch = (('ontouchstart' in window) ||
        (navigator.MaxTouchPoints > 0) ||
        (navigator.msMaxTouchPoints > 0));
// [workaround] IE doesn't have input events for contentEditable
// - see: https://goo.gl/4bfIvA
    var inputEventName = (isMSIE || isEdge) ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';
    /**
     * @class core.env
     *
     * Object which check platform and agent
     *
     * @singleton
     * @alternateClassName env
     */
    var env = {
        isMac: navigator.appVersion.indexOf('Mac') > -1,
        isMSIE: isMSIE,
        isEdge: isEdge,
        isFF: !isEdge && /firefox/i.test(userAgent),
        isPhantom: /PhantomJS/i.test(userAgent),
        isWebkit: !isEdge && /webkit/i.test(userAgent),
        isChrome: !isEdge && /chrome/i.test(userAgent),
        isSafari: !isEdge && /safari/i.test(userAgent),
        browserVersion: browserVersion,
        jqueryVersion: parseFloat($$1.fn.jquery),
        isSupportAmd: isSupportAmd,
        isSupportTouch: isSupportTouch,
        hasCodeMirror: hasCodeMirror,
        isFontInstalled: isFontInstalled,
        isW3CRangeSupport: !!document.createRange,
        inputEventName: inputEventName
    };

    var NBSP_CHAR = String.fromCharCode(160);
    var ZERO_WIDTH_NBSP_CHAR = '\ufeff';

    /**
     * @method isEditable
     *
     * returns whether node is `note-editable` or not.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    function isEditable(node) {
        return node && $$1(node).hasClass('note-editable');
    }

    /**
     * @method isControlSizing
     *
     * returns whether node is `note-control-sizing` or not.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    function isControlSizing(node) {
        return node && $$1(node).hasClass('note-control-sizing');
    }

    /**
     * @method makePredByNodeName
     *
     * returns predicate which judge whether nodeName is same
     *
     * @param {String} nodeName
     * @return {Function}
     */
    function makePredByNodeName(nodeName) {
        nodeName = nodeName.toUpperCase();
        return function (node) {
            return node && node.nodeName.toUpperCase() === nodeName;
        };
    }

    /**
     * @method isText
     *
     *
     *
     * @param {Node} node
     * @return {Boolean} true if node's type is text(3)
     */
    function isText(node) {
        return node && node.nodeType === 3;
    }

    /**
     * @method isElement
     *
     *
     *
     * @param {Node} node
     * @return {Boolean} true if node's type is element(1)
     */
    function isElement(node) {
        return node && node.nodeType === 1;
    }

    /**
     * ex) br, col, embed, hr, img, input, ...
     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
     */
    function isVoid(node) {
        return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT/.test(node.nodeName.toUpperCase());
    }

    function isPara(node) {
        if (isEditable(node)) {
            return false;
        }
        // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph
        return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
    }

    function isHeading(node) {
        return node && /^H[1-7]/.test(node.nodeName.toUpperCase());
    }

    var isPre = makePredByNodeName('PRE');
    var isLi = makePredByNodeName('LI');

    function isPurePara(node) {
        return isPara(node) && !isLi(node);
    }

    var isTable = makePredByNodeName('TABLE');
    var isData = makePredByNodeName('DATA');

    function isInline(node) {
        return !isBodyContainer(node) &&
            !isList(node) &&
            !isHr(node) &&
            !isPara(node) &&
            !isTable(node) &&
            !isBlockquote(node) &&
            !isData(node);
    }

    function isList(node) {
        return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
    }

    var isHr = makePredByNodeName('HR');

    function isCell(node) {
        return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
    }

    var isBlockquote = makePredByNodeName('BLOCKQUOTE');

    function isBodyContainer(node) {
        return isCell(node) || isBlockquote(node) || isEditable(node);
    }

    var isAnchor = makePredByNodeName('A');

    function isParaInline(node) {
        return isInline(node) && !!ancestor(node, isPara);
    }

    function isBodyInline(node) {
        return isInline(node) && !ancestor(node, isPara);
    }

    var isBody = makePredByNodeName('BODY');

    /**
     * returns whether nodeB is closest sibling of nodeA
     *
     * @param {Node} nodeA
     * @param {Node} nodeB
     * @return {Boolean}
     */
    function isClosestSibling(nodeA, nodeB) {
        return nodeA.nextSibling === nodeB ||
            nodeA.previousSibling === nodeB;
    }

    /**
     * returns array of closest siblings with node
     *
     * @param {Node} node
     * @param {function} [pred] - predicate function
     * @return {Node[]}
     */
    function withClosestSiblings(node, pred) {
        pred = pred || func.ok;
        var siblings = [];
        if (node.previousSibling && pred(node.previousSibling)) {
            siblings.push(node.previousSibling);
        }
        siblings.push(node);
        if (node.nextSibling && pred(node.nextSibling)) {
            siblings.push(node.nextSibling);
        }
        return siblings;
    }

    /**
     * blank HTML for cursor position
     * - [workaround] old IE only works with &nbsp;
     * - [workaround] IE11 and other browser works with bogus br
     */
    var blankHTML = env.isMSIE && env.browserVersion < 11 ? '&nbsp;' : '<br>';

    /**
     * @method nodeLength
     *
     * returns #text's text size or element's childNodes size
     *
     * @param {Node} node
     */
    function nodeLength(node) {
        if (isText(node)) {
            return node.nodeValue.length;
        }
        if (node) {
            return node.childNodes.length;
        }
        return 0;
    }

    /**
     * returns whether node is empty or not.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    function isEmpty(node) {
        var len = nodeLength(node);
        if (len === 0) {
            return true;
        }
        else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
            // ex) <p><br></p>, <span><br></span>
            return true;
        }
        else if (lists.all(node.childNodes, isText) && node.innerHTML === '') {
            // ex) <p></p>, <span></span>
            return true;
        }
        return false;
    }

    /**
     * padding blankHTML if node is empty (for cursor position)
     */
    function paddingBlankHTML(node) {
        if (!isVoid(node) && !nodeLength(node)) {
            node.innerHTML = blankHTML;
        }
    }

    /**
     * find nearest ancestor predicate hit
     *
     * @param {Node} node
     * @param {Function} pred - predicate function
     */
    function ancestor(node, pred) {
        while (node) {
            if (pred(node)) {
                return node;
            }
            if (isEditable(node)) {
                break;
            }
            node = node.parentNode;
        }
        return null;
    }

    /**
     * find nearest ancestor only single child blood line and predicate hit
     *
     * @param {Node} node
     * @param {Function} pred - predicate function
     */
    function singleChildAncestor(node, pred) {
        node = node.parentNode;
        while (node) {
            if (nodeLength(node) !== 1) {
                break;
            }
            if (pred(node)) {
                return node;
            }
            if (isEditable(node)) {
                break;
            }
            node = node.parentNode;
        }
        return null;
    }

    /**
     * returns new array of ancestor nodes (until predicate hit).
     *
     * @param {Node} node
     * @param {Function} [optional] pred - predicate function
     */
    function listAncestor(node, pred) {
        pred = pred || func.fail;
        var ancestors = [];
        ancestor(node, function (el) {
            if (!isEditable(el)) {
                ancestors.push(el);
            }
            return pred(el);
        });
        return ancestors;
    }

    /**
     * find farthest ancestor predicate hit
     */
    function lastAncestor(node, pred) {
        var ancestors = listAncestor(node);
        return lists.last(ancestors.filter(pred));
    }

    /**
     * returns common ancestor node between two nodes.
     *
     * @param {Node} nodeA
     * @param {Node} nodeB
     */
    function commonAncestor(nodeA, nodeB) {
        var ancestors = listAncestor(nodeA);
        for (var n = nodeB; n; n = n.parentNode) {
            if ($$1.inArray(n, ancestors) > -1) {
                return n;
            }
        }
        return null; // difference document area
    }

    /**
     * listing all previous siblings (until predicate hit).
     *
     * @param {Node} node
     * @param {Function} [optional] pred - predicate function
     */
    function listPrev(node, pred) {
        pred = pred || func.fail;
        var nodes = [];
        while (node) {
            if (pred(node)) {
                break;
            }
            nodes.push(node);
            node = node.previousSibling;
        }
        return nodes;
    }

    /**
     * listing next siblings (until predicate hit).
     *
     * @param {Node} node
     * @param {Function} [pred] - predicate function
     */
    function listNext(node, pred) {
        pred = pred || func.fail;
        var nodes = [];
        while (node) {
            if (pred(node)) {
                break;
            }
            nodes.push(node);
            node = node.nextSibling;
        }
        return nodes;
    }

    /**
     * listing descendant nodes
     *
     * @param {Node} node
     * @param {Function} [pred] - predicate function
     */
    function listDescendant(node, pred) {
        var descendants = [];
        pred = pred || func.ok;
        // start DFS(depth first search) with node
        (function fnWalk(current) {
            if (node !== current && pred(current)) {
                descendants.push(current);
            }
            for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
                fnWalk(current.childNodes[idx]);
            }
        })(node);
        return descendants;
    }

    /**
     * wrap node with new tag.
     *
     * @param {Node} node
     * @param {Node} tagName of wrapper
     * @return {Node} - wrapper
     */
    function wrap(node, wrapperName) {
        var parent = node.parentNode;
        var wrapper = $$1('<' + wrapperName + '>')[0];
        parent.insertBefore(wrapper, node);
        wrapper.appendChild(node);
        return wrapper;
    }

    /**
     * insert node after preceding
     *
     * @param {Node} node
     * @param {Node} preceding - predicate function
     */
    function insertAfter(node, preceding) {
        var next = preceding.nextSibling;
        var parent = preceding.parentNode;
        if (next) {
            parent.insertBefore(node, next);
        }
        else {
            parent.appendChild(node);
        }
        return node;
    }

    /**
     * append elements.
     *
     * @param {Node} node
     * @param {Collection} aChild
     */
    function appendChildNodes(node, aChild) {
        $$1.each(aChild, function (idx, child) {
            node.appendChild(child);
        });
        return node;
    }

    /**
     * returns whether boundaryPoint is left edge or not.
     *
     * @param {BoundaryPoint} point
     * @return {Boolean}
     */
    function isLeftEdgePoint(point) {
        return point.offset === 0;
    }

    /**
     * returns whether boundaryPoint is right edge or not.
     *
     * @param {BoundaryPoint} point
     * @return {Boolean}
     */
    function isRightEdgePoint(point) {
        return point.offset === nodeLength(point.node);
    }

    /**
     * returns whether boundaryPoint is edge or not.
     *
     * @param {BoundaryPoint} point
     * @return {Boolean}
     */
    function isEdgePoint(point) {
        return isLeftEdgePoint(point) || isRightEdgePoint(point);
    }

    /**
     * returns whether node is left edge of ancestor or not.
     *
     * @param {Node} node
     * @param {Node} ancestor
     * @return {Boolean}
     */
    function isLeftEdgeOf(node, ancestor) {
        while (node && node !== ancestor) {
            if (position(node) !== 0) {
                return false;
            }
            node = node.parentNode;
        }
        return true;
    }

    /**
     * returns whether node is right edge of ancestor or not.
     *
     * @param {Node} node
     * @param {Node} ancestor
     * @return {Boolean}
     */
    function isRightEdgeOf(node, ancestor) {
        if (!ancestor) {
            return false;
        }
        while (node && node !== ancestor) {
            if (position(node) !== nodeLength(node.parentNode) - 1) {
                return false;
            }
            node = node.parentNode;
        }
        return true;
    }

    /**
     * returns whether point is left edge of ancestor or not.
     * @param {BoundaryPoint} point
     * @param {Node} ancestor
     * @return {Boolean}
     */
    function isLeftEdgePointOf(point, ancestor) {
        return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);
    }

    /**
     * returns whether point is right edge of ancestor or not.
     * @param {BoundaryPoint} point
     * @param {Node} ancestor
     * @return {Boolean}
     */
    function isRightEdgePointOf(point, ancestor) {
        return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);
    }

    /**
     * returns offset from parent.
     *
     * @param {Node} node
     */
    function position(node) {
        var offset = 0;
        while ((node = node.previousSibling)) {
            offset += 1;
        }
        return offset;
    }

    function hasChildren(node) {
        return !!(node && node.childNodes && node.childNodes.length);
    }

    /**
     * returns previous boundaryPoint
     *
     * @param {BoundaryPoint} point
     * @param {Boolean} isSkipInnerOffset
     * @return {BoundaryPoint}
     */
    function prevPoint(point, isSkipInnerOffset) {
        var node;
        var offset;
        if (point.offset === 0) {
            if (isEditable(point.node)) {
                return null;
            }
            node = point.node.parentNode;
            offset = position(point.node);
        }
        else if (hasChildren(point.node)) {
            node = point.node.childNodes[point.offset - 1];
            offset = nodeLength(node);
        }
        else {
            node = point.node;
            offset = isSkipInnerOffset ? 0 : point.offset - 1;
        }
        return {
            node: node,
            offset: offset
        };
    }

    /**
     * returns next boundaryPoint
     *
     * @param {BoundaryPoint} point
     * @param {Boolean} isSkipInnerOffset
     * @return {BoundaryPoint}
     */
    function nextPoint(point, isSkipInnerOffset) {
        var node, offset;
        if (nodeLength(point.node) === point.offset) {
            if (isEditable(point.node)) {
                return null;
            }
            node = point.node.parentNode;
            offset = position(point.node) + 1;
        }
        else if (hasChildren(point.node)) {
            node = point.node.childNodes[point.offset];
            offset = 0;
        }
        else {
            node = point.node;
            offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
        }
        return {
            node: node,
            offset: offset
        };
    }

    /**
     * returns whether pointA and pointB is same or not.
     *
     * @param {BoundaryPoint} pointA
     * @param {BoundaryPoint} pointB
     * @return {Boolean}
     */
    function isSamePoint(pointA, pointB) {
        return pointA.node === pointB.node && pointA.offset === pointB.offset;
    }

    /**
     * returns whether point is visible (can set cursor) or not.
     *
     * @param {BoundaryPoint} point
     * @return {Boolean}
     */
    function isVisiblePoint(point) {
        if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {
            return true;
        }
        var leftNode = point.node.childNodes[point.offset - 1];
        var rightNode = point.node.childNodes[point.offset];
        if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {
            return true;
        }
        return false;
    }

    /**
     * @method prevPointUtil
     *
     * @param {BoundaryPoint} point
     * @param {Function} pred
     * @return {BoundaryPoint}
     */
    function prevPointUntil(point, pred) {
        while (point) {
            if (pred(point)) {
                return point;
            }
            point = prevPoint(point);
        }
        return null;
    }

    /**
     * @method nextPointUntil
     *
     * @param {BoundaryPoint} point
     * @param {Function} pred
     * @return {BoundaryPoint}
     */
    function nextPointUntil(point, pred) {
        while (point) {
            if (pred(point)) {
                return point;
            }
            point = nextPoint(point);
        }
        return null;
    }

    /**
     * returns whether point has character or not.
     *
     * @param {Point} point
     * @return {Boolean}
     */
    function isCharPoint(point) {
        if (!isText(point.node)) {
            return false;
        }
        var ch = point.node.nodeValue.charAt(point.offset - 1);
        return ch && (ch !== ' ' && ch !== NBSP_CHAR);
    }

    /**
     * @method walkPoint
     *
     * @param {BoundaryPoint} startPoint
     * @param {BoundaryPoint} endPoint
     * @param {Function} handler
     * @param {Boolean} isSkipInnerOffset
     */
    function walkPoint(startPoint, endPoint, handler, isSkipInnerOffset) {
        var point = startPoint;
        while (point) {
            handler(point);
            if (isSamePoint(point, endPoint)) {
                break;
            }
            var isSkipOffset = isSkipInnerOffset &&
                startPoint.node !== point.node &&
                endPoint.node !== point.node;
            point = nextPoint(point, isSkipOffset);
        }
    }

    /**
     * @method makeOffsetPath
     *
     * return offsetPath(array of offset) from ancestor
     *
     * @param {Node} ancestor - ancestor node
     * @param {Node} node
     */
    function makeOffsetPath(ancestor, node) {
        var ancestors = listAncestor(node, func.eq(ancestor));
        return ancestors.map(position).reverse();
    }

    /**
     * @method fromOffsetPath
     *
     * return element from offsetPath(array of offset)
     *
     * @param {Node} ancestor - ancestor node
     * @param {array} offsets - offsetPath
     */
    function fromOffsetPath(ancestor, offsets) {
        var current = ancestor;
        for (var i = 0, len = offsets.length; i < len; i++) {
            if (current.childNodes.length <= offsets[i]) {
                current = current.childNodes[current.childNodes.length - 1];
            }
            else {
                current = current.childNodes[offsets[i]];
            }
        }
        return current;
    }

    /**
     * @method splitNode
     *
     * split element or #text
     *
     * @param {BoundaryPoint} point
     * @param {Object} [options]
     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
     * @return {Node} right node of boundaryPoint
     */
    function splitNode(point, options) {
        var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
        var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;
        // edge case
        if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
            if (isLeftEdgePoint(point)) {
                return point.node;
            }
            else if (isRightEdgePoint(point)) {
                return point.node.nextSibling;
            }
        }
        // split #text
        if (isText(point.node)) {
            return point.node.splitText(point.offset);
        }
        else {
            var childNode = point.node.childNodes[point.offset];
            var clone = insertAfter(point.node.cloneNode(false), point.node);
            appendChildNodes(clone, listNext(childNode));
            if (!isSkipPaddingBlankHTML) {
                paddingBlankHTML(point.node);
                paddingBlankHTML(clone);
            }
            return clone;
        }
    }

    /**
     * @method splitTree
     *
     * split tree by point
     *
     * @param {Node} root - split root
     * @param {BoundaryPoint} point
     * @param {Object} [options]
     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
     * @return {Node} right node of boundaryPoint
     */
    function splitTree(root, point, options) {
        // ex) [#text, <span>, <p>]
        var ancestors = listAncestor(point.node, func.eq(root));
        if (!ancestors.length) {
            return null;
        }
        else if (ancestors.length === 1) {
            return splitNode(point, options);
        }
        return ancestors.reduce(function (node, parent) {
            if (node === point.node) {
                node = splitNode(point, options);
            }
            return splitNode({
                node: parent,
                offset: node ? position(node) : nodeLength(parent)
            }, options);
        });
    }

    /**
     * split point
     *
     * @param {Point} point
     * @param {Boolean} isInline
     * @return {Object}
     */
    function splitPoint(point, isInline) {
        // find splitRoot, container
        //  - inline: splitRoot is a child of paragraph
        //  - block: splitRoot is a child of bodyContainer
        var pred = isInline ? isPara : isBodyContainer;
        var ancestors = listAncestor(point.node, pred);
        var topAncestor = lists.last(ancestors) || point.node;
        var splitRoot, container;
        if (pred(topAncestor)) {
            splitRoot = ancestors[ancestors.length - 2];
            container = topAncestor;
        }
        else {
            splitRoot = topAncestor;
            container = splitRoot.parentNode;
        }
        // if splitRoot is exists, split with splitTree
        var pivot = splitRoot && splitTree(splitRoot, point, {
            isSkipPaddingBlankHTML: isInline,
            isNotSplitEdgePoint: isInline
        });
        // if container is point.node, find pivot with point.offset
        if (!pivot && container === point.node) {
            pivot = point.node.childNodes[point.offset];
        }
        return {
            rightNode: pivot,
            container: container
        };
    }

    function create(nodeName) {
        return document.createElement(nodeName);
    }

    function createText(text) {
        return document.createTextNode(text);
    }

    /**
     * @method remove
     *
     * remove node, (isRemoveChild: remove child or not)
     *
     * @param {Node} node
     * @param {Boolean} isRemoveChild
     */
    function remove(node, isRemoveChild) {
        if (!node || !node.parentNode) {
            return;
        }
        if (node.removeNode) {
            return node.removeNode(isRemoveChild);
        }
        var parent = node.parentNode;
        if (!isRemoveChild) {
            var nodes = [];
            for (var i = 0, len = node.childNodes.length; i < len; i++) {
                nodes.push(node.childNodes[i]);
            }
            for (var i = 0, len = nodes.length; i < len; i++) {
                parent.insertBefore(nodes[i], node);
            }
        }
        parent.removeChild(node);
    }

    /**
     * @method removeWhile
     *
     * @param {Node} node
     * @param {Function} pred
     */
    function removeWhile(node, pred) {
        while (node) {
            if (isEditable(node) || !pred(node)) {
                break;
            }
            var parent = node.parentNode;
            remove(node);
            node = parent;
        }
    }

    /**
     * @method replace
     *
     * replace node with provided nodeName
     *
     * @param {Node} node
     * @param {String} nodeName
     * @return {Node} - new node
     */
    function replace(node, nodeName) {
        if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
            return node;
        }
        var newNode = create(nodeName);
        if (node.style.cssText) {
            newNode.style.cssText = node.style.cssText;
        }
        appendChildNodes(newNode, lists.from(node.childNodes));
        insertAfter(newNode, node);
        remove(node);
        return newNode;
    }

    var isTextarea = makePredByNodeName('TEXTAREA');

    /**
     * @param {jQuery} $node
     * @param {Boolean} [stripLinebreaks] - default: false
     */
    function value($node, stripLinebreaks) {
        var val = isTextarea($node[0]) ? $node.val() : $node.html();
        if (stripLinebreaks) {
            return val.replace(/[\n\r]/g, '');
        }
        return val;
    }

    /**
     * @method html
     *
     * get the HTML contents of node
     *
     * @param {jQuery} $node
     * @param {Boolean} [isNewlineOnBlock]
     */
    function html($node, isNewlineOnBlock) {
        var markup = value($node);
        if (isNewlineOnBlock) {
            var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
            markup = markup.replace(regexTag, function (match, endSlash, name) {
                name = name.toUpperCase();
                var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&
                    !!endSlash;
                var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);
                return match + ((isEndOfInlineContainer || isBlockNode) ? '\n' : '');
            });
            markup = $$1.trim(markup);
        }
        return markup;
    }

    function posFromPlaceholder(placeholder) {
        var $placeholder = $$1(placeholder);
        var pos = $placeholder.offset();
        var height = $placeholder.outerHeight(true); // include margin
        return {
            left: pos.left,
            top: pos.top + height
        };
    }

    function attachEvents($node, events) {
        Object.keys(events).forEach(function (key) {
            $node.on(key, events[key]);
        });
    }

    function detachEvents($node, events) {
        Object.keys(events).forEach(function (key) {
            $node.off(key, events[key]);
        });
    }

    /**
     * @method isCustomStyleTag
     *
     * assert if a node contains a "note-styletag" class,
     * which implies that's a custom-made style tag node
     *
     * @param {Node} an HTML DOM node
     */
    function isCustomStyleTag(node) {
        return node && !isText(node) && lists.contains(node.classList, 'note-styletag');
    }

    var dom = {
        /** @property {String} NBSP_CHAR */
        NBSP_CHAR: NBSP_CHAR,
        /** @property {String} ZERO_WIDTH_NBSP_CHAR */
        ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,
        /** @property {String} blank */
        blank: blankHTML,
        /** @property {String} emptyPara */
        emptyPara: "<p>" + blankHTML + "</p>",
        makePredByNodeName: makePredByNodeName,
        isEditable: isEditable,
        isControlSizing: isControlSizing,
        isText: isText,
        isElement: isElement,
        isVoid: isVoid,
        isPara: isPara,
        isPurePara: isPurePara,
        isHeading: isHeading,
        isInline: isInline,
        isBlock: func.not(isInline),
        isBodyInline: isBodyInline,
        isBody: isBody,
        isParaInline: isParaInline,
        isPre: isPre,
        isList: isList,
        isTable: isTable,
        isData: isData,
        isCell: isCell,
        isBlockquote: isBlockquote,
        isBodyContainer: isBodyContainer,
        isAnchor: isAnchor,
        isDiv: makePredByNodeName('DIV'),
        isLi: isLi,
        isBR: makePredByNodeName('BR'),
        isSpan: makePredByNodeName('SPAN'),
        isB: makePredByNodeName('B'),
        isU: makePredByNodeName('U'),
        isS: makePredByNodeName('S'),
        isI: makePredByNodeName('I'),
        isImg: makePredByNodeName('IMG'),
        isTextarea: isTextarea,
        isEmpty: isEmpty,
        isEmptyAnchor: func.and(isAnchor, isEmpty),
        isClosestSibling: isClosestSibling,
        withClosestSiblings: withClosestSiblings,
        nodeLength: nodeLength,
        isLeftEdgePoint: isLeftEdgePoint,
        isRightEdgePoint: isRightEdgePoint,
        isEdgePoint: isEdgePoint,
        isLeftEdgeOf: isLeftEdgeOf,
        isRightEdgeOf: isRightEdgeOf,
        isLeftEdgePointOf: isLeftEdgePointOf,
        isRightEdgePointOf: isRightEdgePointOf,
        prevPoint: prevPoint,
        nextPoint: nextPoint,
        isSamePoint: isSamePoint,
        isVisiblePoint: isVisiblePoint,
        prevPointUntil: prevPointUntil,
        nextPointUntil: nextPointUntil,
        isCharPoint: isCharPoint,
        walkPoint: walkPoint,
        ancestor: ancestor,
        singleChildAncestor: singleChildAncestor,
        listAncestor: listAncestor,
        lastAncestor: lastAncestor,
        listNext: listNext,
        listPrev: listPrev,
        listDescendant: listDescendant,
        commonAncestor: commonAncestor,
        wrap: wrap,
        insertAfter: insertAfter,
        appendChildNodes: appendChildNodes,
        position: position,
        hasChildren: hasChildren,
        makeOffsetPath: makeOffsetPath,
        fromOffsetPath: fromOffsetPath,
        splitTree: splitTree,
        splitPoint: splitPoint,
        create: create,
        createText: createText,
        remove: remove,
        removeWhile: removeWhile,
        replace: replace,
        html: html,
        value: value,
        posFromPlaceholder: posFromPlaceholder,
        attachEvents: attachEvents,
        detachEvents: detachEvents,
        isCustomStyleTag: isCustomStyleTag
    };

    $$1.summernote = $$1.summernote || {
        lang: {}
    };
    $$1.extend($$1.summernote.lang, {
        'en-US': {
            font: {
                bold: 'Bold',
                italic: 'Italic',
                underline: 'Underline',
                clear: 'Remove Font Style',
                height: 'Line Height',
                name: 'Font Family',
                strikethrough: 'Strikethrough',
                subscript: 'Subscript',
                superscript: 'Superscript',
                size: 'Font Size'
            },
            image: {
                image: 'Picture',
                insert: 'Insert Image',
                resizeFull: 'Resize Full',
                resizeHalf: 'Resize Half',
                resizeQuarter: 'Resize Quarter',
                floatLeft: 'Float Left',
                floatRight: 'Float Right',
                floatNone: 'Float None',
                shapeRounded: 'Shape: Rounded',
                shapeCircle: 'Shape: Circle',
                shapeThumbnail: 'Shape: Thumbnail',
                shapeNone: 'Shape: None',
                dragImageHere: 'Drag image or text here',
                dropImage: 'Drop image or Text',
                selectFromFiles: 'Select from files',
                maximumFileSize: 'Maximum file size',
                maximumFileSizeError: 'Maximum file size exceeded.',
                url: 'Image URL',
                remove: 'Remove Image',
                original: 'Original'
            },
            video: {
                video: 'Video',
                videoLink: 'Video Link',
                insert: 'Insert Video',
                url: 'Video URL',
                providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'
            },
            link: {
                link: 'Link',
                insert: 'Insert Link',
                unlink: 'Unlink',
                edit: 'Edit',
                textToDisplay: 'Text to display',
                url: 'To what URL should this link go?',
                openInNewWindow: 'Open in new window'
            },
            table: {
                table: 'Table',
                addRowAbove: 'Add row above',
                addRowBelow: 'Add row below',
                addColLeft: 'Add column left',
                addColRight: 'Add column right',
                delRow: 'Delete row',
                delCol: 'Delete column',
                delTable: 'Delete table'
            },
            hr: {
                insert: 'Insert Horizontal Rule'
            },
            style: {
                style: 'Style',
                p: 'Normal',
                blockquote: 'Quote',
                pre: 'Code',
                h1: 'Header 1',
                h2: 'Header 2',
                h3: 'Header 3',
                h4: 'Header 4',
                h5: 'Header 5',
                h6: 'Header 6'
            },
            lists: {
                unordered: 'Unordered list',
                ordered: 'Ordered list'
            },
            options: {
                help: 'Help',
                fullscreen: 'Full Screen',
                codeview: 'Code View'
            },
            paragraph: {
                paragraph: 'Paragraph',
                outdent: 'Outdent',
                indent: 'Indent',
                left: 'Align left',
                center: 'Align center',
                right: 'Align right',
                justify: 'Justify full'
            },
            color: {
                recent: 'Recent Color',
                more: 'More Color',
                background: 'Background Color',
                foreground: 'Foreground Color',
                transparent: 'Transparent',
                setTransparent: 'Set transparent',
                reset: 'Reset',
                resetToDefault: 'Reset to default'
            },
            shortcut: {
                shortcuts: 'Keyboard shortcuts',
                close: 'Close',
                textFormatting: 'Text formatting',
                action: 'Action',
                paragraphFormatting: 'Paragraph formatting',
                documentStyle: 'Document Style',
                extraKeys: 'Extra keys'
            },
            help: {
                'insertParagraph': 'Insert Paragraph',
                'undo': 'Undoes the last command',
                'redo': 'Redoes the last command',
                'tab': 'Tab',
                'untab': 'Untab',
                'bold': 'Set a bold style',
                'italic': 'Set a italic style',
                'underline': 'Set a underline style',
                'strikethrough': 'Set a strikethrough style',
                'removeFormat': 'Clean a style',
                'justifyLeft': 'Set left align',
                'justifyCenter': 'Set center align',
                'justifyRight': 'Set right align',
                'justifyFull': 'Set full align',
                'insertUnorderedList': 'Toggle unordered list',
                'insertOrderedList': 'Toggle ordered list',
                'outdent': 'Outdent on current paragraph',
                'indent': 'Indent on current paragraph',
                'formatPara': 'Change current block\'s format as a paragraph(P tag)',
                'formatH1': 'Change current block\'s format as H1',
                'formatH2': 'Change current block\'s format as H2',
                'formatH3': 'Change current block\'s format as H3',
                'formatH4': 'Change current block\'s format as H4',
                'formatH5': 'Change current block\'s format as H5',
                'formatH6': 'Change current block\'s format as H6',
                'insertHorizontalRule': 'Insert horizontal rule',
                'linkDialog.show': 'Show Link Dialog'
            },
            history: {
                undo: 'Undo',
                redo: 'Redo'
            },
            specialChar: {
                specialChar: 'SPECIAL CHARACTERS',
                select: 'Select Special characters'
            }
        }
    });

    var KEY_MAP = {
        'BACKSPACE': 8,
        'TAB': 9,
        'ENTER': 13,
        'SPACE': 32,
        'DELETE': 46,
        // Arrow
        'LEFT': 37,
        'UP': 38,
        'RIGHT': 39,
        'DOWN': 40,
        // Number: 0-9
        'NUM0': 48,
        'NUM1': 49,
        'NUM2': 50,
        'NUM3': 51,
        'NUM4': 52,
        'NUM5': 53,
        'NUM6': 54,
        'NUM7': 55,
        'NUM8': 56,
        // Alphabet: a-z
        'B': 66,
        'E': 69,
        'I': 73,
        'J': 74,
        'K': 75,
        'L': 76,
        'R': 82,
        'S': 83,
        'U': 85,
        'V': 86,
        'Y': 89,
        'Z': 90,
        'SLASH': 191,
        'LEFTBRACKET': 219,
        'BACKSLASH': 220,
        'RIGHTBRACKET': 221
    };
    /**
     * @class core.key
     *
     * Object for keycodes.
     *
     * @singleton
     * @alternateClassName key
     */
    var key = {
        /**
         * @method isEdit
         *
         * @param {Number} keyCode
         * @return {Boolean}
         */
        isEdit: function (keyCode) {
            return lists.contains([
                KEY_MAP.BACKSPACE,
                KEY_MAP.TAB,
                KEY_MAP.ENTER,
                KEY_MAP.SPACE,
                KEY_MAP.DELETE
            ], keyCode);
        },
        /**
         * @method isMove
         *
         * @param {Number} keyCode
         * @return {Boolean}
         */
        isMove: function (keyCode) {
            return lists.contains([
                KEY_MAP.LEFT,
                KEY_MAP.UP,
                KEY_MAP.RIGHT,
                KEY_MAP.DOWN
            ], keyCode);
        },
        /**
         * @property {Object} nameFromCode
         * @property {String} nameFromCode.8 "BACKSPACE"
         */
        nameFromCode: func.invertObject(KEY_MAP),
        code: KEY_MAP
    };

    /**
     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js
     *
     * @param {TextRange} textRange
     * @param {Boolean} isStart
     * @return {BoundaryPoint}
     *
     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx
     */
    function textRangeToPoint(textRange, isStart) {
        var container = textRange.parentElement();
        var offset;
        var tester = document.body.createTextRange();
        var prevContainer;
        var childNodes = lists.from(container.childNodes);
        for (offset = 0; offset < childNodes.length; offset++) {
            if (dom.isText(childNodes[offset])) {
                continue;
            }
            tester.moveToElementText(childNodes[offset]);
            if (tester.compareEndPoints('StartToStart', textRange) >= 0) {
                break;
            }
            prevContainer = childNodes[offset];
        }
        if (offset !== 0 && dom.isText(childNodes[offset - 1])) {
            var textRangeStart = document.body.createTextRange();
            var curTextNode = null;
            textRangeStart.moveToElementText(prevContainer || container);
            textRangeStart.collapse(!prevContainer);
            curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;
            var pointTester = textRange.duplicate();
            pointTester.setEndPoint('StartToStart', textRangeStart);
            var textCount = pointTester.text.replace(/[\r\n]/g, '').length;
            while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
                textCount -= curTextNode.nodeValue.length;
                curTextNode = curTextNode.nextSibling;
            }
            // [workaround] enforce IE to re-reference curTextNode, hack
            var dummy = curTextNode.nodeValue; // eslint-disable-line
            if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&
                textCount === curTextNode.nodeValue.length) {
                textCount -= curTextNode.nodeValue.length;
                curTextNode = curTextNode.nextSibling;
            }
            container = curTextNode;
            offset = textCount;
        }
        return {
            cont: container,
            offset: offset
        };
    }

    /**
     * return TextRange from boundary point (inspired by google closure-library)
     * @param {BoundaryPoint} point
     * @return {TextRange}
     */
    function pointToTextRange(point) {
        var textRangeInfo = function (container, offset) {
            var node, isCollapseToStart;
            if (dom.isText(container)) {
                var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
                var prevContainer = lists.last(prevTextNodes).previousSibling;
                node = prevContainer || container.parentNode;
                offset += lists.sum(lists.tail(prevTextNodes), dom.nodeLength);
                isCollapseToStart = !prevContainer;
            }
            else {
                node = container.childNodes[offset] || container;
                if (dom.isText(node)) {
                    return textRangeInfo(node, 0);
                }
                offset = 0;
                isCollapseToStart = false;
            }
            return {
                node: node,
                collapseToStart: isCollapseToStart,
                offset: offset
            };
        };
        var textRange = document.body.createTextRange();
        var info = textRangeInfo(point.node, point.offset);
        textRange.moveToElementText(info.node);
        textRange.collapse(info.collapseToStart);
        textRange.moveStart('character', info.offset);
        return textRange;
    }

    /**
     * Wrapped Range
     *
     * @constructor
     * @param {Node} sc - start container
     * @param {Number} so - start offset
     * @param {Node} ec - end container
     * @param {Number} eo - end offset
     */
    var WrappedRange = /** @class */ (function () {
        function WrappedRange(sc, so, ec, eo) {
            this.sc = sc;
            this.so = so;
            this.ec = ec;
            this.eo = eo;
            // isOnEditable: judge whether range is on editable or not
            this.isOnEditable = this.makeIsOn(dom.isEditable);
            // isOnList: judge whether range is on list node or not
            this.isOnList = this.makeIsOn(dom.isList);
            // isOnAnchor: judge whether range is on anchor node or not
            this.isOnAnchor = this.makeIsOn(dom.isAnchor);
            // isOnCell: judge whether range is on cell node or not
            this.isOnCell = this.makeIsOn(dom.isCell);
            // isOnData: judge whether range is on data node or not
            this.isOnData = this.makeIsOn(dom.isData);
        }

        // nativeRange: get nativeRange from sc, so, ec, eo
        WrappedRange.prototype.nativeRange = function () {
            if (env.isW3CRangeSupport) {
                var w3cRange = document.createRange();
                w3cRange.setStart(this.sc, this.so);
                w3cRange.setEnd(this.ec, this.eo);
                return w3cRange;
            }
            else {
                var textRange = pointToTextRange({
                    node: this.sc,
                    offset: this.so
                });
                textRange.setEndPoint('EndToEnd', pointToTextRange({
                    node: this.ec,
                    offset: this.eo
                }));
                return textRange;
            }
        };
        WrappedRange.prototype.getPoints = function () {
            return {
                sc: this.sc,
                so: this.so,
                ec: this.ec,
                eo: this.eo
            };
        };
        WrappedRange.prototype.getStartPoint = function () {
            return {
                node: this.sc,
                offset: this.so
            };
        };
        WrappedRange.prototype.getEndPoint = function () {
            return {
                node: this.ec,
                offset: this.eo
            };
        };
        /**
         * select update visible range
         */
        WrappedRange.prototype.select = function () {
            var nativeRng = this.nativeRange();
            if (env.isW3CRangeSupport) {
                var selection = document.getSelection();
                if (selection.rangeCount > 0) {
                    selection.removeAllRanges();
                }
                selection.addRange(nativeRng);
            }
            else {
                nativeRng.select();
            }
            return this;
        };
        /**
         * Moves the scrollbar to start container(sc) of current range
         *
         * @return {WrappedRange}
         */
        WrappedRange.prototype.scrollIntoView = function (container) {
            var height = $$1(container).height();
            if (container.scrollTop + height < this.sc.offsetTop) {
                container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);
            }
            return this;
        };
        /**
         * @return {WrappedRange}
         */
        WrappedRange.prototype.normalize = function () {
            /**
             * @param {BoundaryPoint} point
             * @param {Boolean} isLeftToRight
             * @return {BoundaryPoint}
             */
            var getVisiblePoint = function (point, isLeftToRight) {
                if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||
                    (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||
                    (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||
                    (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {
                    return point;
                }
                // point on block's edge
                var block = dom.ancestor(point.node, dom.isBlock);
                if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||
                    ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {
                    // returns point already on visible point
                    if (dom.isVisiblePoint(point)) {
                        return point;
                    }
                    // reverse direction
                    isLeftToRight = !isLeftToRight;
                }
                var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint)
                    : dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
                return nextPoint || point;
            };
            var endPoint = getVisiblePoint(this.getEndPoint(), false);
            var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);
            return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
        };
        /**
         * returns matched nodes on range
         *
         * @param {Function} [pred] - predicate function
         * @param {Object} [options]
         * @param {Boolean} [options.includeAncestor]
         * @param {Boolean} [options.fullyContains]
         * @return {Node[]}
         */
        WrappedRange.prototype.nodes = function (pred, options) {
            pred = pred || func.ok;
            var includeAncestor = options && options.includeAncestor;
            var fullyContains = options && options.fullyContains;
            // TODO compare points and sort
            var startPoint = this.getStartPoint();
            var endPoint = this.getEndPoint();
            var nodes = [];
            var leftEdgeNodes = [];
            dom.walkPoint(startPoint, endPoint, function (point) {
                if (dom.isEditable(point.node)) {
                    return;
                }
                var node;
                if (fullyContains) {
                    if (dom.isLeftEdgePoint(point)) {
                        leftEdgeNodes.push(point.node);
                    }
                    if (dom.isRightEdgePoint(point) && lists.contains(leftEdgeNodes, point.node)) {
                        node = point.node;
                    }
                }
                else if (includeAncestor) {
                    node = dom.ancestor(point.node, pred);
                }
                else {
                    node = point.node;
                }
                if (node && pred(node)) {
                    nodes.push(node);
                }
            }, true);
            return lists.unique(nodes);
        };
        /**
         * returns commonAncestor of range
         * @return {Element} - commonAncestor
         */
        WrappedRange.prototype.commonAncestor = function () {
            return dom.commonAncestor(this.sc, this.ec);
        };
        /**
         * returns expanded range by pred
         *
         * @param {Function} pred - predicate function
         * @return {WrappedRange}
         */
        WrappedRange.prototype.expand = function (pred) {
            var startAncestor = dom.ancestor(this.sc, pred);
            var endAncestor = dom.ancestor(this.ec, pred);
            if (!startAncestor && !endAncestor) {
                return new WrappedRange(this.sc, this.so, this.ec, this.eo);
            }
            var boundaryPoints = this.getPoints();
            if (startAncestor) {
                boundaryPoints.sc = startAncestor;
                boundaryPoints.so = 0;
            }
            if (endAncestor) {
                boundaryPoints.ec = endAncestor;
                boundaryPoints.eo = dom.nodeLength(endAncestor);
            }
            return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
        };
        /**
         * @param {Boolean} isCollapseToStart
         * @return {WrappedRange}
         */
        WrappedRange.prototype.collapse = function (isCollapseToStart) {
            if (isCollapseToStart) {
                return new WrappedRange(this.sc, this.so, this.sc, this.so);
            }
            else {
                return new WrappedRange(this.ec, this.eo, this.ec, this.eo);
            }
        };
        /**
         * splitText on range
         */
        WrappedRange.prototype.splitText = function () {
            var isSameContainer = this.sc === this.ec;
            var boundaryPoints = this.getPoints();
            if (dom.isText(this.ec) && !dom.isEdgePoint(this.getEndPoint())) {
                this.ec.splitText(this.eo);
            }
            if (dom.isText(this.sc) && !dom.isEdgePoint(this.getStartPoint())) {
                boundaryPoints.sc = this.sc.splitText(this.so);
                boundaryPoints.so = 0;
                if (isSameContainer) {
                    boundaryPoints.ec = boundaryPoints.sc;
                    boundaryPoints.eo = this.eo - this.so;
                }
            }
            return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
        };
        /**
         * delete contents on range
         * @return {WrappedRange}
         */
        WrappedRange.prototype.deleteContents = function () {
            if (this.isCollapsed()) {
                return this;
            }
            var rng = this.splitText();
            var nodes = rng.nodes(null, {
                fullyContains: true
            });
            // find new cursor point
            var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {
                return !lists.contains(nodes, point.node);
            });
            var emptyParents = [];
            $$1.each(nodes, function (idx, node) {
                // find empty parents
                var parent = node.parentNode;
                if (point.node !== parent && dom.nodeLength(parent) === 1) {
                    emptyParents.push(parent);
                }
                dom.remove(node, false);
            });
            // remove empty parents
            $$1.each(emptyParents, function (idx, node) {
                dom.remove(node, false);
            });
            return new WrappedRange(point.node, point.offset, point.node, point.offset).normalize();
        };
        /**
         * makeIsOn: return isOn(pred) function
         */
        WrappedRange.prototype.makeIsOn = function (pred) {
            return function () {
                var ancestor = dom.ancestor(this.sc, pred);
                return !!ancestor && (ancestor === dom.ancestor(this.ec, pred));
            };
        };
        /**
         * @param {Function} pred
         * @return {Boolean}
         */
        WrappedRange.prototype.isLeftEdgeOf = function (pred) {
            if (!dom.isLeftEdgePoint(this.getStartPoint())) {
                return false;
            }
            var node = dom.ancestor(this.sc, pred);
            return node && dom.isLeftEdgeOf(this.sc, node);
        };
        /**
         * returns whether range was collapsed or not
         */
        WrappedRange.prototype.isCollapsed = function () {
            return this.sc === this.ec && this.so === this.eo;
        };
        /**
         * wrap inline nodes which children of body with paragraph
         *
         * @return {WrappedRange}
         */
        WrappedRange.prototype.wrapBodyInlineWithPara = function () {
            if (dom.isBodyContainer(this.sc) && dom.isEmpty(this.sc)) {
                this.sc.innerHTML = dom.emptyPara;
                return new WrappedRange(this.sc.firstChild, 0, this.sc.firstChild, 0);
            }
            /**
             * [workaround] firefox often create range on not visible point. so normalize here.
             *  - firefox: |<p>text</p>|
             *  - chrome: <p>|text|</p>
             */
            var rng = this.normalize();
            if (dom.isParaInline(this.sc) || dom.isPara(this.sc)) {
                return rng;
            }
            // find inline top ancestor
            var topAncestor;
            if (dom.isInline(rng.sc)) {
                var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
                topAncestor = lists.last(ancestors);
                if (!dom.isInline(topAncestor)) {
                    topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
                }
            }
            else {
                topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
            }
            // siblings not in paragraph
            var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
            inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));
            // wrap with paragraph
            if (inlineSiblings.length) {
                var para = dom.wrap(lists.head(inlineSiblings), 'p');
                dom.appendChildNodes(para, lists.tail(inlineSiblings));
            }
            return this.normalize();
        };
        /**
         * insert node at current cursor
         *
         * @param {Node} node
         * @return {Node}
         */
        WrappedRange.prototype.insertNode = function (node) {
            var rng = this.wrapBodyInlineWithPara().deleteContents();
            var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));
            if (info.rightNode) {
                info.rightNode.parentNode.insertBefore(node, info.rightNode);
            }
            else {
                info.container.appendChild(node);
            }
            return node;
        };
        /**
         * insert html at current cursor
         */
        WrappedRange.prototype.pasteHTML = function (markup) {
            var contentsContainer = $$1('<div></div>').html(markup)[0];
            var childNodes = lists.from(contentsContainer.childNodes);
            var rng = this.wrapBodyInlineWithPara().deleteContents();
            return childNodes.reverse().map(function (childNode) {
                return rng.insertNode(childNode);
            }).reverse();
        };
        /**
         * returns text in range
         *
         * @return {String}
         */
        WrappedRange.prototype.toString = function () {
            var nativeRng = this.nativeRange();
            return env.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
        };
        /**
         * returns range for word before cursor
         *
         * @param {Boolean} [findAfter] - find after cursor, default: false
         * @return {WrappedRange}
         */
        WrappedRange.prototype.getWordRange = function (findAfter) {
            var endPoint = this.getEndPoint();
            if (!dom.isCharPoint(endPoint)) {
                return this;
            }
            var startPoint = dom.prevPointUntil(endPoint, function (point) {
                return !dom.isCharPoint(point);
            });
            if (findAfter) {
                endPoint = dom.nextPointUntil(endPoint, function (point) {
                    return !dom.isCharPoint(point);
                });
            }
            return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
        };
        /**
         * create offsetPath bookmark
         *
         * @param {Node} editable
         */
        WrappedRange.prototype.bookmark = function (editable) {
            return {
                s: {
                    path: dom.makeOffsetPath(editable, this.sc),
                    offset: this.so
                },
                e: {
                    path: dom.makeOffsetPath(editable, this.ec),
                    offset: this.eo
                }
            };
        };
        /**
         * create offsetPath bookmark base on paragraph
         *
         * @param {Node[]} paras
         */
        WrappedRange.prototype.paraBookmark = function (paras) {
            return {
                s: {
                    path: lists.tail(dom.makeOffsetPath(lists.head(paras), this.sc)),
                    offset: this.so
                },
                e: {
                    path: lists.tail(dom.makeOffsetPath(lists.last(paras), this.ec)),
                    offset: this.eo
                }
            };
        };
        /**
         * getClientRects
         * @return {Rect[]}
         */
        WrappedRange.prototype.getClientRects = function () {
            var nativeRng = this.nativeRange();
            return nativeRng.getClientRects();
        };
        return WrappedRange;
    }());
    /**
     * Data structure
     *  * BoundaryPoint: a point of dom tree
     *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range
     *
     * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position
     */
    var range = {
        /**
         * create Range Object From arguments or Browser Selection
         *
         * @param {Node} sc - start container
         * @param {Number} so - start offset
         * @param {Node} ec - end container
         * @param {Number} eo - end offset
         * @return {WrappedRange}
         */
        create: function (sc, so, ec, eo) {
            if (arguments.length === 4) {
                return new WrappedRange(sc, so, ec, eo);
            }
            else if (arguments.length === 2) {
                ec = sc;
                eo = so;
                return new WrappedRange(sc, so, ec, eo);
            }
            else {
                var wrappedRange = this.createFromSelection();
                if (!wrappedRange && arguments.length === 1) {
                    wrappedRange = this.createFromNode(arguments[0]);
                    return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);
                }
                return wrappedRange;
            }
        },
        createFromSelection: function () {
            var sc, so, ec, eo;
            if (env.isW3CRangeSupport) {
                var selection = document.getSelection();
                if (!selection || selection.rangeCount === 0) {
                    return null;
                }
                else if (dom.isBody(selection.anchorNode)) {
                    // Firefox: returns entire body as range on initialization.
                    // We won't never need it.
                    return null;
                }
                var nativeRng = selection.getRangeAt(0);
                sc = nativeRng.startContainer;
                so = nativeRng.startOffset;
                ec = nativeRng.endContainer;
                eo = nativeRng.endOffset;
            }
            else {
                var textRange = document.selection.createRange();
                var textRangeEnd = textRange.duplicate();
                textRangeEnd.collapse(false);
                var textRangeStart = textRange;
                textRangeStart.collapse(true);
                var startPoint = textRangeToPoint(textRangeStart, true);
                var endPoint = textRangeToPoint(textRangeEnd, false);
                // same visible point case: range was collapsed.
                if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&
                    dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&
                    endPoint.node.nextSibling === startPoint.node) {
                    startPoint = endPoint;
                }
                sc = startPoint.cont;
                so = startPoint.offset;
                ec = endPoint.cont;
                eo = endPoint.offset;
            }
            return new WrappedRange(sc, so, ec, eo);
        },
        /**
         * @method
         *
         * create WrappedRange from node
         *
         * @param {Node} node
         * @return {WrappedRange}
         */
        createFromNode: function (node) {
            var sc = node;
            var so = 0;
            var ec = node;
            var eo = dom.nodeLength(ec);
            // browsers can't target a picture or void node
            if (dom.isVoid(sc)) {
                so = dom.listPrev(sc).length - 1;
                sc = sc.parentNode;
            }
            if (dom.isBR(ec)) {
                eo = dom.listPrev(ec).length - 1;
                ec = ec.parentNode;
            }
            else if (dom.isVoid(ec)) {
                eo = dom.listPrev(ec).length;
                ec = ec.parentNode;
            }
            return this.create(sc, so, ec, eo);
        },
        /**
         * create WrappedRange from node after position
         *
         * @param {Node} node
         * @return {WrappedRange}
         */
        createFromNodeBefore: function (node) {
            return this.createFromNode(node).collapse(true);
        },
        /**
         * create WrappedRange from node after position
         *
         * @param {Node} node
         * @return {WrappedRange}
         */
        createFromNodeAfter: function (node) {
            return this.createFromNode(node).collapse();
        },
        /**
         * @method
         *
         * create WrappedRange from bookmark
         *
         * @param {Node} editable
         * @param {Object} bookmark
         * @return {WrappedRange}
         */
        createFromBookmark: function (editable, bookmark) {
            var sc = dom.fromOffsetPath(editable, bookmark.s.path);
            var so = bookmark.s.offset;
            var ec = dom.fromOffsetPath(editable, bookmark.e.path);
            var eo = bookmark.e.offset;
            return new WrappedRange(sc, so, ec, eo);
        },
        /**
         * @method
         *
         * create WrappedRange from paraBookmark
         *
         * @param {Object} bookmark
         * @param {Node[]} paras
         * @return {WrappedRange}
         */
        createFromParaBookmark: function (bookmark, paras) {
            var so = bookmark.s.offset;
            var eo = bookmark.e.offset;
            var sc = dom.fromOffsetPath(lists.head(paras), bookmark.s.path);
            var ec = dom.fromOffsetPath(lists.last(paras), bookmark.e.path);
            return new WrappedRange(sc, so, ec, eo);
        }
    };

    /**
     * @method readFileAsDataURL
     *
     * read contents of file as representing URL
     *
     * @param {File} file
     * @return {Promise} - then: dataUrl
     */
    function readFileAsDataURL(file) {
        return $$1.Deferred(function (deferred) {
            $$1.extend(new FileReader(), {
                onload: function (e) {
                    var dataURL = e.target.result;
                    deferred.resolve(dataURL);
                },
                onerror: function (err) {
                    deferred.reject(err);
                }
            }).readAsDataURL(file);
        }).promise();
    }

    /**
     * @method createImage
     *
     * create `<image>` from url string
     *
     * @param {String} url
     * @return {Promise} - then: $image
     */
    function createImage(url) {
        return $$1.Deferred(function (deferred) {
            var $img = $$1('<img>');
            $img.one('load', function () {
                $img.off('error abort');
                deferred.resolve($img);
            }).one('error abort', function () {
                $img.off('load').detach();
                deferred.reject($img);
            }).css({
                display: 'none'
            }).appendTo(document.body).attr('src', url);
        }).promise();
    }

    var History = /** @class */ (function () {
        function History($editable) {
            this.stack = [];
            this.stackOffset = -1;
            this.$editable = $editable;
            this.editable = $editable[0];
        }

        History.prototype.makeSnapshot = function () {
            var rng = range.create(this.editable);
            var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};
            return {
                contents: this.$editable.html(),
                bookmark: (rng ? rng.bookmark(this.editable) : emptyBookmark)
            };
        };
        History.prototype.applySnapshot = function (snapshot) {
            if (snapshot.contents !== null) {
                this.$editable.html(snapshot.contents);
            }
            if (snapshot.bookmark !== null) {
                range.createFromBookmark(this.editable, snapshot.bookmark).select();
            }
        };
        /**
         * @method rewind
         * Rewinds the history stack back to the first snapshot taken.
         * Leaves the stack intact, so that "Redo" can still be used.
         */
        History.prototype.rewind = function () {
            // Create snap shot if not yet recorded
            if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                this.recordUndo();
            }
            // Return to the first available snapshot.
            this.stackOffset = 0;
            // Apply that snapshot.
            this.applySnapshot(this.stack[this.stackOffset]);
        };
        /**
         * @method reset
         * Resets the history stack completely; reverting to an empty editor.
         */
        History.prototype.reset = function () {
            // Clear the stack.
            this.stack = [];
            // Restore stackOffset to its original value.
            this.stackOffset = -1;
            // Clear the editable area.
            this.$editable.html('');
            // Record our first snapshot (of nothing).
            this.recordUndo();
        };
        /**
         * undo
         */
        History.prototype.undo = function () {
            // Create snap shot if not yet recorded
            if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                this.recordUndo();
            }
            if (this.stackOffset > 0) {
                this.stackOffset--;
                this.applySnapshot(this.stack[this.stackOffset]);
            }
        };
        /**
         * redo
         */
        History.prototype.redo = function () {
            if (this.stack.length - 1 > this.stackOffset) {
                this.stackOffset++;
                this.applySnapshot(this.stack[this.stackOffset]);
            }
        };
        /**
         * recorded undo
         */
        History.prototype.recordUndo = function () {
            this.stackOffset++;
            // Wash out stack after stackOffset
            if (this.stack.length > this.stackOffset) {
                this.stack = this.stack.slice(0, this.stackOffset);
            }
            // Create new snapshot and push it to the end
            this.stack.push(this.makeSnapshot());
        };
        return History;
    }());

    var Style = /** @class */ (function () {
        function Style() {
        }

        /**
         * @method jQueryCSS
         *
         * [workaround] for old jQuery
         * passing an array of style properties to .css()
         * will result in an object of property-value pairs.
         * (compability with version < 1.9)
         *
         * @private
         * @param  {jQuery} $obj
         * @param  {Array} propertyNames - An array of one or more CSS properties.
         * @return {Object}
         */
        Style.prototype.jQueryCSS = function ($obj, propertyNames) {
            if (env.jqueryVersion < 1.9) {
                var result_1 = {};
                $$1.each(propertyNames, function (idx, propertyName) {
                    result_1[propertyName] = $obj.css(propertyName);
                });
                return result_1;
            }
            return $obj.css(propertyNames);
        };
        /**
         * returns style object from node
         *
         * @param {jQuery} $node
         * @return {Object}
         */
        Style.prototype.fromNode = function ($node) {
            var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];
            var styleInfo = this.jQueryCSS($node, properties) || {};
            styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);
            return styleInfo;
        };
        /**
         * paragraph level style
         *
         * @param {WrappedRange} rng
         * @param {Object} styleInfo
         */
        Style.prototype.stylePara = function (rng, styleInfo) {
            $$1.each(rng.nodes(dom.isPara, {
                includeAncestor: true
            }), function (idx, para) {
                $$1(para).css(styleInfo);
            });
        };
        /**
         * insert and returns styleNodes on range.
         *
         * @param {WrappedRange} rng
         * @param {Object} [options] - options for styleNodes
         * @param {String} [options.nodeName] - default: `SPAN`
         * @param {Boolean} [options.expandClosestSibling] - default: `false`
         * @param {Boolean} [options.onlyPartialContains] - default: `false`
         * @return {Node[]}
         */
        Style.prototype.styleNodes = function (rng, options) {
            rng = rng.splitText();
            var nodeName = (options && options.nodeName) || 'SPAN';
            var expandClosestSibling = !!(options && options.expandClosestSibling);
            var onlyPartialContains = !!(options && options.onlyPartialContains);
            if (rng.isCollapsed()) {
                return [rng.insertNode(dom.create(nodeName))];
            }
            var pred = dom.makePredByNodeName(nodeName);
            var nodes = rng.nodes(dom.isText, {
                fullyContains: true
            }).map(function (text) {
                return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);
            });
            if (expandClosestSibling) {
                if (onlyPartialContains) {
                    var nodesInRange_1 = rng.nodes();
                    // compose with partial contains predication
                    pred = func.and(pred, function (node) {
                        return lists.contains(nodesInRange_1, node);
                    });
                }
                return nodes.map(function (node) {
                    var siblings = dom.withClosestSiblings(node, pred);
                    var head = lists.head(siblings);
                    var tails = lists.tail(siblings);
                    $$1.each(tails, function (idx, elem) {
                        dom.appendChildNodes(head, elem.childNodes);
                        dom.remove(elem);
                    });
                    return lists.head(siblings);
                });
            }
            else {
                return nodes;
            }
        };
        /**
         * get current style on cursor
         *
         * @param {WrappedRange} rng
         * @return {Object} - object contains style properties.
         */
        Style.prototype.current = function (rng) {
            var $cont = $$1(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);
            var styleInfo = this.fromNode($cont);
            // document.queryCommandState for toggle state
            // [workaround] prevent Firefox nsresult: "0x80004005 (NS_ERROR_FAILURE)"
            try {
                styleInfo = $$1.extend(styleInfo, {
                    'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',
                    'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',
                    'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',
                    'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',
                    'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',
                    'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal',
                    'font-family': document.queryCommandValue('fontname') || styleInfo['font-family']
                });
            }
            catch (e) {
            }
            // list-style-type to list-style(unordered, ordered)
            if (!rng.isOnList()) {
                styleInfo['list-style'] = 'none';
            }
            else {
                var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];
                var isUnordered = $$1.inArray(styleInfo['list-style-type'], orderedTypes) > -1;
                styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';
            }
            var para = dom.ancestor(rng.sc, dom.isPara);
            if (para && para.style['line-height']) {
                styleInfo['line-height'] = para.style.lineHeight;
            }
            else {
                var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);
                styleInfo['line-height'] = lineHeight.toFixed(1);
            }
            styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
            styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
            styleInfo.range = rng;
            return styleInfo;
        };
        return Style;
    }());

    var Bullet = /** @class */ (function () {
        function Bullet() {
        }

        /**
         * toggle ordered list
         */
        Bullet.prototype.insertOrderedList = function (editable) {
            this.toggleList('OL', editable);
        };
        /**
         * toggle unordered list
         */
        Bullet.prototype.insertUnorderedList = function (editable) {
            this.toggleList('UL', editable);
        };
        /**
         * indent
         */
        Bullet.prototype.indent = function (editable) {
            var _this = this;
            var rng = range.create(editable).wrapBodyInlineWithPara();
            var paras = rng.nodes(dom.isPara, {includeAncestor: true});
            var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
            $$1.each(clustereds, function (idx, paras) {
                var head = lists.head(paras);
                if (dom.isLi(head)) {
                    _this.wrapList(paras, head.parentNode.nodeName);
                }
                else {
                    $$1.each(paras, function (idx, para) {
                        $$1(para).css('marginLeft', function (idx, val) {
                            return (parseInt(val, 10) || 0) + 25;
                        });
                    });
                }
            });
            rng.select();
        };
        /**
         * outdent
         */
        Bullet.prototype.outdent = function (editable) {
            var _this = this;
            var rng = range.create(editable).wrapBodyInlineWithPara();
            var paras = rng.nodes(dom.isPara, {includeAncestor: true});
            var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
            $$1.each(clustereds, function (idx, paras) {
                var head = lists.head(paras);
                if (dom.isLi(head)) {
                    _this.releaseList([paras]);
                }
                else {
                    $$1.each(paras, function (idx, para) {
                        $$1(para).css('marginLeft', function (idx, val) {
                            val = (parseInt(val, 10) || 0);
                            return val > 25 ? val - 25 : '';
                        });
                    });
                }
            });
            rng.select();
        };
        /**
         * toggle list
         *
         * @param {String} listName - OL or UL
         */
        Bullet.prototype.toggleList = function (listName, editable) {
            var _this = this;
            var rng = range.create(editable).wrapBodyInlineWithPara();
            var paras = rng.nodes(dom.isPara, {includeAncestor: true});
            var bookmark = rng.paraBookmark(paras);
            var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
            // paragraph to list
            if (lists.find(paras, dom.isPurePara)) {
                var wrappedParas_1 = [];
                $$1.each(clustereds, function (idx, paras) {
                    wrappedParas_1 = wrappedParas_1.concat(_this.wrapList(paras, listName));
                });
                paras = wrappedParas_1;
                // list to paragraph or change list style
            }
            else {
                var diffLists = rng.nodes(dom.isList, {
                    includeAncestor: true
                }).filter(function (listNode) {
                    return !$$1.nodeName(listNode, listName);
                });
                if (diffLists.length) {
                    $$1.each(diffLists, function (idx, listNode) {
                        dom.replace(listNode, listName);
                    });
                }
                else {
                    paras = this.releaseList(clustereds, true);
                }
            }
            range.createFromParaBookmark(bookmark, paras).select();
        };
        /**
         * @param {Node[]} paras
         * @param {String} listName
         * @return {Node[]}
         */
        Bullet.prototype.wrapList = function (paras, listName) {
            var head = lists.head(paras);
            var last = lists.last(paras);
            var prevList = dom.isList(head.previousSibling) && head.previousSibling;
            var nextList = dom.isList(last.nextSibling) && last.nextSibling;
            var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);
            // P to LI
            paras = paras.map(function (para) {
                return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;
            });
            // append to list(<ul>, <ol>)
            dom.appendChildNodes(listNode, paras);
            if (nextList) {
                dom.appendChildNodes(listNode, lists.from(nextList.childNodes));
                dom.remove(nextList);
            }
            return paras;
        };
        /**
         * @method releaseList
         *
         * @param {Array[]} clustereds
         * @param {Boolean} isEscapseToBody
         * @return {Node[]}
         */
        Bullet.prototype.releaseList = function (clustereds, isEscapseToBody) {
            var releasedParas = [];
            $$1.each(clustereds, function (idx, paras) {
                var head = lists.head(paras);
                var last = lists.last(paras);
                var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) : head.parentNode;
                var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
                    node: last.parentNode,
                    offset: dom.position(last) + 1
                }, {
                    isSkipPaddingBlankHTML: true
                }) : null;
                var middleList = dom.splitTree(headList, {
                    node: head.parentNode,
                    offset: dom.position(head)
                }, {
                    isSkipPaddingBlankHTML: true
                });
                paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi)
                    : lists.from(middleList.childNodes).filter(dom.isLi);
                // LI to P
                if (isEscapseToBody || !dom.isList(headList.parentNode)) {
                    paras = paras.map(function (para) {
                        return dom.replace(para, 'P');
                    });
                }
                $$1.each(lists.from(paras).reverse(), function (idx, para) {
                    dom.insertAfter(para, headList);
                });
                // remove empty lists
                var rootLists = lists.compact([headList, middleList, lastList]);
                $$1.each(rootLists, function (idx, rootList) {
                    var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
                    $$1.each(listNodes.reverse(), function (idx, listNode) {
                        if (!dom.nodeLength(listNode)) {
                            dom.remove(listNode, true);
                        }
                    });
                });
                releasedParas = releasedParas.concat(paras);
            });
            return releasedParas;
        };
        return Bullet;
    }());

    /**
     * @class editing.Typing
     *
     * Typing
     *
     */
    var Typing = /** @class */ (function () {
        function Typing() {
            // a Bullet instance to toggle lists off
            this.bullet = new Bullet();
        }

        /**
         * insert tab
         *
         * @param {WrappedRange} rng
         * @param {Number} tabsize
         */
        Typing.prototype.insertTab = function (rng, tabsize) {
            var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
            rng = rng.deleteContents();
            rng.insertNode(tab, true);
            rng = range.create(tab, tabsize);
            rng.select();
        };
        /**
         * insert paragraph
         */
        Typing.prototype.insertParagraph = function (editable) {
            var rng = range.create(editable);
            // deleteContents on range.
            rng = rng.deleteContents();
            // Wrap range if it needs to be wrapped by paragraph
            rng = rng.wrapBodyInlineWithPara();
            // finding paragraph
            var splitRoot = dom.ancestor(rng.sc, dom.isPara);
            var nextPara;
            // on paragraph: split paragraph
            if (splitRoot) {
                // if it is an empty line with li
                if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {
                    // toogle UL/OL and escape
                    this.bullet.toggleList(splitRoot.parentNode.nodeName);
                    return;
                    // if it is an empty line with para on blockquote
                }
                else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {
                    // escape blockquote
                    dom.insertAfter(splitRoot, splitRoot.parentNode);
                    nextPara = splitRoot;
                    // if new line has content (not a line break)
                }
                else {
                    nextPara = dom.splitTree(splitRoot, rng.getStartPoint());
                    var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
                    emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));
                    $$1.each(emptyAnchors, function (idx, anchor) {
                        dom.remove(anchor);
                    });
                    // replace empty heading, pre or custom-made styleTag with P tag
                    if ((dom.isHeading(nextPara) || dom.isPre(nextPara) || dom.isCustomStyleTag(nextPara)) && dom.isEmpty(nextPara)) {
                        nextPara = dom.replace(nextPara, 'p');
                    }
                }
                // no paragraph: insert empty paragraph
            }
            else {
                var next = rng.sc.childNodes[rng.so];
                nextPara = $$1(dom.emptyPara)[0];
                if (next) {
                    rng.sc.insertBefore(nextPara, next);
                }
                else {
                    rng.sc.appendChild(nextPara);
                }
            }
            range.create(nextPara, 0).normalize().select().scrollIntoView(editable);
        };
        return Typing;
    }());

    /**
     * @class Create a virtual table to create what actions to do in change.
     * @param {object} startPoint Cell selected to apply change.
     * @param {enum} where  Where change will be applied Row or Col. Use enum: TableResultAction.where
     * @param {enum} action Action to be applied. Use enum: TableResultAction.requestAction
     * @param {object} domTable Dom element of table to make changes.
     */
    var TableResultAction = function (startPoint, where, action, domTable) {
        var _startPoint = {'colPos': 0, 'rowPos': 0};
        var _virtualTable = [];
        var _actionCellList = [];
        /// ///////////////////////////////////////////
        // Private functions
        /// ///////////////////////////////////////////
        /**
         * Set the startPoint of action.
         */
        function setStartPoint() {
            if (!startPoint || !startPoint.tagName || (startPoint.tagName.toLowerCase() !== 'td' && startPoint.tagName.toLowerCase() !== 'th')) {
                console.error('Impossible to identify start Cell point.', startPoint);
                return;
            }
            _startPoint.colPos = startPoint.cellIndex;
            if (!startPoint.parentElement || !startPoint.parentElement.tagName || startPoint.parentElement.tagName.toLowerCase() !== 'tr') {
                console.error('Impossible to identify start Row point.', startPoint);
                return;
            }
            _startPoint.rowPos = startPoint.parentElement.rowIndex;
        }

        /**
         * Define virtual table position info object.
         *
         * @param {int} rowIndex Index position in line of virtual table.
         * @param {int} cellIndex Index position in column of virtual table.
         * @param {object} baseRow Row affected by this position.
         * @param {object} baseCell Cell affected by this position.
         * @param {bool} isSpan Inform if it is an span cell/row.
         */
        function setVirtualTablePosition(rowIndex, cellIndex, baseRow, baseCell, isRowSpan, isColSpan, isVirtualCell) {
            var objPosition = {
                'baseRow': baseRow,
                'baseCell': baseCell,
                'isRowSpan': isRowSpan,
                'isColSpan': isColSpan,
                'isVirtual': isVirtualCell
            };
            if (!_virtualTable[rowIndex]) {
                _virtualTable[rowIndex] = [];
            }
            _virtualTable[rowIndex][cellIndex] = objPosition;
        }

        /**
         * Create action cell object.
         *
         * @param {object} virtualTableCellObj Object of specific position on virtual table.
         * @param {enum} resultAction Action to be applied in that item.
         */
        function getActionCell(virtualTableCellObj, resultAction, virtualRowPosition, virtualColPosition) {
            return {
                'baseCell': virtualTableCellObj.baseCell,
                'action': resultAction,
                'virtualTable': {
                    'rowIndex': virtualRowPosition,
                    'cellIndex': virtualColPosition
                }
            };
        }

        /**
         * Recover free index of row to append Cell.
         *
         * @param {int} rowIndex Index of row to find free space.
         * @param {int} cellIndex Index of cell to find free space in table.
         */
        function recoverCellIndex(rowIndex, cellIndex) {
            if (!_virtualTable[rowIndex]) {
                return cellIndex;
            }
            if (!_virtualTable[rowIndex][cellIndex]) {
                return cellIndex;
            }
            var newCellIndex = cellIndex;
            while (_virtualTable[rowIndex][newCellIndex]) {
                newCellIndex++;
                if (!_virtualTable[rowIndex][newCellIndex]) {
                    return newCellIndex;
                }
            }
        }

        /**
         * Recover info about row and cell and add information to virtual table.
         *
         * @param {object} row Row to recover information.
         * @param {object} cell Cell to recover information.
         */
        function addCellInfoToVirtual(row, cell) {
            var cellIndex = recoverCellIndex(row.rowIndex, cell.cellIndex);
            var cellHasColspan = (cell.colSpan > 1);
            var cellHasRowspan = (cell.rowSpan > 1);
            var isThisSelectedCell = (row.rowIndex === _startPoint.rowPos && cell.cellIndex === _startPoint.colPos);
            setVirtualTablePosition(row.rowIndex, cellIndex, row, cell, cellHasRowspan, cellHasColspan, false);
            // Add span rows to virtual Table.
            var rowspanNumber = cell.attributes.rowSpan ? parseInt(cell.attributes.rowSpan.value, 10) : 0;
            if (rowspanNumber > 1) {
                for (var rp = 1; rp < rowspanNumber; rp++) {
                    var rowspanIndex = row.rowIndex + rp;
                    adjustStartPoint(rowspanIndex, cellIndex, cell, isThisSelectedCell);
                    setVirtualTablePosition(rowspanIndex, cellIndex, row, cell, true, cellHasColspan, true);
                }
            }
            // Add span cols to virtual table.
            var colspanNumber = cell.attributes.colSpan ? parseInt(cell.attributes.colSpan.value, 10) : 0;
            if (colspanNumber > 1) {
                for (var cp = 1; cp < colspanNumber; cp++) {
                    var cellspanIndex = recoverCellIndex(row.rowIndex, (cellIndex + cp));
                    adjustStartPoint(row.rowIndex, cellspanIndex, cell, isThisSelectedCell);
                    setVirtualTablePosition(row.rowIndex, cellspanIndex, row, cell, cellHasRowspan, true, true);
                }
            }
        }

        /**
         * Process validation and adjust of start point if needed
         *
         * @param {int} rowIndex
         * @param {int} cellIndex
         * @param {object} cell
         * @param {bool} isSelectedCell
         */
        function adjustStartPoint(rowIndex, cellIndex, cell, isSelectedCell) {
            if (rowIndex === _startPoint.rowPos && _startPoint.colPos >= cell.cellIndex && cell.cellIndex <= cellIndex && !isSelectedCell) {
                _startPoint.colPos++;
            }
        }

        /**
         * Create virtual table of cells with all cells, including span cells.
         */
        function createVirtualTable() {
            var rows = domTable.rows;
            for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                var cells = rows[rowIndex].cells;
                for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                    addCellInfoToVirtual(rows[rowIndex], cells[cellIndex]);
                }
            }
        }

        /**
         * Get action to be applied on the cell.
         *
         * @param {object} cell virtual table cell to apply action
         */
        function getDeleteResultActionToCell(cell) {
            switch (where) {
                case TableResultAction.where.Column:
                    if (cell.isColSpan) {
                        return TableResultAction.resultAction.SubtractSpanCount;
                    }
                    break;
                case TableResultAction.where.Row:
                    if (!cell.isVirtual && cell.isRowSpan) {
                        return TableResultAction.resultAction.AddCell;
                    }
                    else if (cell.isRowSpan) {
                        return TableResultAction.resultAction.SubtractSpanCount;
                    }
                    break;
            }
            return TableResultAction.resultAction.RemoveCell;
        }

        /**
         * Get action to be applied on the cell.
         *
         * @param {object} cell virtual table cell to apply action
         */
        function getAddResultActionToCell(cell) {
            switch (where) {
                case TableResultAction.where.Column:
                    if (cell.isColSpan) {
                        return TableResultAction.resultAction.SumSpanCount;
                    }
                    else if (cell.isRowSpan && cell.isVirtual) {
                        return TableResultAction.resultAction.Ignore;
                    }
                    break;
                case TableResultAction.where.Row:
                    if (cell.isRowSpan) {
                        return TableResultAction.resultAction.SumSpanCount;
                    }
                    else if (cell.isColSpan && cell.isVirtual) {
                        return TableResultAction.resultAction.Ignore;
                    }
                    break;
            }
            return TableResultAction.resultAction.AddCell;
        }

        function init() {
            setStartPoint();
            createVirtualTable();
        }

        /// ///////////////////////////////////////////
        // Public functions
        /// ///////////////////////////////////////////
        /**
         * Recover array os what to do in table.
         */
        this.getActionList = function () {
            var fixedRow = (where === TableResultAction.where.Row) ? _startPoint.rowPos : -1;
            var fixedCol = (where === TableResultAction.where.Column) ? _startPoint.colPos : -1;
            var actualPosition = 0;
            var canContinue = true;
            while (canContinue) {
                var rowPosition = (fixedRow >= 0) ? fixedRow : actualPosition;
                var colPosition = (fixedCol >= 0) ? fixedCol : actualPosition;
                var row = _virtualTable[rowPosition];
                if (!row) {
                    canContinue = false;
                    return _actionCellList;
                }
                var cell = row[colPosition];
                if (!cell) {
                    canContinue = false;
                    return _actionCellList;
                }
                // Define action to be applied in this cell
                var resultAction = TableResultAction.resultAction.Ignore;
                switch (action) {
                    case TableResultAction.requestAction.Add:
                        resultAction = getAddResultActionToCell(cell);
                        break;
                    case TableResultAction.requestAction.Delete:
                        resultAction = getDeleteResultActionToCell(cell);
                        break;
                }
                _actionCellList.push(getActionCell(cell, resultAction, rowPosition, colPosition));
                actualPosition++;
            }
            return _actionCellList;
        };
        init();
    };
    /**
     *
     * Where action occours enum.
     */
    TableResultAction.where = {'Row': 0, 'Column': 1};
    /**
     *
     * Requested action to apply enum.
     */
    TableResultAction.requestAction = {'Add': 0, 'Delete': 1};
    /**
     *
     * Result action to be executed enum.
     */
    TableResultAction.resultAction = {
        'Ignore': 0,
        'SubtractSpanCount': 1,
        'RemoveCell': 2,
        'AddCell': 3,
        'SumSpanCount': 4
    };
    /**
     *
     * @class editing.Table
     *
     * Table
     *
     */
    var Table = /** @class */ (function () {
        function Table() {
        }

        /**
         * handle tab key
         *
         * @param {WrappedRange} rng
         * @param {Boolean} isShift
         */
        Table.prototype.tab = function (rng, isShift) {
            var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
            var table = dom.ancestor(cell, dom.isTable);
            var cells = dom.listDescendant(table, dom.isCell);
            var nextCell = lists[isShift ? 'prev' : 'next'](cells, cell);
            if (nextCell) {
                range.create(nextCell, 0).select();
            }
        };
        /**
         * Add a new row
         *
         * @param {WrappedRange} rng
         * @param {String} position (top/bottom)
         * @return {Node}
         */
        Table.prototype.addRow = function (rng, position) {
            var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
            var currentTr = $$1(cell).closest('tr');
            var trAttributes = this.recoverAttributes(currentTr);
            var html = $$1('<tr' + trAttributes + '></tr>');
            var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Add, $$1(currentTr).closest('table')[0]);
            var actions = vTable.getActionList();
            for (var idCell = 0; idCell < actions.length; idCell++) {
                var currentCell = actions[idCell];
                var tdAttributes = this.recoverAttributes(currentCell.baseCell);
                switch (currentCell.action) {
                    case TableResultAction.resultAction.AddCell:
                        html.append('<td' + tdAttributes + '>' + dom.blank + '</td>');
                        break;
                    case TableResultAction.resultAction.SumSpanCount:
                        if (position === 'top') {
                            var baseCellTr = currentCell.baseCell.parent;
                            var isTopFromRowSpan = (!baseCellTr ? 0 : currentCell.baseCell.closest('tr').rowIndex) <= currentTr[0].rowIndex;
                            if (isTopFromRowSpan) {
                                var newTd = $$1('<div></div>').append($$1('<td' + tdAttributes + '>' + dom.blank + '</td>').removeAttr('rowspan')).html();
                                html.append(newTd);
                                break;
                            }
                        }
                        var rowspanNumber = parseInt(currentCell.baseCell.rowSpan, 10);
                        rowspanNumber++;
                        currentCell.baseCell.setAttribute('rowSpan', rowspanNumber);
                        break;
                }
            }
            if (position === 'top') {
                currentTr.before(html);
            }
            else {
                var cellHasRowspan = (cell.rowSpan > 1);
                if (cellHasRowspan) {
                    var lastTrIndex = currentTr[0].rowIndex + (cell.rowSpan - 2);
                    $$1($$1(currentTr).parent().find('tr')[lastTrIndex]).after($$1(html));
                    return;
                }
                currentTr.after(html);
            }
        };
        /**
         * Add a new col
         *
         * @param {WrappedRange} rng
         * @param {String} position (left/right)
         * @return {Node}
         */
        Table.prototype.addCol = function (rng, position) {
            var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
            var row = $$1(cell).closest('tr');
            var rowsGroup = $$1(row).siblings();
            rowsGroup.push(row);
            var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Add, $$1(row).closest('table')[0]);
            var actions = vTable.getActionList();
            for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                var currentCell = actions[actionIndex];
                var tdAttributes = this.recoverAttributes(currentCell.baseCell);
                switch (currentCell.action) {
                    case TableResultAction.resultAction.AddCell:
                        if (position === 'right') {
                            $$1(currentCell.baseCell).after('<td' + tdAttributes + '>' + dom.blank + '</td>');
                        }
                        else {
                            $$1(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
                        }
                        break;
                    case TableResultAction.resultAction.SumSpanCount:
                        if (position === 'right') {
                            var colspanNumber = parseInt(currentCell.baseCell.colSpan, 10);
                            colspanNumber++;
                            currentCell.baseCell.setAttribute('colSpan', colspanNumber);
                        }
                        else {
                            $$1(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
                        }
                        break;
                }
            }
        };
        /*
    * Copy attributes from element.
    *
    * @param {object} Element to recover attributes.
    * @return {string} Copied string elements.
    */
        Table.prototype.recoverAttributes = function (el) {
            var resultStr = '';
            if (!el) {
                return resultStr;
            }
            var attrList = el.attributes || [];
            for (var i = 0; i < attrList.length; i++) {
                if (attrList[i].name.toLowerCase() === 'id') {
                    continue;
                }
                if (attrList[i].specified) {
                    resultStr += ' ' + attrList[i].name + '=\'' + attrList[i].value + '\'';
                }
            }
            return resultStr;
        };
        /**
         * Delete current row
         *
         * @param {WrappedRange} rng
         * @return {Node}
         */
        Table.prototype.deleteRow = function (rng) {
            var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
            var row = $$1(cell).closest('tr');
            var cellPos = row.children('td, th').index($$1(cell));
            var rowPos = row[0].rowIndex;
            var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Delete, $$1(row).closest('table')[0]);
            var actions = vTable.getActionList();
            for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                if (!actions[actionIndex]) {
                    continue;
                }
                var baseCell = actions[actionIndex].baseCell;
                var virtualPosition = actions[actionIndex].virtualTable;
                var hasRowspan = (baseCell.rowSpan && baseCell.rowSpan > 1);
                var rowspanNumber = (hasRowspan) ? parseInt(baseCell.rowSpan, 10) : 0;
                switch (actions[actionIndex].action) {
                    case TableResultAction.resultAction.Ignore:
                        continue;
                    case TableResultAction.resultAction.AddCell:
                        var nextRow = row.next('tr')[0];
                        if (!nextRow) {
                            continue;
                        }
                        var cloneRow = row[0].cells[cellPos];
                        if (hasRowspan) {
                            if (rowspanNumber > 2) {
                                rowspanNumber--;
                                nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                                nextRow.cells[cellPos].setAttribute('rowSpan', rowspanNumber);
                                nextRow.cells[cellPos].innerHTML = '';
                            }
                            else if (rowspanNumber === 2) {
                                nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                                nextRow.cells[cellPos].removeAttribute('rowSpan');
                                nextRow.cells[cellPos].innerHTML = '';
                            }
                        }
                        continue;
                    case TableResultAction.resultAction.SubtractSpanCount:
                        if (hasRowspan) {
                            if (rowspanNumber > 2) {
                                rowspanNumber--;
                                baseCell.setAttribute('rowSpan', rowspanNumber);
                                if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                                    baseCell.innerHTML = '';
                                }
                            }
                            else if (rowspanNumber === 2) {
                                baseCell.removeAttribute('rowSpan');
                                if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                                    baseCell.innerHTML = '';
                                }
                            }
                        }
                        continue;
                    case TableResultAction.resultAction.RemoveCell:
                        // Do not need remove cell because row will be deleted.
                        continue;
                }
            }
            row.remove();
        };
        /**
         * Delete current col
         *
         * @param {WrappedRange} rng
         * @return {Node}
         */
        Table.prototype.deleteCol = function (rng) {
            var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
            var row = $$1(cell).closest('tr');
            var cellPos = row.children('td, th').index($$1(cell));
            var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Delete, $$1(row).closest('table')[0]);
            var actions = vTable.getActionList();
            for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                if (!actions[actionIndex]) {
                    continue;
                }
                switch (actions[actionIndex].action) {
                    case TableResultAction.resultAction.Ignore:
                        continue;
                    case TableResultAction.resultAction.SubtractSpanCount:
                        var baseCell = actions[actionIndex].baseCell;
                        var hasColspan = (baseCell.colSpan && baseCell.colSpan > 1);
                        if (hasColspan) {
                            var colspanNumber = (baseCell.colSpan) ? parseInt(baseCell.colSpan, 10) : 0;
                            if (colspanNumber > 2) {
                                colspanNumber--;
                                baseCell.setAttribute('colSpan', colspanNumber);
                                if (baseCell.cellIndex === cellPos) {
                                    baseCell.innerHTML = '';
                                }
                            }
                            else if (colspanNumber === 2) {
                                baseCell.removeAttribute('colSpan');
                                if (baseCell.cellIndex === cellPos) {
                                    baseCell.innerHTML = '';
                                }
                            }
                        }
                        continue;
                    case TableResultAction.resultAction.RemoveCell:
                        dom.remove(actions[actionIndex].baseCell, true);
                        continue;
                }
            }
        };
        /**
         * create empty table element
         *
         * @param {Number} rowCount
         * @param {Number} colCount
         * @return {Node}
         */
        Table.prototype.createTable = function (colCount, rowCount, options) {
            var tds = [];
            var tdHTML;
            for (var idxCol = 0; idxCol < colCount; idxCol++) {
                tds.push('<td>' + dom.blank + '</td>');
            }
            tdHTML = tds.join('');
            var trs = [];
            var trHTML;
            for (var idxRow = 0; idxRow < rowCount; idxRow++) {
                trs.push('<tr>' + tdHTML + '</tr>');
            }
            trHTML = trs.join('');
            var $table = $$1('<table>' + trHTML + '</table>');
            if (options && options.tableClassName) {
                $table.addClass(options.tableClassName);
            }
            return $table[0];
        };
        /**
         * Delete current table
         *
         * @param {WrappedRange} rng
         * @return {Node}
         */
        Table.prototype.deleteTable = function (rng) {
            var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
            $$1(cell).closest('table').remove();
        };
        return Table;
    }());

    var KEY_BOGUS = 'bogus';
    /**
     * @class Editor
     */
    var Editor = /** @class */ (function () {
        function Editor(context) {
            var _this = this;
            this.context = context;
            this.$note = context.layoutInfo.note;
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.editable = this.$editable[0];
            this.lastRange = null;
            this.style = new Style();
            this.table = new Table();
            this.typing = new Typing();
            this.bullet = new Bullet();
            this.history = new History(this.$editable);
            this.context.memo('help.undo', this.lang.help.undo);
            this.context.memo('help.redo', this.lang.help.redo);
            this.context.memo('help.tab', this.lang.help.tab);
            this.context.memo('help.untab', this.lang.help.untab);
            this.context.memo('help.insertParagraph', this.lang.help.insertParagraph);
            this.context.memo('help.insertOrderedList', this.lang.help.insertOrderedList);
            this.context.memo('help.insertUnorderedList', this.lang.help.insertUnorderedList);
            this.context.memo('help.indent', this.lang.help.indent);
            this.context.memo('help.outdent', this.lang.help.outdent);
            this.context.memo('help.formatPara', this.lang.help.formatPara);
            this.context.memo('help.insertHorizontalRule', this.lang.help.insertHorizontalRule);
            this.context.memo('help.fontName', this.lang.help.fontName);
            // native commands(with execCommand), generate function for execCommand
            var commands = [
                'bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',
                'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',
                'formatBlock', 'removeFormat', 'backColor'
            ];
            for (var idx = 0, len = commands.length; idx < len; idx++) {
                this[commands[idx]] = (function (sCmd) {
                    return function (value) {
                        _this.beforeCommand();
                        document.execCommand(sCmd, false, value);
                        _this.afterCommand(true);
                    };
                })(commands[idx]);
                this.context.memo('help.' + commands[idx], this.lang.help[commands[idx]]);
            }
            this.fontName = this.wrapCommand(function (value) {
                return _this.fontStyling('font-family', "\'" + value + "\'");
            });
            this.fontSize = this.wrapCommand(function (value) {
                return _this.fontStyling('font-size', value + 'px');
            });
            for (var idx = 1; idx <= 6; idx++) {
                this['formatH' + idx] = (function (idx) {
                    return function () {
                        _this.formatBlock('H' + idx);
                    };
                })(idx);
                this.context.memo('help.formatH' + idx, this.lang.help['formatH' + idx]);
            }

            this.insertParagraph = this.wrapCommand(function () {
                _this.typing.insertParagraph(_this.editable);
            });
            this.insertOrderedList = this.wrapCommand(function () {
                _this.bullet.insertOrderedList(_this.editable);
            });
            this.insertUnorderedList = this.wrapCommand(function () {
                _this.bullet.insertUnorderedList(_this.editable);
            });
            this.indent = this.wrapCommand(function () {
                _this.bullet.indent(_this.editable);
            });
            this.outdent = this.wrapCommand(function () {
                _this.bullet.outdent(_this.editable);
            });
            /**
             * insertNode
             * insert node
             * @param {Node} node
             */
            this.insertNode = this.wrapCommand(function (node) {
                if (_this.isLimited($$1(node).text().length)) {
                    return;
                }
                var rng = _this.createRange();
                rng.insertNode(node);
                range.createFromNodeAfter(node).select();
            });
            /**
             * insert text
             * @param {String} text
             */
            this.insertText = this.wrapCommand(function (text) {
                if (_this.isLimited(text.length)) {
                    return;
                }
                var rng = _this.createRange();
                var textNode = rng.insertNode(dom.createText(text));
                range.create(textNode, dom.nodeLength(textNode)).select();
            });
            /**
             * paste HTML
             * @param {String} markup
             */
            this.pasteHTML = this.wrapCommand(function (markup) {
                if (_this.isLimited(markup.length)) {
                    return;
                }
                var contents = _this.createRange().pasteHTML(markup);
                range.createFromNodeAfter(lists.last(contents)).select();
            });
            /**
             * formatBlock
             *
             * @param {String} tagName
             */
            this.formatBlock = this.wrapCommand(function (tagName, $target) {
                var onApplyCustomStyle = _this.options.callbacks.onApplyCustomStyle;
                if (onApplyCustomStyle) {
                    onApplyCustomStyle.call(_this, $target, _this.context, _this.onFormatBlock);
                }
                else {
                    _this.onFormatBlock(tagName, $target);
                }
            });
            /**
             * insert horizontal rule
             */
            this.insertHorizontalRule = this.wrapCommand(function () {
                var hrNode = _this.createRange().insertNode(dom.create('HR'));
                if (hrNode.nextSibling) {
                    range.create(hrNode.nextSibling, 0).normalize().select();
                }
            });
            /**
             * lineHeight
             * @param {String} value
             */
            this.lineHeight = this.wrapCommand(function (value) {
                _this.style.stylePara(_this.createRange(), {
                    lineHeight: value
                });
            });
            /**
             * create link (command)
             *
             * @param {Object} linkInfo
             */
            this.createLink = this.wrapCommand(function (linkInfo) {
                var linkUrl = linkInfo.url;
                var linkText = linkInfo.text;
                var isNewWindow = linkInfo.isNewWindow;
                var rng = linkInfo.range || _this.createRange();
                var isTextChanged = rng.toString() !== linkText;
                // handle spaced urls from input
                if (typeof linkUrl === 'string') {
                    linkUrl = linkUrl.trim();
                }
                if (_this.options.onCreateLink) {
                    linkUrl = _this.options.onCreateLink(linkUrl);
                }
                else {
                    // if url doesn't match an URL schema, set http:// as default
                    linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?/.test(linkUrl)
                        ? linkUrl : 'http://' + linkUrl;
                }
                var anchors = [];
                if (isTextChanged) {
                    rng = rng.deleteContents();
                    var anchor = rng.insertNode($$1('<A>' + linkText + '</A>')[0]);
                    anchors.push(anchor);
                }
                else {
                    anchors = _this.style.styleNodes(rng, {
                        nodeName: 'A',
                        expandClosestSibling: true,
                        onlyPartialContains: true
                    });
                }
                $$1.each(anchors, function (idx, anchor) {
                    $$1(anchor).attr('href', linkUrl);
                    if (isNewWindow) {
                        $$1(anchor).attr('target', '_blank');
                    }
                    else {
                        $$1(anchor).removeAttr('target');
                    }
                });
                var startRange = range.createFromNodeBefore(lists.head(anchors));
                var startPoint = startRange.getStartPoint();
                var endRange = range.createFromNodeAfter(lists.last(anchors));
                var endPoint = endRange.getEndPoint();
                range.create(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset).select();
            });
            /**
             * setting color
             *
             * @param {Object} sObjColor  color code
             * @param {String} sObjColor.foreColor foreground color
             * @param {String} sObjColor.backColor background color
             */
            this.color = this.wrapCommand(function (colorInfo) {
                var foreColor = colorInfo.foreColor;
                var backColor = colorInfo.backColor;
                if (foreColor) {
                    document.execCommand('foreColor', false, foreColor);
                }
                if (backColor) {
                    document.execCommand('backColor', false, backColor);
                }
            });
            /**
             * Set foreground color
             *
             * @param {String} colorCode foreground color code
             */
            this.foreColor = this.wrapCommand(function (colorInfo) {
                document.execCommand('styleWithCSS', false, true);
                document.execCommand('foreColor', false, colorInfo);
            });
            /**
             * insert Table
             *
             * @param {String} dimension of table (ex : "5x5")
             */
            this.insertTable = this.wrapCommand(function (dim) {
                var dimension = dim.split('x');
                var rng = _this.createRange().deleteContents();
                rng.insertNode(_this.table.createTable(dimension[0], dimension[1], _this.options));
            });
            /**
             * remove media object and Figure Elements if media object is img with Figure.
             */
            this.removeMedia = this.wrapCommand(function () {
                var $target = $$1(_this.restoreTarget()).parent();
                if ($target.parent('figure').length) {
                    $target.parent('figure').remove();
                }
                else {
                    $target = $$1(_this.restoreTarget()).detach();
                }
                _this.context.triggerEvent('media.delete', $target, _this.$editable);
            });
            /**
             * float me
             *
             * @param {String} value
             */
            this.floatMe = this.wrapCommand(function (value) {
                var $target = $$1(_this.restoreTarget());
                $target.toggleClass('note-float-left', value === 'left');
                $target.toggleClass('note-float-right', value === 'right');
                $target.css('float', value);
            });
            /**
             * resize overlay element
             * @param {String} value
             */
            this.resize = this.wrapCommand(function (value) {
                var $target = $$1(_this.restoreTarget());
                $target.css({
                    width: value * 100 + '%',
                    height: ''
                });
            });
        }

        Editor.prototype.initialize = function () {
            var _this = this;
            // bind custom events
            this.$editable.on('keydown', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    _this.context.triggerEvent('enter', event);
                }
                _this.context.triggerEvent('keydown', event);
                if (!event.isDefaultPrevented()) {
                    if (_this.options.shortcuts) {
                        _this.handleKeyMap(event);
                    }
                    else {
                        _this.preventDefaultEditableShortCuts(event);
                    }
                }
                if (_this.isLimited(1, event)) {
                    return false;
                }
            }).on('keyup', function (event) {
                _this.context.triggerEvent('keyup', event);
            }).on('focus', function (event) {
                _this.context.triggerEvent('focus', event);
            }).on('blur', function (event) {
                _this.context.triggerEvent('blur', event);
            }).on('mousedown', function (event) {
                _this.context.triggerEvent('mousedown', event);
            }).on('mouseup', function (event) {
                _this.context.triggerEvent('mouseup', event);
            }).on('scroll', function (event) {
                _this.context.triggerEvent('scroll', event);
            }).on('paste', function (event) {
                _this.context.triggerEvent('paste', event);
            });
            // init content before set event
            this.$editable.html(dom.html(this.$note) || dom.emptyPara);
            this.$editable.on(env.inputEventName, func.debounce(function () {
                _this.context.triggerEvent('change', _this.$editable.html());
            }, 100));
            this.$editor.on('focusin', function (event) {
                _this.context.triggerEvent('focusin', event);
            }).on('focusout', function (event) {
                _this.context.triggerEvent('focusout', event);
            });
            if (!this.options.airMode) {
                if (this.options.width) {
                    this.$editor.outerWidth(this.options.width);
                }
                if (this.options.height) {
                    this.$editable.outerHeight(this.options.height);
                }
                if (this.options.maxHeight) {
                    this.$editable.css('max-height', this.options.maxHeight);
                }
                if (this.options.minHeight) {
                    this.$editable.css('min-height', this.options.minHeight);
                }
            }
            this.history.recordUndo();
        };
        Editor.prototype.destroy = function () {
            this.$editable.off();
        };
        Editor.prototype.handleKeyMap = function (event) {
            var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
            var keys = [];
            if (event.metaKey) {
                keys.push('CMD');
            }
            if (event.ctrlKey && !event.altKey) {
                keys.push('CTRL');
            }
            if (event.shiftKey) {
                keys.push('SHIFT');
            }
            var keyName = key.nameFromCode[event.keyCode];
            if (keyName) {
                keys.push(keyName);
            }
            var eventName = keyMap[keys.join('+')];
            if (eventName) {
                if (this.context.invoke(eventName) !== false) {
                    event.preventDefault();
                }
            }
            else if (key.isEdit(event.keyCode)) {
                this.afterCommand();
            }
        };
        Editor.prototype.preventDefaultEditableShortCuts = function (event) {
            // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)
            if ((event.ctrlKey || event.metaKey) &&
                lists.contains([66, 73, 85], event.keyCode)) {
                event.preventDefault();
            }
        };
        Editor.prototype.isLimited = function (pad, event) {
            pad = pad || 0;
            if (typeof event !== 'undefined') {
                if (key.isMove(event.keyCode) ||
                    (event.ctrlKey || event.metaKey) ||
                    lists.contains([key.code.BACKSPACE, key.code.DELETE], event.keyCode)) {
                    return false;
                }
            }
            if (this.options.maxTextLength > 0) {
                if ((this.$editable.text().length + pad) >= this.options.maxTextLength) {
                    return true;
                }
            }
            return false;
        };
        /**
         * create range
         * @return {WrappedRange}
         */
        Editor.prototype.createRange = function () {
            this.focus();
            return range.create(this.editable);
        };
        /**
         * saveRange
         *
         * save current range
         *
         * @param {Boolean} [thenCollapse=false]
         */
        Editor.prototype.saveRange = function (thenCollapse) {
            this.lastRange = this.createRange();
            if (thenCollapse) {
                this.lastRange.collapse().select();
            }
        };
        /**
         * restoreRange
         *
         * restore lately range
         */
        Editor.prototype.restoreRange = function () {
            if (this.lastRange) {
                this.lastRange.select();
                this.focus();
            }
        };
        Editor.prototype.saveTarget = function (node) {
            this.$editable.data('target', node);
        };
        Editor.prototype.clearTarget = function () {
            this.$editable.removeData('target');
        };
        Editor.prototype.restoreTarget = function () {
            return this.$editable.data('target');
        };
        /**
         * currentStyle
         *
         * current style
         * @return {Object|Boolean} unfocus
         */
        Editor.prototype.currentStyle = function () {
            var rng = range.create();
            if (rng) {
                rng = rng.normalize();
            }
            return rng ? this.style.current(rng) : this.style.fromNode(this.$editable);
        };
        /**
         * style from node
         *
         * @param {jQuery} $node
         * @return {Object}
         */
        Editor.prototype.styleFromNode = function ($node) {
            return this.style.fromNode($node);
        };
        /**
         * undo
         */
        Editor.prototype.undo = function () {
            this.context.triggerEvent('before.command', this.$editable.html());
            this.history.undo();
            this.context.triggerEvent('change', this.$editable.html());
        };
        /**
         * redo
         */
        Editor.prototype.redo = function () {
            this.context.triggerEvent('before.command', this.$editable.html());
            this.history.redo();
            this.context.triggerEvent('change', this.$editable.html());
        };
        /**
         * before command
         */
        Editor.prototype.beforeCommand = function () {
            this.context.triggerEvent('before.command', this.$editable.html());
            // keep focus on editable before command execution
            this.focus();
        };
        /**
         * after command
         * @param {Boolean} isPreventTrigger
         */
        Editor.prototype.afterCommand = function (isPreventTrigger) {
            this.normalizeContent();
            this.history.recordUndo();
            if (!isPreventTrigger) {
                this.context.triggerEvent('change', this.$editable.html());
            }
        };
        /**
         * handle tab key
         */
        Editor.prototype.tab = function () {
            var rng = this.createRange();
            if (rng.isCollapsed() && rng.isOnCell()) {
                this.table.tab(rng);
            }
            else {
                if (this.options.tabSize === 0) {
                    return false;
                }
                if (!this.isLimited(this.options.tabSize)) {
                    this.beforeCommand();
                    this.typing.insertTab(rng, this.options.tabSize);
                    this.afterCommand();
                }
            }
        };
        /**
         * handle shift+tab key
         */
        Editor.prototype.untab = function () {
            var rng = this.createRange();
            if (rng.isCollapsed() && rng.isOnCell()) {
                this.table.tab(rng, true);
            }
            else {
                if (this.options.tabSize === 0) {
                    return false;
                }
            }
        };
        /**
         * run given function between beforeCommand and afterCommand
         */
        Editor.prototype.wrapCommand = function (fn) {
            var _this = this;
            return function () {
                _this.beforeCommand();
                fn.apply(_this, arguments);
                _this.afterCommand();
            };
        };
        /**
         * insert image
         *
         * @param {String} src
         * @param {String|Function} param
         * @return {Promise}
         */
        Editor.prototype.insertImage = function (src, param) {
            var _this = this;
            return createImage(src, param).then(function ($image) {
                _this.beforeCommand();
                if (typeof param === 'function') {
                    param($image);
                }
                else {
                    if (typeof param === 'string') {
                        $image.attr('data-filename', param);
                    }
                    $image.css('width', Math.min(_this.$editable.width(), $image.width()));
                }
                $image.show();
                range.create(_this.editable).insertNode($image[0]);
                range.createFromNodeAfter($image[0]).select();
                _this.afterCommand();
            }).fail(function (e) {
                _this.context.triggerEvent('image.upload.error', e);
            });
        };
        /**
         * insertImages
         * @param {File[]} files
         */
        Editor.prototype.insertImages = function (files) {
            var _this = this;
            $$1.each(files, function (idx, file) {
                var filename = file.name;
                if (_this.options.maximumImageFileSize && _this.options.maximumImageFileSize < file.size) {
                    _this.context.triggerEvent('image.upload.error', _this.lang.image.maximumFileSizeError);
                }
                else {
                    readFileAsDataURL(file).then(function (dataURL) {
                        return _this.insertImage(dataURL, filename);
                    }).fail(function () {
                        _this.context.triggerEvent('image.upload.error');
                    });
                }
            });
        };
        /**
         * insertImagesOrCallback
         * @param {File[]} files
         */
        Editor.prototype.insertImagesOrCallback = function (files) {
            var callbacks = this.options.callbacks;
            // If onImageUpload this.options setted
            if (callbacks.onImageUpload) {
                this.context.triggerEvent('image.upload', files);
                // else insert Image as dataURL
            }
            else {
                this.insertImages(files);
            }
        };
        /**
         * return selected plain text
         * @return {String} text
         */
        Editor.prototype.getSelectedText = function () {
            var rng = this.createRange();
            // if range on anchor, expand range with anchor
            if (rng.isOnAnchor()) {
                rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));
            }
            return rng.toString();
        };
        Editor.prototype.onFormatBlock = function (tagName, $target) {
            // [workaround] for MSIE, IE need `<`
            tagName = env.isMSIE ? '<' + tagName + '>' : tagName;
            document.execCommand('FormatBlock', false, tagName);
            // support custom class
            if ($target && $target.length) {
                var className = $target[0].className || '';
                if (className) {
                    var currentRange = this.createRange();
                    var $parent = $$1([currentRange.sc, currentRange.ec]).closest(tagName);
                    $parent.addClass(className);
                }
            }
        };
        Editor.prototype.formatPara = function () {
            this.formatBlock('P');
        };
        Editor.prototype.fontStyling = function (target, value) {
            var rng = this.createRange();
            if (rng) {
                var spans = this.style.styleNodes(rng);
                $$1(spans).css(target, value);
                // [workaround] added styled bogus span for style
                //  - also bogus character needed for cursor position
                if (rng.isCollapsed()) {
                    var firstSpan = lists.head(spans);
                    if (firstSpan && !dom.nodeLength(firstSpan)) {
                        firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
                        range.createFromNodeAfter(firstSpan.firstChild).select();
                        this.$editable.data(KEY_BOGUS, firstSpan);
                    }
                }
            }
        };
        /**
         * unlink
         *
         * @type command
         */
        Editor.prototype.unlink = function () {
            var rng = this.createRange();
            if (rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                rng = range.createFromNode(anchor);
                rng.select();
                this.beforeCommand();
                document.execCommand('unlink');
                this.afterCommand();
            }
        };
        /**
         * returns link info
         *
         * @return {Object}
         * @return {WrappedRange} return.range
         * @return {String} return.text
         * @return {Boolean} [return.isNewWindow=true]
         * @return {String} [return.url=""]
         */
        Editor.prototype.getLinkInfo = function () {
            var rng = this.createRange().expand(dom.isAnchor);
            // Get the first anchor on range(for edit).
            var $anchor = $$1(lists.head(rng.nodes(dom.isAnchor)));
            var linkInfo = {
                range: rng,
                text: rng.toString(),
                url: $anchor.length ? $anchor.attr('href') : ''
            };
            // Define isNewWindow when anchor exists.
            if ($anchor.length) {
                linkInfo.isNewWindow = $anchor.attr('target') === '_blank';
            }
            return linkInfo;
        };
        Editor.prototype.addRow = function (position) {
            var rng = this.createRange(this.$editable);
            if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.addRow(rng, position);
                this.afterCommand();
            }
        };
        Editor.prototype.addCol = function (position) {
            var rng = this.createRange(this.$editable);
            if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.addCol(rng, position);
                this.afterCommand();
            }
        };
        Editor.prototype.deleteRow = function () {
            var rng = this.createRange(this.$editable);
            if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteRow(rng);
                this.afterCommand();
            }
        };
        Editor.prototype.deleteCol = function () {
            var rng = this.createRange(this.$editable);
            if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteCol(rng);
                this.afterCommand();
            }
        };
        Editor.prototype.deleteTable = function () {
            var rng = this.createRange(this.$editable);
            if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteTable(rng);
                this.afterCommand();
            }
        };
        /**
         * @param {Position} pos
         * @param {jQuery} $target - target element
         * @param {Boolean} [bKeepRatio] - keep ratio
         */
        Editor.prototype.resizeTo = function (pos, $target, bKeepRatio) {
            var imageSize;
            if (bKeepRatio) {
                var newRatio = pos.y / pos.x;
                var ratio = $target.data('ratio');
                imageSize = {
                    width: ratio > newRatio ? pos.x : pos.y / ratio,
                    height: ratio > newRatio ? pos.x * ratio : pos.y
                };
            }
            else {
                imageSize = {
                    width: pos.x,
                    height: pos.y
                };
            }
            $target.css(imageSize);
        };
        /**
         * returns whether editable area has focus or not.
         */
        Editor.prototype.hasFocus = function () {
            return this.$editable.is(':focus');
        };
        /**
         * set focus
         */
        Editor.prototype.focus = function () {
            // [workaround] Screen will move when page is scolled in IE.
            //  - do focus when not focused
            if (!this.hasFocus()) {
                this.$editable.focus();
            }
        };
        /**
         * returns whether contents is empty or not.
         * @return {Boolean}
         */
        Editor.prototype.isEmpty = function () {
            return dom.isEmpty(this.$editable[0]) || dom.emptyPara === this.$editable.html();
        };
        /**
         * Removes all contents and restores the editable instance to an _emptyPara_.
         */
        Editor.prototype.empty = function () {
            this.context.invoke('code', dom.emptyPara);
        };
        /**
         * normalize content
         */
        Editor.prototype.normalizeContent = function () {
            this.$editable[0].normalize();
        };
        return Editor;
    }());

    var Clipboard = /** @class */ (function () {
        function Clipboard(context) {
            this.context = context;
            this.$editable = context.layoutInfo.editable;
        }

        Clipboard.prototype.initialize = function () {
            this.$editable.on('paste', this.pasteByEvent.bind(this));
        };
        /**
         * paste by clipboard event
         *
         * @param {Event} event
         */
        Clipboard.prototype.pasteByEvent = function (event) {
            var clipboardData = event.originalEvent.clipboardData;
            if (clipboardData && clipboardData.items && clipboardData.items.length) {
                var item = lists.head(clipboardData.items);
                if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {
                    this.context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);
                }
                this.context.invoke('editor.afterCommand');
            }
        };
        return Clipboard;
    }());

    var Dropzone = /** @class */ (function () {
        function Dropzone(context) {
            this.context = context;
            this.$eventListener = $$1(document);
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.documentEventHandlers = {};
            this.$dropzone = $$1([
                '<div class="note-dropzone">',
                '  <div class="note-dropzone-message"/>',
                '</div>'
            ].join('')).prependTo(this.$editor);
        }

        /**
         * attach Drag and Drop Events
         */
        Dropzone.prototype.initialize = function () {
            if (this.options.disableDragAndDrop) {
                // prevent default drop event
                this.documentEventHandlers.onDrop = function (e) {
                    e.preventDefault();
                };
                // do not consider outside of dropzone
                this.$eventListener = this.$dropzone;
                this.$eventListener.on('drop', this.documentEventHandlers.onDrop);
            }
            else {
                this.attachDragAndDropEvent();
            }
        };
        /**
         * attach Drag and Drop Events
         */
        Dropzone.prototype.attachDragAndDropEvent = function () {
            var _this = this;
            var collection = $$1();
            var $dropzoneMessage = this.$dropzone.find('.note-dropzone-message');
            this.documentEventHandlers.onDragenter = function (e) {
                var isCodeview = _this.context.invoke('codeview.isActivated');
                var hasEditorSize = _this.$editor.width() > 0 && _this.$editor.height() > 0;
                if (!isCodeview && !collection.length && hasEditorSize) {
                    _this.$editor.addClass('dragover');
                    _this.$dropzone.width(_this.$editor.width());
                    _this.$dropzone.height(_this.$editor.height());
                    $dropzoneMessage.text(_this.lang.image.dragImageHere);
                }
                collection = collection.add(e.target);
            };
            this.documentEventHandlers.onDragleave = function (e) {
                collection = collection.not(e.target);
                if (!collection.length) {
                    _this.$editor.removeClass('dragover');
                }
            };
            this.documentEventHandlers.onDrop = function () {
                collection = $$1();
                _this.$editor.removeClass('dragover');
            };
            // show dropzone on dragenter when dragging a object to document
            // -but only if the editor is visible, i.e. has a positive width and height
            this.$eventListener.on('dragenter', this.documentEventHandlers.onDragenter)
                .on('dragleave', this.documentEventHandlers.onDragleave)
                .on('drop', this.documentEventHandlers.onDrop);
            // change dropzone's message on hover.
            this.$dropzone.on('dragenter', function () {
                _this.$dropzone.addClass('hover');
                $dropzoneMessage.text(_this.lang.image.dropImage);
            }).on('dragleave', function () {
                _this.$dropzone.removeClass('hover');
                $dropzoneMessage.text(_this.lang.image.dragImageHere);
            });
            // attach dropImage
            this.$dropzone.on('drop', function (event) {
                var dataTransfer = event.originalEvent.dataTransfer;
                // stop the browser from opening the dropped content
                event.preventDefault();
                if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                    _this.$editable.focus();
                    _this.context.invoke('editor.insertImagesOrCallback', dataTransfer.files);
                }
                else {
                    $$1.each(dataTransfer.types, function (idx, type) {
                        var content = dataTransfer.getData(type);
                        if (type.toLowerCase().indexOf('text') > -1) {
                            _this.context.invoke('editor.pasteHTML', content);
                        }
                        else {
                            $$1(content).each(function (idx, item) {
                                _this.context.invoke('editor.insertNode', item);
                            });
                        }
                    });
                }
            }).on('dragover', false); // prevent default dragover event
        };
        Dropzone.prototype.destroy = function () {
            var _this = this;
            Object.keys(this.documentEventHandlers).forEach(function (key) {
                _this.$eventListener.off(key.substr(2).toLowerCase(), _this.documentEventHandlers[key]);
            });
            this.documentEventHandlers = {};
        };
        return Dropzone;
    }());

    var CodeMirror;
    if (env.hasCodeMirror) {
        if (env.isSupportAmd) {
            require(['codemirror'], function (cm) {
                CodeMirror = cm;
            });
        }
        else {
            CodeMirror = window.CodeMirror;
        }
    }
    /**
     * @class Codeview
     */
    var CodeView = /** @class */ (function () {
        function CodeView(context) {
            this.context = context;
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.$codable = context.layoutInfo.codable;
            this.options = context.options;
        }

        CodeView.prototype.sync = function () {
            var isCodeview = this.isActivated();
            if (isCodeview && env.hasCodeMirror) {
                this.$codable.data('cmEditor').save();
            }
        };
        /**
         * @return {Boolean}
         */
        CodeView.prototype.isActivated = function () {
            return this.$editor.hasClass('codeview');
        };
        /**
         * toggle codeview
         */
        CodeView.prototype.toggle = function () {
            if (this.isActivated()) {
                this.deactivate();
            }
            else {
                this.activate();
            }
            this.context.triggerEvent('codeview.toggled');
        };
        /**
         * activate code view
         */
        CodeView.prototype.activate = function () {
            var _this = this;
            this.$codable.val(dom.html(this.$editable, this.options.prettifyHtml));
            this.$codable.height(this.$editable.height());
            this.context.invoke('toolbar.updateCodeview', true);
            this.$editor.addClass('codeview');
            this.$codable.focus();
            // activate CodeMirror as codable
            if (env.hasCodeMirror) {
                var cmEditor_1 = CodeMirror.fromTextArea(this.$codable[0], this.options.codemirror);
                // CodeMirror TernServer
                if (this.options.codemirror.tern) {
                    var server_1 = new CodeMirror.TernServer(this.options.codemirror.tern);
                    cmEditor_1.ternServer = server_1;
                    cmEditor_1.on('cursorActivity', function (cm) {
                        server_1.updateArgHints(cm);
                    });
                }
                cmEditor_1.on('blur', function (event) {
                    _this.context.triggerEvent('blur.codeview', cmEditor_1.getValue(), event);
                });
                // CodeMirror hasn't Padding.
                cmEditor_1.setSize(null, this.$editable.outerHeight());
                this.$codable.data('cmEditor', cmEditor_1);
            }
            else {
                this.$codable.on('blur', function (event) {
                    _this.context.triggerEvent('blur.codeview', _this.$codable.val(), event);
                });
            }
        };
        /**
         * deactivate code view
         */
        CodeView.prototype.deactivate = function () {
            // deactivate CodeMirror as codable
            if (env.hasCodeMirror) {
                var cmEditor = this.$codable.data('cmEditor');
                this.$codable.val(cmEditor.getValue());
                cmEditor.toTextArea();
            }
            var value = dom.value(this.$codable, this.options.prettifyHtml) || dom.emptyPara;
            var isChange = this.$editable.html() !== value;
            this.$editable.html(value);
            this.$editable.height(this.options.height ? this.$codable.height() : 'auto');
            this.$editor.removeClass('codeview');
            if (isChange) {
                this.context.triggerEvent('change', this.$editable.html(), this.$editable);
            }
            this.$editable.focus();
            this.context.invoke('toolbar.updateCodeview', false);
        };
        CodeView.prototype.destroy = function () {
            if (this.isActivated()) {
                this.deactivate();
            }
        };
        return CodeView;
    }());

    var EDITABLE_PADDING = 24;
    var Statusbar = /** @class */ (function () {
        function Statusbar(context) {
            this.$document = $$1(document);
            this.$statusbar = context.layoutInfo.statusbar;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
        }

        Statusbar.prototype.initialize = function () {
            var _this = this;
            if (this.options.airMode || this.options.disableResizeEditor) {
                this.destroy();
                return;
            }
            this.$statusbar.on('mousedown', function (event) {
                event.preventDefault();
                event.stopPropagation();
                var editableTop = _this.$editable.offset().top - _this.$document.scrollTop();
                var onMouseMove = function (event) {
                    var height = event.clientY - (editableTop + EDITABLE_PADDING);
                    height = (_this.options.minheight > 0) ? Math.max(height, _this.options.minheight) : height;
                    height = (_this.options.maxHeight > 0) ? Math.min(height, _this.options.maxHeight) : height;
                    _this.$editable.height(height);
                };
                _this.$document.on('mousemove', onMouseMove).one('mouseup', function () {
                    _this.$document.off('mousemove', onMouseMove);
                });
            });
        };
        Statusbar.prototype.destroy = function () {
            this.$statusbar.off();
            this.$statusbar.addClass('locked');
        };
        return Statusbar;
    }());

    var Fullscreen = /** @class */ (function () {
        function Fullscreen(context) {
            var _this = this;
            this.context = context;
            this.$editor = context.layoutInfo.editor;
            this.$toolbar = context.layoutInfo.toolbar;
            this.$editable = context.layoutInfo.editable;
            this.$codable = context.layoutInfo.codable;
            this.$window = $$1(window);
            this.$scrollbar = $$1('html, body');
            this.onResize = function () {
                _this.resizeTo({
                    h: _this.$window.height() - _this.$toolbar.outerHeight()
                });
            };
        }

        Fullscreen.prototype.resizeTo = function (size) {
            this.$editable.css('height', size.h);
            this.$codable.css('height', size.h);
            if (this.$codable.data('cmeditor')) {
                this.$codable.data('cmeditor').setsize(null, size.h);
            }
        };
        /**
         * toggle fullscreen
         */
        Fullscreen.prototype.toggle = function () {
            this.$editor.toggleClass('fullscreen');
            if (this.isFullscreen()) {
                this.$editable.data('orgHeight', this.$editable.css('height'));
                this.$window.on('resize', this.onResize).trigger('resize');
                this.$scrollbar.css('overflow', 'hidden');
            }
            else {
                this.$window.off('resize', this.onResize);
                this.resizeTo({h: this.$editable.data('orgHeight')});
                this.$scrollbar.css('overflow', 'visible');
            }
            this.context.invoke('toolbar.updateFullscreen', this.isFullscreen());
        };
        Fullscreen.prototype.isFullscreen = function () {
            return this.$editor.hasClass('fullscreen');
        };
        return Fullscreen;
    }());

    var Handle = /** @class */ (function () {
        function Handle(context) {
            var _this = this;
            this.context = context;
            this.$document = $$1(document);
            this.$editingArea = context.layoutInfo.editingArea;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.events = {
                'summernote.mousedown': function (we, e) {
                    if (_this.update(e.target)) {
                        e.preventDefault();
                    }
                },
                'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {
                    _this.update();
                },
                'summernote.disable': function () {
                    _this.hide();
                },
                'summernote.codeview.toggled': function () {
                    _this.update();
                }
            };
        }

        Handle.prototype.initialize = function () {
            var _this = this;
            this.$handle = $$1([
                '<div class="note-handle">',
                '<div class="note-control-selection">',
                '<div class="note-control-selection-bg"></div>',
                '<div class="note-control-holder note-control-nw"></div>',
                '<div class="note-control-holder note-control-ne"></div>',
                '<div class="note-control-holder note-control-sw"></div>',
                '<div class="',
                (this.options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),
                ' note-control-se"></div>',
                (this.options.disableResizeImage ? '' : '<div class="note-control-selection-info"></div>'),
                '</div>',
                '</div>'
            ].join('')).prependTo(this.$editingArea);
            this.$handle.on('mousedown', function (event) {
                if (dom.isControlSizing(event.target)) {
                    event.preventDefault();
                    event.stopPropagation();
                    var $target_1 = _this.$handle.find('.note-control-selection').data('target');
                    var posStart_1 = $target_1.offset();
                    var scrollTop_1 = _this.$document.scrollTop();
                    var onMouseMove_1 = function (event) {
                        _this.context.invoke('editor.resizeTo', {
                            x: event.clientX - posStart_1.left,
                            y: event.clientY - (posStart_1.top - scrollTop_1)
                        }, $target_1, !event.shiftKey);
                        _this.update($target_1[0]);
                    };
                    _this.$document
                        .on('mousemove', onMouseMove_1)
                        .one('mouseup', function (e) {
                            e.preventDefault();
                            _this.$document.off('mousemove', onMouseMove_1);
                            _this.context.invoke('editor.afterCommand');
                        });
                    if (!$target_1.data('ratio')) {
                        $target_1.data('ratio', $target_1.height() / $target_1.width());
                    }
                }
            });
            // Listen for scrolling on the handle overlay.
            this.$handle.on('wheel', function (e) {
                e.preventDefault();
                _this.update();
            });
        };
        Handle.prototype.destroy = function () {
            this.$handle.remove();
        };
        Handle.prototype.update = function (target) {
            if (this.context.isDisabled()) {
                return false;
            }
            var isImage = dom.isImg(target);
            var $selection = this.$handle.find('.note-control-selection');
            this.context.invoke('imagePopover.update', target);
            if (isImage) {
                var $image = $$1(target);
                var position = $image.position();
                var pos = {
                    left: position.left + parseInt($image.css('marginLeft'), 10),
                    top: position.top + parseInt($image.css('marginTop'), 10)
                };
                // exclude margin
                var imageSize = {
                    w: $image.outerWidth(false),
                    h: $image.outerHeight(false)
                };
                $selection.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top,
                    width: imageSize.w,
                    height: imageSize.h
                }).data('target', $image); // save current image element.
                var origImageObj = new Image();
                origImageObj.src = $image.attr('src');
                var sizingText = imageSize.w + 'x' + imageSize.h + ' (' + this.lang.image.original + ': ' + origImageObj.width + 'x' + origImageObj.height + ')';
                $selection.find('.note-control-selection-info').text(sizingText);
                this.context.invoke('editor.saveTarget', target);
            }
            else {
                this.hide();
            }
            return isImage;
        };
        /**
         * hide
         *
         * @param {jQuery} $handle
         */
        Handle.prototype.hide = function () {
            this.context.invoke('editor.clearTarget');
            this.$handle.children().hide();
        };
        return Handle;
    }());

    var defaultScheme = 'http://';
    var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;
    var AutoLink = /** @class */ (function () {
        function AutoLink(context) {
            var _this = this;
            this.context = context;
            this.events = {
                'summernote.keyup': function (we, e) {
                    if (!e.isDefaultPrevented()) {
                        _this.handleKeyup(e);
                    }
                },
                'summernote.keydown': function (we, e) {
                    _this.handleKeydown(e);
                }
            };
        }

        AutoLink.prototype.initialize = function () {
            this.lastWordRange = null;
        };
        AutoLink.prototype.destroy = function () {
            this.lastWordRange = null;
        };
        AutoLink.prototype.replace = function () {
            if (!this.lastWordRange) {
                return;
            }
            var keyword = this.lastWordRange.toString();
            var match = keyword.match(linkPattern);
            if (match && (match[1] || match[2])) {
                var link = match[1] ? keyword : defaultScheme + keyword;
                var node = $$1('<a />').html(keyword).attr('href', link)[0];
                this.lastWordRange.insertNode(node);
                this.lastWordRange = null;
                this.context.invoke('editor.focus');
            }
        };
        AutoLink.prototype.handleKeydown = function (e) {
            if (lists.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
                var wordRange = this.context.invoke('editor.createRange').getWordRange();
                this.lastWordRange = wordRange;
            }
        };
        AutoLink.prototype.handleKeyup = function (e) {
            if (lists.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
                this.replace();
            }
        };
        return AutoLink;
    }());

    /**
     * textarea auto sync.
     */
    var AutoSync = /** @class */ (function () {
        function AutoSync(context) {
            var _this = this;
            this.$note = context.layoutInfo.note;
            this.events = {
                'summernote.change': function () {
                    _this.$note.val(context.invoke('code'));
                }
            };
        }

        AutoSync.prototype.shouldInitialize = function () {
            return dom.isTextarea(this.$note[0]);
        };
        return AutoSync;
    }());

    var Placeholder = /** @class */ (function () {
        function Placeholder(context) {
            var _this = this;
            this.context = context;
            this.$editingArea = context.layoutInfo.editingArea;
            this.options = context.options;
            this.events = {
                'summernote.init summernote.change': function () {
                    _this.update();
                },
                'summernote.codeview.toggled': function () {
                    _this.update();
                }
            };
        }

        Placeholder.prototype.shouldInitialize = function () {
            return !!this.options.placeholder;
        };
        Placeholder.prototype.initialize = function () {
            var _this = this;
            this.$placeholder = $$1('<div class="note-placeholder">');
            this.$placeholder.on('click', function () {
                _this.context.invoke('focus');
            }).text(this.options.placeholder).prependTo(this.$editingArea);
            this.update();
        };
        Placeholder.prototype.destroy = function () {
            this.$placeholder.remove();
        };
        Placeholder.prototype.update = function () {
            var isShow = !this.context.invoke('codeview.isActivated') && this.context.invoke('editor.isEmpty');
            this.$placeholder.toggle(isShow);
        };
        return Placeholder;
    }());

    var Buttons = /** @class */ (function () {
        function Buttons(context) {
            this.ui = $$1.summernote.ui;
            this.context = context;
            this.$toolbar = context.layoutInfo.toolbar;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.invertedKeyMap = func.invertObject(this.options.keyMap[env.isMac ? 'mac' : 'pc']);
        }

        Buttons.prototype.representShortcut = function (editorMethod) {
            var shortcut = this.invertedKeyMap[editorMethod];
            if (!this.options.shortcuts || !shortcut) {
                return '';
            }
            if (env.isMac) {
                shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');
            }
            shortcut = shortcut.replace('BACKSLASH', '\\')
                .replace('SLASH', '/')
                .replace('LEFTBRACKET', '[')
                .replace('RIGHTBRACKET', ']');
            return ' (' + shortcut + ')';
        };
        Buttons.prototype.button = function (o) {
            if (!this.options.tooltip && o.tooltip) {
                delete o.tooltip;
            }
            o.container = this.options.container;
            return this.ui.button(o);
        };
        Buttons.prototype.initialize = function () {
            this.addToolbarButtons();
            this.addImagePopoverButtons();
            this.addLinkPopoverButtons();
            this.addTablePopoverButtons();
            this.fontInstalledMap = {};
        };
        Buttons.prototype.destroy = function () {
            delete this.fontInstalledMap;
        };
        Buttons.prototype.isFontInstalled = function (name) {
            if (!this.fontInstalledMap.hasOwnProperty(name)) {
                this.fontInstalledMap[name] = env.isFontInstalled(name) ||
                    lists.contains(this.options.fontNamesIgnoreCheck, name);
            }
            return this.fontInstalledMap[name];
        };
        Buttons.prototype.isFontDeservedToAdd = function (name) {
            var genericFamilies = ['sans-serif', 'serif', 'monospace', 'cursive', 'fantasy'];
            name = name.toLowerCase();
            return ((name !== '') && this.isFontInstalled(name) && ($$1.inArray(name, genericFamilies) === -1));
        };
        Buttons.prototype.addToolbarButtons = function () {
            var _this = this;
            this.context.memo('button.style', function () {
                return _this.ui.buttonGroup([
                    _this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.magic), _this.options),
                        tooltip: _this.lang.style.style,
                        data: {
                            toggle: 'dropdown'
                        }
                    }),
                    _this.ui.dropdown({
                        className: 'dropdown-style',
                        items: _this.options.styleTags,
                        title: _this.lang.style.style,
                        template: function (item) {
                            if (typeof item === 'string') {
                                item = {
                                    tag: item,
                                    title: (_this.lang.style.hasOwnProperty(item) ? _this.lang.style[item] : item)
                                };
                            }
                            var tag = item.tag;
                            var title = item.title;
                            var style = item.style ? ' style="' + item.style + '" ' : '';
                            var className = item.className ? ' class="' + item.className + '"' : '';
                            return '<' + tag + style + className + '>' + title + '</' + tag + '>';
                        },
                        click: _this.context.createInvokeHandler('editor.formatBlock')
                    })
                ]).render();
            });
            var _loop_1 = function (styleIdx, styleLen) {
                var item = this_1.options.styleTags[styleIdx];
                this_1.context.memo('button.style.' + item, function () {
                    return _this.button({
                        className: 'note-btn-style-' + item,
                        contents: '<div data-value="' + item + '">' + item.toUpperCase() + '</div>',
                        tooltip: _this.lang.style[item],
                        click: _this.context.createInvokeHandler('editor.formatBlock')
                    }).render();
                });
            };
            var this_1 = this;
            for (var styleIdx = 0, styleLen = this.options.styleTags.length; styleIdx < styleLen; styleIdx++) {
                _loop_1(styleIdx, styleLen);
            }
            this.context.memo('button.bold', function () {
                return _this.button({
                    className: 'note-btn-bold',
                    contents: _this.ui.icon(_this.options.icons.bold),
                    tooltip: _this.lang.font.bold + _this.representShortcut('bold'),
                    click: _this.context.createInvokeHandlerAndUpdateState('editor.bold')
                }).render();
            });
            this.context.memo('button.italic', function () {
                return _this.button({
                    className: 'note-btn-italic',
                    contents: _this.ui.icon(_this.options.icons.italic),
                    tooltip: _this.lang.font.italic + _this.representShortcut('italic'),
                    click: _this.context.createInvokeHandlerAndUpdateState('editor.italic')
                }).render();
            });
            this.context.memo('button.underline', function () {
                return _this.button({
                    className: 'note-btn-underline',
                    contents: _this.ui.icon(_this.options.icons.underline),
                    tooltip: _this.lang.font.underline + _this.representShortcut('underline'),
                    click: _this.context.createInvokeHandlerAndUpdateState('editor.underline')
                }).render();
            });
            this.context.memo('button.clear', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.eraser),
                    tooltip: _this.lang.font.clear + _this.representShortcut('removeFormat'),
                    click: _this.context.createInvokeHandler('editor.removeFormat')
                }).render();
            });
            this.context.memo('button.strikethrough', function () {
                return _this.button({
                    className: 'note-btn-strikethrough',
                    contents: _this.ui.icon(_this.options.icons.strikethrough),
                    tooltip: _this.lang.font.strikethrough + _this.representShortcut('strikethrough'),
                    click: _this.context.createInvokeHandlerAndUpdateState('editor.strikethrough')
                }).render();
            });
            this.context.memo('button.superscript', function () {
                return _this.button({
                    className: 'note-btn-superscript',
                    contents: _this.ui.icon(_this.options.icons.superscript),
                    tooltip: _this.lang.font.superscript,
                    click: _this.context.createInvokeHandlerAndUpdateState('editor.superscript')
                }).render();
            });
            this.context.memo('button.subscript', function () {
                return _this.button({
                    className: 'note-btn-subscript',
                    contents: _this.ui.icon(_this.options.icons.subscript),
                    tooltip: _this.lang.font.subscript,
                    click: _this.context.createInvokeHandlerAndUpdateState('editor.subscript')
                }).render();
            });
            this.context.memo('button.fontname', function () {
                var styleInfo = _this.context.invoke('editor.currentStyle');
                // Add 'default' fonts into the fontnames array if not exist
                $$1.each(styleInfo['font-family'].split(','), function (idx, fontname) {
                    fontname = fontname.trim().replace(/['"]+/g, '');
                    if (_this.isFontDeservedToAdd(fontname)) {
                        if ($$1.inArray(fontname, _this.options.fontNames) === -1) {
                            _this.options.fontNames.push(fontname);
                        }
                    }
                });
                return _this.ui.buttonGroup([
                    _this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents('<span class="note-current-fontname"/>', _this.options),
                        tooltip: _this.lang.font.name,
                        data: {
                            toggle: 'dropdown'
                        }
                    }),
                    _this.ui.dropdownCheck({
                        className: 'dropdown-fontname',
                        checkClassName: _this.options.icons.menuCheck,
                        items: _this.options.fontNames.filter(_this.isFontInstalled.bind(_this)),
                        title: _this.lang.font.name,
                        template: function (item) {
                            return '<span style="font-family: \'' + item + '\'">' + item + '</span>';
                        },
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.fontName')
                    })
                ]).render();
            });
            this.context.memo('button.fontsize', function () {
                return _this.ui.buttonGroup([
                    _this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents('<span class="note-current-fontsize"/>', _this.options),
                        tooltip: _this.lang.font.size,
                        data: {
                            toggle: 'dropdown'
                        }
                    }),
                    _this.ui.dropdownCheck({
                        className: 'dropdown-fontsize',
                        checkClassName: _this.options.icons.menuCheck,
                        items: _this.options.fontSizes,
                        title: _this.lang.font.size,
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.fontSize')
                    })
                ]).render();
            });
            this.context.memo('button.color', function () {
                return _this.ui.buttonGroup({
                    className: 'note-color',
                    children: [
                        _this.button({
                            className: 'note-current-color-button',
                            contents: _this.ui.icon(_this.options.icons.font + ' note-recent-color'),
                            tooltip: _this.lang.color.recent,
                            click: function (e) {
                                var $button = $$1(e.currentTarget);
                                _this.context.invoke('editor.color', {
                                    backColor: $button.attr('data-backColor'),
                                    foreColor: $button.attr('data-foreColor')
                                });
                            },
                            callback: function ($button) {
                                var $recentColor = $button.find('.note-recent-color');
                                $recentColor.css('background-color', '#FFFF00');
                                $button.attr('data-backColor', '#FFFF00');
                            }
                        }),
                        _this.button({
                            className: 'dropdown-toggle',
                            contents: _this.ui.dropdownButtonContents('', _this.options),
                            tooltip: _this.lang.color.more,
                            data: {
                                toggle: 'dropdown'
                            }
                        }),
                        _this.ui.dropdown({
                            items: [
                                '<div class="note-palette">',
                                '  <div class="note-palette-title">' + _this.lang.color.background + '</div>',
                                '  <div>',
                                '    <button type="button" class="note-color-reset btn btn-light" data-event="backColor" data-value="inherit">',
                                _this.lang.color.transparent,
                                '    </button>',
                                '  </div>',
                                '  <div class="note-holder" data-event="backColor"/>',
                                '</div>',
                                '<div class="note-palette">',
                                '  <div class="note-palette-title">' + _this.lang.color.foreground + '</div>',
                                '  <div>',
                                '    <button type="button" class="note-color-reset btn btn-light" data-event="removeFormat" data-value="foreColor">',
                                _this.lang.color.resetToDefault,
                                '    </button>',
                                '  </div>',
                                '  <div class="note-holder" data-event="foreColor"/>',
                                '</div>'
                            ].join(''),
                            callback: function ($dropdown) {
                                $dropdown.find('.note-holder').each(function (idx, item) {
                                    var $holder = $$1(item);
                                    $holder.append(_this.ui.palette({
                                        colors: _this.options.colors,
                                        colorsName: _this.options.colorsName,
                                        eventName: $holder.data('event'),
                                        container: _this.options.container,
                                        tooltip: _this.options.tooltip
                                    }).render());
                                });
                            },
                            click: function (event) {
                                var $button = $$1(event.target);
                                var eventName = $button.data('event');
                                var value = $button.data('value');
                                if (eventName && value) {
                                    var key = eventName === 'backColor' ? 'background-color' : 'color';
                                    var $color = $button.closest('.note-color').find('.note-recent-color');
                                    var $currentButton = $button.closest('.note-color').find('.note-current-color-button');
                                    $color.css(key, value);
                                    $currentButton.attr('data-' + eventName, value);
                                    _this.context.invoke('editor.' + eventName, value);
                                }
                            }
                        })
                    ]
                }).render();
            });
            this.context.memo('button.ul', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.unorderedlist),
                    tooltip: _this.lang.lists.unordered + _this.representShortcut('insertUnorderedList'),
                    click: _this.context.createInvokeHandler('editor.insertUnorderedList')
                }).render();
            });
            this.context.memo('button.ol', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.orderedlist),
                    tooltip: _this.lang.lists.ordered + _this.representShortcut('insertOrderedList'),
                    click: _this.context.createInvokeHandler('editor.insertOrderedList')
                }).render();
            });
            var justifyLeft = this.button({
                contents: this.ui.icon(this.options.icons.alignLeft),
                tooltip: this.lang.paragraph.left + this.representShortcut('justifyLeft'),
                click: this.context.createInvokeHandler('editor.justifyLeft')
            });
            var justifyCenter = this.button({
                contents: this.ui.icon(this.options.icons.alignCenter),
                tooltip: this.lang.paragraph.center + this.representShortcut('justifyCenter'),
                click: this.context.createInvokeHandler('editor.justifyCenter')
            });
            var justifyRight = this.button({
                contents: this.ui.icon(this.options.icons.alignRight),
                tooltip: this.lang.paragraph.right + this.representShortcut('justifyRight'),
                click: this.context.createInvokeHandler('editor.justifyRight')
            });
            var justifyFull = this.button({
                contents: this.ui.icon(this.options.icons.alignJustify),
                tooltip: this.lang.paragraph.justify + this.representShortcut('justifyFull'),
                click: this.context.createInvokeHandler('editor.justifyFull')
            });
            var outdent = this.button({
                contents: this.ui.icon(this.options.icons.outdent),
                tooltip: this.lang.paragraph.outdent + this.representShortcut('outdent'),
                click: this.context.createInvokeHandler('editor.outdent')
            });
            var indent = this.button({
                contents: this.ui.icon(this.options.icons.indent),
                tooltip: this.lang.paragraph.indent + this.representShortcut('indent'),
                click: this.context.createInvokeHandler('editor.indent')
            });
            this.context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));
            this.context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));
            this.context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));
            this.context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));
            this.context.memo('button.outdent', func.invoke(outdent, 'render'));
            this.context.memo('button.indent', func.invoke(indent, 'render'));
            this.context.memo('button.paragraph', function () {
                return _this.ui.buttonGroup([
                    _this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.alignLeft), _this.options),
                        tooltip: _this.lang.paragraph.paragraph,
                        data: {
                            toggle: 'dropdown'
                        }
                    }),
                    _this.ui.dropdown([
                        _this.ui.buttonGroup({
                            className: 'note-align',
                            children: [justifyLeft, justifyCenter, justifyRight, justifyFull]
                        }),
                        _this.ui.buttonGroup({
                            className: 'note-list',
                            children: [outdent, indent]
                        })
                    ])
                ]).render();
            });
            this.context.memo('button.height', function () {
                return _this.ui.buttonGroup([
                    _this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.textHeight), _this.options),
                        tooltip: _this.lang.font.height,
                        data: {
                            toggle: 'dropdown'
                        }
                    }),
                    _this.ui.dropdownCheck({
                        items: _this.options.lineHeights,
                        checkClassName: _this.options.icons.menuCheck,
                        className: 'dropdown-line-height',
                        title: _this.lang.font.height,
                        click: _this.context.createInvokeHandler('editor.lineHeight')
                    })
                ]).render();
            });
            this.context.memo('button.table', function () {
                return _this.ui.buttonGroup([
                    _this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.table), _this.options),
                        tooltip: _this.lang.table.table,
                        data: {
                            toggle: 'dropdown'
                        }
                    }),
                    _this.ui.dropdown({
                        title: _this.lang.table.table,
                        className: 'note-table',
                        items: [
                            '<div class="note-dimension-picker">',
                            '  <div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"/>',
                            '  <div class="note-dimension-picker-highlighted"/>',
                            '  <div class="note-dimension-picker-unhighlighted"/>',
                            '</div>',
                            '<div class="note-dimension-display">1 x 1</div>'
                        ].join('')
                    })
                ], {
                    callback: function ($node) {
                        var $catcher = $node.find('.note-dimension-picker-mousecatcher');
                        $catcher.css({
                            width: _this.options.insertTableMaxSize.col + 'em',
                            height: _this.options.insertTableMaxSize.row + 'em'
                        }).mousedown(_this.context.createInvokeHandler('editor.insertTable'))
                            .on('mousemove', _this.tableMoveHandler.bind(_this));
                    }
                }).render();
            });
            this.context.memo('button.link', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.link),
                    tooltip: _this.lang.link.link + _this.representShortcut('linkDialog.show'),
                    click: _this.context.createInvokeHandler('linkDialog.show')
                }).render();
            });
            this.context.memo('button.picture', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.picture),
                    tooltip: _this.lang.image.image,
                    click: _this.context.createInvokeHandler('imageDialog.show')
                }).render();
            });
            this.context.memo('button.video', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.video),
                    tooltip: _this.lang.video.video,
                    click: _this.context.createInvokeHandler('videoDialog.show')
                }).render();
            });
            this.context.memo('button.hr', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.minus),
                    tooltip: _this.lang.hr.insert + _this.representShortcut('insertHorizontalRule'),
                    click: _this.context.createInvokeHandler('editor.insertHorizontalRule')
                }).render();
            });
            this.context.memo('button.fullscreen', function () {
                return _this.button({
                    className: 'btn-fullscreen',
                    contents: _this.ui.icon(_this.options.icons.arrowsAlt),
                    tooltip: _this.lang.options.fullscreen,
                    click: _this.context.createInvokeHandler('fullscreen.toggle')
                }).render();
            });
            this.context.memo('button.codeview', function () {
                return _this.button({
                    className: 'btn-codeview',
                    contents: _this.ui.icon(_this.options.icons.code),
                    tooltip: _this.lang.options.codeview,
                    click: _this.context.createInvokeHandler('codeview.toggle')
                }).render();
            });
            this.context.memo('button.redo', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.redo),
                    tooltip: _this.lang.history.redo + _this.representShortcut('redo'),
                    click: _this.context.createInvokeHandler('editor.redo')
                }).render();
            });
            this.context.memo('button.undo', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.undo),
                    tooltip: _this.lang.history.undo + _this.representShortcut('undo'),
                    click: _this.context.createInvokeHandler('editor.undo')
                }).render();
            });
            this.context.memo('button.help', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.question),
                    tooltip: _this.lang.options.help,
                    click: _this.context.createInvokeHandler('helpDialog.show')
                }).render();
            });
        };
        /**
         * image : [
         *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],
         *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],
         *   ['remove', ['removeMedia']]
         * ],
         */
        Buttons.prototype.addImagePopoverButtons = function () {
            var _this = this;
            // Image Size Buttons
            this.context.memo('button.imageSize100', function () {
                return _this.button({
                    contents: '<span class="note-fontsize-10">100%</span>',
                    tooltip: _this.lang.image.resizeFull,
                    click: _this.context.createInvokeHandler('editor.resize', '1')
                }).render();
            });
            this.context.memo('button.imageSize50', function () {
                return _this.button({
                    contents: '<span class="note-fontsize-10">50%</span>',
                    tooltip: _this.lang.image.resizeHalf,
                    click: _this.context.createInvokeHandler('editor.resize', '0.5')
                }).render();
            });
            this.context.memo('button.imageSize25', function () {
                return _this.button({
                    contents: '<span class="note-fontsize-10">25%</span>',
                    tooltip: _this.lang.image.resizeQuarter,
                    click: _this.context.createInvokeHandler('editor.resize', '0.25')
                }).render();
            });
            // Float Buttons
            this.context.memo('button.floatLeft', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.alignLeft),
                    tooltip: _this.lang.image.floatLeft,
                    click: _this.context.createInvokeHandler('editor.floatMe', 'left')
                }).render();
            });
            this.context.memo('button.floatRight', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.alignRight),
                    tooltip: _this.lang.image.floatRight,
                    click: _this.context.createInvokeHandler('editor.floatMe', 'right')
                }).render();
            });
            this.context.memo('button.floatNone', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.alignJustify),
                    tooltip: _this.lang.image.floatNone,
                    click: _this.context.createInvokeHandler('editor.floatMe', 'none')
                }).render();
            });
            // Remove Buttons
            this.context.memo('button.removeMedia', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.trash),
                    tooltip: _this.lang.image.remove,
                    click: _this.context.createInvokeHandler('editor.removeMedia')
                }).render();
            });
        };
        Buttons.prototype.addLinkPopoverButtons = function () {
            var _this = this;
            this.context.memo('button.linkDialogShow', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.link),
                    tooltip: _this.lang.link.edit,
                    click: _this.context.createInvokeHandler('linkDialog.show')
                }).render();
            });
            this.context.memo('button.unlink', function () {
                return _this.button({
                    contents: _this.ui.icon(_this.options.icons.unlink),
                    tooltip: _this.lang.link.unlink,
                    click: _this.context.createInvokeHandler('editor.unlink')
                }).render();
            });
        };
        /**
         * table : [
         *  ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
         *  ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
         * ],
         */
        Buttons.prototype.addTablePopoverButtons = function () {
            var _this = this;
            this.context.memo('button.addRowUp', function () {
                return _this.button({
                    className: 'btn-md',
                    contents: _this.ui.icon(_this.options.icons.rowAbove),
                    tooltip: _this.lang.table.addRowAbove,
                    click: _this.context.createInvokeHandler('editor.addRow', 'top')
                }).render();
            });
            this.context.memo('button.addRowDown', function () {
                return _this.button({
                    className: 'btn-md',
                    contents: _this.ui.icon(_this.options.icons.rowBelow),
                    tooltip: _this.lang.table.addRowBelow,
                    click: _this.context.createInvokeHandler('editor.addRow', 'bottom')
                }).render();
            });
            this.context.memo('button.addColLeft', function () {
                return _this.button({
                    className: 'btn-md',
                    contents: _this.ui.icon(_this.options.icons.colBefore),
                    tooltip: _this.lang.table.addColLeft,
                    click: _this.context.createInvokeHandler('editor.addCol', 'left')
                }).render();
            });
            this.context.memo('button.addColRight', function () {
                return _this.button({
                    className: 'btn-md',
                    contents: _this.ui.icon(_this.options.icons.colAfter),
                    tooltip: _this.lang.table.addColRight,
                    click: _this.context.createInvokeHandler('editor.addCol', 'right')
                }).render();
            });
            this.context.memo('button.deleteRow', function () {
                return _this.button({
                    className: 'btn-md',
                    contents: _this.ui.icon(_this.options.icons.rowRemove),
                    tooltip: _this.lang.table.delRow,
                    click: _this.context.createInvokeHandler('editor.deleteRow')
                }).render();
            });
            this.context.memo('button.deleteCol', function () {
                return _this.button({
                    className: 'btn-md',
                    contents: _this.ui.icon(_this.options.icons.colRemove),
                    tooltip: _this.lang.table.delCol,
                    click: _this.context.createInvokeHandler('editor.deleteCol')
                }).render();
            });
            this.context.memo('button.deleteTable', function () {
                return _this.button({
                    className: 'btn-md',
                    contents: _this.ui.icon(_this.options.icons.trash),
                    tooltip: _this.lang.table.delTable,
                    click: _this.context.createInvokeHandler('editor.deleteTable')
                }).render();
            });
        };
        Buttons.prototype.build = function ($container, groups) {
            for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {
                var group = groups[groupIdx];
                var groupName = $$1.isArray(group) ? group[0] : group;
                var buttons = $$1.isArray(group) ? ((group.length === 1) ? [group[0]] : group[1]) : [group];
                var $group = this.ui.buttonGroup({
                    className: 'note-' + groupName
                }).render();
                for (var idx = 0, len = buttons.length; idx < len; idx++) {
                    var btn = this.context.memo('button.' + buttons[idx]);
                    if (btn) {
                        $group.append(typeof btn === 'function' ? btn(this.context) : btn);
                    }
                }
                $group.appendTo($container);
            }
        };
        /**
         * @param {jQuery} [$container]
         */
        Buttons.prototype.updateCurrentStyle = function ($container) {
            var _this = this;
            var $cont = $container || this.$toolbar;
            var styleInfo = this.context.invoke('editor.currentStyle');
            this.updateBtnStates($cont, {
                '.note-btn-bold': function () {
                    return styleInfo['font-bold'] === 'bold';
                },
                '.note-btn-italic': function () {
                    return styleInfo['font-italic'] === 'italic';
                },
                '.note-btn-underline': function () {
                    return styleInfo['font-underline'] === 'underline';
                },
                '.note-btn-subscript': function () {
                    return styleInfo['font-subscript'] === 'subscript';
                },
                '.note-btn-superscript': function () {
                    return styleInfo['font-superscript'] === 'superscript';
                },
                '.note-btn-strikethrough': function () {
                    return styleInfo['font-strikethrough'] === 'strikethrough';
                }
            });
            if (styleInfo['font-family']) {
                var fontNames = styleInfo['font-family'].split(',').map(function (name) {
                    return name.replace(/[\'\"]/g, '')
                        .replace(/\s+$/, '')
                        .replace(/^\s+/, '');
                });
                var fontName_1 = lists.find(fontNames, this.isFontInstalled.bind(this));
                $cont.find('.dropdown-fontname a').each(function (idx, item) {
                    var $item = $$1(item);
                    // always compare string to avoid creating another func.
                    var isChecked = ($item.data('value') + '') === (fontName_1 + '');
                    $item.toggleClass('checked', isChecked);
                });
                $cont.find('.note-current-fontname').text(fontName_1).css('font-family', fontName_1);
            }
            if (styleInfo['font-size']) {
                var fontSize_1 = styleInfo['font-size'];
                $cont.find('.dropdown-fontsize a').each(function (idx, item) {
                    var $item = $$1(item);
                    // always compare with string to avoid creating another func.
                    var isChecked = ($item.data('value') + '') === (fontSize_1 + '');
                    $item.toggleClass('checked', isChecked);
                });
                $cont.find('.note-current-fontsize').text(fontSize_1);
            }
            if (styleInfo['line-height']) {
                var lineHeight_1 = styleInfo['line-height'];
                $cont.find('.dropdown-line-height li a').each(function (idx, item) {
                    // always compare with string to avoid creating another func.
                    var isChecked = ($$1(item).data('value') + '') === (lineHeight_1 + '');
                    _this.className = isChecked ? 'checked' : '';
                });
            }
        };
        Buttons.prototype.updateBtnStates = function ($container, infos) {
            var _this = this;
            $$1.each(infos, function (selector, pred) {
                _this.ui.toggleBtnActive($container.find(selector), pred());
            });
        };
        Buttons.prototype.tableMoveHandler = function (event) {
            var PX_PER_EM = 18;
            var $picker = $$1(event.target.parentNode); // target is mousecatcher
            var $dimensionDisplay = $picker.next();
            var $catcher = $picker.find('.note-dimension-picker-mousecatcher');
            var $highlighted = $picker.find('.note-dimension-picker-highlighted');
            var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');
            var posOffset;
            // HTML5 with jQuery - e.offsetX is undefined in Firefox
            if (event.offsetX === undefined) {
                var posCatcher = $$1(event.target).offset();
                posOffset = {
                    x: event.pageX - posCatcher.left,
                    y: event.pageY - posCatcher.top
                };
            }
            else {
                posOffset = {
                    x: event.offsetX,
                    y: event.offsetY
                };
            }
            var dim = {
                c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
                r: Math.ceil(posOffset.y / PX_PER_EM) || 1
            };
            $highlighted.css({width: dim.c + 'em', height: dim.r + 'em'});
            $catcher.data('value', dim.c + 'x' + dim.r);
            if (dim.c > 3 && dim.c < this.options.insertTableMaxSize.col) {
                $unhighlighted.css({width: dim.c + 1 + 'em'});
            }
            if (dim.r > 3 && dim.r < this.options.insertTableMaxSize.row) {
                $unhighlighted.css({height: dim.r + 1 + 'em'});
            }
            $dimensionDisplay.html(dim.c + ' x ' + dim.r);
        };
        return Buttons;
    }());

    var Toolbar = /** @class */ (function () {
        function Toolbar(context) {
            this.context = context;
            this.$window = $$1(window);
            this.$document = $$1(document);
            this.ui = $$1.summernote.ui;
            this.$note = context.layoutInfo.note;
            this.$editor = context.layoutInfo.editor;
            this.$toolbar = context.layoutInfo.toolbar;
            this.options = context.options;
            this.followScroll = this.followScroll.bind(this);
        }

        Toolbar.prototype.shouldInitialize = function () {
            return !this.options.airMode;
        };
        Toolbar.prototype.initialize = function () {
            var _this = this;
            this.options.toolbar = this.options.toolbar || [];
            if (!this.options.toolbar.length) {
                this.$toolbar.hide();
            }
            else {
                this.context.invoke('buttons.build', this.$toolbar, this.options.toolbar);
            }
            if (this.options.toolbarContainer) {
                this.$toolbar.appendTo(this.options.toolbarContainer);
            }
            this.changeContainer(false);
            this.$note.on('summernote.keyup summernote.mouseup summernote.change', function () {
                _this.context.invoke('buttons.updateCurrentStyle');
            });
            this.context.invoke('buttons.updateCurrentStyle');
            if (this.options.followingToolbar) {
                this.$window.on('scroll resize', this.followScroll);
            }
        };
        Toolbar.prototype.destroy = function () {
            this.$toolbar.children().remove();
            if (this.options.followingToolbar) {
                this.$window.off('scroll resize', this.followScroll);
            }
        };
        Toolbar.prototype.followScroll = function () {
            if (this.$editor.hasClass('fullscreen')) {
                return false;
            }
            var $toolbarWrapper = this.$toolbar.parent('.note-toolbar-wrapper');
            var editorHeight = this.$editor.outerHeight();
            var editorWidth = this.$editor.width();
            var toolbarHeight = this.$toolbar.height();
            $toolbarWrapper.css({
                height: toolbarHeight
            });
            // check if the web app is currently using another static bar
            var otherBarHeight = 0;
            if (this.options.otherStaticBar) {
                otherBarHeight = $$1(this.options.otherStaticBar).outerHeight();
            }
            var currentOffset = this.$document.scrollTop();
            var editorOffsetTop = this.$editor.offset().top;
            var editorOffsetBottom = editorOffsetTop + editorHeight;
            var activateOffset = editorOffsetTop - otherBarHeight;
            var deactivateOffsetBottom = editorOffsetBottom - otherBarHeight - toolbarHeight;
            if ((currentOffset > activateOffset) && (currentOffset < deactivateOffsetBottom)) {
                this.$toolbar.css({
                    position: 'fixed',
                    top: otherBarHeight,
                    width: editorWidth
                });
            }
            else {
                this.$toolbar.css({
                    position: 'relative',
                    top: 0,
                    width: '100%'
                });
            }
        };
        Toolbar.prototype.changeContainer = function (isFullscreen) {
            if (isFullscreen) {
                this.$toolbar.prependTo(this.$editor);
            }
            else {
                if (this.options.toolbarContainer) {
                    this.$toolbar.appendTo(this.options.toolbarContainer);
                }
            }
        };
        Toolbar.prototype.updateFullscreen = function (isFullscreen) {
            this.ui.toggleBtnActive(this.$toolbar.find('.btn-fullscreen'), isFullscreen);
            this.changeContainer(isFullscreen);
        };
        Toolbar.prototype.updateCodeview = function (isCodeview) {
            this.ui.toggleBtnActive(this.$toolbar.find('.btn-codeview'), isCodeview);
            if (isCodeview) {
                this.deactivate();
            }
            else {
                this.activate();
            }
        };
        Toolbar.prototype.activate = function (isIncludeCodeview) {
            var $btn = this.$toolbar.find('button');
            if (!isIncludeCodeview) {
                $btn = $btn.not('.btn-codeview');
            }
            this.ui.toggleBtn($btn, true);
        };
        Toolbar.prototype.deactivate = function (isIncludeCodeview) {
            var $btn = this.$toolbar.find('button');
            if (!isIncludeCodeview) {
                $btn = $btn.not('.btn-codeview');
            }
            this.ui.toggleBtn($btn, false);
        };
        return Toolbar;
    }());

    var LinkDialog = /** @class */ (function () {
        function LinkDialog(context) {
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.$body = $$1(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
            context.memo('help.linkDialog.show', this.options.langInfo.help['linkDialog.show']);
        }

        LinkDialog.prototype.initialize = function () {
            var $container = this.options.dialogsInBody ? this.$body : this.$editor;
            var body = [
                '<div class="form-group note-form-group">',
                "<label class=\"note-form-label\">" + this.lang.link.textToDisplay + "</label>",
                '<input class="note-link-text form-control note-form-control  note-input" type="text" />',
                '</div>',
                '<div class="form-group note-form-group">',
                "<label class=\"note-form-label\">" + this.lang.link.url + "</label>",
                '<input class="note-link-url form-control note-form-control note-input" type="text" value="http://" />',
                '</div>',
                !this.options.disableLinkTarget
                    ? $$1('<div/>').append(this.ui.checkbox({
                        id: 'sn-checkbox-open-in-new-window',
                        text: this.lang.link.openInNewWindow,
                        checked: true
                    }).render()).html()
                    : ''
            ].join('');
            var buttonClass = 'btn btn-primary note-btn note-btn-primary note-link-btn';
            var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.link.insert + "</button>";
            this.$dialog = this.ui.dialog({
                className: 'link-dialog',
                title: this.lang.link.insert,
                fade: this.options.dialogsFade,
                body: body,
                footer: footer
            }).render().appendTo($container);
        };
        LinkDialog.prototype.destroy = function () {
            this.ui.hideDialog(this.$dialog);
            this.$dialog.remove();
        };
        LinkDialog.prototype.bindEnterKey = function ($input, $btn) {
            $input.on('keypress', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    event.preventDefault();
                    $btn.trigger('click');
                }
            });
        };
        /**
         * toggle update button
         */
        LinkDialog.prototype.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {
            this.ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
        };
        /**
         * Show link dialog and set event handlers on dialog controls.
         *
         * @param {Object} linkInfo
         * @return {Promise}
         */
        LinkDialog.prototype.showLinkDialog = function (linkInfo) {
            var _this = this;
            return $$1.Deferred(function (deferred) {
                var $linkText = _this.$dialog.find('.note-link-text');
                var $linkUrl = _this.$dialog.find('.note-link-url');
                var $linkBtn = _this.$dialog.find('.note-link-btn');
                var $openInNewWindow = _this.$dialog.find('input[type=checkbox]');
                _this.ui.onDialogShown(_this.$dialog, function () {
                    _this.context.triggerEvent('dialog.shown');
                    // if no url was given, copy text to url
                    if (!linkInfo.url) {
                        linkInfo.url = linkInfo.text;
                    }
                    $linkText.val(linkInfo.text);
                    var handleLinkTextUpdate = function () {
                        _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                        // if linktext was modified by keyup,
                        // stop cloning text from linkUrl
                        linkInfo.text = $linkText.val();
                    };
                    $linkText.on('input', handleLinkTextUpdate).on('paste', function () {
                        setTimeout(handleLinkTextUpdate, 0);
                    });
                    var handleLinkUrlUpdate = function () {
                        _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                        // display same link on `Text to display` input
                        // when create a new link
                        if (!linkInfo.text) {
                            $linkText.val($linkUrl.val());
                        }
                    };
                    $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {
                        setTimeout(handleLinkUrlUpdate, 0);
                    }).val(linkInfo.url);
                    if (!env.isSupportTouch) {
                        $linkUrl.trigger('focus');
                    }
                    _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                    _this.bindEnterKey($linkUrl, $linkBtn);
                    _this.bindEnterKey($linkText, $linkBtn);
                    var isChecked = linkInfo.isNewWindow !== undefined
                        ? linkInfo.isNewWindow : _this.context.options.linkTargetBlank;
                    $openInNewWindow.prop('checked', isChecked);
                    $linkBtn.one('click', function (event) {
                        event.preventDefault();
                        deferred.resolve({
                            range: linkInfo.range,
                            url: $linkUrl.val(),
                            text: $linkText.val(),
                            isNewWindow: $openInNewWindow.is(':checked')
                        });
                        _this.ui.hideDialog(_this.$dialog);
                    });
                });
                _this.ui.onDialogHidden(_this.$dialog, function () {
                    // detach events
                    $linkText.off('input paste keypress');
                    $linkUrl.off('input paste keypress');
                    $linkBtn.off('click');
                    if (deferred.state() === 'pending') {
                        deferred.reject();
                    }
                });
                _this.ui.showDialog(_this.$dialog);
            }).promise();
        };
        /**
         * @param {Object} layoutInfo
         */
        LinkDialog.prototype.show = function () {
            var _this = this;
            var linkInfo = this.context.invoke('editor.getLinkInfo');
            this.context.invoke('editor.saveRange');
            this.showLinkDialog(linkInfo).then(function (linkInfo) {
                _this.context.invoke('editor.restoreRange');
                _this.context.invoke('editor.createLink', linkInfo);
            }).fail(function () {
                _this.context.invoke('editor.restoreRange');
            });
        };
        return LinkDialog;
    }());

    var LinkPopover = /** @class */ (function () {
        function LinkPopover(context) {
            var _this = this;
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.options = context.options;
            this.events = {
                'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {
                    _this.update();
                },
                'summernote.disable summernote.dialog.shown': function () {
                    _this.hide();
                }
            };
        }

        LinkPopover.prototype.shouldInitialize = function () {
            return !lists.isEmpty(this.options.popover.link);
        };
        LinkPopover.prototype.initialize = function () {
            this.$popover = this.ui.popover({
                className: 'note-link-popover',
                callback: function ($node) {
                    var $content = $node.find('.popover-content,.note-popover-content');
                    $content.prepend('<span><a target="_blank"></a>&nbsp;</span>');
                }
            }).render().appendTo(this.options.container);
            var $content = this.$popover.find('.popover-content,.note-popover-content');
            this.context.invoke('buttons.build', $content, this.options.popover.link);
        };
        LinkPopover.prototype.destroy = function () {
            this.$popover.remove();
        };
        LinkPopover.prototype.update = function () {
            // Prevent focusing on editable when invoke('code') is executed
            if (!this.context.invoke('editor.hasFocus')) {
                this.hide();
                return;
            }
            var rng = this.context.invoke('editor.createRange');
            if (rng.isCollapsed() && rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                var href = $$1(anchor).attr('href');
                this.$popover.find('a').attr('href', href).html(href);
                var pos = dom.posFromPlaceholder(anchor);
                this.$popover.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top
                });
            }
            else {
                this.hide();
            }
        };
        LinkPopover.prototype.hide = function () {
            this.$popover.hide();
        };
        return LinkPopover;
    }());

    var ImageDialog = /** @class */ (function () {
        function ImageDialog(context) {
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.$body = $$1(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
        }

        ImageDialog.prototype.initialize = function () {
            var $container = this.options.dialogsInBody ? this.$body : this.$editor;
            var imageLimitation = '';
            if (this.options.maximumImageFileSize) {
                var unit = Math.floor(Math.log(this.options.maximumImageFileSize) / Math.log(1024));
                var readableSize = (this.options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +
                    ' ' + ' KMGTP'[unit] + 'B';
                imageLimitation = "<small>" + (this.lang.image.maximumFileSize + ' : ' + readableSize) + "</small>";
            }
            var body = [
                '<div class="form-group note-form-group note-group-select-from-files">',
                '<label class="note-form-label">' + this.lang.image.selectFromFiles + '</label>',
                '<input class="note-image-input note-form-control note-input" ',
                ' type="file" name="files" accept="image/*" multiple="multiple" />',
                imageLimitation,
                '</div>',
                '<div class="form-group note-group-image-url" style="overflow:auto;">',
                '<label class="note-form-label">' + this.lang.image.url + '</label>',
                '<input class="note-image-url form-control note-form-control note-input ',
                ' col-md-12" type="text" />',
                '</div>'
            ].join('');
            var buttonClass = 'btn btn-primary note-btn note-btn-primary note-image-btn';
            var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.image.insert + "</button>";
            this.$dialog = this.ui.dialog({
                title: this.lang.image.insert,
                fade: this.options.dialogsFade,
                body: body,
                footer: footer
            }).render().appendTo($container);
        };
        ImageDialog.prototype.destroy = function () {
            this.ui.hideDialog(this.$dialog);
            this.$dialog.remove();
        };
        ImageDialog.prototype.bindEnterKey = function ($input, $btn) {
            $input.on('keypress', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    event.preventDefault();
                    $btn.trigger('click');
                }
            });
        };
        ImageDialog.prototype.show = function () {
            var _this = this;
            this.context.invoke('editor.saveRange');
            this.showImageDialog().then(function (data) {
                // [workaround] hide dialog before restore range for IE range focus
                _this.ui.hideDialog(_this.$dialog);
                _this.context.invoke('editor.restoreRange');
                if (typeof data === 'string') {
                    _this.context.invoke('editor.insertImage', data);
                }
                else {
                    _this.context.invoke('editor.insertImagesOrCallback', data);
                }
            }).fail(function () {
                _this.context.invoke('editor.restoreRange');
            });
        };
        /**
         * show image dialog
         *
         * @param {jQuery} $dialog
         * @return {Promise}
         */
        ImageDialog.prototype.showImageDialog = function () {
            var _this = this;
            return $$1.Deferred(function (deferred) {
                var $imageInput = _this.$dialog.find('.note-image-input');
                var $imageUrl = _this.$dialog.find('.note-image-url');
                var $imageBtn = _this.$dialog.find('.note-image-btn');
                _this.ui.onDialogShown(_this.$dialog, function () {
                    _this.context.triggerEvent('dialog.shown');
                    // Cloning imageInput to clear element.
                    $imageInput.replaceWith($imageInput.clone().on('change', function (event) {
                        deferred.resolve(event.target.files || event.target.value);
                    }).val(''));
                    $imageBtn.click(function (event) {
                        event.preventDefault();
                        deferred.resolve($imageUrl.val());
                    });
                    $imageUrl.on('keyup paste', function () {
                        var url = $imageUrl.val();
                        _this.ui.toggleBtn($imageBtn, url);
                    }).val('');
                    if (!env.isSupportTouch) {
                        $imageUrl.trigger('focus');
                    }
                    _this.bindEnterKey($imageUrl, $imageBtn);
                });
                _this.ui.onDialogHidden(_this.$dialog, function () {
                    $imageInput.off('change');
                    $imageUrl.off('keyup paste keypress');
                    $imageBtn.off('click');
                    if (deferred.state() === 'pending') {
                        deferred.reject();
                    }
                });
                _this.ui.showDialog(_this.$dialog);
            });
        };
        return ImageDialog;
    }());

    /**
     * Image popover module
     *  mouse events that show/hide popover will be handled by Handle.js.
     *  Handle.js will receive the events and invoke 'imagePopover.update'.
     */
    var ImagePopover = /** @class */ (function () {
        function ImagePopover(context) {
            var _this = this;
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.editable = context.layoutInfo.editable[0];
            this.options = context.options;
            this.events = {
                'summernote.disable': function () {
                    _this.hide();
                }
            };
        }

        ImagePopover.prototype.shouldInitialize = function () {
            return !lists.isEmpty(this.options.popover.image);
        };
        ImagePopover.prototype.initialize = function () {
            this.$popover = this.ui.popover({
                className: 'note-image-popover'
            }).render().appendTo(this.options.container);
            var $content = this.$popover.find('.popover-content,.note-popover-content');
            this.context.invoke('buttons.build', $content, this.options.popover.image);
        };
        ImagePopover.prototype.destroy = function () {
            this.$popover.remove();
        };
        ImagePopover.prototype.update = function (target) {
            if (dom.isImg(target)) {
                var pos = dom.posFromPlaceholder(target);
                var posEditor = dom.posFromPlaceholder(this.editable);
                this.$popover.css({
                    display: 'block',
                    left: this.options.popatmouse ? event.pageX - 20 : pos.left,
                    top: this.options.popatmouse ? event.pageY : Math.min(pos.top, posEditor.top)
                });
            }
            else {
                this.hide();
            }
        };
        ImagePopover.prototype.hide = function () {
            this.$popover.hide();
        };
        return ImagePopover;
    }());

    var TablePopover = /** @class */ (function () {
        function TablePopover(context) {
            var _this = this;
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.options = context.options;
            this.events = {
                'summernote.mousedown': function (we, e) {
                    _this.update(e.target);
                },
                'summernote.keyup summernote.scroll summernote.change': function () {
                    _this.update();
                },
                'summernote.disable': function () {
                    _this.hide();
                }
            };
        }

        TablePopover.prototype.shouldInitialize = function () {
            return !lists.isEmpty(this.options.popover.table);
        };
        TablePopover.prototype.initialize = function () {
            this.$popover = this.ui.popover({
                className: 'note-table-popover'
            }).render().appendTo(this.options.container);
            var $content = this.$popover.find('.popover-content,.note-popover-content');
            this.context.invoke('buttons.build', $content, this.options.popover.table);
            // [workaround] Disable Firefox's default table editor
            if (env.isFF) {
                document.execCommand('enableInlineTableEditing', false, false);
            }
        };
        TablePopover.prototype.destroy = function () {
            this.$popover.remove();
        };
        TablePopover.prototype.update = function (target) {
            if (this.context.isDisabled()) {
                return false;
            }
            var isCell = dom.isCell(target);
            if (isCell) {
                var pos = dom.posFromPlaceholder(target);
                this.$popover.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top
                });
            }
            else {
                this.hide();
            }
            return isCell;
        };
        TablePopover.prototype.hide = function () {
            this.$popover.hide();
        };
        return TablePopover;
    }());

    var VideoDialog = /** @class */ (function () {
        function VideoDialog(context) {
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.$body = $$1(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
        }

        VideoDialog.prototype.initialize = function () {
            var $container = this.options.dialogsInBody ? this.$body : this.$editor;
            var body = [
                '<div class="form-group note-form-group row-fluid">',
                "<label class=\"note-form-label\">" + this.lang.video.url + " <small class=\"text-muted\">" + this.lang.video.providers + "</small></label>",
                '<input class="note-video-url form-control note-form-control note-input" type="text" />',
                '</div>'
            ].join('');
            var buttonClass = 'btn btn-primary note-btn note-btn-primary note-video-btn';
            var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.video.insert + "</button>";
            this.$dialog = this.ui.dialog({
                title: this.lang.video.insert,
                fade: this.options.dialogsFade,
                body: body,
                footer: footer
            }).render().appendTo($container);
        };
        VideoDialog.prototype.destroy = function () {
            this.ui.hideDialog(this.$dialog);
            this.$dialog.remove();
        };
        VideoDialog.prototype.bindEnterKey = function ($input, $btn) {
            $input.on('keypress', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    event.preventDefault();
                    $btn.trigger('click');
                }
            });
        };
        VideoDialog.prototype.createVideoNode = function (url) {
            // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)
            var ytRegExp = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/;
            var ytMatch = url.match(ytRegExp);
            var igRegExp = /(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/;
            var igMatch = url.match(igRegExp);
            var vRegExp = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/;
            var vMatch = url.match(vRegExp);
            var vimRegExp = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/;
            var vimMatch = url.match(vimRegExp);
            var dmRegExp = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/;
            var dmMatch = url.match(dmRegExp);
            var youkuRegExp = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/;
            var youkuMatch = url.match(youkuRegExp);
            var qqRegExp = /\/\/v\.qq\.com.*?vid=(.+)/;
            var qqMatch = url.match(qqRegExp);
            var qqRegExp2 = /\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/;
            var qqMatch2 = url.match(qqRegExp2);
            var mp4RegExp = /^.+.(mp4|m4v)$/;
            var mp4Match = url.match(mp4RegExp);
            var oggRegExp = /^.+.(ogg|ogv)$/;
            var oggMatch = url.match(oggRegExp);
            var webmRegExp = /^.+.(webm)$/;
            var webmMatch = url.match(webmRegExp);
            var $video;
            if (ytMatch && ytMatch[1].length === 11) {
                var youtubeId = ytMatch[1];
                $video = $$1('<iframe>')
                    .attr('frameborder', 0)
                    .attr('src', '//www.youtube.com/embed/' + youtubeId)
                    .attr('width', '640').attr('height', '360');
            }
            else if (igMatch && igMatch[0].length) {
                $video = $$1('<iframe>')
                    .attr('frameborder', 0)
                    .attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')
                    .attr('width', '612').attr('height', '710')
                    .attr('scrolling', 'no')
                    .attr('allowtransparency', 'true');
            }
            else if (vMatch && vMatch[0].length) {
                $video = $$1('<iframe>')
                    .attr('frameborder', 0)
                    .attr('src', vMatch[0] + '/embed/simple')
                    .attr('width', '600').attr('height', '600')
                    .attr('class', 'vine-embed');
            }
            else if (vimMatch && vimMatch[3].length) {
                $video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')
                    .attr('frameborder', 0)
                    .attr('src', '//player.vimeo.com/video/' + vimMatch[3])
                    .attr('width', '640').attr('height', '360');
            }
            else if (dmMatch && dmMatch[2].length) {
                $video = $$1('<iframe>')
                    .attr('frameborder', 0)
                    .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])
                    .attr('width', '640').attr('height', '360');
            }
            else if (youkuMatch && youkuMatch[1].length) {
                $video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')
                    .attr('frameborder', 0)
                    .attr('height', '498')
                    .attr('width', '510')
                    .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);
            }
            else if ((qqMatch && qqMatch[1].length) || (qqMatch2 && qqMatch2[2].length)) {
                var vid = ((qqMatch && qqMatch[1].length) ? qqMatch[1] : qqMatch2[2]);
                $video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')
                    .attr('frameborder', 0)
                    .attr('height', '310')
                    .attr('width', '500')
                    .attr('src', 'http://v.qq.com/iframe/player.html?vid=' + vid + '&amp;auto=0');
            }
            else if (mp4Match || oggMatch || webmMatch) {
                $video = $$1('<video controls>')
                    .attr('src', url)
                    .attr('width', '640').attr('height', '360');
            }
            else {
                // this is not a known video link. Now what, Cat? Now what?
                return false;
            }
            $video.addClass('note-video-clip');
            return $video[0];
        };
        VideoDialog.prototype.show = function () {
            var _this = this;
            var text = this.context.invoke('editor.getSelectedText');
            this.context.invoke('editor.saveRange');
            this.showVideoDialog(text).then(function (url) {
                // [workaround] hide dialog before restore range for IE range focus
                _this.ui.hideDialog(_this.$dialog);
                _this.context.invoke('editor.restoreRange');
                // build node
                var $node = _this.createVideoNode(url);
                if ($node) {
                    // insert video node
                    _this.context.invoke('editor.insertNode', $node);
                }
            }).fail(function () {
                _this.context.invoke('editor.restoreRange');
            });
        };
        /**
         * show image dialog
         *
         * @param {jQuery} $dialog
         * @return {Promise}
         */
        VideoDialog.prototype.showVideoDialog = function (text) {
            var _this = this;
            return $$1.Deferred(function (deferred) {
                var $videoUrl = _this.$dialog.find('.note-video-url');
                var $videoBtn = _this.$dialog.find('.note-video-btn');
                _this.ui.onDialogShown(_this.$dialog, function () {
                    _this.context.triggerEvent('dialog.shown');
                    $videoUrl.val(text).on('input', function () {
                        _this.ui.toggleBtn($videoBtn, $videoUrl.val());
                    });
                    if (!env.isSupportTouch) {
                        $videoUrl.trigger('focus');
                    }
                    $videoBtn.click(function (event) {
                        event.preventDefault();
                        deferred.resolve($videoUrl.val());
                    });
                    _this.bindEnterKey($videoUrl, $videoBtn);
                });
                _this.ui.onDialogHidden(_this.$dialog, function () {
                    $videoUrl.off('input');
                    $videoBtn.off('click');
                    if (deferred.state() === 'pending') {
                        deferred.reject();
                    }
                });
                _this.ui.showDialog(_this.$dialog);
            });
        };
        return VideoDialog;
    }());

    var HelpDialog = /** @class */ (function () {
        function HelpDialog(context) {
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.$body = $$1(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
        }

        HelpDialog.prototype.initialize = function () {
            var $container = this.options.dialogsInBody ? this.$body : this.$editor;
            var body = [
                '<p class="text-center">',
                '<a href="http://summernote.org/" target="_blank">Summernote 0.8.10</a> · ',
                '<a href="https://github.com/summernote/summernote" target="_blank">Project</a> · ',
                '<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>',
                '</p>'
            ].join('');
            this.$dialog = this.ui.dialog({
                title: this.lang.options.help,
                fade: this.options.dialogsFade,
                body: this.createShortcutList(),
                footer: body,
                callback: function ($node) {
                    $node.find('.modal-body,.note-modal-body').css({
                        'max-height': 300,
                        'overflow': 'scroll'
                    });
                }
            }).render().appendTo($container);
        };
        HelpDialog.prototype.destroy = function () {
            this.ui.hideDialog(this.$dialog);
            this.$dialog.remove();
        };
        HelpDialog.prototype.createShortcutList = function () {
            var _this = this;
            var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
            return Object.keys(keyMap).map(function (key) {
                var command = keyMap[key];
                var $row = $$1('<div><div class="help-list-item"/></div>');
                $row.append($$1('<label><kbd>' + key + '</kdb></label>').css({
                    'width': 180,
                    'margin-right': 10
                })).append($$1('<span/>').html(_this.context.memo('help.' + command) || command));
                return $row.html();
            }).join('');
        };
        /**
         * show help dialog
         *
         * @return {Promise}
         */
        HelpDialog.prototype.showHelpDialog = function () {
            var _this = this;
            return $$1.Deferred(function (deferred) {
                _this.ui.onDialogShown(_this.$dialog, function () {
                    _this.context.triggerEvent('dialog.shown');
                    deferred.resolve();
                });
                _this.ui.showDialog(_this.$dialog);
            }).promise();
        };
        HelpDialog.prototype.show = function () {
            var _this = this;
            this.context.invoke('editor.saveRange');
            this.showHelpDialog().then(function () {
                _this.context.invoke('editor.restoreRange');
            });
        };
        return HelpDialog;
    }());

    var AIR_MODE_POPOVER_X_OFFSET = 20;
    var AirPopover = /** @class */ (function () {
        function AirPopover(context) {
            var _this = this;
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.options = context.options;
            this.events = {
                'summernote.keyup summernote.mouseup summernote.scroll': function () {
                    _this.update();
                },
                'summernote.disable summernote.change summernote.dialog.shown': function () {
                    _this.hide();
                },
                'summernote.focusout': function (we, e) {
                    // [workaround] Firefox doesn't support relatedTarget on focusout
                    //  - Ignore hide action on focus out in FF.
                    if (env.isFF) {
                        return;
                    }
                    if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(_this.$popover[0]))) {
                        _this.hide();
                    }
                }
            };
        }

        AirPopover.prototype.shouldInitialize = function () {
            return this.options.airMode && !lists.isEmpty(this.options.popover.air);
        };
        AirPopover.prototype.initialize = function () {
            this.$popover = this.ui.popover({
                className: 'note-air-popover'
            }).render().appendTo(this.options.container);
            var $content = this.$popover.find('.popover-content');
            this.context.invoke('buttons.build', $content, this.options.popover.air);
        };
        AirPopover.prototype.destroy = function () {
            this.$popover.remove();
        };
        AirPopover.prototype.update = function () {
            var styleInfo = this.context.invoke('editor.currentStyle');
            if (styleInfo.range && !styleInfo.range.isCollapsed()) {
                var rect = lists.last(styleInfo.range.getClientRects());
                if (rect) {
                    var bnd = func.rect2bnd(rect);
                    this.$popover.css({
                        display: 'block',
                        left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,
                        top: bnd.top + bnd.height
                    });
                    this.context.invoke('buttons.updateCurrentStyle', this.$popover);
                }
            }
            else {
                this.hide();
            }
        };
        AirPopover.prototype.hide = function () {
            this.$popover.hide();
        };
        return AirPopover;
    }());

    var POPOVER_DIST = 5;
    var HintPopover = /** @class */ (function () {
        function HintPopover(context) {
            var _this = this;
            this.context = context;
            this.ui = $$1.summernote.ui;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.hint = this.options.hint || [];
            this.direction = this.options.hintDirection || 'bottom';
            this.hints = $$1.isArray(this.hint) ? this.hint : [this.hint];
            this.events = {
                'summernote.keyup': function (we, e) {
                    if (!e.isDefaultPrevented()) {
                        _this.handleKeyup(e);
                    }
                },
                'summernote.keydown': function (we, e) {
                    _this.handleKeydown(e);
                },
                'summernote.disable summernote.dialog.shown': function () {
                    _this.hide();
                }
            };
        }

        HintPopover.prototype.shouldInitialize = function () {
            return this.hints.length > 0;
        };
        HintPopover.prototype.initialize = function () {
            var _this = this;
            this.lastWordRange = null;
            this.$popover = this.ui.popover({
                className: 'note-hint-popover',
                hideArrow: true,
                direction: ''
            }).render().appendTo(this.options.container);
            this.$popover.hide();
            this.$content = this.$popover.find('.popover-content,.note-popover-content');
            this.$content.on('click', '.note-hint-item', function () {
                _this.$content.find('.active').removeClass('active');
                $$1(_this).addClass('active');
                _this.replace();
            });
        };
        HintPopover.prototype.destroy = function () {
            this.$popover.remove();
        };
        HintPopover.prototype.selectItem = function ($item) {
            this.$content.find('.active').removeClass('active');
            $item.addClass('active');
            this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);
        };
        HintPopover.prototype.moveDown = function () {
            var $current = this.$content.find('.note-hint-item.active');
            var $next = $current.next();
            if ($next.length) {
                this.selectItem($next);
            }
            else {
                var $nextGroup = $current.parent().next();
                if (!$nextGroup.length) {
                    $nextGroup = this.$content.find('.note-hint-group').first();
                }
                this.selectItem($nextGroup.find('.note-hint-item').first());
            }
        };
        HintPopover.prototype.moveUp = function () {
            var $current = this.$content.find('.note-hint-item.active');
            var $prev = $current.prev();
            if ($prev.length) {
                this.selectItem($prev);
            }
            else {
                var $prevGroup = $current.parent().prev();
                if (!$prevGroup.length) {
                    $prevGroup = this.$content.find('.note-hint-group').last();
                }
                this.selectItem($prevGroup.find('.note-hint-item').last());
            }
        };
        HintPopover.prototype.replace = function () {
            var $item = this.$content.find('.note-hint-item.active');
            if ($item.length) {
                var node = this.nodeFromItem($item);
                // XXX: consider to move codes to editor for recording redo/undo.
                this.lastWordRange.insertNode(node);
                range.createFromNode(node).collapse().select();
                this.lastWordRange = null;
                this.hide();
                this.context.triggerEvent('change', this.$editable.html(), this.$editable[0]);
                this.context.invoke('editor.focus');
            }
        };
        HintPopover.prototype.nodeFromItem = function ($item) {
            var hint = this.hints[$item.data('index')];
            var item = $item.data('item');
            var node = hint.content ? hint.content(item) : item;
            if (typeof node === 'string') {
                node = dom.createText(node);
            }
            return node;
        };
        HintPopover.prototype.createItemTemplates = function (hintIdx, items) {
            var hint = this.hints[hintIdx];
            return items.map(function (item, idx) {
                var $item = $$1('<div class="note-hint-item"/>');
                $item.append(hint.template ? hint.template(item) : item + '');
                $item.data({
                    'index': hintIdx,
                    'item': item
                });
                return $item;
            });
        };
        HintPopover.prototype.handleKeydown = function (e) {
            if (!this.$popover.is(':visible')) {
                return;
            }
            if (e.keyCode === key.code.ENTER) {
                e.preventDefault();
                this.replace();
            }
            else if (e.keyCode === key.code.UP) {
                e.preventDefault();
                this.moveUp();
            }
            else if (e.keyCode === key.code.DOWN) {
                e.preventDefault();
                this.moveDown();
            }
        };
        HintPopover.prototype.searchKeyword = function (index, keyword, callback) {
            var hint = this.hints[index];
            if (hint && hint.match.test(keyword) && hint.search) {
                var matches = hint.match.exec(keyword);
                hint.search(matches[1], callback);
            }
            else {
                callback();
            }
        };
        HintPopover.prototype.createGroup = function (idx, keyword) {
            var _this = this;
            var $group = $$1('<div class="note-hint-group note-hint-group-' + idx + '"/>');
            this.searchKeyword(idx, keyword, function (items) {
                items = items || [];
                if (items.length) {
                    $group.html(_this.createItemTemplates(idx, items));
                    _this.show();
                }
            });
            return $group;
        };
        HintPopover.prototype.handleKeyup = function (e) {
            var _this = this;
            if (!lists.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {
                var wordRange = this.context.invoke('editor.createRange').getWordRange();
                var keyword_1 = wordRange.toString();
                if (this.hints.length && keyword_1) {
                    this.$content.empty();
                    var bnd = func.rect2bnd(lists.last(wordRange.getClientRects()));
                    if (bnd) {
                        this.$popover.hide();
                        this.lastWordRange = wordRange;
                        this.hints.forEach(function (hint, idx) {
                            if (hint.match.test(keyword_1)) {
                                _this.createGroup(idx, keyword_1).appendTo(_this.$content);
                            }
                        });
                        // select first .note-hint-item
                        this.$content.find('.note-hint-item:first').addClass('active');
                        // set position for popover after group is created
                        if (this.direction === 'top') {
                            this.$popover.css({
                                left: bnd.left,
                                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST
                            });
                        }
                        else {
                            this.$popover.css({
                                left: bnd.left,
                                top: bnd.top + bnd.height + POPOVER_DIST
                            });
                        }
                    }
                }
                else {
                    this.hide();
                }
            }
        };
        HintPopover.prototype.show = function () {
            this.$popover.show();
        };
        HintPopover.prototype.hide = function () {
            this.$popover.hide();
        };
        return HintPopover;
    }());

    var Context = /** @class */ (function () {
        /**
         * @param {jQuery} $note
         * @param {Object} options
         */
        function Context($note, options) {
            this.ui = $$1.summernote.ui;
            this.$note = $note;
            this.memos = {};
            this.modules = {};
            this.layoutInfo = {};
            this.options = options;
            this.initialize();
        }

        /**
         * create layout and initialize modules and other resources
         */
        Context.prototype.initialize = function () {
            this.layoutInfo = this.ui.createLayout(this.$note, this.options);
            this._initialize();
            this.$note.hide();
            return this;
        };
        /**
         * destroy modules and other resources and remove layout
         */
        Context.prototype.destroy = function () {
            this._destroy();
            this.$note.removeData('summernote');
            this.ui.removeLayout(this.$note, this.layoutInfo);
        };
        /**
         * destory modules and other resources and initialize it again
         */
        Context.prototype.reset = function () {
            var disabled = this.isDisabled();
            this.code(dom.emptyPara);
            this._destroy();
            this._initialize();
            if (disabled) {
                this.disable();
            }
        };
        Context.prototype._initialize = function () {
            var _this = this;
            // add optional buttons
            var buttons = $$1.extend({}, this.options.buttons);
            Object.keys(buttons).forEach(function (key) {
                _this.memo('button.' + key, buttons[key]);
            });
            var modules = $$1.extend({}, this.options.modules, $$1.summernote.plugins || {});
            // add and initialize modules
            Object.keys(modules).forEach(function (key) {
                _this.module(key, modules[key], true);
            });
            Object.keys(this.modules).forEach(function (key) {
                _this.initializeModule(key);
            });
        };
        Context.prototype._destroy = function () {
            var _this = this;
            // destroy modules with reversed order
            Object.keys(this.modules).reverse().forEach(function (key) {
                _this.removeModule(key);
            });
            Object.keys(this.memos).forEach(function (key) {
                _this.removeMemo(key);
            });
            // trigger custom onDestroy callback
            this.triggerEvent('destroy', this);
        };
        Context.prototype.code = function (html) {
            var isActivated = this.invoke('codeview.isActivated');
            if (html === undefined) {
                this.invoke('codeview.sync');
                return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
            }
            else {
                if (isActivated) {
                    this.layoutInfo.codable.val(html);
                }
                else {
                    this.layoutInfo.editable.html(html);
                }
                this.$note.val(html);
                this.triggerEvent('change', html);
            }
        };
        Context.prototype.isDisabled = function () {
            return this.layoutInfo.editable.attr('contenteditable') === 'false';
        };
        Context.prototype.enable = function () {
            this.layoutInfo.editable.attr('contenteditable', true);
            this.invoke('toolbar.activate', true);
            this.triggerEvent('disable', false);
        };
        Context.prototype.disable = function () {
            // close codeview if codeview is opend
            if (this.invoke('codeview.isActivated')) {
                this.invoke('codeview.deactivate');
            }
            this.layoutInfo.editable.attr('contenteditable', false);
            this.invoke('toolbar.deactivate', true);
            this.triggerEvent('disable', true);
        };
        Context.prototype.triggerEvent = function () {
            var namespace = lists.head(arguments);
            var args = lists.tail(lists.from(arguments));
            var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];
            if (callback) {
                callback.apply(this.$note[0], args);
            }
            this.$note.trigger('summernote.' + namespace, args);
        };
        Context.prototype.initializeModule = function (key) {
            var module = this.modules[key];
            module.shouldInitialize = module.shouldInitialize || func.ok;
            if (!module.shouldInitialize()) {
                return;
            }
            // initialize module
            if (module.initialize) {
                module.initialize();
            }
            // attach events
            if (module.events) {
                dom.attachEvents(this.$note, module.events);
            }
        };
        Context.prototype.module = function (key, ModuleClass, withoutIntialize) {
            if (arguments.length === 1) {
                return this.modules[key];
            }
            this.modules[key] = new ModuleClass(this);
            if (!withoutIntialize) {
                this.initializeModule(key);
            }
        };
        Context.prototype.removeModule = function (key) {
            var module = this.modules[key];
            if (module.shouldInitialize()) {
                if (module.events) {
                    dom.detachEvents(this.$note, module.events);
                }
                if (module.destroy) {
                    module.destroy();
                }
            }
            delete this.modules[key];
        };
        Context.prototype.memo = function (key, obj) {
            if (arguments.length === 1) {
                return this.memos[key];
            }
            this.memos[key] = obj;
        };
        Context.prototype.removeMemo = function (key) {
            if (this.memos[key] && this.memos[key].destroy) {
                this.memos[key].destroy();
            }
            delete this.memos[key];
        };
        /**
         * Some buttons need to change their visual style immediately once they get pressed
         */
        Context.prototype.createInvokeHandlerAndUpdateState = function (namespace, value) {
            var _this = this;
            return function (event) {
                _this.createInvokeHandler(namespace, value)(event);
                _this.invoke('buttons.updateCurrentStyle');
            };
        };
        Context.prototype.createInvokeHandler = function (namespace, value) {
            var _this = this;
            return function (event) {
                event.preventDefault();
                var $target = $$1(event.target);
                _this.invoke(namespace, value || $target.closest('[data-value]').data('value'), $target);
            };
        };
        Context.prototype.invoke = function () {
            var namespace = lists.head(arguments);
            var args = lists.tail(lists.from(arguments));
            var splits = namespace.split('.');
            var hasSeparator = splits.length > 1;
            var moduleName = hasSeparator && lists.head(splits);
            var methodName = hasSeparator ? lists.last(splits) : lists.head(splits);
            var module = this.modules[moduleName || 'editor'];
            if (!moduleName && this[methodName]) {
                return this[methodName].apply(this, args);
            }
            else if (module && module[methodName] && module.shouldInitialize()) {
                return module[methodName].apply(module, args);
            }
        };
        return Context;
    }());

    $$1.fn.extend({
        /**
         * Summernote API
         *
         * @param {Object|String}
         * @return {this}
         */
        summernote: function () {
            var type = $$1.type(lists.head(arguments));
            var isExternalAPICalled = type === 'string';
            var hasInitOptions = type === 'object';
            var options = $$1.extend({}, $$1.summernote.options, hasInitOptions ? lists.head(arguments) : {});
            // Update options
            options.langInfo = $$1.extend(true, {}, $$1.summernote.lang['en-US'], $$1.summernote.lang[options.lang]);
            options.icons = $$1.extend(true, {}, $$1.summernote.options.icons, options.icons);
            options.tooltip = options.tooltip === 'auto' ? !env.isSupportTouch : options.tooltip;
            this.each(function (idx, note) {
                var $note = $$1(note);
                if (!$note.data('summernote')) {
                    var context = new Context($note, options);
                    $note.data('summernote', context);
                    $note.data('summernote').triggerEvent('init', context.layoutInfo);
                }
            });
            var $note = this.first();
            if ($note.length) {
                var context = $note.data('summernote');
                if (isExternalAPICalled) {
                    return context.invoke.apply(context, lists.from(arguments));
                }
                else if (options.focus) {
                    context.invoke('editor.focus');
                }
            }
            return this;
        }
    });

    $$1.summernote = $$1.extend($$1.summernote, {
        version: '0.8.10',
        ui: ui,
        dom: dom,
        plugins: {},
        options: {
            modules: {
                'editor': Editor,
                'clipboard': Clipboard,
                'dropzone': Dropzone,
                'codeview': CodeView,
                'statusbar': Statusbar,
                'fullscreen': Fullscreen,
                'handle': Handle,
                // FIXME: HintPopover must be front of autolink
                //  - Script error about range when Enter key is pressed on hint popover
                'hintPopover': HintPopover,
                'autoLink': AutoLink,
                'autoSync': AutoSync,
                'placeholder': Placeholder,
                'buttons': Buttons,
                'toolbar': Toolbar,
                'linkDialog': LinkDialog,
                'linkPopover': LinkPopover,
                'imageDialog': ImageDialog,
                'imagePopover': ImagePopover,
                'tablePopover': TablePopover,
                'videoDialog': VideoDialog,
                'helpDialog': HelpDialog,
                'airPopover': AirPopover
            },
            buttons: {},
            lang: 'en-US',
            followingToolbar: true,
            otherStaticBar: '',
            // toolbar
            toolbar: [
                ['style', ['style']],
                ['font', ['bold', 'underline', 'clear']],
                ['fontname', ['fontname']],
                ['color', ['color']],
                ['para', ['ul', 'ol', 'paragraph']],
                ['table', ['table']],
                ['insert', ['link', 'picture', 'video']],
                ['view', ['fullscreen', 'codeview', 'help']]
            ],
            // popover
            popatmouse: true,
            popover: {
                image: [
                    ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],
                    ['float', ['floatLeft', 'floatRight', 'floatNone']],
                    ['remove', ['removeMedia']]
                ],
                link: [
                    ['link', ['linkDialogShow', 'unlink']]
                ],
                table: [
                    ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
                    ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
                ],
                air: [
                    ['color', ['color']],
                    ['font', ['bold', 'underline', 'clear']],
                    ['para', ['ul', 'paragraph']],
                    ['table', ['table']],
                    ['insert', ['link', 'picture']]
                ]
            },
            // air mode: inline editor
            airMode: false,
            width: null,
            height: null,
            linkTargetBlank: true,
            focus: false,
            tabSize: 4,
            styleWithSpan: true,
            shortcuts: true,
            textareaAutoSync: true,
            hintDirection: 'bottom',
            tooltip: 'auto',
            container: 'body',
            maxTextLength: 0,
            styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
            fontNames: [
                'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
                'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',
                'Tahoma', 'Times New Roman', 'Verdana'
            ],
            fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],
            // pallete colors(n x n)
            colors: [
                ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],
                ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],
                ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],
                ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],
                ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],
                ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],
                ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],
                ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']
            ],
            // http://chir.ag/projects/name-that-color/
            colorsName: [
                ['Black', 'Tundora', 'Dove Gray', 'Star Dust', 'Pale Slate', 'Gallery', 'Alabaster', 'White'],
                ['Red', 'Orange Peel', 'Yellow', 'Green', 'Cyan', 'Blue', 'Electric Violet', 'Magenta'],
                ['Azalea', 'Karry', 'Egg White', 'Zanah', 'Botticelli', 'Tropical Blue', 'Mischka', 'Twilight'],
                ['Tonys Pink', 'Peach Orange', 'Cream Brulee', 'Sprout', 'Casper', 'Perano', 'Cold Purple', 'Careys Pink'],
                ['Mandy', 'Rajah', 'Dandelion', 'Olivine', 'Gulf Stream', 'Viking', 'Blue Marguerite', 'Puce'],
                ['Guardsman Red', 'Fire Bush', 'Golden Dream', 'Chelsea Cucumber', 'Smalt Blue', 'Boston Blue', 'Butterfly Bush', 'Cadillac'],
                ['Sangria', 'Mai Tai', 'Buddha Gold', 'Forest Green', 'Eden', 'Venice Blue', 'Meteorite', 'Claret'],
                ['Rosewood', 'Cinnamon', 'Olive', 'Parsley', 'Tiber', 'Midnight Blue', 'Valentino', 'Loulou']
            ],
            lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],
            tableClassName: 'table table-bordered',
            insertTableMaxSize: {
                col: 10,
                row: 10
            },
            dialogsInBody: false,
            dialogsFade: false,
            maximumImageFileSize: null,
            callbacks: {
                onInit: null,
                onFocus: null,
                onBlur: null,
                onBlurCodeview: null,
                onEnter: null,
                onKeyup: null,
                onKeydown: null,
                onImageUpload: null,
                onImageUploadError: null
            },
            codemirror: {
                mode: 'text/html',
                htmlMode: true,
                lineNumbers: true
            },
            keyMap: {
                pc: {
                    'ENTER': 'insertParagraph',
                    'CTRL+Z': 'undo',
                    'CTRL+Y': 'redo',
                    'TAB': 'tab',
                    'SHIFT+TAB': 'untab',
                    'CTRL+B': 'bold',
                    'CTRL+I': 'italic',
                    'CTRL+U': 'underline',
                    'CTRL+SHIFT+S': 'strikethrough',
                    'CTRL+BACKSLASH': 'removeFormat',
                    'CTRL+SHIFT+L': 'justifyLeft',
                    'CTRL+SHIFT+E': 'justifyCenter',
                    'CTRL+SHIFT+R': 'justifyRight',
                    'CTRL+SHIFT+J': 'justifyFull',
                    'CTRL+SHIFT+NUM7': 'insertUnorderedList',
                    'CTRL+SHIFT+NUM8': 'insertOrderedList',
                    'CTRL+LEFTBRACKET': 'outdent',
                    'CTRL+RIGHTBRACKET': 'indent',
                    'CTRL+NUM0': 'formatPara',
                    'CTRL+NUM1': 'formatH1',
                    'CTRL+NUM2': 'formatH2',
                    'CTRL+NUM3': 'formatH3',
                    'CTRL+NUM4': 'formatH4',
                    'CTRL+NUM5': 'formatH5',
                    'CTRL+NUM6': 'formatH6',
                    'CTRL+ENTER': 'insertHorizontalRule',
                    'CTRL+K': 'linkDialog.show'
                },
                mac: {
                    'ENTER': 'insertParagraph',
                    'CMD+Z': 'undo',
                    'CMD+SHIFT+Z': 'redo',
                    'TAB': 'tab',
                    'SHIFT+TAB': 'untab',
                    'CMD+B': 'bold',
                    'CMD+I': 'italic',
                    'CMD+U': 'underline',
                    'CMD+SHIFT+S': 'strikethrough',
                    'CMD+BACKSLASH': 'removeFormat',
                    'CMD+SHIFT+L': 'justifyLeft',
                    'CMD+SHIFT+E': 'justifyCenter',
                    'CMD+SHIFT+R': 'justifyRight',
                    'CMD+SHIFT+J': 'justifyFull',
                    'CMD+SHIFT+NUM7': 'insertUnorderedList',
                    'CMD+SHIFT+NUM8': 'insertOrderedList',
                    'CMD+LEFTBRACKET': 'outdent',
                    'CMD+RIGHTBRACKET': 'indent',
                    'CMD+NUM0': 'formatPara',
                    'CMD+NUM1': 'formatH1',
                    'CMD+NUM2': 'formatH2',
                    'CMD+NUM3': 'formatH3',
                    'CMD+NUM4': 'formatH4',
                    'CMD+NUM5': 'formatH5',
                    'CMD+NUM6': 'formatH6',
                    'CMD+ENTER': 'insertHorizontalRule',
                    'CMD+K': 'linkDialog.show'
                }
            },
            icons: {
                'align': 'note-icon-align',
                'alignCenter': 'note-icon-align-center',
                'alignJustify': 'note-icon-align-justify',
                'alignLeft': 'note-icon-align-left',
                'alignRight': 'note-icon-align-right',
                'rowBelow': 'note-icon-row-below',
                'colBefore': 'note-icon-col-before',
                'colAfter': 'note-icon-col-after',
                'rowAbove': 'note-icon-row-above',
                'rowRemove': 'note-icon-row-remove',
                'colRemove': 'note-icon-col-remove',
                'indent': 'note-icon-align-indent',
                'outdent': 'note-icon-align-outdent',
                'arrowsAlt': 'note-icon-arrows-alt',
                'bold': 'note-icon-bold',
                'caret': 'note-icon-caret',
                'circle': 'note-icon-circle',
                'close': 'note-icon-close',
                'code': 'note-icon-code',
                'eraser': 'note-icon-eraser',
                'font': 'note-icon-font',
                'frame': 'note-icon-frame',
                'italic': 'note-icon-italic',
                'link': 'note-icon-link',
                'unlink': 'note-icon-chain-broken',
                'magic': 'note-icon-magic',
                'menuCheck': 'note-icon-menu-check',
                'minus': 'note-icon-minus',
                'orderedlist': 'note-icon-orderedlist',
                'pencil': 'note-icon-pencil',
                'picture': 'note-icon-picture',
                'question': 'note-icon-question',
                'redo': 'note-icon-redo',
                'square': 'note-icon-square',
                'strikethrough': 'note-icon-strikethrough',
                'subscript': 'note-icon-subscript',
                'superscript': 'note-icon-superscript',
                'table': 'note-icon-table',
                'textHeight': 'note-icon-text-height',
                'trash': 'note-icon-trash',
                'underline': 'note-icon-underline',
                'undo': 'note-icon-undo',
                'unorderedlist': 'note-icon-unorderedlist',
                'video': 'note-icon-video'
            }
        }
    });

})));


// Released under MIT license
// Copyright (c) 2009-2010 Dominic Baggott
// Copyright (c) 2009-2010 Ash Berlin
// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)

/*jshint browser:true, devel:true */

(function (expose) {

    /**
     *  class Markdown
     *
     *  Markdown processing in Javascript done right. We have very particular views
     *  on what constitutes 'right' which include:
     *
     *  - produces well-formed HTML (this means that em and strong nesting is
     *    important)
     *
     *  - has an intermediate representation to allow processing of parsed data (We
     *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).
     *
     *  - is easily extensible to add new dialects without having to rewrite the
     *    entire parsing mechanics
     *
     *  - has a good test suite
     *
     *  This implementation fulfills all of these (except that the test suite could
     *  do with expanding to automatically run all the fixtures from other Markdown
     *  implementations.)
     *
     *  ##### Intermediate Representation
     *
     *  *TODO* Talk about this :) Its JsonML, but document the node names we use.
     *
     *  [JsonML]: http://jsonml.org/ "JSON Markup Language"
     **/
    var Markdown = expose.Markdown = function (dialect) {
        switch (typeof dialect) {
            case "undefined":
                this.dialect = Markdown.dialects.Gruber;
                break;
            case "object":
                this.dialect = dialect;
                break;
            default:
                if (dialect in Markdown.dialects) {
                    this.dialect = Markdown.dialects[dialect];
                }
                else {
                    throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
                }
                break;
        }
        this.em_state = [];
        this.strong_state = [];
        this.debug_indent = "";
    };

    /**
     *  parse( markdown, [dialect] ) -> JsonML
     *  - markdown (String): markdown string to parse
     *  - dialect (String | Dialect): the dialect to use, defaults to gruber
     *
     *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.
     **/
    expose.parse = function (source, dialect) {
        // dialect will default if undefined
        var md = new Markdown(dialect);
        return md.toTree(source);
    };

    /**
     *  toHTML( markdown, [dialect]  ) -> String
     *  toHTML( md_tree ) -> String
     *  - markdown (String): markdown string to parse
     *  - md_tree (Markdown.JsonML): parsed markdown tree
     *
     *  Take markdown (either as a string or as a JsonML tree) and run it through
     *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.
     **/
    expose.toHTML = function toHTML(source, dialect, options) {
        var input = expose.toHTMLTree(source, dialect, options);

        return expose.renderJsonML(input);
    };

    /**
     *  toHTMLTree( markdown, [dialect] ) -> JsonML
     *  toHTMLTree( md_tree ) -> JsonML
     *  - markdown (String): markdown string to parse
     *  - dialect (String | Dialect): the dialect to use, defaults to gruber
     *  - md_tree (Markdown.JsonML): parsed markdown tree
     *
     *  Turn markdown into HTML, represented as a JsonML tree. If a string is given
     *  to this function, it is first parsed into a markdown tree by calling
     *  [[parse]].
     **/
    expose.toHTMLTree = function toHTMLTree(input, dialect, options) {
        // convert string input to an MD tree
        if (typeof input === "string") input = this.parse(input, dialect);

        // Now convert the MD tree to an HTML tree

        // remove references from the tree
        var attrs = extract_attr(input),
            refs = {};

        if (attrs && attrs.references) {
            refs = attrs.references;
        }

        var html = convert_tree_to_html(input, refs, options);
        merge_text_nodes(html);
        return html;
    };

// For Spidermonkey based engines
    function mk_block_toSource() {
        return "Markdown.mk_block( " +
            uneval(this.toString()) +
            ", " +
            uneval(this.trailing) +
            ", " +
            uneval(this.lineNumber) +
            " )";
    }

// node
    function mk_block_inspect() {
        var util = require("util");
        return "Markdown.mk_block( " +
            util.inspect(this.toString()) +
            ", " +
            util.inspect(this.trailing) +
            ", " +
            util.inspect(this.lineNumber) +
            " )";

    }

    var mk_block = Markdown.mk_block = function (block, trail, line) {
        // Be helpful for default case in tests.
        if (arguments.length == 1) trail = "\n\n";

        var s = new String(block);
        s.trailing = trail;
        // To make it clear its not just a string
        s.inspect = mk_block_inspect;
        s.toSource = mk_block_toSource;

        if (line != undefined)
            s.lineNumber = line;

        return s;
    };

    function count_lines(str) {
        var n = 0, i = -1;
        while ((i = str.indexOf("\n", i + 1)) !== -1) n++;
        return n;
    }

// Internal - split source into rough blocks
    Markdown.prototype.split_blocks = function splitBlocks(input, startLine) {
        input = input.replace(/(\r\n|\n|\r)/g, "\n");
        // [\s\S] matches _anything_ (newline or space)
        // [^] is equivalent but doesn't work in IEs.
        var re = /([\s\S]+?)($|\n#|\n(?:\s*\n|$)+)/g,
            blocks = [],
            m;

        var line_no = 1;

        if ((m = /^(\s*\n)/.exec(input)) != null) {
            // skip (but count) leading blank lines
            line_no += count_lines(m[0]);
            re.lastIndex = m[0].length;
        }

        while ((m = re.exec(input)) !== null) {
            if (m[2] == "\n#") {
                m[2] = "\n";
                re.lastIndex--;
            }
            blocks.push(mk_block(m[1], m[2], line_no));
            line_no += count_lines(m[0]);
        }

        return blocks;
    };

    /**
     *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]
     *  - block (String): the block to process
     *  - next (Array): the following blocks
     *
     * Process `block` and return an array of JsonML nodes representing `block`.
     *
     * It does this by asking each block level function in the dialect to process
     * the block until one can. Succesful handling is indicated by returning an
     * array (with zero or more JsonML nodes), failure by a false value.
     *
     * Blocks handlers are responsible for calling [[Markdown#processInline]]
     * themselves as appropriate.
     *
     * If the blocks were split incorrectly or adjacent blocks need collapsing you
     * can adjust `next` in place using shift/splice etc.
     *
     * If any of this default behaviour is not right for the dialect, you can
     * define a `__call__` method on the dialect that will get invoked to handle
     * the block processing.
     */
    Markdown.prototype.processBlock = function processBlock(block, next) {
        var cbs = this.dialect.block,
            ord = cbs.__order__;

        if ("__call__" in cbs) {
            return cbs.__call__.call(this, block, next);
        }

        for (var i = 0; i < ord.length; i++) {
            //D:this.debug( "Testing", ord[i] );
            var res = cbs[ord[i]].call(this, block, next);
            if (res) {
                //D:this.debug("  matched");
                if (!isArray(res) || (res.length > 0 && !(isArray(res[0]))))
                    this.debug(ord[i], "didn't return a proper array");
                //D:this.debug( "" );
                return res;
            }
        }

        // Uhoh! no match! Should we throw an error?
        return [];
    };

    Markdown.prototype.processInline = function processInline(block) {
        return this.dialect.inline.__call__.call(this, String(block));
    };

    /**
     *  Markdown#toTree( source ) -> JsonML
     *  - source (String): markdown source to parse
     *
     *  Parse `source` into a JsonML tree representing the markdown document.
     **/
// custom_tree means set this.tree to `custom_tree` and restore old value on return
    Markdown.prototype.toTree = function toTree(source, custom_root) {
        var blocks = source instanceof Array ? source : this.split_blocks(source);

        // Make tree a member variable so its easier to mess with in extensions
        var old_tree = this.tree;
        try {
            this.tree = custom_root || this.tree || ["markdown"];

            blocks:
                while (blocks.length) {
                    var b = this.processBlock(blocks.shift(), blocks);

                    // Reference blocks and the like won't return any content
                    if (!b.length) continue blocks;

                    this.tree.push.apply(this.tree, b);
                }
            return this.tree;
        }
        finally {
            if (custom_root) {
                this.tree = old_tree;
            }
        }
    };

// Noop by default
    Markdown.prototype.debug = function () {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this.debug_indent);
        if (typeof print !== "undefined")
            print.apply(print, args);
        if (typeof console !== "undefined" && typeof console.log !== "undefined")
            console.log.apply(null, args);
    }

    Markdown.prototype.loop_re_over_block = function (re, block, cb) {
        // Dont use /g regexps with this
        var m,
            b = block.valueOf();

        while (b.length && (m = re.exec(b)) != null) {
            b = b.substr(m[0].length);
            cb.call(this, m);
        }
        return b;
    };

    /**
     * Markdown.dialects
     *
     * Namespace of built-in dialects.
     **/
    Markdown.dialects = {};

    /**
     * Markdown.dialects.Gruber
     *
     * The default dialect that follows the rules set out by John Gruber's
     * markdown.pl as closely as possible. Well actually we follow the behaviour of
     * that script which in some places is not exactly what the syntax web page
     * says.
     **/
    Markdown.dialects.Gruber = {
        block: {
            atxHeader: function atxHeader(block, next) {
                var m = block.match(/^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/);

                if (!m) return undefined;

                var header = ["header", {level: m[1].length}];
                Array.prototype.push.apply(header, this.processInline(m[2]));

                if (m[0].length < block.length)
                    next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));

                return [header];
            },

            setextHeader: function setextHeader(block, next) {
                var m = block.match(/^(.*)\n([-=])\2\2+(?:\n|$)/);

                if (!m) return undefined;

                var level = (m[2] === "=") ? 1 : 2;
                var header = ["header", {level: level}, m[1]];

                if (m[0].length < block.length)
                    next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));

                return [header];
            },

            code: function code(block, next) {
                // |    Foo
                // |bar
                // should be a code block followed by a paragraph. Fun
                //
                // There might also be adjacent code block to merge.

                var ret = [],
                    re = /^(?: {0,3}\t| {4})(.*)\n?/,
                    lines;

                // 4 spaces + content
                if (!block.match(re)) return undefined;

                block_search:
                    do {
                        // Now pull out the rest of the lines
                        var b = this.loop_re_over_block(
                            re, block.valueOf(), function (m) {
                                ret.push(m[1]);
                            });

                        if (b.length) {
                            // Case alluded to in first comment. push it back on as a new block
                            next.unshift(mk_block(b, block.trailing));
                            break block_search;
                        }
                        else if (next.length) {
                            // Check the next block - it might be code too
                            if (!next[0].match(re)) break block_search;

                            // Pull how how many blanks lines follow - minus two to account for .join
                            ret.push(block.trailing.replace(/[^\n]/g, "").substring(2));

                            block = next.shift();
                        }
                        else {
                            break block_search;
                        }
                    } while (true);

                return [["code_block", ret.join("\n")]];
            },

            horizRule: function horizRule(block, next) {
                // this needs to find any hr in the block to handle abutting blocks
                var m = block.match(/^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/);

                if (!m) {
                    return undefined;
                }

                var jsonml = [["hr"]];

                // if there's a leading abutting block, process it
                if (m[1]) {
                    jsonml.unshift.apply(jsonml, this.processBlock(m[1], []));
                }

                // if there's a trailing abutting block, stick it into next
                if (m[3]) {
                    next.unshift(mk_block(m[3]));
                }

                return jsonml;
            },

            // There are two types of lists. Tight and loose. Tight lists have no whitespace
            // between the items (and result in text just in the <li>) and loose lists,
            // which have an empty line between list items, resulting in (one or more)
            // paragraphs inside the <li>.
            //
            // There are all sorts weird edge cases about the original markdown.pl's
            // handling of lists:
            //
            // * Nested lists are supposed to be indented by four chars per level. But
            //   if they aren't, you can get a nested list by indenting by less than
            //   four so long as the indent doesn't match an indent of an existing list
            //   item in the 'nest stack'.
            //
            // * The type of the list (bullet or number) is controlled just by the
            //    first item at the indent. Subsequent changes are ignored unless they
            //    are for nested lists
            //
            lists: (function () {
                // Use a closure to hide a few variables.
                var any_list = "[*+-]|\\d+\\.",
                    bullet_list = /[*+-]/,
                    number_list = /\d+\./,
                    // Capture leading indent as it matters for determining nested lists.
                    is_list_re = new RegExp("^( {0,3})(" + any_list + ")[ \t]+"),
                    indent_re = "(?: {0,3}\\t| {4})";

                // TODO: Cache this regexp for certain depths.
                // Create a regexp suitable for matching an li for a given stack depth
                function regex_for_depth(depth) {

                    return new RegExp(
                        // m[1] = indent, m[2] = list_type
                        "(?:^(" + indent_re + "{0," + depth + "} {0,3})(" + any_list + ")\\s+)|" +
                        // m[3] = cont
                        "(^" + indent_re + "{0," + (depth - 1) + "}[ ]{0,4})"
                    );
                }

                function expand_tab(input) {
                    return input.replace(/ {0,3}\t/g, "    ");
                }

                // Add inline content `inline` to `li`. inline comes from processInline
                // so is an array of content
                function add(li, loose, inline, nl) {
                    if (loose) {
                        li.push(["para"].concat(inline));
                        return;
                    }
                    // Hmmm, should this be any block level element or just paras?
                    var add_to = li[li.length - 1] instanceof Array && li[li.length - 1][0] == "para"
                        ? li[li.length - 1]
                        : li;

                    // If there is already some content in this list, add the new line in
                    if (nl && li.length > 1) inline.unshift(nl);

                    for (var i = 0; i < inline.length; i++) {
                        var what = inline[i],
                            is_str = typeof what == "string";
                        if (is_str && add_to.length > 1 && typeof add_to[add_to.length - 1] == "string") {
                            add_to[add_to.length - 1] += what;
                        }
                        else {
                            add_to.push(what);
                        }
                    }
                }

                // contained means have an indent greater than the current one. On
                // *every* line in the block
                function get_contained_blocks(depth, blocks) {

                    var re = new RegExp("^(" + indent_re + "{" + depth + "}.*?\\n?)*$"),
                        replace = new RegExp("^" + indent_re + "{" + depth + "}", "gm"),
                        ret = [];

                    while (blocks.length > 0) {
                        if (re.exec(blocks[0])) {
                            var b = blocks.shift(),
                                // Now remove that indent
                                x = b.replace(replace, "");

                            ret.push(mk_block(x, b.trailing, b.lineNumber));
                        }
                        else {
                            break;
                        }
                    }
                    return ret;
                }

                // passed to stack.forEach to turn list items up the stack into paras
                function paragraphify(s, i, stack) {
                    var list = s.list;
                    var last_li = list[list.length - 1];

                    if (last_li[1] instanceof Array && last_li[1][0] == "para") {
                        return;
                    }
                    if (i + 1 == stack.length) {
                        // Last stack frame
                        // Keep the same array, but replace the contents
                        last_li.push(["para"].concat(last_li.splice(1, last_li.length - 1)));
                    }
                    else {
                        var sublist = last_li.pop();
                        last_li.push(["para"].concat(last_li.splice(1, last_li.length - 1)), sublist);
                    }
                }

                // The matcher function
                return function (block, next) {
                    var m = block.match(is_list_re);
                    if (!m) return undefined;

                    function make_list(m) {
                        var list = bullet_list.exec(m[2])
                            ? ["bulletlist"]
                            : ["numberlist"];

                        stack.push({list: list, indent: m[1]});
                        return list;
                    }


                    var stack = [], // Stack of lists for nesting.
                        list = make_list(m),
                        last_li,
                        loose = false,
                        ret = [stack[0].list],
                        i;

                    // Loop to search over block looking for inner block elements and loose lists
                    loose_search:
                        while (true) {
                            // Split into lines preserving new lines at end of line
                            var lines = block.split(/(?=\n)/);

                            // We have to grab all lines for a li and call processInline on them
                            // once as there are some inline things that can span lines.
                            var li_accumulate = "";

                            // Loop over the lines in this block looking for tight lists.
                            tight_search:
                                for (var line_no = 0; line_no < lines.length; line_no++) {
                                    var nl = "",
                                        l = lines[line_no].replace(/^\n/, function (n) {
                                            nl = n;
                                            return "";
                                        });

                                    // TODO: really should cache this
                                    var line_re = regex_for_depth(stack.length);

                                    m = l.match(line_re);
                                    //print( "line:", uneval(l), "\nline match:", uneval(m) );

                                    // We have a list item
                                    if (m[1] !== undefined) {
                                        // Process the previous list item, if any
                                        if (li_accumulate.length) {
                                            add(last_li, loose, this.processInline(li_accumulate), nl);
                                            // Loose mode will have been dealt with. Reset it
                                            loose = false;
                                            li_accumulate = "";
                                        }

                                        m[1] = expand_tab(m[1]);
                                        var wanted_depth = Math.floor(m[1].length / 4) + 1;
                                        //print( "want:", wanted_depth, "stack:", stack.length);
                                        if (wanted_depth > stack.length) {
                                            // Deep enough for a nested list outright
                                            //print ( "new nested list" );
                                            list = make_list(m);
                                            last_li.push(list);
                                            last_li = list[1] = ["listitem"];
                                        }
                                        else {
                                            // We aren't deep enough to be strictly a new level. This is
                                            // where Md.pl goes nuts. If the indent matches a level in the
                                            // stack, put it there, else put it one deeper then the
                                            // wanted_depth deserves.
                                            var found = false;
                                            for (i = 0; i < stack.length; i++) {
                                                if (stack[i].indent != m[1]) continue;
                                                list = stack[i].list;
                                                stack.splice(i + 1, stack.length - (i + 1));
                                                found = true;
                                                break;
                                            }

                                            if (!found) {
                                                //print("not found. l:", uneval(l));
                                                wanted_depth++;
                                                if (wanted_depth <= stack.length) {
                                                    stack.splice(wanted_depth, stack.length - wanted_depth);
                                                    //print("Desired depth now", wanted_depth, "stack:", stack.length);
                                                    list = stack[wanted_depth - 1].list;
                                                    //print("list:", uneval(list) );
                                                }
                                                else {
                                                    //print ("made new stack for messy indent");
                                                    list = make_list(m);
                                                    last_li.push(list);
                                                }
                                            }

                                            //print( uneval(list), "last", list === stack[stack.length-1].list );
                                            last_li = ["listitem"];
                                            list.push(last_li);
                                        } // end depth of shenegains
                                        nl = "";
                                    }

                                    // Add content
                                    if (l.length > m[0].length) {
                                        li_accumulate += nl + l.substr(m[0].length);
                                    }
                                } // tight_search

                            if (li_accumulate.length) {
                                add(last_li, loose, this.processInline(li_accumulate), nl);
                                // Loose mode will have been dealt with. Reset it
                                loose = false;
                                li_accumulate = "";
                            }

                            // Look at the next block - we might have a loose list. Or an extra
                            // paragraph for the current li
                            var contained = get_contained_blocks(stack.length, next);

                            // Deal with code blocks or properly nested lists
                            if (contained.length > 0) {
                                // Make sure all listitems up the stack are paragraphs
                                forEach(stack, paragraphify, this);

                                last_li.push.apply(last_li, this.toTree(contained, []));
                            }

                            var next_block = next[0] && next[0].valueOf() || "";

                            if (next_block.match(is_list_re) || next_block.match(/^ /)) {
                                block = next.shift();

                                // Check for an HR following a list: features/lists/hr_abutting
                                var hr = this.dialect.block.horizRule(block, next);

                                if (hr) {
                                    ret.push.apply(ret, hr);
                                    break;
                                }

                                // Make sure all listitems up the stack are paragraphs
                                forEach(stack, paragraphify, this);

                                loose = true;
                                continue loose_search;
                            }
                            break;
                        } // loose_search

                    return ret;
                };
            })(),

            blockquote: function blockquote(block, next) {
                if (!block.match(/^>/m))
                    return undefined;

                var jsonml = [];

                // separate out the leading abutting block, if any. I.e. in this case:
                //
                //  a
                //  > b
                //
                if (block[0] != ">") {
                    var lines = block.split(/\n/),
                        prev = [],
                        line_no = block.lineNumber;

                    // keep shifting lines until you find a crotchet
                    while (lines.length && lines[0][0] != ">") {
                        prev.push(lines.shift());
                        line_no++;
                    }

                    var abutting = mk_block(prev.join("\n"), "\n", block.lineNumber);
                    jsonml.push.apply(jsonml, this.processBlock(abutting, []));
                    // reassemble new block of just block quotes!
                    block = mk_block(lines.join("\n"), block.trailing, line_no);
                }


                // if the next block is also a blockquote merge it in
                while (next.length && next[0][0] == ">") {
                    var b = next.shift();
                    block = mk_block(block + block.trailing + b, b.trailing, block.lineNumber);
                }

                // Strip off the leading "> " and re-process as a block.
                var input = block.replace(/^> ?/gm, ""),
                    old_tree = this.tree,
                    processedBlock = this.toTree(input, ["blockquote"]),
                    attr = extract_attr(processedBlock);

                // If any link references were found get rid of them
                if (attr && attr.references) {
                    delete attr.references;
                    // And then remove the attribute object if it's empty
                    if (isEmpty(attr)) {
                        processedBlock.splice(1, 1);
                    }
                }

                jsonml.push(processedBlock);
                return jsonml;
            },

            referenceDefn: function referenceDefn(block, next) {
                var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
                // interesting matches are [ , ref_id, url, , title, title ]

                if (!block.match(re))
                    return undefined;

                // make an attribute node if it doesn't exist
                if (!extract_attr(this.tree)) {
                    this.tree.splice(1, 0, {});
                }

                var attrs = extract_attr(this.tree);

                // make a references hash if it doesn't exist
                if (attrs.references === undefined) {
                    attrs.references = {};
                }

                var b = this.loop_re_over_block(re, block, function (m) {

                    if (m[2] && m[2][0] == "<" && m[2][m[2].length - 1] == ">")
                        m[2] = m[2].substring(1, m[2].length - 1);

                    var ref = attrs.references[m[1].toLowerCase()] = {
                        href: m[2]
                    };

                    if (m[4] !== undefined)
                        ref.title = m[4];
                    else if (m[5] !== undefined)
                        ref.title = m[5];

                });

                if (b.length)
                    next.unshift(mk_block(b, block.trailing));

                return [];
            },

            para: function para(block, next) {
                // everything's a para!
                return [["para"].concat(this.processInline(block))];
            }
        }
    };

    Markdown.dialects.Gruber.inline = {

        __oneElement__: function oneElement(text, patterns_or_re, previous_nodes) {
            var m,
                res,
                lastIndex = 0;

            patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
            var re = new RegExp("([\\s\\S]*?)(" + (patterns_or_re.source || patterns_or_re) + ")");

            m = re.exec(text);
            if (!m) {
                // Just boring text
                return [text.length, text];
            }
            else if (m[1]) {
                // Some un-interesting text matched. Return that first
                return [m[1].length, m[1]];
            }

            var res;
            if (m[2] in this.dialect.inline) {
                res = this.dialect.inline[m[2]].call(
                    this,
                    text.substr(m.index), m, previous_nodes || []);
            }
            // Default for now to make dev easier. just slurp special and output it.
            res = res || [m[2].length, m[2]];
            return res;
        },

        __call__: function inline(text, patterns) {

            var out = [],
                res;

            function add(x) {
                //D:self.debug("  adding output", uneval(x));
                if (typeof x == "string" && typeof out[out.length - 1] == "string")
                    out[out.length - 1] += x;
                else
                    out.push(x);
            }

            while (text.length > 0) {
                res = this.dialect.inline.__oneElement__.call(this, text, patterns, out);
                text = text.substr(res.shift());
                forEach(res, add)
            }

            return out;
        },

        // These characters are intersting elsewhere, so have rules for them so that
        // chunks of plain text blocks don't include them
        "]": function () {
        },
        "}": function () {
        },

        __escape__: /^\\[\\`\*_{}\[\]()#\+.!\-]/,

        "\\": function escaped(text) {
            // [ length of input processed, node/children to add... ]
            // Only esacape: \ ` * _ { } [ ] ( ) # * + - . !
            if (this.dialect.inline.__escape__.exec(text))
                return [2, text.charAt(1)];
            else
            // Not an esacpe
                return [1, "\\"];
        },

        "![": function image(text) {

            // Unlike images, alt text is plain text only. no other elements are
            // allowed in there

            // ![Alt text](/path/to/img.jpg "Optional title")
            //      1          2            3       4         <--- captures
            var m = text.match(/^!\[(.*?)\][ \t]*\([ \t]*([^")]*?)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/);

            if (m) {
                if (m[2] && m[2][0] == "<" && m[2][m[2].length - 1] == ">")
                    m[2] = m[2].substring(1, m[2].length - 1);

                m[2] = this.dialect.inline.__call__.call(this, m[2], /\\/)[0];

                var attrs = {alt: m[1], href: m[2] || ""};
                if (m[4] !== undefined)
                    attrs.title = m[4];

                return [m[0].length, ["img", attrs]];
            }

            // ![Alt text][id]
            m = text.match(/^!\[(.*?)\][ \t]*\[(.*?)\]/);

            if (m) {
                // We can't check if the reference is known here as it likely wont be
                // found till after. Check it in md tree->hmtl tree conversion
                return [m[0].length, ["img_ref", {alt: m[1], ref: m[2].toLowerCase(), original: m[0]}]];
            }

            // Just consume the '!['
            return [2, "!["];
        },

        "[": function link(text) {

            var orig = String(text);
            // Inline content is possible inside `link text`
            var res = Markdown.DialectHelpers.inline_until_char.call(this, text.substr(1), "]");

            // No closing ']' found. Just consume the [
            if (!res) return [1, "["];

            var consumed = 1 + res[0],
                children = res[1],
                link,
                attrs;

            // At this point the first [...] has been parsed. See what follows to find
            // out which kind of link we are (reference or direct url)
            text = text.substr(consumed);

            // [link text](/path/to/img.jpg "Optional title")
            //                 1            2       3         <--- captures
            // This will capture up to the last paren in the block. We then pull
            // back based on if there a matching ones in the url
            //    ([here](/url/(test))
            // The parens have to be balanced
            var m = text.match(/^\s*\([ \t]*([^"']*)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/);
            if (m) {
                var url = m[1];
                consumed += m[0].length;

                if (url && url[0] == "<" && url[url.length - 1] == ">")
                    url = url.substring(1, url.length - 1);

                // If there is a title we don't have to worry about parens in the url
                if (!m[3]) {
                    var open_parens = 1; // One open that isn't in the capture
                    for (var len = 0; len < url.length; len++) {
                        switch (url[len]) {
                            case "(":
                                open_parens++;
                                break;
                            case ")":
                                if (--open_parens == 0) {
                                    consumed -= url.length - len;
                                    url = url.substring(0, len);
                                }
                                break;
                        }
                    }
                }

                // Process escapes only
                url = this.dialect.inline.__call__.call(this, url, /\\/)[0];

                attrs = {href: url || ""};
                if (m[3] !== undefined)
                    attrs.title = m[3];

                link = ["link", attrs].concat(children);
                return [consumed, link];
            }

            // [Alt text][id]
            // [Alt text] [id]
            m = text.match(/^\s*\[(.*?)\]/);

            if (m) {

                consumed += m[0].length;

                // [links][] uses links as its reference
                attrs = {ref: (m[1] || String(children)).toLowerCase(), original: orig.substr(0, consumed)};

                link = ["link_ref", attrs].concat(children);

                // We can't check if the reference is known here as it likely wont be
                // found till after. Check it in md tree->hmtl tree conversion.
                // Store the original so that conversion can revert if the ref isn't found.
                return [consumed, link];
            }

            // [id]
            // Only if id is plain (no formatting.)
            if (children.length == 1 && typeof children[0] == "string") {

                attrs = {ref: children[0].toLowerCase(), original: orig.substr(0, consumed)};
                link = ["link_ref", attrs, children[0]];
                return [consumed, link];
            }

            // Just consume the "["
            return [1, "["];
        },


        "<": function autoLink(text) {
            var m;

            if ((m = text.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/)) != null) {
                if (m[3]) {
                    return [m[0].length, ["link", {href: "mailto:" + m[3]}, m[3]]];

                }
                else if (m[2] == "mailto") {
                    return [m[0].length, ["link", {href: m[1]}, m[1].substr("mailto:".length)]];
                }
                else
                    return [m[0].length, ["link", {href: m[1]}, m[1]]];
            }

            return [1, "<"];
        },

        "`": function inlineCode(text) {
            // Inline code block. as many backticks as you like to start it
            // Always skip over the opening ticks.
            var m = text.match(/(`+)(([\s\S]*?)\1)/);

            if (m && m[2])
                return [m[1].length + m[2].length, ["inlinecode", m[3]]];
            else {
                // TODO: No matching end code found - warn!
                return [1, "`"];
            }
        },

        "  \n": function lineBreak(text) {
            return [3, ["linebreak"]];
        }

    };

// Meta Helper/generator method for em and strong handling
    function strong_em(tag, md) {

        var state_slot = tag + "_state",
            other_slot = tag == "strong" ? "em_state" : "strong_state";

        function CloseTag(len) {
            this.len_after = len;
            this.name = "close_" + md;
        }

        return function (text, orig_match) {

            if (this[state_slot][0] == md) {
                // Most recent em is of this type
                //D:this.debug("closing", md);
                this[state_slot].shift();

                // "Consume" everything to go back to the recrusion in the else-block below
                return [text.length, new CloseTag(text.length - md.length)];
            }
            else {
                // Store a clone of the em/strong states
                var other = this[other_slot].slice(),
                    state = this[state_slot].slice();

                this[state_slot].unshift(md);

                //D:this.debug_indent += "  ";

                // Recurse
                var res = this.processInline(text.substr(md.length));
                //D:this.debug_indent = this.debug_indent.substr(2);

                var last = res[res.length - 1];

                //D:this.debug("processInline from", tag + ": ", uneval( res ) );

                var check = this[state_slot].shift();
                if (last instanceof CloseTag) {
                    res.pop();
                    // We matched! Huzzah.
                    var consumed = text.length - last.len_after;
                    return [consumed, [tag].concat(res)];
                }
                else {
                    // Restore the state of the other kind. We might have mistakenly closed it.
                    this[other_slot] = other;
                    this[state_slot] = state;

                    // We can't reuse the processed result as it could have wrong parsing contexts in it.
                    return [md.length, md];
                }
            }
        }; // End returned function
    }

    Markdown.dialects.Gruber.inline["**"] = strong_em("strong", "**");
    Markdown.dialects.Gruber.inline["__"] = strong_em("strong", "__");
    Markdown.dialects.Gruber.inline["*"] = strong_em("em", "*");
    Markdown.dialects.Gruber.inline["_"] = strong_em("em", "_");


// Build default order from insertion order.
    Markdown.buildBlockOrder = function (d) {
        var ord = [];
        for (var i in d) {
            if (i == "__order__" || i == "__call__") continue;
            ord.push(i);
        }
        d.__order__ = ord;
    };

// Build patterns for inline matcher
    Markdown.buildInlinePatterns = function (d) {
        var patterns = [];

        for (var i in d) {
            // __foo__ is reserved and not a pattern
            if (i.match(/^__.*__$/)) continue;
            var l = i.replace(/([\\.*+?|()\[\]{}])/g, "\\$1")
                .replace(/\n/, "\\n");
            patterns.push(i.length == 1 ? l : "(?:" + l + ")");
        }

        patterns = patterns.join("|");
        d.__patterns__ = patterns;
        //print("patterns:", uneval( patterns ) );

        var fn = d.__call__;
        d.__call__ = function (text, pattern) {
            if (pattern != undefined) {
                return fn.call(this, text, pattern);
            }
            else {
                return fn.call(this, text, patterns);
            }
        };
    };

    Markdown.DialectHelpers = {};
    Markdown.DialectHelpers.inline_until_char = function (text, want) {
        var consumed = 0,
            nodes = [];

        while (true) {
            if (text.charAt(consumed) == want) {
                // Found the character we were looking for
                consumed++;
                return [consumed, nodes];
            }

            if (consumed >= text.length) {
                // No closing char found. Abort.
                return null;
            }

            var res = this.dialect.inline.__oneElement__.call(this, text.substr(consumed));
            consumed += res[0];
            // Add any returned nodes.
            nodes.push.apply(nodes, res.slice(1));
        }
    }

// Helper function to make sub-classing a dialect easier
    Markdown.subclassDialect = function (d) {
        function Block() {
        }

        Block.prototype = d.block;

        function Inline() {
        }

        Inline.prototype = d.inline;

        return {block: new Block(), inline: new Inline()};
    };

    Markdown.buildBlockOrder(Markdown.dialects.Gruber.block);
    Markdown.buildInlinePatterns(Markdown.dialects.Gruber.inline);

    Markdown.dialects.Maruku = Markdown.subclassDialect(Markdown.dialects.Gruber);

    Markdown.dialects.Maruku.processMetaHash = function processMetaHash(meta_string) {
        var meta = split_meta_hash(meta_string),
            attr = {};

        for (var i = 0; i < meta.length; ++i) {
            // id: #foo
            if (/^#/.test(meta[i])) {
                attr.id = meta[i].substring(1);
            }
            // class: .foo
            else if (/^\./.test(meta[i])) {
                // if class already exists, append the new one
                if (attr["class"]) {
                    attr["class"] = attr["class"] + meta[i].replace(/./, " ");
                }
                else {
                    attr["class"] = meta[i].substring(1);
                }
            }
            // attribute: foo=bar
            else if (/\=/.test(meta[i])) {
                var s = meta[i].split(/\=/);
                attr[s[0]] = s[1];
            }
        }

        return attr;
    }

    function split_meta_hash(meta_string) {
        var meta = meta_string.split(""),
            parts = [""],
            in_quotes = false;

        while (meta.length) {
            var letter = meta.shift();
            switch (letter) {
                case " " :
                    // if we're in a quoted section, keep it
                    if (in_quotes) {
                        parts[parts.length - 1] += letter;
                    }
                    // otherwise make a new part
                    else {
                        parts.push("");
                    }
                    break;
                case "'" :
                case '"' :
                    // reverse the quotes and move straight on
                    in_quotes = !in_quotes;
                    break;
                case "\\" :
                    // shift off the next letter to be used straight away.
                    // it was escaped so we'll keep it whatever it is
                    letter = meta.shift();
                default :
                    parts[parts.length - 1] += letter;
                    break;
            }
        }

        return parts;
    }

    Markdown.dialects.Maruku.block.document_meta = function document_meta(block, next) {
        // we're only interested in the first block
        if (block.lineNumber > 1) return undefined;

        // document_meta blocks consist of one or more lines of `Key: Value\n`
        if (!block.match(/^(?:\w+:.*\n)*\w+:.*$/)) return undefined;

        // make an attribute node if it doesn't exist
        if (!extract_attr(this.tree)) {
            this.tree.splice(1, 0, {});
        }

        var pairs = block.split(/\n/);
        for (p in pairs) {
            var m = pairs[p].match(/(\w+):\s*(.*)$/),
                key = m[1].toLowerCase(),
                value = m[2];

            this.tree[1][key] = value;
        }

        // document_meta produces no content!
        return [];
    };

    Markdown.dialects.Maruku.block.block_meta = function block_meta(block, next) {
        // check if the last line of the block is an meta hash
        var m = block.match(/(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/);
        if (!m) return undefined;

        // process the meta hash
        var attr = this.dialect.processMetaHash(m[2]);

        var hash;

        // if we matched ^ then we need to apply meta to the previous block
        if (m[1] === "") {
            var node = this.tree[this.tree.length - 1];
            hash = extract_attr(node);

            // if the node is a string (rather than JsonML), bail
            if (typeof node === "string") return undefined;

            // create the attribute hash if it doesn't exist
            if (!hash) {
                hash = {};
                node.splice(1, 0, hash);
            }

            // add the attributes in
            for (a in attr) {
                hash[a] = attr[a];
            }

            // return nothing so the meta hash is removed
            return [];
        }

        // pull the meta hash off the block and process what's left
        var b = block.replace(/\n.*$/, ""),
            result = this.processBlock(b, []);

        // get or make the attributes hash
        hash = extract_attr(result[0]);
        if (!hash) {
            hash = {};
            result[0].splice(1, 0, hash);
        }

        // attach the attributes to the block
        for (a in attr) {
            hash[a] = attr[a];
        }

        return result;
    };

    Markdown.dialects.Maruku.block.definition_list = function definition_list(block, next) {
        // one or more terms followed by one or more definitions, in a single block
        var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/,
            list = ["dl"],
            i, m;

        // see if we're dealing with a tight or loose block
        if ((m = block.match(tight))) {
            // pull subsequent tight DL blocks out of `next`
            var blocks = [block];
            while (next.length && tight.exec(next[0])) {
                blocks.push(next.shift());
            }

            for (var b = 0; b < blocks.length; ++b) {
                var m = blocks[b].match(tight),
                    terms = m[1].replace(/\n$/, "").split(/\n/),
                    defns = m[2].split(/\n:\s+/);

                // print( uneval( m ) );

                for (i = 0; i < terms.length; ++i) {
                    list.push(["dt", terms[i]]);
                }

                for (i = 0; i < defns.length; ++i) {
                    // run inline processing over the definition
                    list.push(["dd"].concat(this.processInline(defns[i].replace(/(\n)\s+/, "$1"))));
                }
            }
        }
        else {
            return undefined;
        }

        return [list];
    };

// splits on unescaped instances of @ch. If @ch is not a character the result
// can be unpredictable

    Markdown.dialects.Maruku.block.table = function table(block, next) {

        var _split_on_unescaped = function (s, ch) {
            ch = ch || '\\s';
            if (ch.match(/^[\\|\[\]{}?*.+^$]$/)) {
                ch = '\\' + ch;
            }
            var res = [],
                r = new RegExp('^((?:\\\\.|[^\\\\' + ch + '])*)' + ch + '(.*)'),
                m;
            while (m = s.match(r)) {
                res.push(m[1]);
                s = m[2];
            }
            res.push(s);
            return res;
        }

        var leading_pipe = /^ {0,3}\|(.+)\n {0,3}\|\s*([\-:]+[\-| :]*)\n((?:\s*\|.*(?:\n|$))*)(?=\n|$)/,
            // find at least an unescaped pipe in each line
            no_leading_pipe = /^ {0,3}(\S(?:\\.|[^\\|])*\|.*)\n {0,3}([\-:]+\s*\|[\-| :]*)\n((?:(?:\\.|[^\\|])*\|.*(?:\n|$))*)(?=\n|$)/,
            i, m;
        if (m = block.match(leading_pipe)) {
            // remove leading pipes in contents
            // (header and horizontal rule already have the leading pipe left out)
            m[3] = m[3].replace(/^\s*\|/gm, '');
        } else if (!(m = block.match(no_leading_pipe))) {
            return undefined;
        }

        var table = ["table", ["thead", ["tr"]], ["tbody"]];

        // remove trailing pipes, then split on pipes
        // (no escaped pipes are allowed in horizontal rule)
        m[2] = m[2].replace(/\|\s*$/, '').split('|');

        // process alignment
        var html_attrs = [];
        forEach(m[2], function (s) {
            if (s.match(/^\s*-+:\s*$/)) html_attrs.push({align: "right"});
            else if (s.match(/^\s*:-+\s*$/)) html_attrs.push({align: "left"});
            else if (s.match(/^\s*:-+:\s*$/)) html_attrs.push({align: "center"});
            else html_attrs.push({});
        });

        // now for the header, avoid escaped pipes
        m[1] = _split_on_unescaped(m[1].replace(/\|\s*$/, ''), '|');
        for (i = 0; i < m[1].length; i++) {
            table[1][1].push(['th', html_attrs[i] || {}].concat(
                this.processInline(m[1][i].trim())));
        }

        // now for body contents
        forEach(m[3].replace(/\|\s*$/mg, '').split('\n'), function (row) {
            var html_row = ['tr'];
            row = _split_on_unescaped(row, '|');
            for (i = 0; i < row.length; i++) {
                html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));
            }
            table[2].push(html_row);
        }, this);

        return [table];
    }

    Markdown.dialects.Maruku.inline["{:"] = function inline_meta(text, matches, out) {
        if (!out.length) {
            return [2, "{:"];
        }

        // get the preceeding element
        var before = out[out.length - 1];

        if (typeof before === "string") {
            return [2, "{:"];
        }

        // match a meta hash
        var m = text.match(/^\{:\s*((?:\\\}|[^\}])*)\s*\}/);

        // no match, false alarm
        if (!m) {
            return [2, "{:"];
        }

        // attach the attributes to the preceeding element
        var meta = this.dialect.processMetaHash(m[1]),
            attr = extract_attr(before);

        if (!attr) {
            attr = {};
            before.splice(1, 0, attr);
        }

        for (var k in meta) {
            attr[k] = meta[k];
        }

        // cut out the string and replace it with nothing
        return [m[0].length, ""];
    };

    Markdown.dialects.Maruku.inline.__escape__ = /^\\[\\`\*_{}\[\]()#\+.!\-|:]/;

    Markdown.buildBlockOrder(Markdown.dialects.Maruku.block);
    Markdown.buildInlinePatterns(Markdown.dialects.Maruku.inline);

    var isArray = Array.isArray || function (obj) {
        return Object.prototype.toString.call(obj) == "[object Array]";
    };

    var forEach;
// Don't mess with Array.prototype. Its not friendly
    if (Array.prototype.forEach) {
        forEach = function (arr, cb, thisp) {
            return arr.forEach(cb, thisp);
        };
    }
    else {
        forEach = function (arr, cb, thisp) {
            for (var i = 0; i < arr.length; i++) {
                cb.call(thisp || arr, arr[i], i, arr);
            }
        }
    }

    var isEmpty = function (obj) {
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }

        return true;
    }

    function extract_attr(jsonml) {
        return isArray(jsonml)
        && jsonml.length > 1
        && typeof jsonml[1] === "object"
        && !(isArray(jsonml[1]))
            ? jsonml[1]
            : undefined;
    }


    /**
     *  renderJsonML( jsonml[, options] ) -> String
     *  - jsonml (Array): JsonML array to render to XML
     *  - options (Object): options
     *
     *  Converts the given JsonML into well-formed XML.
     *
     *  The options currently understood are:
     *
     *  - root (Boolean): wether or not the root node should be included in the
     *    output, or just its children. The default `false` is to not include the
     *    root itself.
     */
    expose.renderJsonML = function (jsonml, options) {
        options = options || {};
        // include the root element in the rendered output?
        options.root = options.root || false;

        var content = [];

        if (options.root) {
            content.push(render_tree(jsonml));
        }
        else {
            jsonml.shift(); // get rid of the tag
            if (jsonml.length && typeof jsonml[0] === "object" && !(jsonml[0] instanceof Array)) {
                jsonml.shift(); // get rid of the attributes
            }

            while (jsonml.length) {
                content.push(render_tree(jsonml.shift()));
            }
        }

        return content.join("\n\n");
    };

    function escapeHTML(text) {
        return text.replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }

    function render_tree(jsonml) {
        // basic case
        if (typeof jsonml === "string") {
            return escapeHTML(jsonml);
        }

        var tag = jsonml.shift(),
            attributes = {},
            content = [];

        if (jsonml.length && typeof jsonml[0] === "object" && !(jsonml[0] instanceof Array)) {
            attributes = jsonml.shift();
        }

        while (jsonml.length) {
            content.push(render_tree(jsonml.shift()));
        }

        var tag_attrs = "";
        for (var a in attributes) {
            tag_attrs += " " + a + '="' + escapeHTML(attributes[a]) + '"';
        }

        // be careful about adding whitespace here for inline elements
        if (tag == "img" || tag == "br" || tag == "hr") {
            return "<" + tag + tag_attrs + "/>";
        }
        else {
            return "<" + tag + tag_attrs + ">" + content.join("") + "</" + tag + ">";
        }
    }

    function convert_tree_to_html(tree, references, options) {
        var i;
        options = options || {};

        // shallow clone
        var jsonml = tree.slice(0);

        if (typeof options.preprocessTreeNode === "function") {
            jsonml = options.preprocessTreeNode(jsonml, references);
        }

        // Clone attributes if they exist
        var attrs = extract_attr(jsonml);
        if (attrs) {
            jsonml[1] = {};
            for (i in attrs) {
                jsonml[1][i] = attrs[i];
            }
            attrs = jsonml[1];
        }

        // basic case
        if (typeof jsonml === "string") {
            return jsonml;
        }

        // convert this node
        switch (jsonml[0]) {
            case "header":
                jsonml[0] = "h" + jsonml[1].level;
                delete jsonml[1].level;
                break;
            case "bulletlist":
                jsonml[0] = "ul";
                break;
            case "numberlist":
                jsonml[0] = "ol";
                break;
            case "listitem":
                jsonml[0] = "li";
                break;
            case "para":
                jsonml[0] = "p";
                break;
            case "markdown":
                jsonml[0] = "html";
                if (attrs) delete attrs.references;
                break;
            case "code_block":
                jsonml[0] = "pre";
                i = attrs ? 2 : 1;
                var code = ["code"];
                code.push.apply(code, jsonml.splice(i, jsonml.length - i));
                jsonml[i] = code;
                break;
            case "inlinecode":
                jsonml[0] = "code";
                break;
            case "img":
                jsonml[1].src = jsonml[1].href;
                delete jsonml[1].href;
                break;
            case "linebreak":
                jsonml[0] = "br";
                break;
            case "link":
                jsonml[0] = "a";
                break;
            case "link_ref":
                jsonml[0] = "a";

                // grab this ref and clean up the attribute node
                var ref = references[attrs.ref];

                // if the reference exists, make the link
                if (ref) {
                    delete attrs.ref;

                    // add in the href and title, if present
                    attrs.href = ref.href;
                    if (ref.title) {
                        attrs.title = ref.title;
                    }

                    // get rid of the unneeded original text
                    delete attrs.original;
                }
                // the reference doesn't exist, so revert to plain text
                else {
                    return attrs.original;
                }
                break;
            case "img_ref":
                jsonml[0] = "img";

                // grab this ref and clean up the attribute node
                var ref = references[attrs.ref];

                // if the reference exists, make the link
                if (ref) {
                    delete attrs.ref;

                    // add in the href and title, if present
                    attrs.src = ref.href;
                    if (ref.title) {
                        attrs.title = ref.title;
                    }

                    // get rid of the unneeded original text
                    delete attrs.original;
                }
                // the reference doesn't exist, so revert to plain text
                else {
                    return attrs.original;
                }
                break;
        }

        // convert all the children
        i = 1;

        // deal with the attribute node, if it exists
        if (attrs) {
            // if there are keys, skip over it
            for (var key in jsonml[1]) {
                i = 2;
                break;
            }
            // if there aren't, remove it
            if (i === 1) {
                jsonml.splice(i, 1);
            }
        }

        for (; i < jsonml.length; ++i) {
            jsonml[i] = convert_tree_to_html(jsonml[i], references, options);
        }

        return jsonml;
    }


// merges adjacent text nodes into a single node
    function merge_text_nodes(jsonml) {
        // skip the tag name and attribute hash
        var i = extract_attr(jsonml) ? 2 : 1;

        while (i < jsonml.length) {
            // if it's a string check the next item too
            if (typeof jsonml[i] === "string") {
                if (i + 1 < jsonml.length && typeof jsonml[i + 1] === "string") {
                    // merge the second string into the first and remove it
                    jsonml[i] += jsonml.splice(i + 1, 1)[0];
                }
                else {
                    ++i;
                }
            }
            // if it's not a string recurse
            else {
                merge_text_nodes(jsonml[i]);
                ++i;
            }
        }
    }

})((function () {
    if (typeof exports === "undefined") {
        window.markdown = {};
        return window.markdown;
    }
    else {
        return exports;
    }
})());

/* ===================================================
 * bootstrap-markdown.js v2.10.0
 * http://github.com/toopay/bootstrap-markdown
 * ===================================================
 * Copyright 2013-2016 Taufan Aditya
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */

(function (factory) {
    if (typeof define === "function" && define.amd) {
        //RequireJS
        define(["jquery"], factory);
    } else if (typeof exports === 'object') {
        //Backbone.js
        factory(require('jquery'));
    } else {
        //Jquery plugin
        factory(jQuery);
    }
}(function ($) {
    "use strict"; // jshint ;_;

    /* MARKDOWN CLASS DEFINITION
   * ========================== */

    var Markdown = function (element, options) {
        // @TODO : remove this BC on next major release
        // @see : https://github.com/toopay/bootstrap-markdown/issues/109
        var opts = ['autofocus', 'savable', 'hideable', 'width',
            'height', 'resize', 'iconlibrary', 'language',
            'footer', 'fullscreen', 'hiddenButtons', 'disabledButtons'];
        $.each(opts, function (_, opt) {
            if (typeof $(element).data(opt) !== 'undefined') {
                options = typeof options == 'object' ? options : {}
                options[opt] = $(element).data(opt)
            }
        });
        // End BC

        // Class Properties
        this.$ns = 'bootstrap-markdown';
        this.$element = $(element);
        this.$editable = {el: null, type: null, attrKeys: [], attrValues: [], content: null};
        this.$options = $.extend(true, {}, $.fn.markdown.defaults, options, this.$element.data('options'));
        this.$oldContent = null;
        this.$isPreview = false;
        this.$isFullscreen = false;
        this.$editor = null;
        this.$textarea = null;
        this.$handler = [];
        this.$callback = [];
        this.$nextTab = [];

        this.showEditor();
    };

    Markdown.prototype = {

        constructor: Markdown

        , __alterButtons: function (name, alter) {
            var handler = this.$handler, isAll = (name == 'all'), that = this;

            $.each(handler, function (k, v) {
                var halt = true;
                if (isAll) {
                    halt = false;
                } else {
                    halt = v.indexOf(name) < 0;
                }

                if (halt === false) {
                    alter(that.$editor.find('button[data-handler="' + v + '"]'));
                }
            });
        }

        , __buildButtons: function (buttonsArray, container) {
            var i,
                ns = this.$ns,
                handler = this.$handler,
                callback = this.$callback;

            for (i = 0; i < buttonsArray.length; i++) {
                // Build each group container
                var y, btnGroups = buttonsArray[i];
                for (y = 0; y < btnGroups.length; y++) {
                    // Build each button group
                    var z,
                        buttons = btnGroups[y].data,
                        btnGroupContainer = $('<div/>', {
                            'class': 'btn-group'
                        });

                    for (z = 0; z < buttons.length; z++) {
                        var button = buttons[z],
                            buttonContainer, buttonIconContainer,
                            buttonHandler = ns + '-' + button.name,
                            buttonIcon = this.__getIcon(button.icon),
                            btnText = button.btnText ? button.btnText : '',
                            btnClass = button.btnClass ? button.btnClass : 'btn',
                            tabIndex = button.tabIndex ? button.tabIndex : '-1',
                            hotkey = typeof button.hotkey !== 'undefined' ? button.hotkey : '',
                            hotkeyCaption = typeof jQuery.hotkeys !== 'undefined' && hotkey !== '' ? ' (' + hotkey + ')' : '';

                        // Construct the button object
                        buttonContainer = $('<button></button>');
                        buttonContainer.text(' ' + this.__localize(btnText)).addClass('btn-default btn-sm').addClass(btnClass);
                        if (btnClass.match(/btn\-(primary|success|info|warning|danger|link)/)) {
                            buttonContainer.removeClass('btn-default');
                        }
                        buttonContainer.attr({
                            'type': 'button',
                            'title': this.__localize(button.title) + hotkeyCaption,
                            'tabindex': tabIndex,
                            'data-provider': ns,
                            'data-handler': buttonHandler,
                            'data-hotkey': hotkey
                        });
                        if (button.toggle === true) {
                            buttonContainer.attr('data-toggle', 'button');
                        }
                        buttonIconContainer = $('<span/>');
                        buttonIconContainer.addClass(buttonIcon);
                        buttonIconContainer.prependTo(buttonContainer);

                        // Attach the button object
                        btnGroupContainer.append(buttonContainer);

                        // Register handler and callback
                        handler.push(buttonHandler);
                        callback.push(button.callback);
                    }

                    // Attach the button group into container dom
                    container.append(btnGroupContainer);
                }
            }

            return container;
        }
        , __setListener: function () {
            // Set size and resizable Properties
            var hasRows = typeof this.$textarea.attr('rows') !== 'undefined',
                maxRows = this.$textarea.val().split("\n").length > 5 ? this.$textarea.val().split("\n").length : '5',
                rowsVal = hasRows ? this.$textarea.attr('rows') : maxRows;

            this.$textarea.attr('rows', rowsVal);
            if (this.$options.resize) {
                this.$textarea.css('resize', this.$options.resize);
            }

            this.$textarea.on({
                'focus': $.proxy(this.focus, this),
                'keyup': $.proxy(this.keyup, this),
                'change': $.proxy(this.change, this),
                'select': $.proxy(this.select, this)
            });

            if (this.eventSupported('keydown')) {
                this.$textarea.on('keydown', $.proxy(this.keydown, this));
            }

            if (this.eventSupported('keypress')) {
                this.$textarea.on('keypress', $.proxy(this.keypress, this))
            }

            // Re-attach markdown data
            this.$textarea.data('markdown', this);
        }

        , __handle: function (e) {
            var target = $(e.currentTarget),
                handler = this.$handler,
                callback = this.$callback,
                handlerName = target.attr('data-handler'),
                callbackIndex = handler.indexOf(handlerName),
                callbackHandler = callback[callbackIndex];

            // Trigger the focusin
            $(e.currentTarget).focus();

            callbackHandler(this);

            // Trigger onChange for each button handle
            this.change(this);

            // Unless it was the save handler,
            // focusin the textarea
            if (handlerName.indexOf('cmdSave') < 0) {
                this.$textarea.focus();
            }

            e.preventDefault();
        }

        , __localize: function (string) {
            var messages = $.fn.markdown.messages,
                language = this.$options.language;
            if (
                typeof messages !== 'undefined' &&
                typeof messages[language] !== 'undefined' &&
                typeof messages[language][string] !== 'undefined'
            ) {
                return messages[language][string];
            }
            return string;
        }

        , __getIcon: function (src) {
            return typeof src == 'object' ? src[this.$options.iconlibrary] : src;
        }

        , setFullscreen: function (mode) {
            var $editor = this.$editor,
                $textarea = this.$textarea;

            if (mode === true) {
                $editor.addClass('md-fullscreen-mode');
                $('body').addClass('md-nooverflow');
                this.$options.onFullscreen(this);
            } else {
                $editor.removeClass('md-fullscreen-mode');
                $('body').removeClass('md-nooverflow');

                if (this.$isPreview == true) this.hidePreview().showPreview()
            }

            this.$isFullscreen = mode;
            $textarea.focus();
        }

        , showEditor: function () {
            var instance = this,
                textarea,
                ns = this.$ns,
                container = this.$element,
                originalHeigth = container.css('height'),
                originalWidth = container.css('width'),
                editable = this.$editable,
                handler = this.$handler,
                callback = this.$callback,
                options = this.$options,
                editor = $('<div/>', {
                    'class': 'md-editor',
                    click: function () {
                        instance.focus();
                    }
                });

            // Prepare the editor
            if (this.$editor === null) {
                // Create the panel
                var editorHeader = $('<div/>', {
                    'class': 'md-header btn-toolbar'
                });

                // Merge the main & additional button groups together
                var allBtnGroups = [];
                if (options.buttons.length > 0) allBtnGroups = allBtnGroups.concat(options.buttons[0]);
                if (options.additionalButtons.length > 0) {
                    // iterate the additional button groups
                    $.each(options.additionalButtons[0], function (idx, buttonGroup) {

                        // see if the group name of the addional group matches an existing group
                        var matchingGroups = $.grep(allBtnGroups, function (allButtonGroup, allIdx) {
                            return allButtonGroup.name === buttonGroup.name;
                        });

                        // if it matches add the addional buttons to that group, if not just add it to the all buttons group
                        if (matchingGroups.length > 0) {
                            matchingGroups[0].data = matchingGroups[0].data.concat(buttonGroup.data);
                        } else {
                            allBtnGroups.push(options.additionalButtons[0][idx]);
                        }

                    });
                }

                // Reduce and/or reorder the button groups
                if (options.reorderButtonGroups.length > 0) {
                    allBtnGroups = allBtnGroups
                        .filter(function (btnGroup) {
                            return options.reorderButtonGroups.indexOf(btnGroup.name) > -1;
                        })
                        .sort(function (a, b) {
                            if (options.reorderButtonGroups.indexOf(a.name) < options.reorderButtonGroups.indexOf(b.name)) return -1;
                            if (options.reorderButtonGroups.indexOf(a.name) > options.reorderButtonGroups.indexOf(b.name)) return 1;
                            return 0;
                        });
                }

                // Build the buttons
                if (allBtnGroups.length > 0) {
                    editorHeader = this.__buildButtons([allBtnGroups], editorHeader);
                }

                if (options.fullscreen.enable) {
                    editorHeader.append('<div class="md-controls"><a class="md-control md-control-fullscreen" href="#"><span class="' + this.__getIcon(options.fullscreen.icons.fullscreenOn) + '"></span></a></div>').on('click', '.md-control-fullscreen', function (e) {
                        e.preventDefault();
                        instance.setFullscreen(true);
                    });
                }

                editor.append(editorHeader);

                // Wrap the textarea
                if (container.is('textarea')) {
                    container.before(editor);
                    textarea = container;
                    textarea.addClass('md-input');
                    editor.append(textarea);
                } else {
                    var rawContent = (typeof toMarkdown == 'function') ? toMarkdown(container.html()) : container.html(),
                        currentContent = $.trim(rawContent);

                    // This is some arbitrary content that could be edited
                    textarea = $('<textarea/>', {
                        'class': 'md-input',
                        'val': currentContent
                    });

                    editor.append(textarea);

                    // Save the editable
                    editable.el = container;
                    editable.type = container.prop('tagName').toLowerCase();
                    editable.content = container.html();

                    $(container[0].attributes).each(function () {
                        editable.attrKeys.push(this.nodeName);
                        editable.attrValues.push(this.nodeValue);
                    });

                    // Set editor to blocked the original container
                    container.replaceWith(editor);
                }

                var editorFooter = $('<div/>', {
                        'class': 'md-footer'
                    }),
                    createFooter = false,
                    footer = '';
                // Create the footer if savable
                if (options.savable) {
                    createFooter = true;
                    var saveHandler = 'cmdSave';

                    // Register handler and callback
                    handler.push(saveHandler);
                    callback.push(options.onSave);

                    editorFooter.append('<button class="btn btn-success" data-provider="'
                        + ns
                        + '" data-handler="'
                        + saveHandler
                        + '"><i class="icon icon-white icon-ok"></i> '
                        + this.__localize('Save')
                        + '</button>');


                }

                footer = typeof options.footer === 'function' ? options.footer(this) : options.footer;

                if ($.trim(footer) !== '') {
                    createFooter = true;
                    editorFooter.append(footer);
                }

                if (createFooter) editor.append(editorFooter);

                // Set width
                if (options.width && options.width !== 'inherit') {
                    if (jQuery.isNumeric(options.width)) {
                        editor.css('display', 'table');
                        textarea.css('width', options.width + 'px');
                    } else {
                        editor.addClass(options.width);
                    }
                }

                // Set height
                if (options.height && options.height !== 'inherit') {
                    if (jQuery.isNumeric(options.height)) {
                        var height = options.height;
                        if (editorHeader) height = Math.max(0, height - editorHeader.outerHeight());
                        if (editorFooter) height = Math.max(0, height - editorFooter.outerHeight());
                        textarea.css('height', height + 'px');
                    } else {
                        editor.addClass(options.height);
                    }
                }

                // Reference
                this.$editor = editor;
                this.$textarea = textarea;
                this.$editable = editable;
                this.$oldContent = this.getContent();

                this.__setListener();

                // Set editor attributes, data short-hand API and listener
                this.$editor.attr('id', (new Date()).getTime());
                this.$editor.on('click', '[data-provider="bootstrap-markdown"]', $.proxy(this.__handle, this));

                if (this.$element.is(':disabled') || this.$element.is('[readonly]')) {
                    this.$editor.addClass('md-editor-disabled');
                    this.disableButtons('all');
                }

                if (this.eventSupported('keydown') && typeof jQuery.hotkeys === 'object') {
                    editorHeader.find('[data-provider="bootstrap-markdown"]').each(function () {
                        var $button = $(this),
                            hotkey = $button.attr('data-hotkey');
                        if (hotkey.toLowerCase() !== '') {
                            textarea.bind('keydown', hotkey, function () {
                                $button.trigger('click');
                                return false;
                            });
                        }
                    });
                }

                if (options.initialstate === 'preview') {
                    this.showPreview();
                } else if (options.initialstate === 'fullscreen' && options.fullscreen.enable) {
                    this.setFullscreen(true);
                }

            } else {
                this.$editor.show();
            }

            if (options.autofocus) {
                this.$textarea.focus();
                this.$editor.addClass('active');
            }

            if (options.fullscreen.enable && options.fullscreen !== false) {
                this.$editor.append('<div class="md-fullscreen-controls">'
                    + '<a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="' + this.__getIcon(options.fullscreen.icons.fullscreenOff) + '">'
                    + '</span></a>'
                    + '</div>');
                this.$editor.on('click', '.exit-fullscreen', function (e) {
                    e.preventDefault();
                    instance.setFullscreen(false);
                });
            }

            // hide hidden buttons from options
            this.hideButtons(options.hiddenButtons);

            // disable disabled buttons from options
            this.disableButtons(options.disabledButtons);

            // Trigger the onShow hook
            options.onShow(this);

            return this;
        }

        , parseContent: function (val) {
            var content;

            // parse with supported markdown parser
            var val = val || this.$textarea.val();

            if (this.$options.parser) {
                content = this.$options.parser(val);
            } else if (typeof markdown == 'object') {
                content = markdown.toHTML(val);
            } else if (typeof marked == 'function') {
                content = marked(val);
            } else {
                content = val;
            }

            return content;
        }

        , showPreview: function () {
            var options = this.$options,
                container = this.$textarea,
                afterContainer = container.next(),
                replacementContainer = $('<div/>', {'class': 'md-preview', 'data-provider': 'markdown-preview'}),
                content,
                callbackContent;

            if (this.$isPreview == true) {
                // Avoid sequenced element creation on missused scenario
                // @see https://github.com/toopay/bootstrap-markdown/issues/170
                return this;
            }

            // Give flag that tell the editor enter preview mode
            this.$isPreview = true;
            // Disable all buttons
            this.disableButtons('all').enableButtons('cmdPreview');

            // Try to get the content from callback
            callbackContent = options.onPreview(this);
            // Set the content based from the callback content if string otherwise parse value from textarea
            content = typeof callbackContent == 'string' ? callbackContent : this.parseContent();

            // Build preview element
            replacementContainer.html(content);

            if (afterContainer && afterContainer.attr('class') == 'md-footer') {
                // If there is footer element, insert the preview container before it
                replacementContainer.insertBefore(afterContainer);
            } else {
                // Otherwise, just append it after textarea
                container.parent().append(replacementContainer);
            }

            // Set the preview element dimensions
            replacementContainer.css({
                width: container.outerWidth() + 'px',
                height: container.outerHeight() + 'px'
            });

            if (this.$options.resize) {
                replacementContainer.css('resize', this.$options.resize);
            }

            // Hide the last-active textarea
            container.hide();

            // Attach the editor instances
            replacementContainer.data('markdown', this);

            if (this.$element.is(':disabled') || this.$element.is('[readonly]')) {
                this.$editor.addClass('md-editor-disabled');
                this.disableButtons('all');
            }

            return this;
        }

        , hidePreview: function () {
            // Give flag that tell the editor quit preview mode
            this.$isPreview = false;

            // Obtain the preview container
            var container = this.$editor.find('div[data-provider="markdown-preview"]');

            // Remove the preview container
            container.remove();

            // Enable all buttons
            this.enableButtons('all');
            // Disable configured disabled buttons
            this.disableButtons(this.$options.disabledButtons);

            // Back to the editor
            this.$textarea.show();
            this.__setListener();

            return this;
        }

        , isDirty: function () {
            return this.$oldContent != this.getContent();
        }

        , getContent: function () {
            return this.$textarea.val();
        }

        , setContent: function (content) {
            this.$textarea.val(content);

            return this;
        }

        , findSelection: function (chunk) {
            var content = this.getContent(), startChunkPosition;

            if (startChunkPosition = content.indexOf(chunk), startChunkPosition >= 0 && chunk.length > 0) {
                var oldSelection = this.getSelection(), selection;

                this.setSelection(startChunkPosition, startChunkPosition + chunk.length);
                selection = this.getSelection();

                this.setSelection(oldSelection.start, oldSelection.end);

                return selection;
            } else {
                return null;
            }
        }

        , getSelection: function () {

            var e = this.$textarea[0];

            return (

                ('selectionStart' in e && function () {
                    var l = e.selectionEnd - e.selectionStart;
                    return {
                        start: e.selectionStart,
                        end: e.selectionEnd,
                        length: l,
                        text: e.value.substr(e.selectionStart, l)
                    };
                }) ||

                /* browser not supported */
                function () {
                    return null;
                }

            )();

        }

        , setSelection: function (start, end) {

            var e = this.$textarea[0];

            return (

                ('selectionStart' in e && function () {
                    e.selectionStart = start;
                    e.selectionEnd = end;
                    return;
                }) ||

                /* browser not supported */
                function () {
                    return null;
                }

            )();

        }

        , replaceSelection: function (text) {

            var e = this.$textarea[0];

            return (

                ('selectionStart' in e && function () {
                    e.value = e.value.substr(0, e.selectionStart) + text + e.value.substr(e.selectionEnd, e.value.length);
                    // Set cursor to the last replacement end
                    e.selectionStart = e.value.length;
                    return this;
                }) ||

                /* browser not supported */
                function () {
                    e.value += text;
                    return jQuery(e);
                }

            )();
        }

        , getNextTab: function () {
            // Shift the nextTab
            if (this.$nextTab.length === 0) {
                return null;
            } else {
                var nextTab, tab = this.$nextTab.shift();

                if (typeof tab == 'function') {
                    nextTab = tab();
                } else if (typeof tab == 'object' && tab.length > 0) {
                    nextTab = tab;
                }

                return nextTab;
            }
        }

        , setNextTab: function (start, end) {
            // Push new selection into nextTab collections
            if (typeof start == 'string') {
                var that = this;
                this.$nextTab.push(function () {
                    return that.findSelection(start);
                });
            } else if (typeof start == 'number' && typeof end == 'number') {
                var oldSelection = this.getSelection();

                this.setSelection(start, end);
                this.$nextTab.push(this.getSelection());

                this.setSelection(oldSelection.start, oldSelection.end);
            }

            return;
        }

        , __parseButtonNameParam: function (names) {
            return typeof names == 'string' ?
                names.split(' ') :
                names;

        }

        , enableButtons: function (name) {
            var buttons = this.__parseButtonNameParam(name),
                that = this;

            $.each(buttons, function (i, v) {
                that.__alterButtons(buttons[i], function (el) {
                    el.removeAttr('disabled');
                });
            });

            return this;
        }

        , disableButtons: function (name) {
            var buttons = this.__parseButtonNameParam(name),
                that = this;

            $.each(buttons, function (i, v) {
                that.__alterButtons(buttons[i], function (el) {
                    el.attr('disabled', 'disabled');
                });
            });

            return this;
        }

        , hideButtons: function (name) {
            var buttons = this.__parseButtonNameParam(name),
                that = this;

            $.each(buttons, function (i, v) {
                that.__alterButtons(buttons[i], function (el) {
                    el.addClass('hidden');
                });
            });

            return this;
        }

        , showButtons: function (name) {
            var buttons = this.__parseButtonNameParam(name),
                that = this;

            $.each(buttons, function (i, v) {
                that.__alterButtons(buttons[i], function (el) {
                    el.removeClass('hidden');
                });
            });

            return this;
        }

        , eventSupported: function (eventName) {
            var isSupported = eventName in this.$element;
            if (!isSupported) {
                this.$element.setAttribute(eventName, 'return;');
                isSupported = typeof this.$element[eventName] === 'function';
            }
            return isSupported;
        }

        , keyup: function (e) {
            var blocked = false;
            switch (e.keyCode) {
                case 40: // down arrow
                case 38: // up arrow
                case 16: // shift
                case 17: // ctrl
                case 18: // alt
                    break;

                case 9: // tab
                    var nextTab;
                    if (nextTab = this.getNextTab(), nextTab !== null) {
                        // Get the nextTab if exists
                        var that = this;
                        setTimeout(function () {
                            that.setSelection(nextTab.start, nextTab.end);
                        }, 500);

                        blocked = true;
                    } else {
                        // The next tab memory contains nothing...
                        // check the cursor position to determine tab action
                        var cursor = this.getSelection();

                        if (cursor.start == cursor.end && cursor.end == this.getContent().length) {
                            // The cursor already reach the end of the content
                            blocked = false;
                        } else {
                            // Put the cursor to the end
                            this.setSelection(this.getContent().length, this.getContent().length);

                            blocked = true;
                        }
                    }

                    break;

                case 13: // enter
                    blocked = false;
                    break;
                case 27: // escape
                    if (this.$isFullscreen) this.setFullscreen(false);
                    blocked = false;
                    break;

                default:
                    blocked = false;
            }

            if (blocked) {
                e.stopPropagation();
                e.preventDefault();
            }

            this.$options.onChange(this);
        }

        , change: function (e) {
            this.$options.onChange(this);
            return this;
        }
        , select: function (e) {
            this.$options.onSelect(this);
            return this;
        }
        , focus: function (e) {
            var options = this.$options,
                isHideable = options.hideable,
                editor = this.$editor;

            editor.addClass('active');

            // Blur other markdown(s)
            $(document).find('.md-editor').each(function () {
                if ($(this).attr('id') !== editor.attr('id')) {
                    var attachedMarkdown;

                    if (attachedMarkdown = $(this).find('textarea').data('markdown'),
                    attachedMarkdown === null) {
                        attachedMarkdown = $(this).find('div[data-provider="markdown-preview"]').data('markdown');
                    }

                    if (attachedMarkdown) {
                        attachedMarkdown.blur();
                    }
                }
            });

            // Trigger the onFocus hook
            options.onFocus(this);

            return this;
        }

        , blur: function (e) {
            var options = this.$options,
                isHideable = options.hideable,
                editor = this.$editor,
                editable = this.$editable;

            if (editor.hasClass('active') || this.$element.parent().length === 0) {
                editor.removeClass('active');

                if (isHideable) {
                    // Check for editable elements
                    if (editable.el !== null) {
                        // Build the original element
                        var oldElement = $('<' + editable.type + '/>'),
                            content = this.getContent(),
                            currentContent = this.parseContent(content);

                        $(editable.attrKeys).each(function (k, v) {
                            oldElement.attr(editable.attrKeys[k], editable.attrValues[k]);
                        });

                        // Get the editor content
                        oldElement.html(currentContent);

                        editor.replaceWith(oldElement);
                    } else {
                        editor.hide();
                    }
                }

                // Trigger the onBlur hook
                options.onBlur(this);
            }

            return this;
        }

    };

    /* MARKDOWN PLUGIN DEFINITION
  * ========================== */

    var old = $.fn.markdown;

    $.fn.markdown = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('markdown')
                , options = typeof option == 'object' && option;
            if (!data) $this.data('markdown', (data = new Markdown(this, options)))
        })
    };

    $.fn.markdown.messages = {};

    $.fn.markdown.defaults = {
        /* Editor Properties */
        autofocus: false,
        hideable: false,
        savable: false,
        width: 'inherit',
        height: 'inherit',
        resize: 'none',
        iconlibrary: 'glyph',
        language: 'en',
        initialstate: 'editor',
        parser: null,

        /* Buttons Properties */
        buttons: [
            [{
                name: 'groupFont',
                data: [{
                    name: 'cmdBold',
                    hotkey: 'Ctrl+B',
                    title: 'Bold',
                    icon: {glyph: 'glyphicon glyphicon-bold', fa: 'fa fa-bold', 'fa-3': 'icon-bold'},
                    callback: function (e) {
                        // Give/remove ** surround the selection
                        var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                        if (selected.length === 0) {
                            // Give extra word
                            chunk = e.__localize('strong text');
                        } else {
                            chunk = selected.text;
                        }

                        // transform selection and set the cursor into chunked text
                        if (content.substr(selected.start - 2, 2) === '**'
                            && content.substr(selected.end, 2) === '**') {
                            e.setSelection(selected.start - 2, selected.end + 2);
                            e.replaceSelection(chunk);
                            cursor = selected.start - 2;
                        } else {
                            e.replaceSelection('**' + chunk + '**');
                            cursor = selected.start + 2;
                        }

                        // Set the cursor
                        e.setSelection(cursor, cursor + chunk.length);
                    }
                }, {
                    name: 'cmdItalic',
                    title: 'Italic',
                    hotkey: 'Ctrl+I',
                    icon: {glyph: 'glyphicon glyphicon-italic', fa: 'fa fa-italic', 'fa-3': 'icon-italic'},
                    callback: function (e) {
                        // Give/remove * surround the selection
                        var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                        if (selected.length === 0) {
                            // Give extra word
                            chunk = e.__localize('emphasized text');
                        } else {
                            chunk = selected.text;
                        }

                        // transform selection and set the cursor into chunked text
                        if (content.substr(selected.start - 1, 1) === '_'
                            && content.substr(selected.end, 1) === '_') {
                            e.setSelection(selected.start - 1, selected.end + 1);
                            e.replaceSelection(chunk);
                            cursor = selected.start - 1;
                        } else {
                            e.replaceSelection('_' + chunk + '_');
                            cursor = selected.start + 1;
                        }

                        // Set the cursor
                        e.setSelection(cursor, cursor + chunk.length);
                    }
                }, {
                    name: 'cmdHeading',
                    title: 'Heading',
                    hotkey: 'Ctrl+H',
                    icon: {glyph: 'glyphicon glyphicon-header', fa: 'fa fa-header', 'fa-3': 'icon-font'},
                    callback: function (e) {
                        // Append/remove ### surround the selection
                        var chunk, cursor, selected = e.getSelection(), content = e.getContent(), pointer, prevChar;

                        if (selected.length === 0) {
                            // Give extra word
                            chunk = e.__localize('heading text');
                        } else {
                            chunk = selected.text + '\n';
                        }

                        // transform selection and set the cursor into chunked text
                        if ((pointer = 4, content.substr(selected.start - pointer, pointer) === '### ')
                            || (pointer = 3, content.substr(selected.start - pointer, pointer) === '###')) {
                            e.setSelection(selected.start - pointer, selected.end);
                            e.replaceSelection(chunk);
                            cursor = selected.start - pointer;
                        } else if (selected.start > 0 && (prevChar = content.substr(selected.start - 1, 1), !!prevChar && prevChar != '\n')) {
                            e.replaceSelection('\n\n### ' + chunk);
                            cursor = selected.start + 6;
                        } else {
                            // Empty string before element
                            e.replaceSelection('### ' + chunk);
                            cursor = selected.start + 4;
                        }

                        // Set the cursor
                        e.setSelection(cursor, cursor + chunk.length);
                    }
                }]
            }, {
                name: 'groupLink',
                data: [{
                    name: 'cmdUrl',
                    title: 'URL/Link',
                    hotkey: 'Ctrl+L',
                    icon: {glyph: 'glyphicon glyphicon-link', fa: 'fa fa-link', 'fa-3': 'icon-link'},
                    callback: function (e) {
                        // Give [] surround the selection and prepend the link
                        var chunk, cursor, selected = e.getSelection(), content = e.getContent(), link;

                        if (selected.length === 0) {
                            // Give extra word
                            chunk = e.__localize('enter link description here');
                        } else {
                            chunk = selected.text;
                        }

                        link = prompt(e.__localize('Insert Hyperlink'), 'http://');

                        var urlRegex = new RegExp('^((http|https)://|(mailto:)|(//))[a-z0-9]', 'i');
                        if (link !== null && link !== '' && link !== 'http://' && urlRegex.test(link)) {
                            var sanitizedLink = $('<div>' + link + '</div>').text();

                            // transform selection and set the cursor into chunked text
                            e.replaceSelection('[' + chunk + '](' + sanitizedLink + ')');
                            cursor = selected.start + 1;

                            // Set the cursor
                            e.setSelection(cursor, cursor + chunk.length);
                        }
                    }
                }, {
                    name: 'cmdImage',
                    title: 'Image',
                    hotkey: 'Ctrl+G',
                    icon: {glyph: 'glyphicon glyphicon-picture', fa: 'fa fa-picture-o', 'fa-3': 'icon-picture'},
                    callback: function (e) {
                        // Give ![] surround the selection and prepend the image link
                        var chunk, cursor, selected = e.getSelection(), content = e.getContent(), link;

                        if (selected.length === 0) {
                            // Give extra word
                            chunk = e.__localize('enter image description here');
                        } else {
                            chunk = selected.text;
                        }

                        link = prompt(e.__localize('Insert Image Hyperlink'), 'http://');

                        var urlRegex = new RegExp('^((http|https)://|(//))[a-z0-9]', 'i');
                        if (link !== null && link !== '' && link !== 'http://' && urlRegex.test(link)) {
                            var sanitizedLink = $('<div>' + link + '</div>').text();

                            // transform selection and set the cursor into chunked text
                            e.replaceSelection('![' + chunk + '](' + sanitizedLink + ' "' + e.__localize('enter image title here') + '")');
                            cursor = selected.start + 2;

                            // Set the next tab
                            e.setNextTab(e.__localize('enter image title here'));

                            // Set the cursor
                            e.setSelection(cursor, cursor + chunk.length);
                        }
                    }
                }]
            }, {
                name: 'groupMisc',
                data: [{
                    name: 'cmdList',
                    hotkey: 'Ctrl+U',
                    title: 'Unordered List',
                    icon: {glyph: 'glyphicon glyphicon-list', fa: 'fa fa-list', 'fa-3': 'icon-list-ul'},
                    callback: function (e) {
                        // Prepend/Give - surround the selection
                        var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                        // transform selection and set the cursor into chunked text
                        if (selected.length === 0) {
                            // Give extra word
                            chunk = e.__localize('list text here');

                            e.replaceSelection('- ' + chunk);
                            // Set the cursor
                            cursor = selected.start + 2;
                        } else {
                            if (selected.text.indexOf('\n') < 0) {
                                chunk = selected.text;

                                e.replaceSelection('- ' + chunk);

                                // Set the cursor
                                cursor = selected.start + 2;
                            } else {
                                var list = [];

                                list = selected.text.split('\n');
                                chunk = list[0];

                                $.each(list, function (k, v) {
                                    list[k] = '- ' + v;
                                });

                                e.replaceSelection('\n\n' + list.join('\n'));

                                // Set the cursor
                                cursor = selected.start + 4;
                            }
                        }

                        // Set the cursor
                        e.setSelection(cursor, cursor + chunk.length);
                    }
                },
                    {
                        name: 'cmdListO',
                        hotkey: 'Ctrl+O',
                        title: 'Ordered List',
                        icon: {glyph: 'glyphicon glyphicon-th-list', fa: 'fa fa-list-ol', 'fa-3': 'icon-list-ol'},
                        callback: function (e) {

                            // Prepend/Give - surround the selection
                            var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                            // transform selection and set the cursor into chunked text
                            if (selected.length === 0) {
                                // Give extra word
                                chunk = e.__localize('list text here');
                                e.replaceSelection('1. ' + chunk);
                                // Set the cursor
                                cursor = selected.start + 3;
                            } else {
                                if (selected.text.indexOf('\n') < 0) {
                                    chunk = selected.text;

                                    e.replaceSelection('1. ' + chunk);

                                    // Set the cursor
                                    cursor = selected.start + 3;
                                } else {
                                    var list = [];

                                    list = selected.text.split('\n');
                                    chunk = list[0];

                                    $.each(list, function (k, v) {
                                        list[k] = '1. ' + v;
                                    });

                                    e.replaceSelection('\n\n' + list.join('\n'));

                                    // Set the cursor
                                    cursor = selected.start + 5;
                                }
                            }

                            // Set the cursor
                            e.setSelection(cursor, cursor + chunk.length);
                        }
                    },
                    {
                        name: 'cmdCode',
                        hotkey: 'Ctrl+K',
                        title: 'Code',
                        icon: {glyph: 'glyphicon glyphicon-asterisk', fa: 'fa fa-code', 'fa-3': 'icon-code'},
                        callback: function (e) {
                            // Give/remove ** surround the selection
                            var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                            if (selected.length === 0) {
                                // Give extra word
                                chunk = e.__localize('code text here');
                            } else {
                                chunk = selected.text;
                            }

                            // transform selection and set the cursor into chunked text
                            if (content.substr(selected.start - 4, 4) === '```\n'
                                && content.substr(selected.end, 4) === '\n```') {
                                e.setSelection(selected.start - 4, selected.end + 4);
                                e.replaceSelection(chunk);
                                cursor = selected.start - 4;
                            } else if (content.substr(selected.start - 1, 1) === '`'
                                && content.substr(selected.end, 1) === '`') {
                                e.setSelection(selected.start - 1, selected.end + 1);
                                e.replaceSelection(chunk);
                                cursor = selected.start - 1;
                            } else if (content.indexOf('\n') > -1) {
                                e.replaceSelection('```\n' + chunk + '\n```');
                                cursor = selected.start + 4;
                            } else {
                                e.replaceSelection('`' + chunk + '`');
                                cursor = selected.start + 1;
                            }

                            // Set the cursor
                            e.setSelection(cursor, cursor + chunk.length);
                        }
                    },
                    {
                        name: 'cmdQuote',
                        hotkey: 'Ctrl+Q',
                        title: 'Quote',
                        icon: {glyph: 'glyphicon glyphicon-comment', fa: 'fa fa-quote-left', 'fa-3': 'icon-quote-left'},
                        callback: function (e) {
                            // Prepend/Give - surround the selection
                            var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                            // transform selection and set the cursor into chunked text
                            if (selected.length === 0) {
                                // Give extra word
                                chunk = e.__localize('quote here');

                                e.replaceSelection('> ' + chunk);

                                // Set the cursor
                                cursor = selected.start + 2;
                            } else {
                                if (selected.text.indexOf('\n') < 0) {
                                    chunk = selected.text;

                                    e.replaceSelection('> ' + chunk);

                                    // Set the cursor
                                    cursor = selected.start + 2;
                                } else {
                                    var list = [];

                                    list = selected.text.split('\n');
                                    chunk = list[0];

                                    $.each(list, function (k, v) {
                                        list[k] = '> ' + v;
                                    });

                                    e.replaceSelection('\n\n' + list.join('\n'));

                                    // Set the cursor
                                    cursor = selected.start + 4;
                                }
                            }

                            // Set the cursor
                            e.setSelection(cursor, cursor + chunk.length);
                        }
                    }]
            }, {
                name: 'groupUtil',
                data: [{
                    name: 'cmdPreview',
                    toggle: true,
                    hotkey: 'Ctrl+P',
                    title: 'Preview',
                    btnText: 'Preview',
                    btnClass: 'btn btn-primary btn-sm',
                    icon: {glyph: 'glyphicon glyphicon-search', fa: 'fa fa-search', 'fa-3': 'icon-search'},
                    callback: function (e) {
                        // Check the preview mode and toggle based on this flag
                        var isPreview = e.$isPreview, content;

                        if (isPreview === false) {
                            // Give flag that tell the editor enter preview mode
                            e.showPreview();
                        } else {
                            e.hidePreview();
                        }
                    }
                }]
            }]
        ],
        additionalButtons: [], // Place to hook more buttons by code
        reorderButtonGroups: [],
        hiddenButtons: [], // Default hidden buttons
        disabledButtons: [], // Default disabled buttons
        footer: '',
        fullscreen: {
            enable: true,
            icons: {
                fullscreenOn: {
                    fa: 'fa fa-expand',
                    glyph: 'glyphicon glyphicon-fullscreen',
                    'fa-3': 'icon-resize-full'
                },
                fullscreenOff: {
                    fa: 'fa fa-compress',
                    glyph: 'glyphicon glyphicon-fullscreen',
                    'fa-3': 'icon-resize-small'
                }
            }
        },

        /* Events hook */
        onShow: function (e) {
        },
        onPreview: function (e) {
        },
        onSave: function (e) {
        },
        onBlur: function (e) {
        },
        onFocus: function (e) {
        },
        onChange: function (e) {
        },
        onFullscreen: function (e) {
        },
        onSelect: function (e) {
        }
    };

    $.fn.markdown.Constructor = Markdown;


    /* MARKDOWN NO CONFLICT
  * ==================== */

    $.fn.markdown.noConflict = function () {
        $.fn.markdown = old;
        return this;
    };

    /* MARKDOWN GLOBAL FUNCTION & DATA-API
  * ==================================== */
    var initMarkdown = function (el) {
        var $this = el;

        if ($this.data('markdown')) {
            $this.data('markdown').showEditor();
            return;
        }

        $this.markdown()
    };

    var blurNonFocused = function (e) {
        var $activeElement = $(document.activeElement);

        // Blur event
        $(document).find('.md-editor').each(function () {
            var $this = $(this),
                focused = $activeElement.closest('.md-editor')[0] === this,
                attachedMarkdown = $this.find('textarea').data('markdown') ||
                    $this.find('div[data-provider="markdown-preview"]').data('markdown');

            if (attachedMarkdown && !focused) {
                attachedMarkdown.blur();
            }
        })
    };

    $(document)
        .on('click.markdown.data-api', '[data-provide="markdown-editable"]', function (e) {
            initMarkdown($(this));
            e.preventDefault();
        })
        .on('click focusin', function (e) {
            blurNonFocused(e);
        })
        .ready(function () {
            $('textarea[data-provide="markdown"]').each(function () {
                initMarkdown($(this));
            })
        });

}));

"use strict";
$.fn.markdown.defaults.iconlibrary = 'fa';
$.fn.markdown.defaults.buttons[0][0]['data'][2]['icon']['fa'] = 'fa fa-heading';
$.fn.markdown.defaults.buttons[0][1]['data'][1]['icon']['fa'] = 'fa fa-image';
$.fn.markdown.defaults.buttons[0][2]['data'][1]['icon']['fa'] = 'fa fa-list-ol';

/*!
 * jQuery Validation Plugin v1.17.0
 *
 * https://jqueryvalidation.org/
 *
 * Copyright (c) 2017 Jörn Zaefferer
 * Released under the MIT license
 */
(function (factory) {
    if (typeof define === "function" && define.amd) {
        define(["jquery"], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
}(function ($) {

    $.extend($.fn, {

        // https://jqueryvalidation.org/validate/
        validate: function (options) {

            // If nothing is selected, return nothing; can't chain anyway
            if (!this.length) {
                if (options && options.debug && window.console) {
                    console.warn("Nothing selected, can't validate, returning nothing.");
                }
                return;
            }

            // Check if a validator for this form was already created
            var validator = $.data(this[0], "validator");
            if (validator) {
                return validator;
            }

            // Add novalidate tag if HTML5.
            this.attr("novalidate", "novalidate");

            validator = new $.validator(options, this[0]);
            $.data(this[0], "validator", validator);

            if (validator.settings.onsubmit) {

                this.on("click.validate", ":submit", function (event) {

                    // Track the used submit button to properly handle scripted
                    // submits later.
                    validator.submitButton = event.currentTarget;

                    // Allow suppressing validation by adding a cancel class to the submit button
                    if ($(this).hasClass("cancel")) {
                        validator.cancelSubmit = true;
                    }

                    // Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
                    if ($(this).attr("formnovalidate") !== undefined) {
                        validator.cancelSubmit = true;
                    }
                });

                // Validate the form on submit
                this.on("submit.validate", function (event) {
                    if (validator.settings.debug) {

                        // Prevent form submit to be able to see console output
                        event.preventDefault();
                    }

                    function handle() {
                        var hidden, result;

                        // Insert a hidden input as a replacement for the missing submit button
                        // The hidden input is inserted in two cases:
                        //   - A user defined a `submitHandler`
                        //   - There was a pending request due to `remote` method and `stopRequest()`
                        //     was called to submit the form in case it's valid
                        if (validator.submitButton && (validator.settings.submitHandler || validator.formSubmitted)) {
                            hidden = $("<input type='hidden'/>")
                                .attr("name", validator.submitButton.name)
                                .val($(validator.submitButton).val())
                                .appendTo(validator.currentForm);
                        }

                        if (validator.settings.submitHandler) {
                            result = validator.settings.submitHandler.call(validator, validator.currentForm, event);
                            if (hidden) {

                                // And clean up afterwards; thanks to no-block-scope, hidden can be referenced
                                hidden.remove();
                            }
                            if (result !== undefined) {
                                return result;
                            }
                            return false;
                        }
                        return true;
                    }

                    // Prevent submit for invalid forms or custom submit handlers
                    if (validator.cancelSubmit) {
                        validator.cancelSubmit = false;
                        return handle();
                    }
                    if (validator.form()) {
                        if (validator.pendingRequest) {
                            validator.formSubmitted = true;
                            return false;
                        }
                        return handle();
                    } else {
                        validator.focusInvalid();
                        return false;
                    }
                });
            }

            return validator;
        },

        // https://jqueryvalidation.org/valid/
        valid: function () {
            var valid, validator, errorList;

            if ($(this[0]).is("form")) {
                valid = this.validate().form();
            } else {
                errorList = [];
                valid = true;
                validator = $(this[0].form).validate();
                this.each(function () {
                    valid = validator.element(this) && valid;
                    if (!valid) {
                        errorList = errorList.concat(validator.errorList);
                    }
                });
                validator.errorList = errorList;
            }
            return valid;
        },

        // https://jqueryvalidation.org/rules/
        rules: function (command, argument) {
            var element = this[0],
                settings, staticRules, existingRules, data, param, filtered;

            // If nothing is selected, return empty object; can't chain anyway
            if (element == null) {
                return;
            }

            if (!element.form && element.hasAttribute("contenteditable")) {
                element.form = this.closest("form")[0];
                element.name = this.attr("name");
            }

            if (element.form == null) {
                return;
            }

            if (command) {
                settings = $.data(element.form, "validator").settings;
                staticRules = settings.rules;
                existingRules = $.validator.staticRules(element);
                switch (command) {
                    case "add":
                        $.extend(existingRules, $.validator.normalizeRule(argument));

                        // Remove messages from rules, but allow them to be set separately
                        delete existingRules.messages;
                        staticRules[element.name] = existingRules;
                        if (argument.messages) {
                            settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);
                        }
                        break;
                    case "remove":
                        if (!argument) {
                            delete staticRules[element.name];
                            return existingRules;
                        }
                        filtered = {};
                        $.each(argument.split(/\s/), function (index, method) {
                            filtered[method] = existingRules[method];
                            delete existingRules[method];
                        });
                        return filtered;
                }
            }

            data = $.validator.normalizeRules(
                $.extend(
                    {},
                    $.validator.classRules(element),
                    $.validator.attributeRules(element),
                    $.validator.dataRules(element),
                    $.validator.staticRules(element)
                ), element);

            // Make sure required is at front
            if (data.required) {
                param = data.required;
                delete data.required;
                data = $.extend({required: param}, data);
            }

            // Make sure remote is at back
            if (data.remote) {
                param = data.remote;
                delete data.remote;
                data = $.extend(data, {remote: param});
            }

            return data;
        }
    });

// Custom selectors
    $.extend($.expr.pseudos || $.expr[":"], {		// '|| $.expr[ ":" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support

        // https://jqueryvalidation.org/blank-selector/
        blank: function (a) {
            return !$.trim("" + $(a).val());
        },

        // https://jqueryvalidation.org/filled-selector/
        filled: function (a) {
            var val = $(a).val();
            return val !== null && !!$.trim("" + val);
        },

        // https://jqueryvalidation.org/unchecked-selector/
        unchecked: function (a) {
            return !$(a).prop("checked");
        }
    });

// Constructor for validator
    $.validator = function (options, form) {
        this.settings = $.extend(true, {}, $.validator.defaults, options);
        this.currentForm = form;
        this.init();
    };

// https://jqueryvalidation.org/jQuery.validator.format/
    $.validator.format = function (source, params) {
        if (arguments.length === 1) {
            return function () {
                var args = $.makeArray(arguments);
                args.unshift(source);
                return $.validator.format.apply(this, args);
            };
        }
        if (params === undefined) {
            return source;
        }
        if (arguments.length > 2 && params.constructor !== Array) {
            params = $.makeArray(arguments).slice(1);
        }
        if (params.constructor !== Array) {
            params = [params];
        }
        $.each(params, function (i, n) {
            source = source.replace(new RegExp("\\{" + i + "\\}", "g"), function () {
                return n;
            });
        });
        return source;
    };

    $.extend($.validator, {

        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            pendingClass: "pending",
            validClass: "valid",
            errorElement: "label",
            focusCleanup: false,
            focusInvalid: true,
            errorContainer: $([]),
            errorLabelContainer: $([]),
            onsubmit: true,
            ignore: ":hidden",
            ignoreTitle: false,
            onfocusin: function (element) {
                this.lastActive = element;

                // Hide error label and remove error class on focus if enabled
                if (this.settings.focusCleanup) {
                    if (this.settings.unhighlight) {
                        this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
                    }
                    this.hideThese(this.errorsFor(element));
                }
            },
            onfocusout: function (element) {
                if (!this.checkable(element) && (element.name in this.submitted || !this.optional(element))) {
                    this.element(element);
                }
            },
            onkeyup: function (element, event) {

                // Avoid revalidate the field when pressing one of the following keys
                // Shift       => 16
                // Ctrl        => 17
                // Alt         => 18
                // Caps lock   => 20
                // End         => 35
                // Home        => 36
                // Left arrow  => 37
                // Up arrow    => 38
                // Right arrow => 39
                // Down arrow  => 40
                // Insert      => 45
                // Num lock    => 144
                // AltGr key   => 225
                var excludedKeys = [
                    16, 17, 18, 20, 35, 36, 37,
                    38, 39, 40, 45, 144, 225
                ];

                if (event.which === 9 && this.elementValue(element) === "" || $.inArray(event.keyCode, excludedKeys) !== -1) {
                    return;
                } else if (element.name in this.submitted || element.name in this.invalid) {
                    this.element(element);
                }
            },
            onclick: function (element) {

                // Click on selects, radiobuttons and checkboxes
                if (element.name in this.submitted) {
                    this.element(element);

                    // Or option elements, check parent select in that case
                } else if (element.parentNode.name in this.submitted) {
                    this.element(element.parentNode);
                }
            },
            highlight: function (element, errorClass, validClass) {
                if (element.type === "radio") {
                    this.findByName(element.name).addClass(errorClass).removeClass(validClass);
                } else {
                    $(element).addClass(errorClass).removeClass(validClass);
                }
            },
            unhighlight: function (element, errorClass, validClass) {
                if (element.type === "radio") {
                    this.findByName(element.name).removeClass(errorClass).addClass(validClass);
                } else {
                    $(element).removeClass(errorClass).addClass(validClass);
                }
            }
        },

        // https://jqueryvalidation.org/jQuery.validator.setDefaults/
        setDefaults: function (settings) {
            $.extend($.validator.defaults, settings);
        },

        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date (ISO).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            equalTo: "Please enter the same value again.",
            maxlength: $.validator.format("Please enter no more than {0} characters."),
            minlength: $.validator.format("Please enter at least {0} characters."),
            rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
            range: $.validator.format("Please enter a value between {0} and {1}."),
            max: $.validator.format("Please enter a value less than or equal to {0}."),
            min: $.validator.format("Please enter a value greater than or equal to {0}."),
            step: $.validator.format("Please enter a multiple of {0}.")
        },

        autoCreateRanges: false,

        prototype: {

            init: function () {
                this.labelContainer = $(this.settings.errorLabelContainer);
                this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
                this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
                this.submitted = {};
                this.valueCache = {};
                this.pendingRequest = 0;
                this.pending = {};
                this.invalid = {};
                this.reset();

                var groups = (this.groups = {}),
                    rules;
                $.each(this.settings.groups, function (key, value) {
                    if (typeof value === "string") {
                        value = value.split(/\s/);
                    }
                    $.each(value, function (index, name) {
                        groups[name] = key;
                    });
                });
                rules = this.settings.rules;
                $.each(rules, function (key, value) {
                    rules[key] = $.validator.normalizeRule(value);
                });

                function delegate(event) {

                    // Set form expando on contenteditable
                    if (!this.form && this.hasAttribute("contenteditable")) {
                        this.form = $(this).closest("form")[0];
                        this.name = $(this).attr("name");
                    }

                    var validator = $.data(this.form, "validator"),
                        eventType = "on" + event.type.replace(/^validate/, ""),
                        settings = validator.settings;
                    if (settings[eventType] && !$(this).is(settings.ignore)) {
                        settings[eventType].call(validator, this, event);
                    }
                }

                $(this.currentForm)
                    .on("focusin.validate focusout.validate keyup.validate",
                        ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
                        "[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
                        "[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
                        "[type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate)

                    // Support: Chrome, oldIE
                    // "select" is provided as event.target when clicking a option
                    .on("click.validate", "select, option, [type='radio'], [type='checkbox']", delegate);

                if (this.settings.invalidHandler) {
                    $(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler);
                }
            },

            // https://jqueryvalidation.org/Validator.form/
            form: function () {
                this.checkForm();
                $.extend(this.submitted, this.errorMap);
                this.invalid = $.extend({}, this.errorMap);
                if (!this.valid()) {
                    $(this.currentForm).triggerHandler("invalid-form", [this]);
                }
                this.showErrors();
                return this.valid();
            },

            checkForm: function () {
                this.prepareForm();
                for (var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++) {
                    this.check(elements[i]);
                }
                return this.valid();
            },

            // https://jqueryvalidation.org/Validator.element/
            element: function (element) {
                var cleanElement = this.clean(element),
                    checkElement = this.validationTargetFor(cleanElement),
                    v = this,
                    result = true,
                    rs, group;

                if (checkElement === undefined) {
                    delete this.invalid[cleanElement.name];
                } else {
                    this.prepareElement(checkElement);
                    this.currentElements = $(checkElement);

                    // If this element is grouped, then validate all group elements already
                    // containing a value
                    group = this.groups[checkElement.name];
                    if (group) {
                        $.each(this.groups, function (name, testgroup) {
                            if (testgroup === group && name !== checkElement.name) {
                                cleanElement = v.validationTargetFor(v.clean(v.findByName(name)));
                                if (cleanElement && cleanElement.name in v.invalid) {
                                    v.currentElements.push(cleanElement);
                                    result = v.check(cleanElement) && result;
                                }
                            }
                        });
                    }

                    rs = this.check(checkElement) !== false;
                    result = result && rs;
                    if (rs) {
                        this.invalid[checkElement.name] = false;
                    } else {
                        this.invalid[checkElement.name] = true;
                    }

                    if (!this.numberOfInvalids()) {

                        // Hide error containers on last error
                        this.toHide = this.toHide.add(this.containers);
                    }
                    this.showErrors();

                    // Add aria-invalid status for screen readers
                    $(element).attr("aria-invalid", !rs);
                }

                return result;
            },

            // https://jqueryvalidation.org/Validator.showErrors/
            showErrors: function (errors) {
                if (errors) {
                    var validator = this;

                    // Add items to error list and map
                    $.extend(this.errorMap, errors);
                    this.errorList = $.map(this.errorMap, function (message, name) {
                        return {
                            message: message,
                            element: validator.findByName(name)[0]
                        };
                    });

                    // Remove items from success list
                    this.successList = $.grep(this.successList, function (element) {
                        return !(element.name in errors);
                    });
                }
                if (this.settings.showErrors) {
                    this.settings.showErrors.call(this, this.errorMap, this.errorList);
                } else {
                    this.defaultShowErrors();
                }
            },

            // https://jqueryvalidation.org/Validator.resetForm/
            resetForm: function () {
                if ($.fn.resetForm) {
                    $(this.currentForm).resetForm();
                }
                this.invalid = {};
                this.submitted = {};
                this.prepareForm();
                this.hideErrors();
                var elements = this.elements()
                    .removeData("previousValue")
                    .removeAttr("aria-invalid");

                this.resetElements(elements);
            },

            resetElements: function (elements) {
                var i;

                if (this.settings.unhighlight) {
                    for (i = 0; elements[i]; i++) {
                        this.settings.unhighlight.call(this, elements[i],
                            this.settings.errorClass, "");
                        this.findByName(elements[i].name).removeClass(this.settings.validClass);
                    }
                } else {
                    elements
                        .removeClass(this.settings.errorClass)
                        .removeClass(this.settings.validClass);
                }
            },

            numberOfInvalids: function () {
                return this.objectLength(this.invalid);
            },

            objectLength: function (obj) {
                /* jshint unused: false */
                var count = 0,
                    i;
                for (i in obj) {

                    // This check allows counting elements with empty error
                    // message as invalid elements
                    if (obj[i] !== undefined && obj[i] !== null && obj[i] !== false) {
                        count++;
                    }
                }
                return count;
            },

            hideErrors: function () {
                this.hideThese(this.toHide);
            },

            hideThese: function (errors) {
                errors.not(this.containers).text("");
                this.addWrapper(errors).hide();
            },

            valid: function () {
                return this.size() === 0;
            },

            size: function () {
                return this.errorList.length;
            },

            focusInvalid: function () {
                if (this.settings.focusInvalid) {
                    try {
                        $(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])
                            .filter(":visible")
                            .focus()

                            // Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
                            .trigger("focusin");
                    } catch (e) {

                        // Ignore IE throwing errors when focusing hidden elements
                    }
                }
            },

            findLastActive: function () {
                var lastActive = this.lastActive;
                return lastActive && $.grep(this.errorList, function (n) {
                    return n.element.name === lastActive.name;
                }).length === 1 && lastActive;
            },

            elements: function () {
                var validator = this,
                    rulesCache = {};

                // Select all valid inputs inside the form (no submit or reset buttons)
                return $(this.currentForm)
                    .find("input, select, textarea, [contenteditable]")
                    .not(":submit, :reset, :image, :disabled")
                    .not(this.settings.ignore)
                    .filter(function () {
                        var name = this.name || $(this).attr("name"); // For contenteditable
                        if (!name && validator.settings.debug && window.console) {
                            console.error("%o has no name assigned", this);
                        }

                        // Set form expando on contenteditable
                        if (this.hasAttribute("contenteditable")) {
                            this.form = $(this).closest("form")[0];
                            this.name = name;
                        }

                        // Select only the first element for each name, and only those with rules specified
                        if (name in rulesCache || !validator.objectLength($(this).rules())) {
                            return false;
                        }

                        rulesCache[name] = true;
                        return true;
                    });
            },

            clean: function (selector) {
                return $(selector)[0];
            },

            errors: function () {
                var errorClass = this.settings.errorClass.split(" ").join(".");
                return $(this.settings.errorElement + "." + errorClass, this.errorContext);
            },

            resetInternals: function () {
                this.successList = [];
                this.errorList = [];
                this.errorMap = {};
                this.toShow = $([]);
                this.toHide = $([]);
            },

            reset: function () {
                this.resetInternals();
                this.currentElements = $([]);
            },

            prepareForm: function () {
                this.reset();
                this.toHide = this.errors().add(this.containers);
            },

            prepareElement: function (element) {
                this.reset();
                this.toHide = this.errorsFor(element);
            },

            elementValue: function (element) {
                var $element = $(element),
                    type = element.type,
                    val, idx;

                if (type === "radio" || type === "checkbox") {
                    return this.findByName(element.name).filter(":checked").val();
                } else if (type === "number" && typeof element.validity !== "undefined") {
                    return element.validity.badInput ? "NaN" : $element.val();
                }

                if (element.hasAttribute("contenteditable")) {
                    val = $element.text();
                } else {
                    val = $element.val();
                }

                if (type === "file") {

                    // Modern browser (chrome & safari)
                    if (val.substr(0, 12) === "C:\\fakepath\\") {
                        return val.substr(12);
                    }

                    // Legacy browsers
                    // Unix-based path
                    idx = val.lastIndexOf("/");
                    if (idx >= 0) {
                        return val.substr(idx + 1);
                    }

                    // Windows-based path
                    idx = val.lastIndexOf("\\");
                    if (idx >= 0) {
                        return val.substr(idx + 1);
                    }

                    // Just the file name
                    return val;
                }

                if (typeof val === "string") {
                    return val.replace(/\r/g, "");
                }
                return val;
            },

            check: function (element) {
                element = this.validationTargetFor(this.clean(element));

                var rules = $(element).rules(),
                    rulesCount = $.map(rules, function (n, i) {
                        return i;
                    }).length,
                    dependencyMismatch = false,
                    val = this.elementValue(element),
                    result, method, rule, normalizer;

                // Prioritize the local normalizer defined for this element over the global one
                // if the former exists, otherwise user the global one in case it exists.
                if (typeof rules.normalizer === "function") {
                    normalizer = rules.normalizer;
                } else if (typeof this.settings.normalizer === "function") {
                    normalizer = this.settings.normalizer;
                }

                // If normalizer is defined, then call it to retreive the changed value instead
                // of using the real one.
                // Note that `this` in the normalizer is `element`.
                if (normalizer) {
                    val = normalizer.call(element, val);

                    if (typeof val !== "string") {
                        throw new TypeError("The normalizer should return a string value.");
                    }

                    // Delete the normalizer from rules to avoid treating it as a pre-defined method.
                    delete rules.normalizer;
                }

                for (method in rules) {
                    rule = {method: method, parameters: rules[method]};
                    try {
                        result = $.validator.methods[method].call(this, val, element, rule.parameters);

                        // If a method indicates that the field is optional and therefore valid,
                        // don't mark it as valid when there are no other rules
                        if (result === "dependency-mismatch" && rulesCount === 1) {
                            dependencyMismatch = true;
                            continue;
                        }
                        dependencyMismatch = false;

                        if (result === "pending") {
                            this.toHide = this.toHide.not(this.errorsFor(element));
                            return;
                        }

                        if (!result) {
                            this.formatAndAdd(element, rule);
                            return false;
                        }
                    } catch (e) {
                        if (this.settings.debug && window.console) {
                            console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e);
                        }
                        if (e instanceof TypeError) {
                            e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
                        }

                        throw e;
                    }
                }
                if (dependencyMismatch) {
                    return;
                }
                if (this.objectLength(rules)) {
                    this.successList.push(element);
                }
                return true;
            },

            // Return the custom message for the given element and validation method
            // specified in the element's HTML5 data attribute
            // return the generic message if present and no method specific message is present
            customDataMessage: function (element, method) {
                return $(element).data("msg" + method.charAt(0).toUpperCase() +
                    method.substring(1).toLowerCase()) || $(element).data("msg");
            },

            // Return the custom message for the given element name and validation method
            customMessage: function (name, method) {
                var m = this.settings.messages[name];
                return m && (m.constructor === String ? m : m[method]);
            },

            // Return the first defined argument, allowing empty strings
            findDefined: function () {
                for (var i = 0; i < arguments.length; i++) {
                    if (arguments[i] !== undefined) {
                        return arguments[i];
                    }
                }
                return undefined;
            },

            // The second parameter 'rule' used to be a string, and extended to an object literal
            // of the following form:
            // rule = {
            //     method: "method name",
            //     parameters: "the given method parameters"
            // }
            //
            // The old behavior still supported, kept to maintain backward compatibility with
            // old code, and will be removed in the next major release.
            defaultMessage: function (element, rule) {
                if (typeof rule === "string") {
                    rule = {method: rule};
                }

                var message = this.findDefined(
                    this.customMessage(element.name, rule.method),
                    this.customDataMessage(element, rule.method),

                    // 'title' is never undefined, so handle empty string as undefined
                    !this.settings.ignoreTitle && element.title || undefined,
                    $.validator.messages[rule.method],
                    "<strong>Warning: No message defined for " + element.name + "</strong>"
                    ),
                    theregex = /\$?\{(\d+)\}/g;
                if (typeof message === "function") {
                    message = message.call(this, rule.parameters, element);
                } else if (theregex.test(message)) {
                    message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);
                }

                return message;
            },

            formatAndAdd: function (element, rule) {
                var message = this.defaultMessage(element, rule);

                this.errorList.push({
                    message: message,
                    element: element,
                    method: rule.method
                });

                this.errorMap[element.name] = message;
                this.submitted[element.name] = message;
            },

            addWrapper: function (toToggle) {
                if (this.settings.wrapper) {
                    toToggle = toToggle.add(toToggle.parent(this.settings.wrapper));
                }
                return toToggle;
            },

            defaultShowErrors: function () {
                var i, elements, error;
                for (i = 0; this.errorList[i]; i++) {
                    error = this.errorList[i];
                    if (this.settings.highlight) {
                        this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                    }
                    this.showLabel(error.element, error.message);
                }
                if (this.errorList.length) {
                    this.toShow = this.toShow.add(this.containers);
                }
                if (this.settings.success) {
                    for (i = 0; this.successList[i]; i++) {
                        this.showLabel(this.successList[i]);
                    }
                }
                if (this.settings.unhighlight) {
                    for (i = 0, elements = this.validElements(); elements[i]; i++) {
                        this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
                    }
                }
                this.toHide = this.toHide.not(this.toShow);
                this.hideErrors();
                this.addWrapper(this.toShow).show();
            },

            validElements: function () {
                return this.currentElements.not(this.invalidElements());
            },

            invalidElements: function () {
                return $(this.errorList).map(function () {
                    return this.element;
                });
            },

            showLabel: function (element, message) {
                var place, group, errorID, v,
                    error = this.errorsFor(element),
                    elementID = this.idOrName(element),
                    describedBy = $(element).attr("aria-describedby");

                if (error.length) {

                    // Refresh error/success class
                    error.removeClass(this.settings.validClass).addClass(this.settings.errorClass);

                    // Replace message on existing label
                    error.html(message);
                } else {

                    // Create error element
                    error = $("<" + this.settings.errorElement + ">")
                        .attr("id", elementID + "-error")
                        .addClass(this.settings.errorClass)
                        .html(message || "");

                    // Maintain reference to the element to be placed into the DOM
                    place = error;
                    if (this.settings.wrapper) {

                        // Make sure the element is visible, even in IE
                        // actually showing the wrapped element is handled elsewhere
                        place = error.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
                    }
                    if (this.labelContainer.length) {
                        this.labelContainer.append(place);
                    } else if (this.settings.errorPlacement) {
                        this.settings.errorPlacement.call(this, place, $(element));
                    } else {
                        place.insertAfter(element);
                    }

                    // Link error back to the element
                    if (error.is("label")) {

                        // If the error is a label, then associate using 'for'
                        error.attr("for", elementID);

                        // If the element is not a child of an associated label, then it's necessary
                        // to explicitly apply aria-describedby
                    } else if (error.parents("label[for='" + this.escapeCssMeta(elementID) + "']").length === 0) {
                        errorID = error.attr("id");

                        // Respect existing non-error aria-describedby
                        if (!describedBy) {
                            describedBy = errorID;
                        } else if (!describedBy.match(new RegExp("\\b" + this.escapeCssMeta(errorID) + "\\b"))) {

                            // Add to end of list if not already present
                            describedBy += " " + errorID;
                        }
                        $(element).attr("aria-describedby", describedBy);

                        // If this element is grouped, then assign to all elements in the same group
                        group = this.groups[element.name];
                        if (group) {
                            v = this;
                            $.each(v.groups, function (name, testgroup) {
                                if (testgroup === group) {
                                    $("[name='" + v.escapeCssMeta(name) + "']", v.currentForm)
                                        .attr("aria-describedby", error.attr("id"));
                                }
                            });
                        }
                    }
                }
                if (!message && this.settings.success) {
                    error.text("");
                    if (typeof this.settings.success === "string") {
                        error.addClass(this.settings.success);
                    } else {
                        this.settings.success(error, element);
                    }
                }
                this.toShow = this.toShow.add(error);
            },

            errorsFor: function (element) {
                var name = this.escapeCssMeta(this.idOrName(element)),
                    describer = $(element).attr("aria-describedby"),
                    selector = "label[for='" + name + "'], label[for='" + name + "'] *";

                // 'aria-describedby' should directly reference the error element
                if (describer) {
                    selector = selector + ", #" + this.escapeCssMeta(describer)
                        .replace(/\s+/g, ", #");
                }

                return this
                    .errors()
                    .filter(selector);
            },

            // See https://api.jquery.com/category/selectors/, for CSS
            // meta-characters that should be escaped in order to be used with JQuery
            // as a literal part of a name/id or any selector.
            escapeCssMeta: function (string) {
                return string.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1");
            },

            idOrName: function (element) {
                return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
            },

            validationTargetFor: function (element) {

                // If radio/checkbox, validate first element in group instead
                if (this.checkable(element)) {
                    element = this.findByName(element.name);
                }

                // Always apply ignore filter
                return $(element).not(this.settings.ignore)[0];
            },

            checkable: function (element) {
                return (/radio|checkbox/i).test(element.type);
            },

            findByName: function (name) {
                return $(this.currentForm).find("[name='" + this.escapeCssMeta(name) + "']");
            },

            getLength: function (value, element) {
                switch (element.nodeName.toLowerCase()) {
                    case "select":
                        return $("option:selected", element).length;
                    case "input":
                        if (this.checkable(element)) {
                            return this.findByName(element.name).filter(":checked").length;
                        }
                }
                return value.length;
            },

            depend: function (param, element) {
                return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
            },

            dependTypes: {
                "boolean": function (param) {
                    return param;
                },
                "string": function (param, element) {
                    return !!$(param, element.form).length;
                },
                "function": function (param, element) {
                    return param(element);
                }
            },

            optional: function (element) {
                var val = this.elementValue(element);
                return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
            },

            startRequest: function (element) {
                if (!this.pending[element.name]) {
                    this.pendingRequest++;
                    $(element).addClass(this.settings.pendingClass);
                    this.pending[element.name] = true;
                }
            },

            stopRequest: function (element, valid) {
                this.pendingRequest--;

                // Sometimes synchronization fails, make sure pendingRequest is never < 0
                if (this.pendingRequest < 0) {
                    this.pendingRequest = 0;
                }
                delete this.pending[element.name];
                $(element).removeClass(this.settings.pendingClass);
                if (valid && this.pendingRequest === 0 && this.formSubmitted && this.form()) {
                    $(this.currentForm).submit();

                    // Remove the hidden input that was used as a replacement for the
                    // missing submit button. The hidden input is added by `handle()`
                    // to ensure that the value of the used submit button is passed on
                    // for scripted submits triggered by this method
                    if (this.submitButton) {
                        $("input:hidden[name='" + this.submitButton.name + "']", this.currentForm).remove();
                    }

                    this.formSubmitted = false;
                } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
                    $(this.currentForm).triggerHandler("invalid-form", [this]);
                    this.formSubmitted = false;
                }
            },

            previousValue: function (element, method) {
                method = typeof method === "string" && method || "remote";

                return $.data(element, "previousValue") || $.data(element, "previousValue", {
                    old: null,
                    valid: true,
                    message: this.defaultMessage(element, {method: method})
                });
            },

            // Cleans up all forms and elements, removes validator-specific events
            destroy: function () {
                this.resetForm();

                $(this.currentForm)
                    .off(".validate")
                    .removeData("validator")
                    .find(".validate-equalTo-blur")
                    .off(".validate-equalTo")
                    .removeClass("validate-equalTo-blur");
            }

        },

        classRuleSettings: {
            required: {required: true},
            email: {email: true},
            url: {url: true},
            date: {date: true},
            dateISO: {dateISO: true},
            number: {number: true},
            digits: {digits: true},
            creditcard: {creditcard: true}
        },

        addClassRules: function (className, rules) {
            if (className.constructor === String) {
                this.classRuleSettings[className] = rules;
            } else {
                $.extend(this.classRuleSettings, className);
            }
        },

        classRules: function (element) {
            var rules = {},
                classes = $(element).attr("class");

            if (classes) {
                $.each(classes.split(" "), function () {
                    if (this in $.validator.classRuleSettings) {
                        $.extend(rules, $.validator.classRuleSettings[this]);
                    }
                });
            }
            return rules;
        },

        normalizeAttributeRule: function (rules, type, method, value) {

            // Convert the value to a number for number inputs, and for text for backwards compability
            // allows type="date" and others to be compared as strings
            if (/min|max|step/.test(method) && (type === null || /number|range|text/.test(type))) {
                value = Number(value);

                // Support Opera Mini, which returns NaN for undefined minlength
                if (isNaN(value)) {
                    value = undefined;
                }
            }

            if (value || value === 0) {
                rules[method] = value;
            } else if (type === method && type !== "range") {

                // Exception: the jquery validate 'range' method
                // does not test for the html5 'range' type
                rules[method] = true;
            }
        },

        attributeRules: function (element) {
            var rules = {},
                $element = $(element),
                type = element.getAttribute("type"),
                method, value;

            for (method in $.validator.methods) {

                // Support for <input required> in both html5 and older browsers
                if (method === "required") {
                    value = element.getAttribute(method);

                    // Some browsers return an empty string for the required attribute
                    // and non-HTML5 browsers might have required="" markup
                    if (value === "") {
                        value = true;
                    }

                    // Force non-HTML5 browsers to return bool
                    value = !!value;
                } else {
                    value = $element.attr(method);
                }

                this.normalizeAttributeRule(rules, type, method, value);
            }

            // 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
            if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
                delete rules.maxlength;
            }

            return rules;
        },

        dataRules: function (element) {
            var rules = {},
                $element = $(element),
                type = element.getAttribute("type"),
                method, value;

            for (method in $.validator.methods) {
                value = $element.data("rule" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase());
                this.normalizeAttributeRule(rules, type, method, value);
            }
            return rules;
        },

        staticRules: function (element) {
            var rules = {},
                validator = $.data(element.form, "validator");

            if (validator.settings.rules) {
                rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
            }
            return rules;
        },

        normalizeRules: function (rules, element) {

            // Handle dependency check
            $.each(rules, function (prop, val) {

                // Ignore rule when param is explicitly false, eg. required:false
                if (val === false) {
                    delete rules[prop];
                    return;
                }
                if (val.param || val.depends) {
                    var keepRule = true;
                    switch (typeof val.depends) {
                        case "string":
                            keepRule = !!$(val.depends, element.form).length;
                            break;
                        case "function":
                            keepRule = val.depends.call(element, element);
                            break;
                    }
                    if (keepRule) {
                        rules[prop] = val.param !== undefined ? val.param : true;
                    } else {
                        $.data(element.form, "validator").resetElements($(element));
                        delete rules[prop];
                    }
                }
            });

            // Evaluate parameters
            $.each(rules, function (rule, parameter) {
                rules[rule] = $.isFunction(parameter) && rule !== "normalizer" ? parameter(element) : parameter;
            });

            // Clean number parameters
            $.each(["minlength", "maxlength"], function () {
                if (rules[this]) {
                    rules[this] = Number(rules[this]);
                }
            });
            $.each(["rangelength", "range"], function () {
                var parts;
                if (rules[this]) {
                    if ($.isArray(rules[this])) {
                        rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
                    } else if (typeof rules[this] === "string") {
                        parts = rules[this].replace(/[\[\]]/g, "").split(/[\s,]+/);
                        rules[this] = [Number(parts[0]), Number(parts[1])];
                    }
                }
            });

            if ($.validator.autoCreateRanges) {

                // Auto-create ranges
                if (rules.min != null && rules.max != null) {
                    rules.range = [rules.min, rules.max];
                    delete rules.min;
                    delete rules.max;
                }
                if (rules.minlength != null && rules.maxlength != null) {
                    rules.rangelength = [rules.minlength, rules.maxlength];
                    delete rules.minlength;
                    delete rules.maxlength;
                }
            }

            return rules;
        },

        // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
        normalizeRule: function (data) {
            if (typeof data === "string") {
                var transformed = {};
                $.each(data.split(/\s/), function () {
                    transformed[this] = true;
                });
                data = transformed;
            }
            return data;
        },

        // https://jqueryvalidation.org/jQuery.validator.addMethod/
        addMethod: function (name, method, message) {
            $.validator.methods[name] = method;
            $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
            if (method.length < 3) {
                $.validator.addClassRules(name, $.validator.normalizeRule(name));
            }
        },

        // https://jqueryvalidation.org/jQuery.validator.methods/
        methods: {

            // https://jqueryvalidation.org/required-method/
            required: function (value, element, param) {

                // Check if dependency is met
                if (!this.depend(param, element)) {
                    return "dependency-mismatch";
                }
                if (element.nodeName.toLowerCase() === "select") {

                    // Could be an array for select-multiple or a string, both are fine this way
                    var val = $(element).val();
                    return val && val.length > 0;
                }
                if (this.checkable(element)) {
                    return this.getLength(value, element) > 0;
                }
                return value.length > 0;
            },

            // https://jqueryvalidation.org/email-method/
            email: function (value, element) {

                // From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address
                // Retrieved 2014-01-14
                // If you have a problem with this implementation, report a bug against the above spec
                // Or use custom methods to implement your own email validation
                return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);
            },

            // https://jqueryvalidation.org/url-method/
            url: function (value, element) {

                // Copyright (c) 2010-2013 Diego Perini, MIT licensed
                // https://gist.github.com/dperini/729294
                // see also https://mathiasbynens.be/demo/url-regex
                // modified to allow protocol-relative URLs
                return this.optional(element) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(value);
            },

            // https://jqueryvalidation.org/date-method/
            date: function (value, element) {
                return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
            },

            // https://jqueryvalidation.org/dateISO-method/
            dateISO: function (value, element) {
                return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
            },

            // https://jqueryvalidation.org/number-method/
            number: function (value, element) {
                return this.optional(element) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
            },

            // https://jqueryvalidation.org/digits-method/
            digits: function (value, element) {
                return this.optional(element) || /^\d+$/.test(value);
            },

            // https://jqueryvalidation.org/minlength-method/
            minlength: function (value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length >= param;
            },

            // https://jqueryvalidation.org/maxlength-method/
            maxlength: function (value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length <= param;
            },

            // https://jqueryvalidation.org/rangelength-method/
            rangelength: function (value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || (length >= param[0] && length <= param[1]);
            },

            // https://jqueryvalidation.org/min-method/
            min: function (value, element, param) {
                return this.optional(element) || value >= param;
            },

            // https://jqueryvalidation.org/max-method/
            max: function (value, element, param) {
                return this.optional(element) || value <= param;
            },

            // https://jqueryvalidation.org/range-method/
            range: function (value, element, param) {
                return this.optional(element) || (value >= param[0] && value <= param[1]);
            },

            // https://jqueryvalidation.org/step-method/
            step: function (value, element, param) {
                var type = $(element).attr("type"),
                    errorMessage = "Step attribute on input type " + type + " is not supported.",
                    supportedTypes = ["text", "number", "range"],
                    re = new RegExp("\\b" + type + "\\b"),
                    notSupported = type && !re.test(supportedTypes.join()),
                    decimalPlaces = function (num) {
                        var match = ("" + num).match(/(?:\.(\d+))?$/);
                        if (!match) {
                            return 0;
                        }

                        // Number of digits right of decimal point.
                        return match[1] ? match[1].length : 0;
                    },
                    toInt = function (num) {
                        return Math.round(num * Math.pow(10, decimals));
                    },
                    valid = true,
                    decimals;

                // Works only for text, number and range input types
                // TODO find a way to support input types date, datetime, datetime-local, month, time and week
                if (notSupported) {
                    throw new Error(errorMessage);
                }

                decimals = decimalPlaces(param);

                // Value can't have too many decimals
                if (decimalPlaces(value) > decimals || toInt(value) % toInt(param) !== 0) {
                    valid = false;
                }

                return this.optional(element) || valid;
            },

            // https://jqueryvalidation.org/equalTo-method/
            equalTo: function (value, element, param) {

                // Bind to the blur event of the target in order to revalidate whenever the target field is updated
                var target = $(param);
                if (this.settings.onfocusout && target.not(".validate-equalTo-blur").length) {
                    target.addClass("validate-equalTo-blur").on("blur.validate-equalTo", function () {
                        $(element).valid();
                    });
                }
                return value === target.val();
            },

            // https://jqueryvalidation.org/remote-method/
            remote: function (value, element, param, method) {
                if (this.optional(element)) {
                    return "dependency-mismatch";
                }

                method = typeof method === "string" && method || "remote";

                var previous = this.previousValue(element, method),
                    validator, data, optionDataString;

                if (!this.settings.messages[element.name]) {
                    this.settings.messages[element.name] = {};
                }
                previous.originalMessage = previous.originalMessage || this.settings.messages[element.name][method];
                this.settings.messages[element.name][method] = previous.message;

                param = typeof param === "string" && {url: param} || param;
                optionDataString = $.param($.extend({data: value}, param.data));
                if (previous.old === optionDataString) {
                    return previous.valid;
                }

                previous.old = optionDataString;
                validator = this;
                this.startRequest(element);
                data = {};
                data[element.name] = value;
                $.ajax($.extend(true, {
                    mode: "abort",
                    port: "validate" + element.name,
                    dataType: "json",
                    data: data,
                    context: validator.currentForm,
                    success: function (response) {
                        var valid = response === true || response === "true",
                            errors, message, submitted;

                        validator.settings.messages[element.name][method] = previous.originalMessage;
                        if (valid) {
                            submitted = validator.formSubmitted;
                            validator.resetInternals();
                            validator.toHide = validator.errorsFor(element);
                            validator.formSubmitted = submitted;
                            validator.successList.push(element);
                            validator.invalid[element.name] = false;
                            validator.showErrors();
                        } else {
                            errors = {};
                            message = response || validator.defaultMessage(element, {
                                method: method,
                                parameters: value
                            });
                            errors[element.name] = previous.message = message;
                            validator.invalid[element.name] = true;
                            validator.showErrors(errors);
                        }
                        previous.valid = valid;
                        validator.stopRequest(element, valid);
                    }
                }, param));
                return "pending";
            }
        }

    });

// Ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

    var pendingRequests = {},
        ajax;

// Use a prefilter if available (1.5+)
    if ($.ajaxPrefilter) {
        $.ajaxPrefilter(function (settings, _, xhr) {
            var port = settings.port;
            if (settings.mode === "abort") {
                if (pendingRequests[port]) {
                    pendingRequests[port].abort();
                }
                pendingRequests[port] = xhr;
            }
        });
    } else {

        // Proxy ajax
        ajax = $.ajax;
        $.ajax = function (settings) {
            var mode = ("mode" in settings ? settings : $.ajaxSettings).mode,
                port = ("port" in settings ? settings : $.ajaxSettings).port;
            if (mode === "abort") {
                if (pendingRequests[port]) {
                    pendingRequests[port].abort();
                }
                pendingRequests[port] = ajax.apply(this, arguments);
                return pendingRequests[port];
            }
            return ajax.apply(this, arguments);
        };
    }
    return $;
}));
/*!
 * jQuery Validation Plugin v1.17.0
 *
 * https://jqueryvalidation.org/
 *
 * Copyright (c) 2017 Jörn Zaefferer
 * Released under the MIT license
 */
(function (factory) {
    if (typeof define === "function" && define.amd) {
        define(["jquery", "./jquery.validate"], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
}(function ($) {

    (function () {

        function stripHtml(value) {

            // Remove html tags and space chars
            return value.replace(/<.[^<>]*?>/g, " ").replace(/&nbsp;|&#160;/gi, " ")

            // Remove punctuation
                .replace(/[.(),;:!?%#$'\"_+=\/\-“”’]*/g, "");
        }

        $.validator.addMethod("maxWords", function (value, element, params) {
            return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length <= params;
        }, $.validator.format("Please enter {0} words or less."));

        $.validator.addMethod("minWords", function (value, element, params) {
            return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length >= params;
        }, $.validator.format("Please enter at least {0} words."));

        $.validator.addMethod("rangeWords", function (value, element, params) {
            var valueStripped = stripHtml(value),
                regex = /\b\w+\b/g;
            return this.optional(element) || valueStripped.match(regex).length >= params[0] && valueStripped.match(regex).length <= params[1];
        }, $.validator.format("Please enter between {0} and {1} words."));

    }());

// Accept a value from a file input based on a required mimetype
    $.validator.addMethod("accept", function (value, element, param) {

        // Split mime on commas in case we have multiple types we can accept
        var typeParam = typeof param === "string" ? param.replace(/\s/g, "") : "image/*",
            optionalValue = this.optional(element),
            i, file, regex;

        // Element is optional
        if (optionalValue) {
            return optionalValue;
        }

        if ($(element).attr("type") === "file") {

            // Escape string to be used in the regex
            // see: https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
            // Escape also "/*" as "/.*" as a wildcard
            typeParam = typeParam
                .replace(/[\-\[\]\/\{\}\(\)\+\?\.\\\^\$\|]/g, "\\$&")
                .replace(/,/g, "|")
                .replace(/\/\*/g, "/.*");

            // Check if the element has a FileList before checking each file
            if (element.files && element.files.length) {
                regex = new RegExp(".?(" + typeParam + ")$", "i");
                for (i = 0; i < element.files.length; i++) {
                    file = element.files[i];

                    // Grab the mimetype from the loaded file, verify it matches
                    if (!file.type.match(regex)) {
                        return false;
                    }
                }
            }
        }

        // Either return true because we've validated each file, or because the
        // browser does not support element.files and the FileList feature
        return true;
    }, $.validator.format("Please enter a value with a valid mimetype."));

    $.validator.addMethod("alphanumeric", function (value, element) {
        return this.optional(element) || /^\w+$/i.test(value);
    }, "Letters, numbers, and underscores only please");

    /*
 * Dutch bank account numbers (not 'giro' numbers) have 9 digits
 * and pass the '11 check'.
 * We accept the notation with spaces, as that is common.
 * acceptable: 123456789 or 12 34 56 789
 */
    $.validator.addMethod("bankaccountNL", function (value, element) {
        if (this.optional(element)) {
            return true;
        }
        if (!(/^[0-9]{9}|([0-9]{2} ){3}[0-9]{3}$/.test(value))) {
            return false;
        }

        // Now '11 check'
        var account = value.replace(/ /g, ""), // Remove spaces
            sum = 0,
            len = account.length,
            pos, factor, digit;
        for (pos = 0; pos < len; pos++) {
            factor = len - pos;
            digit = account.substring(pos, pos + 1);
            sum = sum + factor * digit;
        }
        return sum % 11 === 0;
    }, "Please specify a valid bank account number");

    $.validator.addMethod("bankorgiroaccountNL", function (value, element) {
        return this.optional(element) ||
            ($.validator.methods.bankaccountNL.call(this, value, element)) ||
            ($.validator.methods.giroaccountNL.call(this, value, element));
    }, "Please specify a valid bank or giro account number");

    /**
     * BIC is the business identifier code (ISO 9362). This BIC check is not a guarantee for authenticity.
     *
     * BIC pattern: BBBBCCLLbbb (8 or 11 characters long; bbb is optional)
     *
     * Validation is case-insensitive. Please make sure to normalize input yourself.
     *
     * BIC definition in detail:
     * - First 4 characters - bank code (only letters)
     * - Next 2 characters - ISO 3166-1 alpha-2 country code (only letters)
     * - Next 2 characters - location code (letters and digits)
     *   a. shall not start with '0' or '1'
     *   b. second character must be a letter ('O' is not allowed) or digit ('0' for test (therefore not allowed), '1' denoting passive participant, '2' typically reverse-billing)
     * - Last 3 characters - branch code, optional (shall not start with 'X' except in case of 'XXX' for primary office) (letters and digits)
     */
    $.validator.addMethod("bic", function (value, element) {
        return this.optional(element) || /^([A-Z]{6}[A-Z2-9][A-NP-Z1-9])(X{3}|[A-WY-Z0-9][A-Z0-9]{2})?$/.test(value.toUpperCase());
    }, "Please specify a valid BIC code");

    /*
 * Código de identificación fiscal ( CIF ) is the tax identification code for Spanish legal entities
 * Further rules can be found in Spanish on http://es.wikipedia.org/wiki/C%C3%B3digo_de_identificaci%C3%B3n_fiscal
 *
 * Spanish CIF structure:
 *
 * [ T ][ P ][ P ][ N ][ N ][ N ][ N ][ N ][ C ]
 *
 * Where:
 *
 * T: 1 character. Kind of Organization Letter: [ABCDEFGHJKLMNPQRSUVW]
 * P: 2 characters. Province.
 * N: 5 characters. Secuencial Number within the province.
 * C: 1 character. Control Digit: [0-9A-J].
 *
 * [ T ]: Kind of Organizations. Possible values:
 *
 *   A. Corporations
 *   B. LLCs
 *   C. General partnerships
 *   D. Companies limited partnerships
 *   E. Communities of goods
 *   F. Cooperative Societies
 *   G. Associations
 *   H. Communities of homeowners in horizontal property regime
 *   J. Civil Societies
 *   K. Old format
 *   L. Old format
 *   M. Old format
 *   N. Nonresident entities
 *   P. Local authorities
 *   Q. Autonomous bodies, state or not, and the like, and congregations and religious institutions
 *   R. Congregations and religious institutions (since 2008 ORDER EHA/451/2008)
 *   S. Organs of State Administration and regions
 *   V. Agrarian Transformation
 *   W. Permanent establishments of non-resident in Spain
 *
 * [ C ]: Control Digit. It can be a number or a letter depending on T value:
 * [ T ]  -->  [ C ]
 * ------    ----------
 *   A         Number
 *   B         Number
 *   E         Number
 *   H         Number
 *   K         Letter
 *   P         Letter
 *   Q         Letter
 *   S         Letter
 *
 */
    $.validator.addMethod("cifES", function (value, element) {
        "use strict";

        if (this.optional(element)) {
            return true;
        }

        var cifRegEx = new RegExp(/^([ABCDEFGHJKLMNPQRSUVW])(\d{7})([0-9A-J])$/gi);
        var letter = value.substring(0, 1), // [ T ]
            number = value.substring(1, 8), // [ P ][ P ][ N ][ N ][ N ][ N ][ N ]
            control = value.substring(8, 9), // [ C ]
            all_sum = 0,
            even_sum = 0,
            odd_sum = 0,
            i, n,
            control_digit,
            control_letter;

        function isOdd(n) {
            return n % 2 === 0;
        }

        // Quick format test
        if (value.length !== 9 || !cifRegEx.test(value)) {
            return false;
        }

        for (i = 0; i < number.length; i++) {
            n = parseInt(number[i], 10);

            // Odd positions
            if (isOdd(i)) {

                // Odd positions are multiplied first.
                n *= 2;

                // If the multiplication is bigger than 10 we need to adjust
                odd_sum += n < 10 ? n : n - 9;

                // Even positions
                // Just sum them
            } else {
                even_sum += n;
            }
        }

        all_sum = even_sum + odd_sum;
        control_digit = (10 - (all_sum).toString().substr(-1)).toString();
        control_digit = parseInt(control_digit, 10) > 9 ? "0" : control_digit;
        control_letter = "JABCDEFGHI".substr(control_digit, 1).toString();

        // Control must be a digit
        if (letter.match(/[ABEH]/)) {
            return control === control_digit;

            // Control must be a letter
        } else if (letter.match(/[KPQS]/)) {
            return control === control_letter;
        }

        // Can be either
        return control === control_digit || control === control_letter;

    }, "Please specify a valid CIF number.");

    /*
 * Brazillian CPF number (Cadastrado de Pessoas Físicas) is the equivalent of a Brazilian tax registration number.
 * CPF numbers have 11 digits in total: 9 numbers followed by 2 check numbers that are being used for validation.
 */
    $.validator.addMethod("cpfBR", function (value) {

        // Removing special characters from value
        value = value.replace(/([~!@#$%^&*()_+=`{}\[\]\-|\\:;'<>,.\/? ])+/g, "");

        // Checking value to have 11 digits only
        if (value.length !== 11) {
            return false;
        }

        var sum = 0,
            firstCN, secondCN, checkResult, i;

        firstCN = parseInt(value.substring(9, 10), 10);
        secondCN = parseInt(value.substring(10, 11), 10);

        checkResult = function (sum, cn) {
            var result = (sum * 10) % 11;
            if ((result === 10) || (result === 11)) {
                result = 0;
            }
            return (result === cn);
        };

        // Checking for dump data
        if (value === "" ||
            value === "00000000000" ||
            value === "11111111111" ||
            value === "22222222222" ||
            value === "33333333333" ||
            value === "44444444444" ||
            value === "55555555555" ||
            value === "66666666666" ||
            value === "77777777777" ||
            value === "88888888888" ||
            value === "99999999999"
        ) {
            return false;
        }

        // Step 1 - using first Check Number:
        for (i = 1; i <= 9; i++) {
            sum = sum + parseInt(value.substring(i - 1, i), 10) * (11 - i);
        }

        // If first Check Number (CN) is valid, move to Step 2 - using second Check Number:
        if (checkResult(sum, firstCN)) {
            sum = 0;
            for (i = 1; i <= 10; i++) {
                sum = sum + parseInt(value.substring(i - 1, i), 10) * (12 - i);
            }
            return checkResult(sum, secondCN);
        }
        return false;

    }, "Please specify a valid CPF number");

// https://jqueryvalidation.org/creditcard-method/
// based on https://en.wikipedia.org/wiki/Luhn_algorithm
    $.validator.addMethod("creditcard", function (value, element) {
        if (this.optional(element)) {
            return "dependency-mismatch";
        }

        // Accept only spaces, digits and dashes
        if (/[^0-9 \-]+/.test(value)) {
            return false;
        }

        var nCheck = 0,
            nDigit = 0,
            bEven = false,
            n, cDigit;

        value = value.replace(/\D/g, "");

        // Basing min and max length on
        // https://developer.ean.com/general_info/Valid_Credit_Card_Types
        if (value.length < 13 || value.length > 19) {
            return false;
        }

        for (n = value.length - 1; n >= 0; n--) {
            cDigit = value.charAt(n);
            nDigit = parseInt(cDigit, 10);
            if (bEven) {
                if ((nDigit *= 2) > 9) {
                    nDigit -= 9;
                }
            }

            nCheck += nDigit;
            bEven = !bEven;
        }

        return (nCheck % 10) === 0;
    }, "Please enter a valid credit card number.");

    /* NOTICE: Modified version of Castle.Components.Validator.CreditCardValidator
 * Redistributed under the the Apache License 2.0 at http://www.apache.org/licenses/LICENSE-2.0
 * Valid Types: mastercard, visa, amex, dinersclub, enroute, discover, jcb, unknown, all (overrides all other settings)
 */
    $.validator.addMethod("creditcardtypes", function (value, element, param) {
        if (/[^0-9\-]+/.test(value)) {
            return false;
        }

        value = value.replace(/\D/g, "");

        var validTypes = 0x0000;

        if (param.mastercard) {
            validTypes |= 0x0001;
        }
        if (param.visa) {
            validTypes |= 0x0002;
        }
        if (param.amex) {
            validTypes |= 0x0004;
        }
        if (param.dinersclub) {
            validTypes |= 0x0008;
        }
        if (param.enroute) {
            validTypes |= 0x0010;
        }
        if (param.discover) {
            validTypes |= 0x0020;
        }
        if (param.jcb) {
            validTypes |= 0x0040;
        }
        if (param.unknown) {
            validTypes |= 0x0080;
        }
        if (param.all) {
            validTypes = 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080;
        }
        if (validTypes & 0x0001 && /^(5[12345])/.test(value)) { // Mastercard
            return value.length === 16;
        }
        if (validTypes & 0x0002 && /^(4)/.test(value)) { // Visa
            return value.length === 16;
        }
        if (validTypes & 0x0004 && /^(3[47])/.test(value)) { // Amex
            return value.length === 15;
        }
        if (validTypes & 0x0008 && /^(3(0[012345]|[68]))/.test(value)) { // Dinersclub
            return value.length === 14;
        }
        if (validTypes & 0x0010 && /^(2(014|149))/.test(value)) { // Enroute
            return value.length === 15;
        }
        if (validTypes & 0x0020 && /^(6011)/.test(value)) { // Discover
            return value.length === 16;
        }
        if (validTypes & 0x0040 && /^(3)/.test(value)) { // Jcb
            return value.length === 16;
        }
        if (validTypes & 0x0040 && /^(2131|1800)/.test(value)) { // Jcb
            return value.length === 15;
        }
        if (validTypes & 0x0080) { // Unknown
            return true;
        }
        return false;
    }, "Please enter a valid credit card number.");

    /**
     * Validates currencies with any given symbols by @jameslouiz
     * Symbols can be optional or required. Symbols required by default
     *
     * Usage examples:
     *  currency: ["£", false] - Use false for soft currency validation
     *  currency: ["$", false]
     *  currency: ["RM", false] - also works with text based symbols such as "RM" - Malaysia Ringgit etc
     *
     *  <input class="currencyInput" name="currencyInput">
     *
     * Soft symbol checking
     *  currencyInput: {
 *     currency: ["$", false]
 *  }
     *
     * Strict symbol checking (default)
     *  currencyInput: {
 *     currency: "$"
 *     //OR
 *     currency: ["$", true]
 *  }
     *
     * Multiple Symbols
     *  currencyInput: {
 *     currency: "$,£,¢"
 *  }
     */
    $.validator.addMethod("currency", function (value, element, param) {
        var isParamString = typeof param === "string",
            symbol = isParamString ? param : param[0],
            soft = isParamString ? true : param[1],
            regex;

        symbol = symbol.replace(/,/g, "");
        symbol = soft ? symbol + "]" : symbol + "]?";
        regex = "^[" + symbol + "([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$";
        regex = new RegExp(regex);
        return this.optional(element) || regex.test(value);

    }, "Please specify a valid currency");

    $.validator.addMethod("dateFA", function (value, element) {
        return this.optional(element) || /^[1-4]\d{3}\/((0?[1-6]\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\/(30|([1-2][0-9])|(0?[1-9]))))$/.test(value);
    }, $.validator.messages.date);

    /**
     * Return true, if the value is a valid date, also making this formal check dd/mm/yyyy.
     *
     * @example $.validator.methods.date("01/01/1900")
     * @result true
     *
     * @example $.validator.methods.date("01/13/1990")
     * @result false
     *
     * @example $.validator.methods.date("01.01.1900")
     * @result false
     *
     * @example <input name="pippo" class="{dateITA:true}" />
     * @desc Declares an optional input element whose value must be a valid date.
     *
     * @name $.validator.methods.dateITA
     * @type Boolean
     * @cat Plugins/Validate/Methods
     */
    $.validator.addMethod("dateITA", function (value, element) {
        var check = false,
            re = /^\d{1,2}\/\d{1,2}\/\d{4}$/,
            adata, gg, mm, aaaa, xdata;
        if (re.test(value)) {
            adata = value.split("/");
            gg = parseInt(adata[0], 10);
            mm = parseInt(adata[1], 10);
            aaaa = parseInt(adata[2], 10);
            xdata = new Date(Date.UTC(aaaa, mm - 1, gg, 12, 0, 0, 0));
            if ((xdata.getUTCFullYear() === aaaa) && (xdata.getUTCMonth() === mm - 1) && (xdata.getUTCDate() === gg)) {
                check = true;
            } else {
                check = false;
            }
        } else {
            check = false;
        }
        return this.optional(element) || check;
    }, $.validator.messages.date);

    $.validator.addMethod("dateNL", function (value, element) {
        return this.optional(element) || /^(0?[1-9]|[12]\d|3[01])[\.\/\-](0?[1-9]|1[012])[\.\/\-]([12]\d)?(\d\d)$/.test(value);
    }, $.validator.messages.date);

// Older "accept" file extension method. Old docs: http://docs.jquery.com/Plugins/Validation/Methods/accept
    $.validator.addMethod("extension", function (value, element, param) {
        param = typeof param === "string" ? param.replace(/,/g, "|") : "png|jpe?g|gif";
        return this.optional(element) || value.match(new RegExp("\\.(" + param + ")$", "i"));
    }, $.validator.format("Please enter a value with a valid extension."));

    /**
     * Dutch giro account numbers (not bank numbers) have max 7 digits
     */
    $.validator.addMethod("giroaccountNL", function (value, element) {
        return this.optional(element) || /^[0-9]{1,7}$/.test(value);
    }, "Please specify a valid giro account number");

    /**
     * IBAN is the international bank account number.
     * It has a country - specific format, that is checked here too
     *
     * Validation is case-insensitive. Please make sure to normalize input yourself.
     */
    $.validator.addMethod("iban", function (value, element) {

        // Some quick simple tests to prevent needless work
        if (this.optional(element)) {
            return true;
        }

        // Remove spaces and to upper case
        var iban = value.replace(/ /g, "").toUpperCase(),
            ibancheckdigits = "",
            leadingZeroes = true,
            cRest = "",
            cOperator = "",
            countrycode, ibancheck, charAt, cChar, bbanpattern, bbancountrypatterns, ibanregexp, i, p;

        // Check for IBAN code length.
        // It contains:
        // country code ISO 3166-1 - two letters,
        // two check digits,
        // Basic Bank Account Number (BBAN) - up to 30 chars
        var minimalIBANlength = 5;
        if (iban.length < minimalIBANlength) {
            return false;
        }

        // Check the country code and find the country specific format
        countrycode = iban.substring(0, 2);
        bbancountrypatterns = {
            "AL": "\\d{8}[\\dA-Z]{16}",
            "AD": "\\d{8}[\\dA-Z]{12}",
            "AT": "\\d{16}",
            "AZ": "[\\dA-Z]{4}\\d{20}",
            "BE": "\\d{12}",
            "BH": "[A-Z]{4}[\\dA-Z]{14}",
            "BA": "\\d{16}",
            "BR": "\\d{23}[A-Z][\\dA-Z]",
            "BG": "[A-Z]{4}\\d{6}[\\dA-Z]{8}",
            "CR": "\\d{17}",
            "HR": "\\d{17}",
            "CY": "\\d{8}[\\dA-Z]{16}",
            "CZ": "\\d{20}",
            "DK": "\\d{14}",
            "DO": "[A-Z]{4}\\d{20}",
            "EE": "\\d{16}",
            "FO": "\\d{14}",
            "FI": "\\d{14}",
            "FR": "\\d{10}[\\dA-Z]{11}\\d{2}",
            "GE": "[\\dA-Z]{2}\\d{16}",
            "DE": "\\d{18}",
            "GI": "[A-Z]{4}[\\dA-Z]{15}",
            "GR": "\\d{7}[\\dA-Z]{16}",
            "GL": "\\d{14}",
            "GT": "[\\dA-Z]{4}[\\dA-Z]{20}",
            "HU": "\\d{24}",
            "IS": "\\d{22}",
            "IE": "[\\dA-Z]{4}\\d{14}",
            "IL": "\\d{19}",
            "IT": "[A-Z]\\d{10}[\\dA-Z]{12}",
            "KZ": "\\d{3}[\\dA-Z]{13}",
            "KW": "[A-Z]{4}[\\dA-Z]{22}",
            "LV": "[A-Z]{4}[\\dA-Z]{13}",
            "LB": "\\d{4}[\\dA-Z]{20}",
            "LI": "\\d{5}[\\dA-Z]{12}",
            "LT": "\\d{16}",
            "LU": "\\d{3}[\\dA-Z]{13}",
            "MK": "\\d{3}[\\dA-Z]{10}\\d{2}",
            "MT": "[A-Z]{4}\\d{5}[\\dA-Z]{18}",
            "MR": "\\d{23}",
            "MU": "[A-Z]{4}\\d{19}[A-Z]{3}",
            "MC": "\\d{10}[\\dA-Z]{11}\\d{2}",
            "MD": "[\\dA-Z]{2}\\d{18}",
            "ME": "\\d{18}",
            "NL": "[A-Z]{4}\\d{10}",
            "NO": "\\d{11}",
            "PK": "[\\dA-Z]{4}\\d{16}",
            "PS": "[\\dA-Z]{4}\\d{21}",
            "PL": "\\d{24}",
            "PT": "\\d{21}",
            "RO": "[A-Z]{4}[\\dA-Z]{16}",
            "SM": "[A-Z]\\d{10}[\\dA-Z]{12}",
            "SA": "\\d{2}[\\dA-Z]{18}",
            "RS": "\\d{18}",
            "SK": "\\d{20}",
            "SI": "\\d{15}",
            "ES": "\\d{20}",
            "SE": "\\d{20}",
            "CH": "\\d{5}[\\dA-Z]{12}",
            "TN": "\\d{20}",
            "TR": "\\d{5}[\\dA-Z]{17}",
            "AE": "\\d{3}\\d{16}",
            "GB": "[A-Z]{4}\\d{14}",
            "VG": "[\\dA-Z]{4}\\d{16}"
        };

        bbanpattern = bbancountrypatterns[countrycode];

        // As new countries will start using IBAN in the
        // future, we only check if the countrycode is known.
        // This prevents false negatives, while almost all
        // false positives introduced by this, will be caught
        // by the checksum validation below anyway.
        // Strict checking should return FALSE for unknown
        // countries.
        if (typeof bbanpattern !== "undefined") {
            ibanregexp = new RegExp("^[A-Z]{2}\\d{2}" + bbanpattern + "$", "");
            if (!(ibanregexp.test(iban))) {
                return false; // Invalid country specific format
            }
        }

        // Now check the checksum, first convert to digits
        ibancheck = iban.substring(4, iban.length) + iban.substring(0, 4);
        for (i = 0; i < ibancheck.length; i++) {
            charAt = ibancheck.charAt(i);
            if (charAt !== "0") {
                leadingZeroes = false;
            }
            if (!leadingZeroes) {
                ibancheckdigits += "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(charAt);
            }
        }

        // Calculate the result of: ibancheckdigits % 97
        for (p = 0; p < ibancheckdigits.length; p++) {
            cChar = ibancheckdigits.charAt(p);
            cOperator = "" + cRest + "" + cChar;
            cRest = cOperator % 97;
        }
        return cRest === 1;
    }, "Please specify a valid IBAN");

    $.validator.addMethod("integer", function (value, element) {
        return this.optional(element) || /^-?\d+$/.test(value);
    }, "A positive or negative non-decimal number please");

    $.validator.addMethod("ipv4", function (value, element) {
        return this.optional(element) || /^(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)$/i.test(value);
    }, "Please enter a valid IP v4 address.");

    $.validator.addMethod("ipv6", function (value, element) {
        return this.optional(element) || /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test(value);
    }, "Please enter a valid IP v6 address.");

    $.validator.addMethod("lettersonly", function (value, element) {
        return this.optional(element) || /^[a-z]+$/i.test(value);
    }, "Letters only please");

    $.validator.addMethod("letterswithbasicpunc", function (value, element) {
        return this.optional(element) || /^[a-z\-.,()'"\s]+$/i.test(value);
    }, "Letters or punctuation only please");

    $.validator.addMethod("mobileNL", function (value, element) {
        return this.optional(element) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)6((\s|\s?\-\s?)?[0-9]){8}$/.test(value);
    }, "Please specify a valid mobile number");

    /* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
    $.validator.addMethod("mobileUK", function (phone_number, element) {
        phone_number = phone_number.replace(/\(|\)|\s+|-/g, "");
        return this.optional(element) || phone_number.length > 9 &&
            phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?|0)7(?:[1345789]\d{2}|624)\s?\d{3}\s?\d{3})$/);
    }, "Please specify a valid mobile number");

    $.validator.addMethod("netmask", function (value, element) {
        return this.optional(element) || /^(254|252|248|240|224|192|128)\.0\.0\.0|255\.(254|252|248|240|224|192|128|0)\.0\.0|255\.255\.(254|252|248|240|224|192|128|0)\.0|255\.255\.255\.(254|252|248|240|224|192|128|0)/i.test(value);
    }, "Please enter a valid netmask.");

    /*
 * The NIE (Número de Identificación de Extranjero) is a Spanish tax identification number assigned by the Spanish
 * authorities to any foreigner.
 *
 * The NIE is the equivalent of a Spaniards Número de Identificación Fiscal (NIF) which serves as a fiscal
 * identification number. The CIF number (Certificado de Identificación Fiscal) is equivalent to the NIF, but applies to
 * companies rather than individuals. The NIE consists of an 'X' or 'Y' followed by 7 or 8 digits then another letter.
 */
    $.validator.addMethod("nieES", function (value, element) {
        "use strict";

        if (this.optional(element)) {
            return true;
        }

        var nieRegEx = new RegExp(/^[MXYZ]{1}[0-9]{7,8}[TRWAGMYFPDXBNJZSQVHLCKET]{1}$/gi);
        var validChars = "TRWAGMYFPDXBNJZSQVHLCKET",
            letter = value.substr(value.length - 1).toUpperCase(),
            number;

        value = value.toString().toUpperCase();

        // Quick format test
        if (value.length > 10 || value.length < 9 || !nieRegEx.test(value)) {
            return false;
        }

        // X means same number
        // Y means number + 10000000
        // Z means number + 20000000
        value = value.replace(/^[X]/, "0")
            .replace(/^[Y]/, "1")
            .replace(/^[Z]/, "2");

        number = value.length === 9 ? value.substr(0, 8) : value.substr(0, 9);

        return validChars.charAt(parseInt(number, 10) % 23) === letter;

    }, "Please specify a valid NIE number.");

    /*
 * The Número de Identificación Fiscal ( NIF ) is the way tax identification used in Spain for individuals
 */
    $.validator.addMethod("nifES", function (value, element) {
        "use strict";

        if (this.optional(element)) {
            return true;
        }

        value = value.toUpperCase();

        // Basic format test
        if (!value.match("((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)")) {
            return false;
        }

        // Test NIF
        if (/^[0-9]{8}[A-Z]{1}$/.test(value)) {
            return ("TRWAGMYFPDXBNJZSQVHLCKE".charAt(value.substring(8, 0) % 23) === value.charAt(8));
        }

        // Test specials NIF (starts with K, L or M)
        if (/^[KLM]{1}/.test(value)) {
            return (value[8] === "TRWAGMYFPDXBNJZSQVHLCKE".charAt(value.substring(8, 1) % 23));
        }

        return false;

    }, "Please specify a valid NIF number.");

    /*
 * Numer identyfikacji podatkowej ( NIP ) is the way tax identification used in Poland for companies
 */
    $.validator.addMethod("nipPL", function (value) {
        "use strict";

        value = value.replace(/[^0-9]/g, "");

        if (value.length !== 10) {
            return false;
        }

        var arrSteps = [6, 5, 7, 2, 3, 4, 5, 6, 7];
        var intSum = 0;
        for (var i = 0; i < 9; i++) {
            intSum += arrSteps[i] * value[i];
        }
        var int2 = intSum % 11;
        var intControlNr = (int2 === 10) ? 0 : int2;

        return (intControlNr === parseInt(value[9], 10));
    }, "Please specify a valid NIP number.");

    $.validator.addMethod("notEqualTo", function (value, element, param) {
        return this.optional(element) || !$.validator.methods.equalTo.call(this, value, element, param);
    }, "Please enter a different value, values must not be the same.");

    $.validator.addMethod("nowhitespace", function (value, element) {
        return this.optional(element) || /^\S+$/i.test(value);
    }, "No white space please");

    /**
     * Return true if the field value matches the given format RegExp
     *
     * @example $.validator.methods.pattern("AR1004",element,/^AR\d{4}$/)
     * @result true
     *
     * @example $.validator.methods.pattern("BR1004",element,/^AR\d{4}$/)
     * @result false
     *
     * @name $.validator.methods.pattern
     * @type Boolean
     * @cat Plugins/Validate/Methods
     */
    $.validator.addMethod("pattern", function (value, element, param) {
        if (this.optional(element)) {
            return true;
        }
        if (typeof param === "string") {
            param = new RegExp("^(?:" + param + ")$");
        }
        return param.test(value);
    }, "Invalid format.");

    /**
     * Dutch phone numbers have 10 digits (or 11 and start with +31).
     */
    $.validator.addMethod("phoneNL", function (value, element) {
        return this.optional(element) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)[1-9]((\s|\s?\-\s?)?[0-9]){8}$/.test(value);
    }, "Please specify a valid phone number.");

    /* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */

// Matches UK landline + mobile, accepting only 01-3 for landline or 07 for mobile to exclude many premium numbers
    $.validator.addMethod("phonesUK", function (phone_number, element) {
        phone_number = phone_number.replace(/\(|\)|\s+|-/g, "");
        return this.optional(element) || phone_number.length > 9 &&
            phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?|0)(?:1\d{8,9}|[23]\d{9}|7(?:[1345789]\d{8}|624\d{6})))$/);
    }, "Please specify a valid uk phone number");

    /* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
    $.validator.addMethod("phoneUK", function (phone_number, element) {
        phone_number = phone_number.replace(/\(|\)|\s+|-/g, "");
        return this.optional(element) || phone_number.length > 9 &&
            phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?)|(?:\(?0))(?:\d{2}\)?\s?\d{4}\s?\d{4}|\d{3}\)?\s?\d{3}\s?\d{3,4}|\d{4}\)?\s?(?:\d{5}|\d{3}\s?\d{3})|\d{5}\)?\s?\d{4,5})$/);
    }, "Please specify a valid phone number");

    /**
     * Matches US phone number format
     *
     * where the area code may not start with 1 and the prefix may not start with 1
     * allows '-' or ' ' as a separator and allows parens around area code
     * some people may want to put a '1' in front of their number
     *
     * 1(212)-999-2345 or
     * 212 999 2344 or
     * 212-999-0983
     *
     * but not
     * 111-123-5434
     * and not
     * 212 123 4567
     */
    $.validator.addMethod("phoneUS", function (phone_number, element) {
        phone_number = phone_number.replace(/\s+/g, "");
        return this.optional(element) || phone_number.length > 9 &&
            phone_number.match(/^(\+?1-?)?(\([2-9]([02-9]\d|1[02-9])\)|[2-9]([02-9]\d|1[02-9]))-?[2-9]([02-9]\d|1[02-9])-?\d{4}$/);
    }, "Please specify a valid phone number");

    /*
* Valida CEPs do brasileiros:
*
* Formatos aceitos:
* 99999-999
* 99.999-999
* 99999999
*/
    $.validator.addMethod("postalcodeBR", function (cep_value, element) {
        return this.optional(element) || /^\d{2}.\d{3}-\d{3}?$|^\d{5}-?\d{3}?$/.test(cep_value);
    }, "Informe um CEP válido.");

    /**
     * Matches a valid Canadian Postal Code
     *
     * @example jQuery.validator.methods.postalCodeCA( "H0H 0H0", element )
     * @result true
     *
     * @example jQuery.validator.methods.postalCodeCA( "H0H0H0", element )
     * @result false
     *
     * @name jQuery.validator.methods.postalCodeCA
     * @type Boolean
     * @cat Plugins/Validate/Methods
     */
    $.validator.addMethod("postalCodeCA", function (value, element) {
        return this.optional(element) || /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ] *\d[ABCEGHJKLMNPRSTVWXYZ]\d$/i.test(value);
    }, "Please specify a valid postal code");

    /* Matches Italian postcode (CAP) */
    $.validator.addMethod("postalcodeIT", function (value, element) {
        return this.optional(element) || /^\d{5}$/.test(value);
    }, "Please specify a valid postal code");

    $.validator.addMethod("postalcodeNL", function (value, element) {
        return this.optional(element) || /^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/.test(value);
    }, "Please specify a valid postal code");

// Matches UK postcode. Does not match to UK Channel Islands that have their own postcodes (non standard UK)
    $.validator.addMethod("postcodeUK", function (value, element) {
        return this.optional(element) || /^((([A-PR-UWYZ][0-9])|([A-PR-UWYZ][0-9][0-9])|([A-PR-UWYZ][A-HK-Y][0-9])|([A-PR-UWYZ][A-HK-Y][0-9][0-9])|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\s?([0-9][ABD-HJLNP-UW-Z]{2})|(GIR)\s?(0AA))$/i.test(value);
    }, "Please specify a valid UK postcode");

    /*
 * Lets you say "at least X inputs that match selector Y must be filled."
 *
 * The end result is that neither of these inputs:
 *
 *	<input class="productinfo" name="partnumber">
 *	<input class="productinfo" name="description">
 *
 *	...will validate unless at least one of them is filled.
 *
 * partnumber:	{require_from_group: [1,".productinfo"]},
 * description: {require_from_group: [1,".productinfo"]}
 *
 * options[0]: number of fields that must be filled in the group
 * options[1]: CSS selector that defines the group of conditionally required fields
 */
    $.validator.addMethod("require_from_group", function (value, element, options) {
        var $fields = $(options[1], element.form),
            $fieldsFirst = $fields.eq(0),
            validator = $fieldsFirst.data("valid_req_grp") ? $fieldsFirst.data("valid_req_grp") : $.extend({}, this),
            isValid = $fields.filter(function () {
                return validator.elementValue(this);
            }).length >= options[0];

        // Store the cloned validator for future validation
        $fieldsFirst.data("valid_req_grp", validator);

        // If element isn't being validated, run each require_from_group field's validation rules
        if (!$(element).data("being_validated")) {
            $fields.data("being_validated", true);
            $fields.each(function () {
                validator.element(this);
            });
            $fields.data("being_validated", false);
        }
        return isValid;
    }, $.validator.format("Please fill at least {0} of these fields."));

    /*
 * Lets you say "either at least X inputs that match selector Y must be filled,
 * OR they must all be skipped (left blank)."
 *
 * The end result, is that none of these inputs:
 *
 *	<input class="productinfo" name="partnumber">
 *	<input class="productinfo" name="description">
 *	<input class="productinfo" name="color">
 *
 *	...will validate unless either at least two of them are filled,
 *	OR none of them are.
 *
 * partnumber:	{skip_or_fill_minimum: [2,".productinfo"]},
 * description: {skip_or_fill_minimum: [2,".productinfo"]},
 * color:		{skip_or_fill_minimum: [2,".productinfo"]}
 *
 * options[0]: number of fields that must be filled in the group
 * options[1]: CSS selector that defines the group of conditionally required fields
 *
 */
    $.validator.addMethod("skip_or_fill_minimum", function (value, element, options) {
        var $fields = $(options[1], element.form),
            $fieldsFirst = $fields.eq(0),
            validator = $fieldsFirst.data("valid_skip") ? $fieldsFirst.data("valid_skip") : $.extend({}, this),
            numberFilled = $fields.filter(function () {
                return validator.elementValue(this);
            }).length,
            isValid = numberFilled === 0 || numberFilled >= options[0];

        // Store the cloned validator for future validation
        $fieldsFirst.data("valid_skip", validator);

        // If element isn't being validated, run each skip_or_fill_minimum field's validation rules
        if (!$(element).data("being_validated")) {
            $fields.data("being_validated", true);
            $fields.each(function () {
                validator.element(this);
            });
            $fields.data("being_validated", false);
        }
        return isValid;
    }, $.validator.format("Please either skip these fields or fill at least {0} of them."));

    /* Validates US States and/or Territories by @jdforsythe
 * Can be case insensitive or require capitalization - default is case insensitive
 * Can include US Territories or not - default does not
 * Can include US Military postal abbreviations (AA, AE, AP) - default does not
 *
 * Note: "States" always includes DC (District of Colombia)
 *
 * Usage examples:
 *
 *  This is the default - case insensitive, no territories, no military zones
 *  stateInput: {
 *     caseSensitive: false,
 *     includeTerritories: false,
 *     includeMilitary: false
 *  }
 *
 *  Only allow capital letters, no territories, no military zones
 *  stateInput: {
 *     caseSensitive: false
 *  }
 *
 *  Case insensitive, include territories but not military zones
 *  stateInput: {
 *     includeTerritories: true
 *  }
 *
 *  Only allow capital letters, include territories and military zones
 *  stateInput: {
 *     caseSensitive: true,
 *     includeTerritories: true,
 *     includeMilitary: true
 *  }
 *
 */
    $.validator.addMethod("stateUS", function (value, element, options) {
        var isDefault = typeof options === "undefined",
            caseSensitive = (isDefault || typeof options.caseSensitive === "undefined") ? false : options.caseSensitive,
            includeTerritories = (isDefault || typeof options.includeTerritories === "undefined") ? false : options.includeTerritories,
            includeMilitary = (isDefault || typeof options.includeMilitary === "undefined") ? false : options.includeMilitary,
            regex;

        if (!includeTerritories && !includeMilitary) {
            regex = "^(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$";
        } else if (includeTerritories && includeMilitary) {
            regex = "^(A[AEKLPRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$";
        } else if (includeTerritories) {
            regex = "^(A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$";
        } else {
            regex = "^(A[AEKLPRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$";
        }

        regex = caseSensitive ? new RegExp(regex) : new RegExp(regex, "i");
        return this.optional(element) || regex.test(value);
    }, "Please specify a valid state");

// TODO check if value starts with <, otherwise don't try stripping anything
    $.validator.addMethod("strippedminlength", function (value, element, param) {
        return $(value).text().length >= param;
    }, $.validator.format("Please enter at least {0} characters"));

    $.validator.addMethod("time", function (value, element) {
        return this.optional(element) || /^([01]\d|2[0-3]|[0-9])(:[0-5]\d){1,2}$/.test(value);
    }, "Please enter a valid time, between 00:00 and 23:59");

    $.validator.addMethod("time12h", function (value, element) {
        return this.optional(element) || /^((0?[1-9]|1[012])(:[0-5]\d){1,2}(\ ?[AP]M))$/i.test(value);
    }, "Please enter a valid time in 12-hour am/pm format");

// Same as url, but TLD is optional
    $.validator.addMethod("url2", function (value, element) {
        return this.optional(element) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
    }, $.validator.messages.url);

    /**
     * Return true, if the value is a valid vehicle identification number (VIN).
     *
     * Works with all kind of text inputs.
     *
     * @example <input type="text" size="20" name="VehicleID" class="{required:true,vinUS:true}" />
     * @desc Declares a required input element whose value must be a valid vehicle identification number.
     *
     * @name $.validator.methods.vinUS
     * @type Boolean
     * @cat Plugins/Validate/Methods
     */
    $.validator.addMethod("vinUS", function (v) {
        if (v.length !== 17) {
            return false;
        }

        var LL = ["A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"],
            VL = [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7, 8, 9],
            FL = [8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2],
            rs = 0,
            i, n, d, f, cd, cdv;

        for (i = 0; i < 17; i++) {
            f = FL[i];
            d = v.slice(i, i + 1);
            if (i === 8) {
                cdv = d;
            }
            if (!isNaN(d)) {
                d *= f;
            } else {
                for (n = 0; n < LL.length; n++) {
                    if (d.toUpperCase() === LL[n]) {
                        d = VL[n];
                        d *= f;
                        if (isNaN(cdv) && n === 8) {
                            cdv = LL[n];
                        }
                        break;
                    }
                }
            }
            rs += d;
        }
        cd = rs % 11;
        if (cd === 10) {
            cd = "X";
        }
        if (cd === cdv) {
            return true;
        }
        return false;
    }, "The specified vehicle identification number (VIN) is invalid.");

    $.validator.addMethod("zipcodeUS", function (value, element) {
        return this.optional(element) || /^\d{5}(-\d{4})?$/.test(value);
    }, "The specified US ZIP Code is invalid");

    $.validator.addMethod("ziprange", function (value, element) {
        return this.optional(element) || /^90[2-5]\d\{2\}-\d{4}$/.test(value);
    }, "Your ZIP-code must be in the range 902xx-xxxx to 905xx-xxxx");
    return $;
}));
"use strict";
var valGetParentContainer = function (element) {
    var element = $(element);

    if ($(element).closest('.form-group-sub').length > 0) {
        return $(element).closest('.form-group-sub')
    } else if ($(element).closest('.bootstrap-select').length > 0) {
        return $(element).closest('.bootstrap-select')
    } else {
        return $(element).closest('.form-group');
    }
}

jQuery.validator.setDefaults({
    errorElement: 'div', //default input error message container
    focusInvalid: false, // do not focus the last invalid input
    ignore: "",  // validate all fields including form hidden input

    errorPlacement: function (error, element) { // render error placement for each input type
        var element = $(element);

        var group = valGetParentContainer(element);
        var help = group.find('.form-text');

        if (group.find('.valid-feedback, .invalid-feedback').length !== 0) {
            return;
        }

        element.addClass('is-invalid');
        error.addClass('invalid-feedback');

        if (help.length > 0) {
            help.before(error);
        } else {
            if (element.closest('.bootstrap-select').length > 0) {     //Bootstrap select
                element.closest('.bootstrap-select').find('.bs-placeholder').after(error);
            } else if (element.closest('.input-group').length > 0) {   //Bootstrap group
                element.after(error);
            } else {                                                   //Checkbox & radios
                if (element.is(':checkbox')) {
                    element.closest('.k-checkbox').find('> span').after(error);
                } else {
                    element.after(error);
                }
            }
        }
    },

    highlight: function (element) { // hightlight error inputs
        var group = valGetParentContainer(element);
        group.addClass('validate');
        group.addClass('is-invalid');
        $(element).removeClass('is-valid');
    },

    unhighlight: function (element) { // revert the change done by hightlight
        var group = valGetParentContainer(element);
        group.removeClass('validate');
        group.removeClass('is-invalid');
        $(element).removeClass('is-invalid');
    },

    success: function (label, element) {
        var group = valGetParentContainer(element);
        group.removeClass('validate');
        group.find('.invalid-feedback').remove();
    }
});

jQuery.validator.addMethod("email", function (value, element) {
    if (/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/.test(value)) {
        return true;
    } else {
        return false;
    }
}, "Please enter a valid Email.");
!function (e) {
    e(["jquery"], function (e) {
        return function () {
            function t(e, t, n) {
                return g({type: O.error, iconClass: m().iconClasses.error, message: e, optionsOverride: n, title: t})
            }

            function n(t, n) {
                return t || (t = m()), v = e("#" + t.containerId), v.length ? v : (n && (v = d(t)), v)
            }

            function o(e, t, n) {
                return g({type: O.info, iconClass: m().iconClasses.info, message: e, optionsOverride: n, title: t})
            }

            function s(e) {
                C = e
            }

            function i(e, t, n) {
                return g({
                    type: O.success,
                    iconClass: m().iconClasses.success,
                    message: e,
                    optionsOverride: n,
                    title: t
                })
            }

            function a(e, t, n) {
                return g({
                    type: O.warning,
                    iconClass: m().iconClasses.warning,
                    message: e,
                    optionsOverride: n,
                    title: t
                })
            }

            function r(e, t) {
                var o = m();
                v || n(o), u(e, o, t) || l(o)
            }

            function c(t) {
                var o = m();
                return v || n(o), t && 0 === e(":focus", t).length ? void h(t) : void(v.children().length && v.remove())
            }

            function l(t) {
                for (var n = v.children(), o = n.length - 1; o >= 0; o--) u(e(n[o]), t)
            }

            function u(t, n, o) {
                var s = !(!o || !o.force) && o.force;
                return !(!t || !s && 0 !== e(":focus", t).length) && (t[n.hideMethod]({
                    duration: n.hideDuration,
                    easing: n.hideEasing,
                    complete: function () {
                        h(t)
                    }
                }), !0)
            }

            function d(t) {
                return v = e("<div/>").attr("id", t.containerId).addClass(t.positionClass), v.appendTo(e(t.target)), v
            }

            function p() {
                return {
                    tapToDismiss: !0,
                    toastClass: "toast",
                    containerId: "toast-container",
                    debug: !1,
                    showMethod: "fadeIn",
                    showDuration: 300,
                    showEasing: "swing",
                    onShown: void 0,
                    hideMethod: "fadeOut",
                    hideDuration: 1e3,
                    hideEasing: "swing",
                    onHidden: void 0,
                    closeMethod: !1,
                    closeDuration: !1,
                    closeEasing: !1,
                    closeOnHover: !0,
                    extendedTimeOut: 1e3,
                    iconClasses: {
                        error: "toast-error",
                        info: "toast-info",
                        success: "toast-success",
                        warning: "toast-warning"
                    },
                    iconClass: "toast-info",
                    positionClass: "toast-top-right",
                    timeOut: 5e3,
                    titleClass: "toast-title",
                    messageClass: "toast-message",
                    escapeHtml: !1,
                    target: "body",
                    closeHtml: '<button type="button">&times;</button>',
                    closeClass: "toast-close-button",
                    newestOnTop: !0,
                    preventDuplicates: !1,
                    progressBar: !1,
                    progressClass: "toast-progress",
                    rtl: !1
                }
            }

            function f(e) {
                C && C(e)
            }

            function g(t) {
                function o(e) {
                    return null == e && (e = ""), e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                }

                function s() {
                    c(), u(), d(), p(), g(), C(), l(), i()
                }

                function i() {
                    var e = "";
                    switch (t.iconClass) {
                        case"toast-success":
                        case"toast-info":
                            e = "polite";
                            break;
                        default:
                            e = "assertive"
                    }
                    I.attr("aria-live", e)
                }

                function a() {
                    E.closeOnHover && I.hover(H, D), !E.onclick && E.tapToDismiss && I.click(b), E.closeButton && j && j.click(function (e) {
                        e.stopPropagation ? e.stopPropagation() : void 0 !== e.cancelBubble && e.cancelBubble !== !0 && (e.cancelBubble = !0), E.onCloseClick && E.onCloseClick(e), b(!0)
                    }), E.onclick && I.click(function (e) {
                        E.onclick(e), b()
                    })
                }

                function r() {
                    I.hide(), I[E.showMethod]({
                        duration: E.showDuration,
                        easing: E.showEasing,
                        complete: E.onShown
                    }), E.timeOut > 0 && (k = setTimeout(b, E.timeOut), F.maxHideTime = parseFloat(E.timeOut), F.hideEta = (new Date).getTime() + F.maxHideTime, E.progressBar && (F.intervalId = setInterval(x, 10)))
                }

                function c() {
                    t.iconClass && I.addClass(E.toastClass).addClass(y)
                }

                function l() {
                    E.newestOnTop ? v.prepend(I) : v.append(I)
                }

                function u() {
                    if (t.title) {
                        var e = t.title;
                        E.escapeHtml && (e = o(t.title)), M.append(e).addClass(E.titleClass), I.append(M)
                    }
                }

                function d() {
                    if (t.message) {
                        var e = t.message;
                        E.escapeHtml && (e = o(t.message)), B.append(e).addClass(E.messageClass), I.append(B)
                    }
                }

                function p() {
                    E.closeButton && (j.addClass(E.closeClass).attr("role", "button"), I.prepend(j))
                }

                function g() {
                    E.progressBar && (q.addClass(E.progressClass), I.prepend(q))
                }

                function C() {
                    E.rtl && I.addClass("rtl")
                }

                function O(e, t) {
                    if (e.preventDuplicates) {
                        if (t.message === w) return !0;
                        w = t.message
                    }
                    return !1
                }

                function b(t) {
                    var n = t && E.closeMethod !== !1 ? E.closeMethod : E.hideMethod,
                        o = t && E.closeDuration !== !1 ? E.closeDuration : E.hideDuration,
                        s = t && E.closeEasing !== !1 ? E.closeEasing : E.hideEasing;
                    if (!e(":focus", I).length || t) return clearTimeout(F.intervalId), I[n]({
                        duration: o,
                        easing: s,
                        complete: function () {
                            h(I), clearTimeout(k), E.onHidden && "hidden" !== P.state && E.onHidden(), P.state = "hidden", P.endTime = new Date, f(P)
                        }
                    })
                }

                function D() {
                    (E.timeOut > 0 || E.extendedTimeOut > 0) && (k = setTimeout(b, E.extendedTimeOut), F.maxHideTime = parseFloat(E.extendedTimeOut), F.hideEta = (new Date).getTime() + F.maxHideTime)
                }

                function H() {
                    clearTimeout(k), F.hideEta = 0, I.stop(!0, !0)[E.showMethod]({
                        duration: E.showDuration,
                        easing: E.showEasing
                    })
                }

                function x() {
                    var e = (F.hideEta - (new Date).getTime()) / F.maxHideTime * 100;
                    q.width(e + "%")
                }

                var E = m(), y = t.iconClass || E.iconClass;
                if ("undefined" != typeof t.optionsOverride && (E = e.extend(E, t.optionsOverride), y = t.optionsOverride.iconClass || y), !O(E, t)) {
                    T++, v = n(E, !0);
                    var k = null, I = e("<div/>"), M = e("<div/>"), B = e("<div/>"), q = e("<div/>"),
                        j = e(E.closeHtml), F = {intervalId: null, hideEta: null, maxHideTime: null},
                        P = {toastId: T, state: "visible", startTime: new Date, options: E, map: t};
                    return s(), r(), a(), f(P), E.debug && console && console.log(P), I
                }
            }

            function m() {
                return e.extend({}, p(), b.options)
            }

            function h(e) {
                v || (v = n()), e.is(":visible") || (e.remove(), e = null, 0 === v.children().length && (v.remove(), w = void 0))
            }

            var v, C, w, T = 0, O = {error: "error", info: "info", success: "success", warning: "warning"}, b = {
                clear: r,
                remove: c,
                error: t,
                getContainer: n,
                info: o,
                options: {},
                subscribe: s,
                success: i,
                version: "2.1.4",
                warning: a
            };
            return b
        }()
    })
}("function" == typeof define && define.amd ? define : function (e, t) {
    "undefined" != typeof module && module.exports ? module.exports = t(require("jquery")) : window.toastr = t(window.jQuery)
});


// ┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.2.0 - JavaScript Vector Library                                                             │ \\
// ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                       │ \\
// │ Copyright © 2008-2016 Sencha Labs (http://sencha.com)                                                 │ \\
// ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license.│ \\
// └───────────────────────────────────────────────────────────────────────────────────────────────────────┘ \\

(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else if (typeof exports === 'object')
        exports["Raphael"] = factory();
    else
        root["Raphael"] = factory();
})(this, function () {
    return /******/ (function (modules) { // webpackBootstrap
        /******/ 	// The module cache
        /******/
        var installedModules = {};

        /******/ 	// The require function
        /******/
        function __webpack_require__(moduleId) {

            /******/ 		// Check if module is in cache
            /******/
            if (installedModules[moduleId])
            /******/            return installedModules[moduleId].exports;

            /******/ 		// Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/            exports: {},
                /******/            id: moduleId,
                /******/            loaded: false
                /******/
            };

            /******/ 		// Execute the module function
            /******/
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

            /******/ 		// Flag the module as loaded
            /******/
            module.loaded = true;

            /******/ 		// Return the exports of the module
            /******/
            return module.exports;
            /******/
        }


        /******/ 	// expose the modules object (__webpack_modules__)
        /******/
        __webpack_require__.m = modules;

        /******/ 	// expose the module cache
        /******/
        __webpack_require__.c = installedModules;

        /******/ 	// __webpack_public_path__
        /******/
        __webpack_require__.p = "";

        /******/ 	// Load entry module and return exports
        /******/
        return __webpack_require__(0);
        /******/
    })
    /************************************************************************/
    /******/([
        /* 0 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {

                return R;

            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

            /***/
        },
        /* 1 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {

                /*\
	     * Raphael
	     [ method ]
	     **
	     * Creates a canvas object on which to draw.
	     * You must do this first, as all future calls to drawing methods
	     * from this instance will be bound to this canvas.
	     > Parameters
	     **
	     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
	     - width (number)
	     - height (number)
	     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
	     * or
	     - x (number)
	     - y (number)
	     - width (number)
	     - height (number)
	     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
	     * or
	     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
	     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
	     * or
	     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
	     = (object) @Paper
	     > Usage
	     | // Each of the following examples create a canvas
	     | // that is 320px wide by 200px high.
	     | // Canvas is created at the viewport’s 10,50 coordinate.
	     | var paper = Raphael(10, 50, 320, 200);
	     | // Canvas is created at the top left corner of the #notepad element
	     | // (or its top right corner in dir="rtl" elements)
	     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
	     | // Same as above
	     | var paper = Raphael("notepad", 320, 200);
	     | // Image dump
	     | var set = Raphael(["notepad", 320, 200, {
	     |     type: "rect",
	     |     x: 10,
	     |     y: 10,
	     |     width: 25,
	     |     height: 25,
	     |     stroke: "#f00"
	     | }, {
	     |     type: "text",
	     |     x: 30,
	     |     y: 40,
	     |     text: "Dump"
	     | }]);
	    \*/
                function R(first) {
                    if (R.is(first, "function")) {
                        return loaded ? first() : eve.on("raphael.DOMload", first);
                    } else if (R.is(first, array)) {
                        return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
                    } else {
                        var args = Array.prototype.slice.call(arguments, 0);
                        if (R.is(args[args.length - 1], "function")) {
                            var f = args.pop();
                            return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                                f.call(R._engine.create[apply](R, args));
                            });
                        } else {
                            return R._engine.create[apply](R, arguments);
                        }
                    }
                }

                R.version = "2.2.0";
                R.eve = eve;
                var loaded,
                    separator = /[, ]+/,
                    elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
                    formatrg = /\{(\d+)\}/g,
                    proto = "prototype",
                    has = "hasOwnProperty",
                    g = {
                        doc: document,
                        win: window
                    },
                    oldRaphael = {
                        was: Object.prototype[has].call(g.win, "Raphael"),
                        is: g.win.Raphael
                    },
                    Paper = function () {
                        /*\
	             * Paper.ca
	             [ property (object) ]
	             **
	             * Shortcut for @Paper.customAttributes
	            \*/
                        /*\
	             * Paper.customAttributes
	             [ property (object) ]
	             **
	             * If you have a set of attributes that you would like to represent
	             * as a function of some number you can do it easily with custom attributes:
	             > Usage
	             | paper.customAttributes.hue = function (num) {
	             |     num = num % 1;
	             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
	             | };
	             | // Custom attribute “hue” will change fill
	             | // to be given hue with fixed saturation and brightness.
	             | // Now you can use it like this:
	             | var c = paper.circle(10, 10, 10).attr({hue: .45});
	             | // or even like this:
	             | c.animate({hue: 1}, 1e3);
	             |
	             | // You could also create custom attribute
	             | // with multiple parameters:
	             | paper.customAttributes.hsb = function (h, s, b) {
	             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
	             | };
	             | c.attr({hsb: "0.5 .8 1"});
	             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
	            \*/
                        this.ca = this.customAttributes = {};
                    },
                    paperproto,
                    appendChild = "appendChild",
                    apply = "apply",
                    concat = "concat",
                    supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
                    E = "",
                    S = " ",
                    Str = String,
                    split = "split",
                    events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
                    touchMap = {
                        mousedown: "touchstart",
                        mousemove: "touchmove",
                        mouseup: "touchend"
                    },
                    lowerCase = Str.prototype.toLowerCase,
                    math = Math,
                    mmax = math.max,
                    mmin = math.min,
                    abs = math.abs,
                    pow = math.pow,
                    PI = math.PI,
                    nu = "number",
                    string = "string",
                    array = "array",
                    toString = "toString",
                    fillString = "fill",
                    objectToString = Object.prototype.toString,
                    paper = {},
                    push = "push",
                    ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i,
                    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
                    isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
                    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
                    round = math.round,
                    setAttribute = "setAttribute",
                    toFloat = parseFloat,
                    toInt = parseInt,
                    upperCase = Str.prototype.toUpperCase,
                    availableAttrs = R._availableAttrs = {
                        "arrow-end": "none",
                        "arrow-start": "none",
                        blur: 0,
                        "clip-rect": "0 0 1e9 1e9",
                        cursor: "default",
                        cx: 0,
                        cy: 0,
                        fill: "#fff",
                        "fill-opacity": 1,
                        font: '10px "Arial"',
                        "font-family": '"Arial"',
                        "font-size": "10",
                        "font-style": "normal",
                        "font-weight": 400,
                        gradient: 0,
                        height: 0,
                        href: "http://raphaeljs.com/",
                        "letter-spacing": 0,
                        opacity: 1,
                        path: "M0,0",
                        r: 0,
                        rx: 0,
                        ry: 0,
                        src: "",
                        stroke: "#000",
                        "stroke-dasharray": "",
                        "stroke-linecap": "butt",
                        "stroke-linejoin": "butt",
                        "stroke-miterlimit": 0,
                        "stroke-opacity": 1,
                        "stroke-width": 1,
                        target: "_blank",
                        "text-anchor": "middle",
                        title: "Raphael",
                        transform: "",
                        width: 0,
                        x: 0,
                        y: 0,
                        "class": ""
                    },
                    availableAnimAttrs = R._availableAnimAttrs = {
                        blur: nu,
                        "clip-rect": "csv",
                        cx: nu,
                        cy: nu,
                        fill: "colour",
                        "fill-opacity": nu,
                        "font-size": nu,
                        height: nu,
                        opacity: nu,
                        path: "path",
                        r: nu,
                        rx: nu,
                        ry: nu,
                        stroke: "colour",
                        "stroke-opacity": nu,
                        "stroke-width": nu,
                        transform: "transform",
                        width: nu,
                        x: nu,
                        y: nu
                    },
                    whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
                    commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
                    hsrg = {hs: 1, rg: 1},
                    p2s = /,?([achlmqrstvxz]),?/gi,
                    pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
                    tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
                    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
                    radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
                    eldata = {},
                    sortByKey = function (a, b) {
                        return a.key - b.key;
                    },
                    sortByNumber = function (a, b) {
                        return toFloat(a) - toFloat(b);
                    },
                    fun = function () {
                    },
                    pipe = function (x) {
                        return x;
                    },
                    rectPath = R._rectPath = function (x, y, w, h, r) {
                        if (r) {
                            return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
                        }
                        return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
                    },
                    ellipsePath = function (x, y, rx, ry) {
                        if (ry == null) {
                            ry = rx;
                        }
                        return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
                    },
                    getPath = R._getPath = {
                        path: function (el) {
                            return el.attr("path");
                        },
                        circle: function (el) {
                            var a = el.attrs;
                            return ellipsePath(a.cx, a.cy, a.r);
                        },
                        ellipse: function (el) {
                            var a = el.attrs;
                            return ellipsePath(a.cx, a.cy, a.rx, a.ry);
                        },
                        rect: function (el) {
                            var a = el.attrs;
                            return rectPath(a.x, a.y, a.width, a.height, a.r);
                        },
                        image: function (el) {
                            var a = el.attrs;
                            return rectPath(a.x, a.y, a.width, a.height);
                        },
                        text: function (el) {
                            var bbox = el._getBBox();
                            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
                        },
                        set: function (el) {
                            var bbox = el._getBBox();
                            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
                        }
                    },
                    /*\
	         * Raphael.mapPath
	         [ method ]
	         **
	         * Transform the path string with given matrix.
	         > Parameters
	         - path (string) path string
	         - matrix (object) see @Matrix
	         = (string) transformed path string
	        \*/
                    mapPath = R.mapPath = function (path, matrix) {
                        if (!matrix) {
                            return path;
                        }
                        var x, y, i, j, ii, jj, pathi;
                        path = path2curve(path);
                        for (i = 0, ii = path.length; i < ii; i++) {
                            pathi = path[i];
                            for (j = 1, jj = pathi.length; j < jj; j += 2) {
                                x = matrix.x(pathi[j], pathi[j + 1]);
                                y = matrix.y(pathi[j], pathi[j + 1]);
                                pathi[j] = x;
                                pathi[j + 1] = y;
                            }
                        }
                        return path;
                    };

                R._g = g;
                /*\
	     * Raphael.type
	     [ property (string) ]
	     **
	     * Can be “SVG”, “VML” or empty, depending on browser support.
	    \*/
                R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
                if (R.type == "VML") {
                    var d = g.doc.createElement("div"),
                        b;
                    d.innerHTML = '<v:shape adj="1"/>';
                    b = d.firstChild;
                    b.style.behavior = "url(#default#VML)";
                    if (!(b && typeof b.adj == "object")) {
                        return (R.type = E);
                    }
                    d = null;
                }
                /*\
	     * Raphael.svg
	     [ property (boolean) ]
	     **
	     * `true` if browser supports SVG.
	    \*/
                /*\
	     * Raphael.vml
	     [ property (boolean) ]
	     **
	     * `true` if browser supports VML.
	    \*/
                R.svg = !(R.vml = R.type == "VML");
                R._Paper = Paper;
                /*\
	     * Raphael.fn
	     [ property (object) ]
	     **
	     * You can add your own method to the canvas. For example if you want to draw a pie chart,
	     * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
	     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
	     * Raphaël instance is created, otherwise it will take no effect. Please note that the
	     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
	     * ensure any namespacing ensures proper context.
	     > Usage
	     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
	     |     return this.path( ... );
	     | };
	     | // or create namespace
	     | Raphael.fn.mystuff = {
	     |     arrow: function () {…},
	     |     star: function () {…},
	     |     // etc…
	     | };
	     | var paper = Raphael(10, 10, 630, 480);
	     | // then use it
	     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
	     | paper.mystuff.arrow();
	     | paper.mystuff.star();
	    \*/
                R.fn = paperproto = Paper.prototype = R.prototype;
                R._id = 0;
                /*\
	     * Raphael.is
	     [ method ]
	     **
	     * Handful of replacements for `typeof` operator.
	     > Parameters
	     - o (…) any object or primitive
	     - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
	     = (boolean) is given value is of given type
	    \*/
                R.is = function (o, type) {
                    type = lowerCase.call(type);
                    if (type == "finite") {
                        return !isnan[has](+o);
                    }
                    if (type == "array") {
                        return o instanceof Array;
                    }
                    return (type == "null" && o === null) ||
                        (type == typeof o && o !== null) ||
                        (type == "object" && o === Object(o)) ||
                        (type == "array" && Array.isArray && Array.isArray(o)) ||
                        objectToString.call(o).slice(8, -1).toLowerCase() == type;
                };

                function clone(obj) {
                    if (typeof obj == "function" || Object(obj) !== obj) {
                        return obj;
                    }
                    var res = new obj.constructor;
                    for (var key in obj) if (obj[has](key)) {
                        res[key] = clone(obj[key]);
                    }
                    return res;
                }

                /*\
	     * Raphael.angle
	     [ method ]
	     **
	     * Returns angle between two or three points
	     > Parameters
	     - x1 (number) x coord of first point
	     - y1 (number) y coord of first point
	     - x2 (number) x coord of second point
	     - y2 (number) y coord of second point
	     - x3 (number) #optional x coord of third point
	     - y3 (number) #optional y coord of third point
	     = (number) angle in degrees.
	    \*/
                R.angle = function (x1, y1, x2, y2, x3, y3) {
                    if (x3 == null) {
                        var x = x1 - x2,
                            y = y1 - y2;
                        if (!x && !y) {
                            return 0;
                        }
                        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
                    } else {
                        return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
                    }
                };
                /*\
	     * Raphael.rad
	     [ method ]
	     **
	     * Transform angle to radians
	     > Parameters
	     - deg (number) angle in degrees
	     = (number) angle in radians.
	    \*/
                R.rad = function (deg) {
                    return deg % 360 * PI / 180;
                };
                /*\
	     * Raphael.deg
	     [ method ]
	     **
	     * Transform angle to degrees
	     > Parameters
	     - rad (number) angle in radians
	     = (number) angle in degrees.
	    \*/
                R.deg = function (rad) {
                    return Math.round((rad * 180 / PI % 360) * 1000) / 1000;
                };
                /*\
	     * Raphael.snapTo
	     [ method ]
	     **
	     * Snaps given value to given grid.
	     > Parameters
	     - values (array|number) given array of values or step of the grid
	     - value (number) value to adjust
	     - tolerance (number) #optional tolerance for snapping. Default is `10`.
	     = (number) adjusted value.
	    \*/
                R.snapTo = function (values, value, tolerance) {
                    tolerance = R.is(tolerance, "finite") ? tolerance : 10;
                    if (R.is(values, array)) {
                        var i = values.length;
                        while (i--) if (abs(values[i] - value) <= tolerance) {
                            return values[i];
                        }
                    } else {
                        values = +values;
                        var rem = value % values;
                        if (rem < tolerance) {
                            return value - rem;
                        }
                        if (rem > values - tolerance) {
                            return value - rem + values;
                        }
                    }
                    return value;
                };

                /*\
	     * Raphael.createUUID
	     [ method ]
	     **
	     * Returns RFC4122, version 4 ID
	    \*/
                var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
                    return function () {
                        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
                    };
                })(/[xy]/g, function (c) {
                    var r = math.random() * 16 | 0,
                        v = c == "x" ? r : (r & 3 | 8);
                    return v.toString(16);
                });

                /*\
	     * Raphael.setWindow
	     [ method ]
	     **
	     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
	     > Parameters
	     - newwin (window) new window object
	    \*/
                R.setWindow = function (newwin) {
                    eve("raphael.setWindow", R, g.win, newwin);
                    g.win = newwin;
                    g.doc = g.win.document;
                    if (R._engine.initWin) {
                        R._engine.initWin(g.win);
                    }
                };
                var toHex = function (color) {
                        if (R.vml) {
                            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
                            var trim = /^\s+|\s+$/g;
                            var bod;
                            try {
                                var docum = new ActiveXObject("htmlfile");
                                docum.write("<body>");
                                docum.close();
                                bod = docum.body;
                            } catch (e) {
                                bod = createPopup().document.body;
                            }
                            var range = bod.createTextRange();
                            toHex = cacher(function (color) {
                                try {
                                    bod.style.color = Str(color).replace(trim, E);
                                    var value = range.queryCommandValue("ForeColor");
                                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                                    return "#" + ("000000" + value.toString(16)).slice(-6);
                                } catch (e) {
                                    return "none";
                                }
                            });
                        } else {
                            var i = g.doc.createElement("i");
                            i.title = "Rapha\xebl Colour Picker";
                            i.style.display = "none";
                            g.doc.body.appendChild(i);
                            toHex = cacher(function (color) {
                                i.style.color = color;
                                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                            });
                        }
                        return toHex(color);
                    },
                    hsbtoString = function () {
                        return "hsb(" + [this.h, this.s, this.b] + ")";
                    },
                    hsltoString = function () {
                        return "hsl(" + [this.h, this.s, this.l] + ")";
                    },
                    rgbtoString = function () {
                        return this.hex;
                    },
                    prepareRGB = function (r, g, b) {
                        if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
                            b = r.b;
                            g = r.g;
                            r = r.r;
                        }
                        if (g == null && R.is(r, string)) {
                            var clr = R.getRGB(r);
                            r = clr.r;
                            g = clr.g;
                            b = clr.b;
                        }
                        if (r > 1 || g > 1 || b > 1) {
                            r /= 255;
                            g /= 255;
                            b /= 255;
                        }

                        return [r, g, b];
                    },
                    packageRGB = function (r, g, b, o) {
                        r *= 255;
                        g *= 255;
                        b *= 255;
                        var rgb = {
                            r: r,
                            g: g,
                            b: b,
                            hex: R.rgb(r, g, b),
                            toString: rgbtoString
                        };
                        R.is(o, "finite") && (rgb.opacity = o);
                        return rgb;
                    };

                /*\
	     * Raphael.color
	     [ method ]
	     **
	     * Parses the color string and returns object with all values for the given color.
	     > Parameters
	     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
	     = (object) Combined RGB & HSB object in format:
	     o {
	     o     r (number) red,
	     o     g (number) green,
	     o     b (number) blue,
	     o     hex (string) color in HTML/CSS format: #••••••,
	     o     error (boolean) `true` if string can’t be parsed,
	     o     h (number) hue,
	     o     s (number) saturation,
	     o     v (number) value (brightness),
	     o     l (number) lightness
	     o }
	    \*/
                R.color = function (clr) {
                    var rgb;
                    if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
                        rgb = R.hsb2rgb(clr);
                        clr.r = rgb.r;
                        clr.g = rgb.g;
                        clr.b = rgb.b;
                        clr.hex = rgb.hex;
                    } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
                        rgb = R.hsl2rgb(clr);
                        clr.r = rgb.r;
                        clr.g = rgb.g;
                        clr.b = rgb.b;
                        clr.hex = rgb.hex;
                    } else {
                        if (R.is(clr, "string")) {
                            clr = R.getRGB(clr);
                        }
                        if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                            rgb = R.rgb2hsl(clr);
                            clr.h = rgb.h;
                            clr.s = rgb.s;
                            clr.l = rgb.l;
                            rgb = R.rgb2hsb(clr);
                            clr.v = rgb.b;
                        } else {
                            clr = {hex: "none"};
                            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
                        }
                    }
                    clr.toString = rgbtoString;
                    return clr;
                };
                /*\
	     * Raphael.hsb2rgb
	     [ method ]
	     **
	     * Converts HSB values to RGB object.
	     > Parameters
	     - h (number) hue
	     - s (number) saturation
	     - v (number) value or brightness
	     = (object) RGB object in format:
	     o {
	     o     r (number) red,
	     o     g (number) green,
	     o     b (number) blue,
	     o     hex (string) color in HTML/CSS format: #••••••
	     o }
	    \*/
                R.hsb2rgb = function (h, s, v, o) {
                    if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
                        v = h.b;
                        s = h.s;
                        o = h.o;
                        h = h.h;
                    }
                    h *= 360;
                    var R, G, B, X, C;
                    h = (h % 360) / 60;
                    C = v * s;
                    X = C * (1 - abs(h % 2 - 1));
                    R = G = B = v - C;

                    h = ~~h;
                    R += [C, X, 0, 0, X, C][h];
                    G += [X, C, C, X, 0, 0][h];
                    B += [0, 0, X, C, C, X][h];
                    return packageRGB(R, G, B, o);
                };
                /*\
	     * Raphael.hsl2rgb
	     [ method ]
	     **
	     * Converts HSL values to RGB object.
	     > Parameters
	     - h (number) hue
	     - s (number) saturation
	     - l (number) luminosity
	     = (object) RGB object in format:
	     o {
	     o     r (number) red,
	     o     g (number) green,
	     o     b (number) blue,
	     o     hex (string) color in HTML/CSS format: #••••••
	     o }
	    \*/
                R.hsl2rgb = function (h, s, l, o) {
                    if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
                        l = h.l;
                        s = h.s;
                        h = h.h;
                    }
                    if (h > 1 || s > 1 || l > 1) {
                        h /= 360;
                        s /= 100;
                        l /= 100;
                    }
                    h *= 360;
                    var R, G, B, X, C;
                    h = (h % 360) / 60;
                    C = 2 * s * (l < .5 ? l : 1 - l);
                    X = C * (1 - abs(h % 2 - 1));
                    R = G = B = l - C / 2;

                    h = ~~h;
                    R += [C, X, 0, 0, X, C][h];
                    G += [X, C, C, X, 0, 0][h];
                    B += [0, 0, X, C, C, X][h];
                    return packageRGB(R, G, B, o);
                };
                /*\
	     * Raphael.rgb2hsb
	     [ method ]
	     **
	     * Converts RGB values to HSB object.
	     > Parameters
	     - r (number) red
	     - g (number) green
	     - b (number) blue
	     = (object) HSB object in format:
	     o {
	     o     h (number) hue
	     o     s (number) saturation
	     o     b (number) brightness
	     o }
	    \*/
                R.rgb2hsb = function (r, g, b) {
                    b = prepareRGB(r, g, b);
                    r = b[0];
                    g = b[1];
                    b = b[2];

                    var H, S, V, C;
                    V = mmax(r, g, b);
                    C = V - mmin(r, g, b);
                    H = (C == 0 ? null :
                            V == r ? (g - b) / C :
                                V == g ? (b - r) / C + 2 :
                                    (r - g) / C + 4
                    );
                    H = ((H + 360) % 6) * 60 / 360;
                    S = C == 0 ? 0 : C / V;
                    return {h: H, s: S, b: V, toString: hsbtoString};
                };
                /*\
	     * Raphael.rgb2hsl
	     [ method ]
	     **
	     * Converts RGB values to HSL object.
	     > Parameters
	     - r (number) red
	     - g (number) green
	     - b (number) blue
	     = (object) HSL object in format:
	     o {
	     o     h (number) hue
	     o     s (number) saturation
	     o     l (number) luminosity
	     o }
	    \*/
                R.rgb2hsl = function (r, g, b) {
                    b = prepareRGB(r, g, b);
                    r = b[0];
                    g = b[1];
                    b = b[2];

                    var H, S, L, M, m, C;
                    M = mmax(r, g, b);
                    m = mmin(r, g, b);
                    C = M - m;
                    H = (C == 0 ? null :
                        M == r ? (g - b) / C :
                            M == g ? (b - r) / C + 2 :
                                (r - g) / C + 4);
                    H = ((H + 360) % 6) * 60 / 360;
                    L = (M + m) / 2;
                    S = (C == 0 ? 0 :
                        L < .5 ? C / (2 * L) :
                            C / (2 - 2 * L));
                    return {h: H, s: S, l: L, toString: hsltoString};
                };
                R._path2string = function () {
                    return this.join(",").replace(p2s, "$1");
                };

                function repush(array, item) {
                    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
                        return array.push(array.splice(i, 1)[0]);
                    }
                }

                function cacher(f, scope, postprocessor) {
                    function newf() {
                        var arg = Array.prototype.slice.call(arguments, 0),
                            args = arg.join("\u2400"),
                            cache = newf.cache = newf.cache || {},
                            count = newf.count = newf.count || [];
                        if (cache[has](args)) {
                            repush(count, args);
                            return postprocessor ? postprocessor(cache[args]) : cache[args];
                        }
                        count.length >= 1e3 && delete cache[count.shift()];
                        count.push(args);
                        cache[args] = f[apply](scope, arg);
                        return postprocessor ? postprocessor(cache[args]) : cache[args];
                    }

                    return newf;
                }

                var preload = R._preload = function (src, f) {
                    var img = g.doc.createElement("img");
                    img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
                    img.onload = function () {
                        f.call(this);
                        this.onload = null;
                        g.doc.body.removeChild(this);
                    };
                    img.onerror = function () {
                        g.doc.body.removeChild(this);
                    };
                    g.doc.body.appendChild(img);
                    img.src = src;
                };

                function clrToString() {
                    return this.hex;
                }

                /*\
	     * Raphael.getRGB
	     [ method ]
	     **
	     * Parses colour string as RGB object
	     > Parameters
	     - colour (string) colour string in one of formats:
	     # <ul>
	     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
	     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
	     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
	     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
	     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
	     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
	     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
	     #     <li>hsl(•••, •••, •••) — same as hsb</li>
	     #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>
	     # </ul>
	     = (object) RGB object in format:
	     o {
	     o     r (number) red,
	     o     g (number) green,
	     o     b (number) blue
	     o     hex (string) color in HTML/CSS format: #••••••,
	     o     error (boolean) true if string can’t be parsed
	     o }
	    \*/
                R.getRGB = cacher(function (colour) {
                    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
                        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
                    }
                    if (colour == "none") {
                        return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
                    }
                    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
                    var res,
                        red,
                        green,
                        blue,
                        opacity,
                        t,
                        values,
                        rgb = colour.match(colourRegExp);
                    if (rgb) {
                        if (rgb[2]) {
                            blue = toInt(rgb[2].substring(5), 16);
                            green = toInt(rgb[2].substring(3, 5), 16);
                            red = toInt(rgb[2].substring(1, 3), 16);
                        }
                        if (rgb[3]) {
                            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                            green = toInt((t = rgb[3].charAt(2)) + t, 16);
                            red = toInt((t = rgb[3].charAt(1)) + t, 16);
                        }
                        if (rgb[4]) {
                            values = rgb[4][split](commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red *= 2.55);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green *= 2.55);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue *= 2.55);
                            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                        }
                        if (rgb[5]) {
                            values = rgb[5][split](commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red *= 2.55);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green *= 2.55);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue *= 2.55);
                            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                            return R.hsb2rgb(red, green, blue, opacity);
                        }
                        if (rgb[6]) {
                            values = rgb[6][split](commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red *= 2.55);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green *= 2.55);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue *= 2.55);
                            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                            return R.hsl2rgb(red, green, blue, opacity);
                        }
                        rgb = {r: red, g: green, b: blue, toString: clrToString};
                        rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
                        R.is(opacity, "finite") && (rgb.opacity = opacity);
                        return rgb;
                    }
                    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
                }, R);
                /*\
	     * Raphael.hsb
	     [ method ]
	     **
	     * Converts HSB values to hex representation of the colour.
	     > Parameters
	     - h (number) hue
	     - s (number) saturation
	     - b (number) value or brightness
	     = (string) hex representation of the colour.
	    \*/
                R.hsb = cacher(function (h, s, b) {
                    return R.hsb2rgb(h, s, b).hex;
                });
                /*\
	     * Raphael.hsl
	     [ method ]
	     **
	     * Converts HSL values to hex representation of the colour.
	     > Parameters
	     - h (number) hue
	     - s (number) saturation
	     - l (number) luminosity
	     = (string) hex representation of the colour.
	    \*/
                R.hsl = cacher(function (h, s, l) {
                    return R.hsl2rgb(h, s, l).hex;
                });
                /*\
	     * Raphael.rgb
	     [ method ]
	     **
	     * Converts RGB values to hex representation of the colour.
	     > Parameters
	     - r (number) red
	     - g (number) green
	     - b (number) blue
	     = (string) hex representation of the colour.
	    \*/
                R.rgb = cacher(function (r, g, b) {
                    function round(x) {
                        return (x + 0.5) | 0;
                    }

                    return "#" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);
                });
                /*\
	     * Raphael.getColor
	     [ method ]
	     **
	     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
	     > Parameters
	     - value (number) #optional brightness, default is `0.75`
	     = (string) hex representation of the colour.
	    \*/
                R.getColor = function (value) {
                    var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
                        rgb = this.hsb2rgb(start.h, start.s, start.b);
                    start.h += .075;
                    if (start.h > 1) {
                        start.h = 0;
                        start.s -= .2;
                        start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
                    }
                    return rgb.hex;
                };
                /*\
	     * Raphael.getColor.reset
	     [ method ]
	     **
	     * Resets spectrum position for @Raphael.getColor back to red.
	    \*/
                R.getColor.reset = function () {
                    delete this.start;
                };

                // http://schepers.cc/getting-to-the-point
                function catmullRom2bezier(crp, z) {
                    var d = [];
                    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
                        var p = [
                            {x: +crp[i - 2], y: +crp[i - 1]},
                            {x: +crp[i], y: +crp[i + 1]},
                            {x: +crp[i + 2], y: +crp[i + 3]},
                            {x: +crp[i + 4], y: +crp[i + 5]}
                        ];
                        if (z) {
                            if (!i) {
                                p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                            } else if (iLen - 4 == i) {
                                p[3] = {x: +crp[0], y: +crp[1]};
                            } else if (iLen - 2 == i) {
                                p[2] = {x: +crp[0], y: +crp[1]};
                                p[3] = {x: +crp[2], y: +crp[3]};
                            }
                        } else {
                            if (iLen - 4 == i) {
                                p[3] = p[2];
                            } else if (!i) {
                                p[0] = {x: +crp[i], y: +crp[i + 1]};
                            }
                        }
                        d.push(["C",
                            (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                            (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                            (p[1].x + 6 * p[2].x - p[3].x) / 6,
                            (p[1].y + 6 * p[2].y - p[3].y) / 6,
                            p[2].x,
                            p[2].y
                        ]);
                    }

                    return d;
                }

                /*\
	     * Raphael.parsePathString
	     [ method ]
	     **
	     * Utility method
	     **
	     * Parses given path string into an array of arrays of path segments.
	     > Parameters
	     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
	     = (array) array of segments.
	    \*/
                R.parsePathString = function (pathString) {
                    if (!pathString) {
                        return null;
                    }
                    var pth = paths(pathString);
                    if (pth.arr) {
                        return pathClone(pth.arr);
                    }

                    var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
                        data = [];
                    if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
                        data = pathClone(pathString);
                    }
                    if (!data.length) {
                        Str(pathString).replace(pathCommand, function (a, b, c) {
                            var params = [],
                                name = b.toLowerCase();
                            c.replace(pathValues, function (a, b) {
                                b && params.push(+b);
                            });
                            if (name == "m" && params.length > 2) {
                                data.push([b][concat](params.splice(0, 2)));
                                name = "l";
                                b = b == "m" ? "l" : "L";
                            }
                            if (name == "r") {
                                data.push([b][concat](params));
                            } else while (params.length >= paramCounts[name]) {
                                data.push([b][concat](params.splice(0, paramCounts[name])));
                                if (!paramCounts[name]) {
                                    break;
                                }
                            }
                        });
                    }
                    data.toString = R._path2string;
                    pth.arr = pathClone(data);
                    return data;
                };
                /*\
	     * Raphael.parseTransformString
	     [ method ]
	     **
	     * Utility method
	     **
	     * Parses given path string into an array of transformations.
	     > Parameters
	     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
	     = (array) array of transformations.
	    \*/
                R.parseTransformString = cacher(function (TString) {
                    if (!TString) {
                        return null;
                    }
                    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
                        data = [];
                    if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
                        data = pathClone(TString);
                    }
                    if (!data.length) {
                        Str(TString).replace(tCommand, function (a, b, c) {
                            var params = [],
                                name = lowerCase.call(b);
                            c.replace(pathValues, function (a, b) {
                                b && params.push(+b);
                            });
                            data.push([b][concat](params));
                        });
                    }
                    data.toString = R._path2string;
                    return data;
                });
                // PATHS
                var paths = function (ps) {
                    var p = paths.ps = paths.ps || {};
                    if (p[ps]) {
                        p[ps].sleep = 100;
                    } else {
                        p[ps] = {
                            sleep: 100
                        };
                    }
                    setTimeout(function () {
                        for (var key in p) if (p[has](key) && key != ps) {
                            p[key].sleep--;
                            !p[key].sleep && delete p[key];
                        }
                    });
                    return p[ps];
                };
                /*\
	     * Raphael.findDotsAtSegment
	     [ method ]
	     **
	     * Utility method
	     **
	     * Find dot coordinates on the given cubic bezier curve at the given t.
	     > Parameters
	     - p1x (number) x of the first point of the curve
	     - p1y (number) y of the first point of the curve
	     - c1x (number) x of the first anchor of the curve
	     - c1y (number) y of the first anchor of the curve
	     - c2x (number) x of the second anchor of the curve
	     - c2y (number) y of the second anchor of the curve
	     - p2x (number) x of the second point of the curve
	     - p2y (number) y of the second point of the curve
	     - t (number) position on the curve (0..1)
	     = (object) point information in format:
	     o {
	     o     x: (number) x coordinate of the point
	     o     y: (number) y coordinate of the point
	     o     m: {
	     o         x: (number) x coordinate of the left anchor
	     o         y: (number) y coordinate of the left anchor
	     o     }
	     o     n: {
	     o         x: (number) x coordinate of the right anchor
	     o         y: (number) y coordinate of the right anchor
	     o     }
	     o     start: {
	     o         x: (number) x coordinate of the start of the curve
	     o         y: (number) y coordinate of the start of the curve
	     o     }
	     o     end: {
	     o         x: (number) x coordinate of the end of the curve
	     o         y: (number) y coordinate of the end of the curve
	     o     }
	     o     alpha: (number) angle of the curve derivative at the point
	     o }
	    \*/
                R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                    var t1 = 1 - t,
                        t13 = pow(t1, 3),
                        t12 = pow(t1, 2),
                        t2 = t * t,
                        t3 = t2 * t,
                        x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
                        y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
                        mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
                        my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
                        nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
                        ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
                        ax = t1 * p1x + t * c1x,
                        ay = t1 * p1y + t * c1y,
                        cx = t1 * c2x + t * p2x,
                        cy = t1 * c2y + t * p2y,
                        alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
                    (mx > nx || my < ny) && (alpha += 180);
                    return {
                        x: x,
                        y: y,
                        m: {x: mx, y: my},
                        n: {x: nx, y: ny},
                        start: {x: ax, y: ay},
                        end: {x: cx, y: cy},
                        alpha: alpha
                    };
                };
                /*\
	     * Raphael.bezierBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Return bounding box of a given cubic bezier curve
	     > Parameters
	     - p1x (number) x of the first point of the curve
	     - p1y (number) y of the first point of the curve
	     - c1x (number) x of the first anchor of the curve
	     - c1y (number) y of the first anchor of the curve
	     - c2x (number) x of the second anchor of the curve
	     - c2y (number) y of the second anchor of the curve
	     - p2x (number) x of the second point of the curve
	     - p2y (number) y of the second point of the curve
	     * or
	     - bez (array) array of six points for bezier curve
	     = (object) point information in format:
	     o {
	     o     min: {
	     o         x: (number) x coordinate of the left point
	     o         y: (number) y coordinate of the top point
	     o     }
	     o     max: {
	     o         x: (number) x coordinate of the right point
	     o         y: (number) y coordinate of the bottom point
	     o     }
	     o }
	    \*/
                R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                    if (!R.is(p1x, "array")) {
                        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
                    }
                    var bbox = curveDim.apply(null, p1x);
                    return {
                        x: bbox.min.x,
                        y: bbox.min.y,
                        x2: bbox.max.x,
                        y2: bbox.max.y,
                        width: bbox.max.x - bbox.min.x,
                        height: bbox.max.y - bbox.min.y
                    };
                };
                /*\
	     * Raphael.isPointInsideBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if given point is inside bounding boxes.
	     > Parameters
	     - bbox (string) bounding box
	     - x (string) x coordinate of the point
	     - y (string) y coordinate of the point
	     = (boolean) `true` if point inside
	    \*/
                R.isPointInsideBBox = function (bbox, x, y) {
                    return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
                };
                /*\
	     * Raphael.isBBoxIntersect
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if two bounding boxes intersect
	     > Parameters
	     - bbox1 (string) first bounding box
	     - bbox2 (string) second bounding box
	     = (boolean) `true` if they intersect
	    \*/
                R.isBBoxIntersect = function (bbox1, bbox2) {
                    var i = R.isPointInsideBBox;
                    return i(bbox2, bbox1.x, bbox1.y)
                        || i(bbox2, bbox1.x2, bbox1.y)
                        || i(bbox2, bbox1.x, bbox1.y2)
                        || i(bbox2, bbox1.x2, bbox1.y2)
                        || i(bbox1, bbox2.x, bbox2.y)
                        || i(bbox1, bbox2.x2, bbox2.y)
                        || i(bbox1, bbox2.x, bbox2.y2)
                        || i(bbox1, bbox2.x2, bbox2.y2)
                        || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
                        && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
                };

                function base3(t, p1, p2, p3, p4) {
                    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
                        t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
                    return t * t2 - 3 * p1 + 3 * p2;
                }

                function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
                    if (z == null) {
                        z = 1;
                    }
                    z = z > 1 ? 1 : z < 0 ? 0 : z;
                    var z2 = z / 2,
                        n = 12,
                        Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
                        Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
                        sum = 0;
                    for (var i = 0; i < n; i++) {
                        var ct = z2 * Tvalues[i] + z2,
                            xbase = base3(ct, x1, x2, x3, x4),
                            ybase = base3(ct, y1, y2, y3, y4),
                            comb = xbase * xbase + ybase * ybase;
                        sum += Cvalues[i] * math.sqrt(comb);
                    }
                    return z2 * sum;
                }

                function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
                    if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
                        return;
                    }
                    var t = 1,
                        step = t / 2,
                        t2 = t - step,
                        l,
                        e = .01;
                    l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                    while (abs(l - ll) > e) {
                        step /= 2;
                        t2 += (l < ll ? 1 : -1) * step;
                        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                    }
                    return t2;
                }

                function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                    if (
                        mmax(x1, x2) < mmin(x3, x4) ||
                        mmin(x1, x2) > mmax(x3, x4) ||
                        mmax(y1, y2) < mmin(y3, y4) ||
                        mmin(y1, y2) > mmax(y3, y4)
                    ) {
                        return;
                    }
                    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
                        ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
                        denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

                    if (!denominator) {
                        return;
                    }
                    var px = nx / denominator,
                        py = ny / denominator,
                        px2 = +px.toFixed(2),
                        py2 = +py.toFixed(2);
                    if (
                        px2 < +mmin(x1, x2).toFixed(2) ||
                        px2 > +mmax(x1, x2).toFixed(2) ||
                        px2 < +mmin(x3, x4).toFixed(2) ||
                        px2 > +mmax(x3, x4).toFixed(2) ||
                        py2 < +mmin(y1, y2).toFixed(2) ||
                        py2 > +mmax(y1, y2).toFixed(2) ||
                        py2 < +mmin(y3, y4).toFixed(2) ||
                        py2 > +mmax(y3, y4).toFixed(2)
                    ) {
                        return;
                    }
                    return {x: px, y: py};
                }

                function inter(bez1, bez2) {
                    return interHelper(bez1, bez2);
                }

                function interCount(bez1, bez2) {
                    return interHelper(bez1, bez2, 1);
                }

                function interHelper(bez1, bez2, justCount) {
                    var bbox1 = R.bezierBBox(bez1),
                        bbox2 = R.bezierBBox(bez2);
                    if (!R.isBBoxIntersect(bbox1, bbox2)) {
                        return justCount ? 0 : [];
                    }
                    var l1 = bezlen.apply(0, bez1),
                        l2 = bezlen.apply(0, bez2),
                        n1 = mmax(~~(l1 / 5), 1),
                        n2 = mmax(~~(l2 / 5), 1),
                        dots1 = [],
                        dots2 = [],
                        xy = {},
                        res = justCount ? 0 : [];
                    for (var i = 0; i < n1 + 1; i++) {
                        var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
                        dots1.push({x: p.x, y: p.y, t: i / n1});
                    }
                    for (i = 0; i < n2 + 1; i++) {
                        p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
                        dots2.push({x: p.x, y: p.y, t: i / n2});
                    }
                    for (i = 0; i < n1; i++) {
                        for (var j = 0; j < n2; j++) {
                            var di = dots1[i],
                                di1 = dots1[i + 1],
                                dj = dots2[j],
                                dj1 = dots2[j + 1],
                                ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                                cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                                is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                            if (is) {
                                if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                                    continue;
                                }
                                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                                var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                                    t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                                if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                                    if (justCount) {
                                        res++;
                                    } else {
                                        res.push({
                                            x: is.x,
                                            y: is.y,
                                            t1: mmin(t1, 1),
                                            t2: mmin(t2, 1)
                                        });
                                    }
                                }
                            }
                        }
                    }
                    return res;
                }

                /*\
	     * Raphael.pathIntersection
	     [ method ]
	     **
	     * Utility method
	     **
	     * Finds intersections of two paths
	     > Parameters
	     - path1 (string) path string
	     - path2 (string) path string
	     = (array) dots of intersection
	     o [
	     o     {
	     o         x: (number) x coordinate of the point
	     o         y: (number) y coordinate of the point
	     o         t1: (number) t value for segment of path1
	     o         t2: (number) t value for segment of path2
	     o         segment1: (number) order number for segment of path1
	     o         segment2: (number) order number for segment of path2
	     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
	     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
	     o     }
	     o ]
	    \*/
                R.pathIntersection = function (path1, path2) {
                    return interPathHelper(path1, path2);
                };
                R.pathIntersectionNumber = function (path1, path2) {
                    return interPathHelper(path1, path2, 1);
                };

                function interPathHelper(path1, path2, justCount) {
                    path1 = R._path2curve(path1);
                    path2 = R._path2curve(path2);
                    var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
                        res = justCount ? 0 : [];
                    for (var i = 0, ii = path1.length; i < ii; i++) {
                        var pi = path1[i];
                        if (pi[0] == "M") {
                            x1 = x1m = pi[1];
                            y1 = y1m = pi[2];
                        } else {
                            if (pi[0] == "C") {
                                bez1 = [x1, y1].concat(pi.slice(1));
                                x1 = bez1[6];
                                y1 = bez1[7];
                            } else {
                                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                                x1 = x1m;
                                y1 = y1m;
                            }
                            for (var j = 0, jj = path2.length; j < jj; j++) {
                                var pj = path2[j];
                                if (pj[0] == "M") {
                                    x2 = x2m = pj[1];
                                    y2 = y2m = pj[2];
                                } else {
                                    if (pj[0] == "C") {
                                        bez2 = [x2, y2].concat(pj.slice(1));
                                        x2 = bez2[6];
                                        y2 = bez2[7];
                                    } else {
                                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                                        x2 = x2m;
                                        y2 = y2m;
                                    }
                                    var intr = interHelper(bez1, bez2, justCount);
                                    if (justCount) {
                                        res += intr;
                                    } else {
                                        for (var k = 0, kk = intr.length; k < kk; k++) {
                                            intr[k].segment1 = i;
                                            intr[k].segment2 = j;
                                            intr[k].bez1 = bez1;
                                            intr[k].bez2 = bez2;
                                        }
                                        res = res.concat(intr);
                                    }
                                }
                            }
                        }
                    }
                    return res;
                }

                /*\
	     * Raphael.isPointInsidePath
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if given point is inside a given closed path.
	     > Parameters
	     - path (string) path string
	     - x (number) x of the point
	     - y (number) y of the point
	     = (boolean) true, if point is inside the path
	    \*/
                R.isPointInsidePath = function (path, x, y) {
                    var bbox = R.pathBBox(path);
                    return R.isPointInsideBBox(bbox, x, y) &&
                        interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
                };
                R._removedFactory = function (methodname) {
                    return function () {
                        eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
                    };
                };
                /*\
	     * Raphael.pathBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Return bounding box of a given path
	     > Parameters
	     - path (string) path string
	     = (object) bounding box
	     o {
	     o     x: (number) x coordinate of the left top point of the box
	     o     y: (number) y coordinate of the left top point of the box
	     o     x2: (number) x coordinate of the right bottom point of the box
	     o     y2: (number) y coordinate of the right bottom point of the box
	     o     width: (number) width of the box
	     o     height: (number) height of the box
	     o     cx: (number) x coordinate of the center of the box
	     o     cy: (number) y coordinate of the center of the box
	     o }
	    \*/
                var pathDimensions = R.pathBBox = function (path) {
                        var pth = paths(path);
                        if (pth.bbox) {
                            return clone(pth.bbox);
                        }
                        if (!path) {
                            return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
                        }
                        path = path2curve(path);
                        var x = 0,
                            y = 0,
                            X = [],
                            Y = [],
                            p;
                        for (var i = 0, ii = path.length; i < ii; i++) {
                            p = path[i];
                            if (p[0] == "M") {
                                x = p[1];
                                y = p[2];
                                X.push(x);
                                Y.push(y);
                            } else {
                                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                                X = X[concat](dim.min.x, dim.max.x);
                                Y = Y[concat](dim.min.y, dim.max.y);
                                x = p[5];
                                y = p[6];
                            }
                        }
                        var xmin = mmin[apply](0, X),
                            ymin = mmin[apply](0, Y),
                            xmax = mmax[apply](0, X),
                            ymax = mmax[apply](0, Y),
                            width = xmax - xmin,
                            height = ymax - ymin,
                            bb = {
                                x: xmin,
                                y: ymin,
                                x2: xmax,
                                y2: ymax,
                                width: width,
                                height: height,
                                cx: xmin + width / 2,
                                cy: ymin + height / 2
                            };
                        pth.bbox = clone(bb);
                        return bb;
                    },
                    pathClone = function (pathArray) {
                        var res = clone(pathArray);
                        res.toString = R._path2string;
                        return res;
                    },
                    pathToRelative = R._pathToRelative = function (pathArray) {
                        var pth = paths(pathArray);
                        if (pth.rel) {
                            return pathClone(pth.rel);
                        }
                        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                            pathArray = R.parsePathString(pathArray);
                        }
                        var res = [],
                            x = 0,
                            y = 0,
                            mx = 0,
                            my = 0,
                            start = 0;
                        if (pathArray[0][0] == "M") {
                            x = pathArray[0][1];
                            y = pathArray[0][2];
                            mx = x;
                            my = y;
                            start++;
                            res.push(["M", x, y]);
                        }
                        for (var i = start, ii = pathArray.length; i < ii; i++) {
                            var r = res[i] = [],
                                pa = pathArray[i];
                            if (pa[0] != lowerCase.call(pa[0])) {
                                r[0] = lowerCase.call(pa[0]);
                                switch (r[0]) {
                                    case "a":
                                        r[1] = pa[1];
                                        r[2] = pa[2];
                                        r[3] = pa[3];
                                        r[4] = pa[4];
                                        r[5] = pa[5];
                                        r[6] = +(pa[6] - x).toFixed(3);
                                        r[7] = +(pa[7] - y).toFixed(3);
                                        break;
                                    case "v":
                                        r[1] = +(pa[1] - y).toFixed(3);
                                        break;
                                    case "m":
                                        mx = pa[1];
                                        my = pa[2];
                                    default:
                                        for (var j = 1, jj = pa.length; j < jj; j++) {
                                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                                        }
                                }
                            } else {
                                r = res[i] = [];
                                if (pa[0] == "m") {
                                    mx = pa[1] + x;
                                    my = pa[2] + y;
                                }
                                for (var k = 0, kk = pa.length; k < kk; k++) {
                                    res[i][k] = pa[k];
                                }
                            }
                            var len = res[i].length;
                            switch (res[i][0]) {
                                case "z":
                                    x = mx;
                                    y = my;
                                    break;
                                case "h":
                                    x += +res[i][len - 1];
                                    break;
                                case "v":
                                    y += +res[i][len - 1];
                                    break;
                                default:
                                    x += +res[i][len - 2];
                                    y += +res[i][len - 1];
                            }
                        }
                        res.toString = R._path2string;
                        pth.rel = pathClone(res);
                        return res;
                    },
                    pathToAbsolute = R._pathToAbsolute = function (pathArray) {
                        var pth = paths(pathArray);
                        if (pth.abs) {
                            return pathClone(pth.abs);
                        }
                        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                            pathArray = R.parsePathString(pathArray);
                        }
                        if (!pathArray || !pathArray.length) {
                            return [["M", 0, 0]];
                        }
                        var res = [],
                            x = 0,
                            y = 0,
                            mx = 0,
                            my = 0,
                            start = 0;
                        if (pathArray[0][0] == "M") {
                            x = +pathArray[0][1];
                            y = +pathArray[0][2];
                            mx = x;
                            my = y;
                            start++;
                            res[0] = ["M", x, y];
                        }
                        var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
                        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                            res.push(r = []);
                            pa = pathArray[i];
                            if (pa[0] != upperCase.call(pa[0])) {
                                r[0] = upperCase.call(pa[0]);
                                switch (r[0]) {
                                    case "A":
                                        r[1] = pa[1];
                                        r[2] = pa[2];
                                        r[3] = pa[3];
                                        r[4] = pa[4];
                                        r[5] = pa[5];
                                        r[6] = +(pa[6] + x);
                                        r[7] = +(pa[7] + y);
                                        break;
                                    case "V":
                                        r[1] = +pa[1] + y;
                                        break;
                                    case "H":
                                        r[1] = +pa[1] + x;
                                        break;
                                    case "R":
                                        var dots = [x, y][concat](pa.slice(1));
                                        for (var j = 2, jj = dots.length; j < jj; j++) {
                                            dots[j] = +dots[j] + x;
                                            dots[++j] = +dots[j] + y;
                                        }
                                        res.pop();
                                        res = res[concat](catmullRom2bezier(dots, crz));
                                        break;
                                    case "M":
                                        mx = +pa[1] + x;
                                        my = +pa[2] + y;
                                    default:
                                        for (j = 1, jj = pa.length; j < jj; j++) {
                                            r[j] = +pa[j] + ((j % 2) ? x : y);
                                        }
                                }
                            } else if (pa[0] == "R") {
                                dots = [x, y][concat](pa.slice(1));
                                res.pop();
                                res = res[concat](catmullRom2bezier(dots, crz));
                                r = ["R"][concat](pa.slice(-2));
                            } else {
                                for (var k = 0, kk = pa.length; k < kk; k++) {
                                    r[k] = pa[k];
                                }
                            }
                            switch (r[0]) {
                                case "Z":
                                    x = mx;
                                    y = my;
                                    break;
                                case "H":
                                    x = r[1];
                                    break;
                                case "V":
                                    y = r[1];
                                    break;
                                case "M":
                                    mx = r[r.length - 2];
                                    my = r[r.length - 1];
                                default:
                                    x = r[r.length - 2];
                                    y = r[r.length - 1];
                            }
                        }
                        res.toString = R._path2string;
                        pth.abs = pathClone(res);
                        return res;
                    },
                    l2c = function (x1, y1, x2, y2) {
                        return [x1, y1, x2, y2, x2, y2];
                    },
                    q2c = function (x1, y1, ax, ay, x2, y2) {
                        var _13 = 1 / 3,
                            _23 = 2 / 3;
                        return [
                            _13 * x1 + _23 * ax,
                            _13 * y1 + _23 * ay,
                            _13 * x2 + _23 * ax,
                            _13 * y2 + _23 * ay,
                            x2,
                            y2
                        ];
                    },
                    a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
                        // for more information of where this math came from visit:
                        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                        var _120 = PI * 120 / 180,
                            rad = PI / 180 * (+angle || 0),
                            res = [],
                            xy,
                            rotate = cacher(function (x, y, rad) {
                                var X = x * math.cos(rad) - y * math.sin(rad),
                                    Y = x * math.sin(rad) + y * math.cos(rad);
                                return {x: X, y: Y};
                            });
                        if (!recursive) {
                            xy = rotate(x1, y1, -rad);
                            x1 = xy.x;
                            y1 = xy.y;
                            xy = rotate(x2, y2, -rad);
                            x2 = xy.x;
                            y2 = xy.y;
                            var cos = math.cos(PI / 180 * angle),
                                sin = math.sin(PI / 180 * angle),
                                x = (x1 - x2) / 2,
                                y = (y1 - y2) / 2;
                            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                            if (h > 1) {
                                h = math.sqrt(h);
                                rx = h * rx;
                                ry = h * ry;
                            }
                            var rx2 = rx * rx,
                                ry2 = ry * ry,
                                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                                cx = k * rx * y / ry + (x1 + x2) / 2,
                                cy = k * -ry * x / rx + (y1 + y2) / 2,
                                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                            f1 = x1 < cx ? PI - f1 : f1;
                            f2 = x2 < cx ? PI - f2 : f2;
                            f1 < 0 && (f1 = PI * 2 + f1);
                            f2 < 0 && (f2 = PI * 2 + f2);
                            if (sweep_flag && f1 > f2) {
                                f1 = f1 - PI * 2;
                            }
                            if (!sweep_flag && f2 > f1) {
                                f2 = f2 - PI * 2;
                            }
                        } else {
                            f1 = recursive[0];
                            f2 = recursive[1];
                            cx = recursive[2];
                            cy = recursive[3];
                        }
                        var df = f2 - f1;
                        if (abs(df) > _120) {
                            var f2old = f2,
                                x2old = x2,
                                y2old = y2;
                            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                            x2 = cx + rx * math.cos(f2);
                            y2 = cy + ry * math.sin(f2);
                            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
                        }
                        df = f2 - f1;
                        var c1 = math.cos(f1),
                            s1 = math.sin(f1),
                            c2 = math.cos(f2),
                            s2 = math.sin(f2),
                            t = math.tan(df / 4),
                            hx = 4 / 3 * rx * t,
                            hy = 4 / 3 * ry * t,
                            m1 = [x1, y1],
                            m2 = [x1 + hx * s1, y1 - hy * c1],
                            m3 = [x2 + hx * s2, y2 - hy * c2],
                            m4 = [x2, y2];
                        m2[0] = 2 * m1[0] - m2[0];
                        m2[1] = 2 * m1[1] - m2[1];
                        if (recursive) {
                            return [m2, m3, m4][concat](res);
                        } else {
                            res = [m2, m3, m4][concat](res).join()[split](",");
                            var newres = [];
                            for (var i = 0, ii = res.length; i < ii; i++) {
                                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                            }
                            return newres;
                        }
                    },
                    findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                        var t1 = 1 - t;
                        return {
                            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
                        };
                    },
                    curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                        var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                            b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                            c = p1x - c1x,
                            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                            y = [p1y, p2y],
                            x = [p1x, p2x],
                            dot;
                        abs(t1) > "1e12" && (t1 = .5);
                        abs(t2) > "1e12" && (t2 = .5);
                        if (t1 > 0 && t1 < 1) {
                            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                            x.push(dot.x);
                            y.push(dot.y);
                        }
                        if (t2 > 0 && t2 < 1) {
                            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                            x.push(dot.x);
                            y.push(dot.y);
                        }
                        a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
                        b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
                        c = p1y - c1y;
                        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
                        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
                        abs(t1) > "1e12" && (t1 = .5);
                        abs(t2) > "1e12" && (t2 = .5);
                        if (t1 > 0 && t1 < 1) {
                            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                            x.push(dot.x);
                            y.push(dot.y);
                        }
                        if (t2 > 0 && t2 < 1) {
                            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                            x.push(dot.x);
                            y.push(dot.y);
                        }
                        return {
                            min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                            max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
                        };
                    }),
                    path2curve = R._path2curve = cacher(function (path, path2) {
                        var pth = !path2 && paths(path);
                        if (!path2 && pth.curve) {
                            return pathClone(pth.curve);
                        }
                        var p = pathToAbsolute(path),
                            p2 = path2 && pathToAbsolute(path2),
                            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                            processPath = function (path, d, pcom) {
                                var nx, ny, tq = {T: 1, Q: 1};
                                if (!path) {
                                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                                }
                                !(path[0] in tq) && (d.qx = d.qy = null);
                                switch (path[0]) {
                                    case "M":
                                        d.X = path[1];
                                        d.Y = path[2];
                                        break;
                                    case "A":
                                        path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                                        break;
                                    case "S":
                                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                            nx = d.x * 2 - d.bx;          // And reflect the previous
                                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                                        }
                                        else {                            // or some else or nothing
                                            nx = d.x;
                                            ny = d.y;
                                        }
                                        path = ["C", nx, ny][concat](path.slice(1));
                                        break;
                                    case "T":
                                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                            d.qy = d.y * 2 - d.qy;        // to case "S".
                                        }
                                        else {                            // or something else or nothing
                                            d.qx = d.x;
                                            d.qy = d.y;
                                        }
                                        path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                                        break;
                                    case "Q":
                                        d.qx = path[1];
                                        d.qy = path[2];
                                        path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                                        break;
                                    case "L":
                                        path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                                        break;
                                    case "H":
                                        path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                                        break;
                                    case "V":
                                        path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                                        break;
                                    case "Z":
                                        path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                                        break;
                                }
                                return path;
                            },
                            fixArc = function (pp, i) {
                                if (pp[i].length > 7) {
                                    pp[i].shift();
                                    var pi = pp[i];
                                    while (pi.length) {
                                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                                        p2 && (pcoms2[i] = "A"); // the same as above
                                        pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                                    }
                                    pp.splice(i, 1);
                                    ii = mmax(p.length, p2 && p2.length || 0);
                                }
                            },
                            fixM = function (path1, path2, a1, a2, i) {
                                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                                    a1.bx = 0;
                                    a1.by = 0;
                                    a1.x = path1[i][1];
                                    a1.y = path1[i][2];
                                    ii = mmax(p.length, p2 && p2.length || 0);
                                }
                            },
                            pcoms1 = [], // path commands of original path p
                            pcoms2 = [], // path commands of original path p2
                            pfirst = "", // temporary holder for original path command
                            pcom = ""; // holder for previous path command of original path
                        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                            p[i] && (pfirst = p[i][0]); // save current path command

                            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                            {
                                pcoms1[i] = pfirst; // Save current path command
                                i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
                            }
                            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                            // which may produce multiple C:s
                            // so we have to make sure that C is also C in original path

                            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                            if (p2) { // the same procedures is done to p2
                                p2[i] && (pfirst = p2[i][0]);
                                if (pfirst != "C") {
                                    pcoms2[i] = pfirst;
                                    i && (pcom = pcoms2[i - 1]);
                                }
                                p2[i] = processPath(p2[i], attrs2, pcom);

                                if (pcoms2[i] != "A" && pfirst == "C") pcoms2[i] = "C";

                                fixArc(p2, i);
                            }
                            fixM(p, p2, attrs, attrs2, i);
                            fixM(p2, p, attrs2, attrs, i);
                            var seg = p[i],
                                seg2 = p2 && p2[i],
                                seglen = seg.length,
                                seg2len = p2 && seg2.length;
                            attrs.x = seg[seglen - 2];
                            attrs.y = seg[seglen - 1];
                            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                            attrs2.x = p2 && seg2[seg2len - 2];
                            attrs2.y = p2 && seg2[seg2len - 1];
                        }
                        if (!p2) {
                            pth.curve = pathClone(p);
                        }
                        return p2 ? [p, p2] : p;
                    }, null, pathClone),
                    parseDots = R._parseDots = cacher(function (gradient) {
                        var dots = [];
                        for (var i = 0, ii = gradient.length; i < ii; i++) {
                            var dot = {},
                                par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                            dot.color = R.getRGB(par[1]);
                            if (dot.color.error) {
                                return null;
                            }
                            dot.opacity = dot.color.opacity;
                            dot.color = dot.color.hex;
                            par[2] && (dot.offset = par[2] + "%");
                            dots.push(dot);
                        }
                        for (i = 1, ii = dots.length - 1; i < ii; i++) {
                            if (!dots[i].offset) {
                                var start = toFloat(dots[i - 1].offset || 0),
                                    end = 0;
                                for (var j = i + 1; j < ii; j++) {
                                    if (dots[j].offset) {
                                        end = dots[j].offset;
                                        break;
                                    }
                                }
                                if (!end) {
                                    end = 100;
                                    j = ii;
                                }
                                end = toFloat(end);
                                var d = (end - start) / (j - i + 1);
                                for (; i < j; i++) {
                                    start += d;
                                    dots[i].offset = start + "%";
                                }
                            }
                        }
                        return dots;
                    }),
                    tear = R._tear = function (el, paper) {
                        el == paper.top && (paper.top = el.prev);
                        el == paper.bottom && (paper.bottom = el.next);
                        el.next && (el.next.prev = el.prev);
                        el.prev && (el.prev.next = el.next);
                    },
                    tofront = R._tofront = function (el, paper) {
                        if (paper.top === el) {
                            return;
                        }
                        tear(el, paper);
                        el.next = null;
                        el.prev = paper.top;
                        paper.top.next = el;
                        paper.top = el;
                    },
                    toback = R._toback = function (el, paper) {
                        if (paper.bottom === el) {
                            return;
                        }
                        tear(el, paper);
                        el.next = paper.bottom;
                        el.prev = null;
                        paper.bottom.prev = el;
                        paper.bottom = el;
                    },
                    insertafter = R._insertafter = function (el, el2, paper) {
                        tear(el, paper);
                        el2 == paper.top && (paper.top = el);
                        el2.next && (el2.next.prev = el);
                        el.next = el2.next;
                        el.prev = el2;
                        el2.next = el;
                    },
                    insertbefore = R._insertbefore = function (el, el2, paper) {
                        tear(el, paper);
                        el2 == paper.bottom && (paper.bottom = el);
                        el2.prev && (el2.prev.next = el);
                        el.prev = el2.prev;
                        el2.prev = el;
                        el.next = el2;
                    },
                    /*\
	         * Raphael.toMatrix
	         [ method ]
	         **
	         * Utility method
	         **
	         * Returns matrix of transformations applied to a given path
	         > Parameters
	         - path (string) path string
	         - transform (string|array) transformation string
	         = (object) @Matrix
	        \*/
                    toMatrix = R.toMatrix = function (path, transform) {
                        var bb = pathDimensions(path),
                            el = {
                                _: {
                                    transform: E
                                },
                                getBBox: function () {
                                    return bb;
                                }
                            };
                        extractTransform(el, transform);
                        return el.matrix;
                    },
                    /*\
	         * Raphael.transformPath
	         [ method ]
	         **
	         * Utility method
	         **
	         * Returns path transformed by a given transformation
	         > Parameters
	         - path (string) path string
	         - transform (string|array) transformation string
	         = (string) path
	        \*/
                    transformPath = R.transformPath = function (path, transform) {
                        return mapPath(path, toMatrix(path, transform));
                    },
                    extractTransform = R._extractTransform = function (el, tstr) {
                        if (tstr == null) {
                            return el._.transform;
                        }
                        tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
                        var tdata = R.parseTransformString(tstr),
                            deg = 0,
                            dx = 0,
                            dy = 0,
                            sx = 1,
                            sy = 1,
                            _ = el._,
                            m = new Matrix;
                        _.transform = tdata || [];
                        if (tdata) {
                            for (var i = 0, ii = tdata.length; i < ii; i++) {
                                var t = tdata[i],
                                    tlen = t.length,
                                    command = Str(t[0]).toLowerCase(),
                                    absolute = t[0] != command,
                                    inver = absolute ? m.invert() : 0,
                                    x1,
                                    y1,
                                    x2,
                                    y2,
                                    bb;
                                if (command == "t" && tlen == 3) {
                                    if (absolute) {
                                        x1 = inver.x(0, 0);
                                        y1 = inver.y(0, 0);
                                        x2 = inver.x(t[1], t[2]);
                                        y2 = inver.y(t[1], t[2]);
                                        m.translate(x2 - x1, y2 - y1);
                                    } else {
                                        m.translate(t[1], t[2]);
                                    }
                                } else if (command == "r") {
                                    if (tlen == 2) {
                                        bb = bb || el.getBBox(1);
                                        m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                                        deg += t[1];
                                    } else if (tlen == 4) {
                                        if (absolute) {
                                            x2 = inver.x(t[2], t[3]);
                                            y2 = inver.y(t[2], t[3]);
                                            m.rotate(t[1], x2, y2);
                                        } else {
                                            m.rotate(t[1], t[2], t[3]);
                                        }
                                        deg += t[1];
                                    }
                                } else if (command == "s") {
                                    if (tlen == 2 || tlen == 3) {
                                        bb = bb || el.getBBox(1);
                                        m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                                        sx *= t[1];
                                        sy *= t[tlen - 1];
                                    } else if (tlen == 5) {
                                        if (absolute) {
                                            x2 = inver.x(t[3], t[4]);
                                            y2 = inver.y(t[3], t[4]);
                                            m.scale(t[1], t[2], x2, y2);
                                        } else {
                                            m.scale(t[1], t[2], t[3], t[4]);
                                        }
                                        sx *= t[1];
                                        sy *= t[2];
                                    }
                                } else if (command == "m" && tlen == 7) {
                                    m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                                }
                                _.dirtyT = 1;
                                el.matrix = m;
                            }
                        }

                        /*\
	             * Element.matrix
	             [ property (object) ]
	             **
	             * Keeps @Matrix object, which represents element transformation
	            \*/
                        el.matrix = m;

                        _.sx = sx;
                        _.sy = sy;
                        _.deg = deg;
                        _.dx = dx = m.e;
                        _.dy = dy = m.f;

                        if (sx == 1 && sy == 1 && !deg && _.bbox) {
                            _.bbox.x += +dx;
                            _.bbox.y += +dy;
                        } else {
                            _.dirtyT = 1;
                        }
                    },
                    getEmpty = function (item) {
                        var l = item[0];
                        switch (l.toLowerCase()) {
                            case "t":
                                return [l, 0, 0];
                            case "m":
                                return [l, 1, 0, 0, 1, 0, 0];
                            case "r":
                                if (item.length == 4) {
                                    return [l, 0, item[2], item[3]];
                                } else {
                                    return [l, 0];
                                }
                            case "s":
                                if (item.length == 5) {
                                    return [l, 1, 1, item[3], item[4]];
                                } else if (item.length == 3) {
                                    return [l, 1, 1];
                                } else {
                                    return [l, 1];
                                }
                        }
                    },
                    equaliseTransform = R._equaliseTransform = function (t1, t2) {
                        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
                        t1 = R.parseTransformString(t1) || [];
                        t2 = R.parseTransformString(t2) || [];
                        var maxlength = mmax(t1.length, t2.length),
                            from = [],
                            to = [],
                            i = 0, j, jj,
                            tt1, tt2;
                        for (; i < maxlength; i++) {
                            tt1 = t1[i] || getEmpty(t2[i]);
                            tt2 = t2[i] || getEmpty(tt1);
                            if ((tt1[0] != tt2[0]) ||
                                (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                                (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                            ) {
                                return;
                            }
                            from[i] = [];
                            to[i] = [];
                            for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                                j in tt1 && (from[i][j] = tt1[j]);
                                j in tt2 && (to[i][j] = tt2[j]);
                            }
                        }
                        return {
                            from: from,
                            to: to
                        };
                    };
                R._getContainer = function (x, y, w, h) {
                    var container;
                    container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
                    if (container == null) {
                        return;
                    }
                    if (container.tagName) {
                        if (y == null) {
                            return {
                                container: container,
                                width: container.style.pixelWidth || container.offsetWidth,
                                height: container.style.pixelHeight || container.offsetHeight
                            };
                        } else {
                            return {
                                container: container,
                                width: y,
                                height: w
                            };
                        }
                    }
                    return {
                        container: 1,
                        x: x,
                        y: y,
                        width: w,
                        height: h
                    };
                };
                /*\
	     * Raphael.pathToRelative
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path to relative form
	     > Parameters
	     - pathString (string|array) path string or array of segments
	     = (array) array of segments.
	    \*/
                R.pathToRelative = pathToRelative;
                R._engine = {};
                /*\
	     * Raphael.path2curve
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path to a new path where all segments are cubic bezier curves.
	     > Parameters
	     - pathString (string|array) path string or array of segments
	     = (array) array of segments.
	    \*/
                R.path2curve = path2curve;
                /*\
	     * Raphael.matrix
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns matrix based on given parameters.
	     > Parameters
	     - a (number)
	     - b (number)
	     - c (number)
	     - d (number)
	     - e (number)
	     - f (number)
	     = (object) @Matrix
	    \*/
                R.matrix = function (a, b, c, d, e, f) {
                    return new Matrix(a, b, c, d, e, f);
                };

                function Matrix(a, b, c, d, e, f) {
                    if (a != null) {
                        this.a = +a;
                        this.b = +b;
                        this.c = +c;
                        this.d = +d;
                        this.e = +e;
                        this.f = +f;
                    } else {
                        this.a = 1;
                        this.b = 0;
                        this.c = 0;
                        this.d = 1;
                        this.e = 0;
                        this.f = 0;
                    }
                }

                (function (matrixproto) {
                    /*\
	         * Matrix.add
	         [ method ]
	         **
	         * Adds given matrix to existing one.
	         > Parameters
	         - a (number)
	         - b (number)
	         - c (number)
	         - d (number)
	         - e (number)
	         - f (number)
	         or
	         - matrix (object) @Matrix
	        \*/
                    matrixproto.add = function (a, b, c, d, e, f) {
                        var out = [[], [], []],
                            m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                            matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                            x, y, z, res;

                        if (a && a instanceof Matrix) {
                            matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
                        }

                        for (x = 0; x < 3; x++) {
                            for (y = 0; y < 3; y++) {
                                res = 0;
                                for (z = 0; z < 3; z++) {
                                    res += m[x][z] * matrix[z][y];
                                }
                                out[x][y] = res;
                            }
                        }
                        this.a = out[0][0];
                        this.b = out[1][0];
                        this.c = out[0][1];
                        this.d = out[1][1];
                        this.e = out[0][2];
                        this.f = out[1][2];
                    };
                    /*\
	         * Matrix.invert
	         [ method ]
	         **
	         * Returns inverted version of the matrix
	         = (object) @Matrix
	        \*/
                    matrixproto.invert = function () {
                        var me = this,
                            x = me.a * me.d - me.b * me.c;
                        return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
                    };
                    /*\
	         * Matrix.clone
	         [ method ]
	         **
	         * Returns copy of the matrix
	         = (object) @Matrix
	        \*/
                    matrixproto.clone = function () {
                        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
                    };
                    /*\
	         * Matrix.translate
	         [ method ]
	         **
	         * Translate the matrix
	         > Parameters
	         - x (number)
	         - y (number)
	        \*/
                    matrixproto.translate = function (x, y) {
                        this.add(1, 0, 0, 1, x, y);
                    };
                    /*\
	         * Matrix.scale
	         [ method ]
	         **
	         * Scales the matrix
	         > Parameters
	         - x (number)
	         - y (number) #optional
	         - cx (number) #optional
	         - cy (number) #optional
	        \*/
                    matrixproto.scale = function (x, y, cx, cy) {
                        y == null && (y = x);
                        (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
                        this.add(x, 0, 0, y, 0, 0);
                        (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
                    };
                    /*\
	         * Matrix.rotate
	         [ method ]
	         **
	         * Rotates the matrix
	         > Parameters
	         - a (number)
	         - x (number)
	         - y (number)
	        \*/
                    matrixproto.rotate = function (a, x, y) {
                        a = R.rad(a);
                        x = x || 0;
                        y = y || 0;
                        var cos = +math.cos(a).toFixed(9),
                            sin = +math.sin(a).toFixed(9);
                        this.add(cos, sin, -sin, cos, x, y);
                        this.add(1, 0, 0, 1, -x, -y);
                    };
                    /*\
	         * Matrix.x
	         [ method ]
	         **
	         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
	         > Parameters
	         - x (number)
	         - y (number)
	         = (number) x
	        \*/
                    matrixproto.x = function (x, y) {
                        return x * this.a + y * this.c + this.e;
                    };
                    /*\
	         * Matrix.y
	         [ method ]
	         **
	         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
	         > Parameters
	         - x (number)
	         - y (number)
	         = (number) y
	        \*/
                    matrixproto.y = function (x, y) {
                        return x * this.b + y * this.d + this.f;
                    };
                    matrixproto.get = function (i) {
                        return +this[Str.fromCharCode(97 + i)].toFixed(4);
                    };
                    matrixproto.toString = function () {
                        return R.svg ?
                            "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                            [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
                    };
                    matrixproto.toFilter = function () {
                        return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                            ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                            ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
                    };
                    matrixproto.offset = function () {
                        return [this.e.toFixed(4), this.f.toFixed(4)];
                    };

                    function norm(a) {
                        return a[0] * a[0] + a[1] * a[1];
                    }

                    function normalize(a) {
                        var mag = math.sqrt(norm(a));
                        a[0] && (a[0] /= mag);
                        a[1] && (a[1] /= mag);
                    }

                    /*\
	         * Matrix.split
	         [ method ]
	         **
	         * Splits matrix into primitive transformations
	         = (object) in format:
	         o dx (number) translation by x
	         o dy (number) translation by y
	         o scalex (number) scale by x
	         o scaley (number) scale by y
	         o shear (number) shear
	         o rotate (number) rotation in deg
	         o isSimple (boolean) could it be represented via simple transformations
	        \*/
                    matrixproto.split = function () {
                        var out = {};
                        // translation
                        out.dx = this.e;
                        out.dy = this.f;

                        // scale and shear
                        var row = [[this.a, this.c], [this.b, this.d]];
                        out.scalex = math.sqrt(norm(row[0]));
                        normalize(row[0]);

                        out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
                        row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

                        out.scaley = math.sqrt(norm(row[1]));
                        normalize(row[1]);
                        out.shear /= out.scaley;

                        // rotation
                        var sin = -row[0][1],
                            cos = row[1][1];
                        if (cos < 0) {
                            out.rotate = R.deg(math.acos(cos));
                            if (sin < 0) {
                                out.rotate = 360 - out.rotate;
                            }
                        } else {
                            out.rotate = R.deg(math.asin(sin));
                        }

                        out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
                        out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
                        out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
                        return out;
                    };
                    /*\
	         * Matrix.toTransformString
	         [ method ]
	         **
	         * Return transform string that represents given matrix
	         = (string) transform string
	        \*/
                    matrixproto.toTransformString = function (shorter) {
                        var s = shorter || this[split]();
                        if (s.isSimple) {
                            s.scalex = +s.scalex.toFixed(4);
                            s.scaley = +s.scaley.toFixed(4);
                            s.rotate = +s.rotate.toFixed(4);
                            return (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                                (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                                (s.rotate ? "r" + [s.rotate, 0, 0] : E);
                        } else {
                            return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
                        }
                    };
                })(Matrix.prototype);

                var preventDefault = function () {
                        this.returnValue = false;
                    },
                    preventTouch = function () {
                        return this.originalEvent.preventDefault();
                    },
                    stopPropagation = function () {
                        this.cancelBubble = true;
                    },
                    stopTouch = function () {
                        return this.originalEvent.stopPropagation();
                    },
                    getEventPosition = function (e) {
                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

                        return {
                            x: e.clientX + scrollX,
                            y: e.clientY + scrollY
                        };
                    },
                    addEvent = (function () {
                        if (g.doc.addEventListener) {
                            return function (obj, type, fn, element) {
                                var f = function (e) {
                                    var pos = getEventPosition(e);
                                    return fn.call(element, e, pos.x, pos.y);
                                };
                                obj.addEventListener(type, f, false);

                                if (supportsTouch && touchMap[type]) {
                                    var _f = function (e) {
                                        var pos = getEventPosition(e),
                                            olde = e;

                                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                            if (e.targetTouches[i].target == obj) {
                                                e = e.targetTouches[i];
                                                e.originalEvent = olde;
                                                e.preventDefault = preventTouch;
                                                e.stopPropagation = stopTouch;
                                                break;
                                            }
                                        }

                                        return fn.call(element, e, pos.x, pos.y);
                                    };
                                    obj.addEventListener(touchMap[type], _f, false);
                                }

                                return function () {
                                    obj.removeEventListener(type, f, false);

                                    if (supportsTouch && touchMap[type])
                                        obj.removeEventListener(touchMap[type], _f, false);

                                    return true;
                                };
                            };
                        } else if (g.doc.attachEvent) {
                            return function (obj, type, fn, element) {
                                var f = function (e) {
                                    e = e || g.win.event;
                                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                                        x = e.clientX + scrollX,
                                        y = e.clientY + scrollY;
                                    e.preventDefault = e.preventDefault || preventDefault;
                                    e.stopPropagation = e.stopPropagation || stopPropagation;
                                    return fn.call(element, e, x, y);
                                };
                                obj.attachEvent("on" + type, f);
                                var detacher = function () {
                                    obj.detachEvent("on" + type, f);
                                    return true;
                                };
                                return detacher;
                            };
                        }
                    })(),
                    drag = [],
                    dragMove = function (e) {
                        var x = e.clientX,
                            y = e.clientY,
                            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                            dragi,
                            j = drag.length;
                        while (j--) {
                            dragi = drag[j];
                            if (supportsTouch && e.touches) {
                                var i = e.touches.length,
                                    touch;
                                while (i--) {
                                    touch = e.touches[i];
                                    if (touch.identifier == dragi.el._drag.id) {
                                        x = touch.clientX;
                                        y = touch.clientY;
                                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                                        break;
                                    }
                                }
                            } else {
                                e.preventDefault();
                            }
                            var node = dragi.el.node,
                                o,
                                next = node.nextSibling,
                                parent = node.parentNode,
                                display = node.style.display;
                            g.win.opera && parent.removeChild(node);
                            node.style.display = "none";
                            o = dragi.el.paper.getElementByPoint(x, y);
                            node.style.display = display;
                            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                            o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
                            x += scrollX;
                            y += scrollY;
                            eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
                        }
                    },
                    dragUp = function (e) {
                        R.unmousemove(dragMove).unmouseup(dragUp);
                        var i = drag.length,
                            dragi;
                        while (i--) {
                            dragi = drag[i];
                            dragi.el._drag = {};
                            eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
                        }
                        drag = [];
                    },
                    /*\
	     * Raphael.el
	     [ property (object) ]
	     **
	     * You can add your own method to elements. This is useful when you want to hack default functionality or
	     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
	     * you can redefine element method at any time. Expending element methods wouldn’t affect set.
	     > Usage
	     | Raphael.el.red = function () {
	     |     this.attr({fill: "#f00"});
	     | };
	     | // then use it
	     | paper.circle(100, 100, 20).red();
	    \*/
                    elproto = R.el = {};
                /*\
	     * Element.click
	     [ method ]
	     **
	     * Adds event handler for click for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unclick
	     [ method ]
	     **
	     * Removes event handler for click for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.dblclick
	     [ method ]
	     **
	     * Adds event handler for double click for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.undblclick
	     [ method ]
	     **
	     * Removes event handler for double click for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mousedown
	     [ method ]
	     **
	     * Adds event handler for mousedown for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmousedown
	     [ method ]
	     **
	     * Removes event handler for mousedown for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mousemove
	     [ method ]
	     **
	     * Adds event handler for mousemove for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmousemove
	     [ method ]
	     **
	     * Removes event handler for mousemove for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mouseout
	     [ method ]
	     **
	     * Adds event handler for mouseout for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmouseout
	     [ method ]
	     **
	     * Removes event handler for mouseout for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mouseover
	     [ method ]
	     **
	     * Adds event handler for mouseover for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmouseover
	     [ method ]
	     **
	     * Removes event handler for mouseover for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mouseup
	     [ method ]
	     **
	     * Adds event handler for mouseup for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmouseup
	     [ method ]
	     **
	     * Removes event handler for mouseup for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.touchstart
	     [ method ]
	     **
	     * Adds event handler for touchstart for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.untouchstart
	     [ method ]
	     **
	     * Removes event handler for touchstart for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.touchmove
	     [ method ]
	     **
	     * Adds event handler for touchmove for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.untouchmove
	     [ method ]
	     **
	     * Removes event handler for touchmove for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.touchend
	     [ method ]
	     **
	     * Adds event handler for touchend for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.untouchend
	     [ method ]
	     **
	     * Removes event handler for touchend for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.touchcancel
	     [ method ]
	     **
	     * Adds event handler for touchcancel for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.untouchcancel
	     [ method ]
	     **
	     * Removes event handler for touchcancel for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/
                for (var i = events.length; i--;) {
                    (function (eventName) {
                        R[eventName] = elproto[eventName] = function (fn, scope) {
                            if (R.is(fn, "function")) {
                                this.events = this.events || [];
                                this.events.push({
                                    name: eventName,
                                    f: fn,
                                    unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
                                });
                            }
                            return this;
                        };
                        R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                            var events = this.events || [],
                                l = events.length;
                            while (l--) {
                                if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                                    events[l].unbind();
                                    events.splice(l, 1);
                                    !events.length && delete this.events;
                                }
                            }
                            return this;
                        };
                    })(events[i]);
                }

                /*\
	     * Element.data
	     [ method ]
	     **
	     * Adds or retrieves given value associated with given key.
	     **
	     * See also @Element.removeData
	     > Parameters
	     - key (string) key to store data
	     - value (any) #optional value to store
	     = (object) @Element
	     * or, if value is not specified:
	     = (any) value
	     * or, if key and value are not specified:
	     = (object) Key/value pairs for all the data associated with the element.
	     > Usage
	     | for (var i = 0, i < 5, i++) {
	     |     paper.circle(10 + 15 * i, 10, 10)
	     |          .attr({fill: "#000"})
	     |          .data("i", i)
	     |          .click(function () {
	     |             alert(this.data("i"));
	     |          });
	     | }
	    \*/
                elproto.data = function (key, value) {
                    var data = eldata[this.id] = eldata[this.id] || {};
                    if (arguments.length == 0) {
                        return data;
                    }
                    if (arguments.length == 1) {
                        if (R.is(key, "object")) {
                            for (var i in key) if (key[has](i)) {
                                this.data(i, key[i]);
                            }
                            return this;
                        }
                        eve("raphael.data.get." + this.id, this, data[key], key);
                        return data[key];
                    }
                    data[key] = value;
                    eve("raphael.data.set." + this.id, this, value, key);
                    return this;
                };
                /*\
	     * Element.removeData
	     [ method ]
	     **
	     * Removes value associated with an element by given key.
	     * If key is not provided, removes all the data of the element.
	     > Parameters
	     - key (string) #optional key
	     = (object) @Element
	    \*/
                elproto.removeData = function (key) {
                    if (key == null) {
                        eldata[this.id] = {};
                    } else {
                        eldata[this.id] && delete eldata[this.id][key];
                    }
                    return this;
                };
                /*\
	     * Element.getData
	     [ method ]
	     **
	     * Retrieves the element data
	     = (object) data
	    \*/
                elproto.getData = function () {
                    return clone(eldata[this.id] || {});
                };
                /*\
	     * Element.hover
	     [ method ]
	     **
	     * Adds event handlers for hover for the element.
	     > Parameters
	     - f_in (function) handler for hover in
	     - f_out (function) handler for hover out
	     - icontext (object) #optional context for hover in handler
	     - ocontext (object) #optional context for hover out handler
	     = (object) @Element
	    \*/
                elproto.hover = function (f_in, f_out, scope_in, scope_out) {
                    return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
                };
                /*\
	     * Element.unhover
	     [ method ]
	     **
	     * Removes event handlers for hover for the element.
	     > Parameters
	     - f_in (function) handler for hover in
	     - f_out (function) handler for hover out
	     = (object) @Element
	    \*/
                elproto.unhover = function (f_in, f_out) {
                    return this.unmouseover(f_in).unmouseout(f_out);
                };
                var draggable = [];
                /*\
	     * Element.drag
	     [ method ]
	     **
	     * Adds event handlers for drag of the element.
	     > Parameters
	     - onmove (function) handler for moving
	     - onstart (function) handler for drag start
	     - onend (function) handler for drag end
	     - mcontext (object) #optional context for moving handler
	     - scontext (object) #optional context for drag start handler
	     - econtext (object) #optional context for drag end handler
	     * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,
	     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
	     * `drag.over.<id>` will be fired as well.
	     *
	     * Start event and start handler will be called in specified context or in context of the element with following parameters:
	     o x (number) x position of the mouse
	     o y (number) y position of the mouse
	     o event (object) DOM event object
	     * Move event and move handler will be called in specified context or in context of the element with following parameters:
	     o dx (number) shift by x from the start point
	     o dy (number) shift by y from the start point
	     o x (number) x position of the mouse
	     o y (number) y position of the mouse
	     o event (object) DOM event object
	     * End event and end handler will be called in specified context or in context of the element with following parameters:
	     o event (object) DOM event object
	     = (object) @Element
	    \*/
                elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
                    function start(e) {
                        (e.originalEvent || e).preventDefault();
                        var x = e.clientX,
                            y = e.clientY,
                            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                        this._drag.id = e.identifier;
                        if (supportsTouch && e.touches) {
                            var i = e.touches.length, touch;
                            while (i--) {
                                touch = e.touches[i];
                                this._drag.id = touch.identifier;
                                if (touch.identifier == this._drag.id) {
                                    x = touch.clientX;
                                    y = touch.clientY;
                                    break;
                                }
                            }
                        }
                        this._drag.x = x + scrollX;
                        this._drag.y = y + scrollY;
                        !drag.length && R.mousemove(dragMove).mouseup(dragUp);
                        drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
                        onstart && eve.on("raphael.drag.start." + this.id, onstart);
                        onmove && eve.on("raphael.drag.move." + this.id, onmove);
                        onend && eve.on("raphael.drag.end." + this.id, onend);
                        eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
                    }

                    this._drag = {};
                    draggable.push({el: this, start: start});
                    this.mousedown(start);
                    return this;
                };
                /*\
	     * Element.onDragOver
	     [ method ]
	     **
	     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
	     > Parameters
	     - f (function) handler for event, first argument would be the element you are dragging over
	    \*/
                elproto.onDragOver = function (f) {
                    f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
                };
                /*\
	     * Element.undrag
	     [ method ]
	     **
	     * Removes all drag event handlers from given element.
	    \*/
                elproto.undrag = function () {
                    var i = draggable.length;
                    while (i--) if (draggable[i].el == this) {
                        this.unmousedown(draggable[i].start);
                        draggable.splice(i, 1);
                        eve.unbind("raphael.drag.*." + this.id);
                    }
                    !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
                    drag = [];
                };
                /*\
	     * Paper.circle
	     [ method ]
	     **
	     * Draws a circle.
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the centre
	     - y (number) y coordinate of the centre
	     - r (number) radius
	     = (object) Raphaël element object with type “circle”
	     **
	     > Usage
	     | var c = paper.circle(50, 50, 40);
	    \*/
                paperproto.circle = function (x, y, r) {
                    var out = R._engine.circle(this, x || 0, y || 0, r || 0);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.rect
	     [ method ]
	     *
	     * Draws a rectangle.
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the top left corner
	     - y (number) y coordinate of the top left corner
	     - width (number) width
	     - height (number) height
	     - r (number) #optional radius for rounded corners, default is 0
	     = (object) Raphaël element object with type “rect”
	     **
	     > Usage
	     | // regular rectangle
	     | var c = paper.rect(10, 10, 50, 50);
	     | // rectangle with rounded corners
	     | var c = paper.rect(40, 40, 50, 50, 10);
	    \*/
                paperproto.rect = function (x, y, w, h, r) {
                    var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.ellipse
	     [ method ]
	     **
	     * Draws an ellipse.
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the centre
	     - y (number) y coordinate of the centre
	     - rx (number) horizontal radius
	     - ry (number) vertical radius
	     = (object) Raphaël element object with type “ellipse”
	     **
	     > Usage
	     | var c = paper.ellipse(50, 50, 40, 20);
	    \*/
                paperproto.ellipse = function (x, y, rx, ry) {
                    var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.path
	     [ method ]
	     **
	     * Creates a path element by given path data string.
	     > Parameters
	     - pathString (string) #optional path string in SVG format.
	     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
	     | "M10,20L30,40"
	     * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
	     *
	     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
	     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
	     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
	     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
	     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
	     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
	     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
	     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
	     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
	     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
	     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
	     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
	     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
	     * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
	     * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
	     > Usage
	     | var c = paper.path("M10 10L90 90");
	     | // draw a diagonal line:
	     | // move to 10,10, line to 90,90
	     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
	    \*/
                paperproto.path = function (pathString) {
                    pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
                    var out = R._engine.path(R.format[apply](R, arguments), this);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.image
	     [ method ]
	     **
	     * Embeds an image into the surface.
	     **
	     > Parameters
	     **
	     - src (string) URI of the source image
	     - x (number) x coordinate position
	     - y (number) y coordinate position
	     - width (number) width of the image
	     - height (number) height of the image
	     = (object) Raphaël element object with type “image”
	     **
	     > Usage
	     | var c = paper.image("apple.png", 10, 10, 80, 80);
	    \*/
                paperproto.image = function (src, x, y, w, h) {
                    var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.text
	     [ method ]
	     **
	     * Draws a text string. If you need line breaks, put “\n” in the string.
	     **
	     > Parameters
	     **
	     - x (number) x coordinate position
	     - y (number) y coordinate position
	     - text (string) The text string to draw
	     = (object) Raphaël element object with type “text”
	     **
	     > Usage
	     | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
	    \*/
                paperproto.text = function (x, y, text) {
                    var out = R._engine.text(this, x || 0, y || 0, Str(text));
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.set
	     [ method ]
	     **
	     * Creates array-like object to keep and operate several elements at once.
	     * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
	     * Sets act as pseudo elements — all methods available to an element can be used on a set.
	     = (object) array-like object that represents set of elements
	     **
	     > Usage
	     | var st = paper.set();
	     | st.push(
	     |     paper.circle(10, 10, 5),
	     |     paper.circle(30, 10, 5)
	     | );
	     | st.attr({fill: "red"}); // changes the fill of both circles
	    \*/
                paperproto.set = function (itemsArray) {
                    !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
                    var out = new Set(itemsArray);
                    this.__set__ && this.__set__.push(out);
                    out["paper"] = this;
                    out["type"] = "set";
                    return out;
                };
                /*\
	     * Paper.setStart
	     [ method ]
	     **
	     * Creates @Paper.set. All elements that will be created after calling this method and before calling
	     * @Paper.setFinish will be added to the set.
	     **
	     > Usage
	     | paper.setStart();
	     | paper.circle(10, 10, 5),
	     | paper.circle(30, 10, 5)
	     | var st = paper.setFinish();
	     | st.attr({fill: "red"}); // changes the fill of both circles
	    \*/
                paperproto.setStart = function (set) {
                    this.__set__ = set || this.set();
                };
                /*\
	     * Paper.setFinish
	     [ method ]
	     **
	     * See @Paper.setStart. This method finishes catching and returns resulting set.
	     **
	     = (object) set
	    \*/
                paperproto.setFinish = function (set) {
                    var out = this.__set__;
                    delete this.__set__;
                    return out;
                };
                /*\
	     * Paper.getSize
	     [ method ]
	     **
	     * Obtains current paper actual size.
	     **
	     = (object)
	     \*/
                paperproto.getSize = function () {
                    var container = this.canvas.parentNode;
                    return {
                        width: container.offsetWidth,
                        height: container.offsetHeight
                    };
                };
                /*\
	     * Paper.setSize
	     [ method ]
	     **
	     * If you need to change dimensions of the canvas call this method
	     **
	     > Parameters
	     **
	     - width (number) new width of the canvas
	     - height (number) new height of the canvas
	    \*/
                paperproto.setSize = function (width, height) {
                    return R._engine.setSize.call(this, width, height);
                };
                /*\
	     * Paper.setViewBox
	     [ method ]
	     **
	     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
	     * specifying new boundaries.
	     **
	     > Parameters
	     **
	     - x (number) new x position, default is `0`
	     - y (number) new y position, default is `0`
	     - w (number) new width of the canvas
	     - h (number) new height of the canvas
	     - fit (boolean) `true` if you want graphics to fit into new boundary box
	    \*/
                paperproto.setViewBox = function (x, y, w, h, fit) {
                    return R._engine.setViewBox.call(this, x, y, w, h, fit);
                };
                /*\
	     * Paper.top
	     [ property ]
	     **
	     * Points to the topmost element on the paper
	    \*/
                /*\
	     * Paper.bottom
	     [ property ]
	     **
	     * Points to the bottom element on the paper
	    \*/
                paperproto.top = paperproto.bottom = null;
                /*\
	     * Paper.raphael
	     [ property ]
	     **
	     * Points to the @Raphael object/function
	    \*/
                paperproto.raphael = R;
                var getOffset = function (elem) {
                    var box = elem.getBoundingClientRect(),
                        doc = elem.ownerDocument,
                        body = doc.body,
                        docElem = doc.documentElement,
                        clientTop = docElem.clientTop || body.clientTop || 0,
                        clientLeft = docElem.clientLeft || body.clientLeft || 0,
                        top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
                        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
                    return {
                        y: top,
                        x: left
                    };
                };
                /*\
	     * Paper.getElementByPoint
	     [ method ]
	     **
	     * Returns you topmost element under given point.
	     **
	     = (object) Raphaël element object
	     > Parameters
	     **
	     - x (number) x coordinate from the top left corner of the window
	     - y (number) y coordinate from the top left corner of the window
	     > Usage
	     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
	    \*/
                paperproto.getElementByPoint = function (x, y) {
                    var paper = this,
                        svg = paper.canvas,
                        target = g.doc.elementFromPoint(x, y);
                    if (g.win.opera && target.tagName == "svg") {
                        var so = getOffset(svg),
                            sr = svg.createSVGRect();
                        sr.x = x - so.x;
                        sr.y = y - so.y;
                        sr.width = sr.height = 1;
                        var hits = svg.getIntersectionList(sr, null);
                        if (hits.length) {
                            target = hits[hits.length - 1];
                        }
                    }
                    if (!target) {
                        return null;
                    }
                    while (target.parentNode && target != svg.parentNode && !target.raphael) {
                        target = target.parentNode;
                    }
                    target == paper.canvas.parentNode && (target = svg);
                    target = target && target.raphael ? paper.getById(target.raphaelid) : null;
                    return target;
                };

                /*\
	     * Paper.getElementsByBBox
	     [ method ]
	     **
	     * Returns set of elements that have an intersecting bounding box
	     **
	     > Parameters
	     **
	     - bbox (object) bbox to check with
	     = (object) @Set
	     \*/
                paperproto.getElementsByBBox = function (bbox) {
                    var set = this.set();
                    this.forEach(function (el) {
                        if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                            set.push(el);
                        }
                    });
                    return set;
                };

                /*\
	     * Paper.getById
	     [ method ]
	     **
	     * Returns you element by its internal ID.
	     **
	     > Parameters
	     **
	     - id (number) id
	     = (object) Raphaël element object
	    \*/
                paperproto.getById = function (id) {
                    var bot = this.bottom;
                    while (bot) {
                        if (bot.id == id) {
                            return bot;
                        }
                        bot = bot.next;
                    }
                    return null;
                };
                /*\
	     * Paper.forEach
	     [ method ]
	     **
	     * Executes given function for each element on the paper
	     *
	     * If callback function returns `false` it will stop loop running.
	     **
	     > Parameters
	     **
	     - callback (function) function to run
	     - thisArg (object) context object for the callback
	     = (object) Paper object
	     > Usage
	     | paper.forEach(function (el) {
	     |     el.attr({ stroke: "blue" });
	     | });
	    \*/
                paperproto.forEach = function (callback, thisArg) {
                    var bot = this.bottom;
                    while (bot) {
                        if (callback.call(thisArg, bot) === false) {
                            return this;
                        }
                        bot = bot.next;
                    }
                    return this;
                };
                /*\
	     * Paper.getElementsByPoint
	     [ method ]
	     **
	     * Returns set of elements that have common point inside
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the point
	     - y (number) y coordinate of the point
	     = (object) @Set
	    \*/
                paperproto.getElementsByPoint = function (x, y) {
                    var set = this.set();
                    this.forEach(function (el) {
                        if (el.isPointInside(x, y)) {
                            set.push(el);
                        }
                    });
                    return set;
                };

                function x_y() {
                    return this.x + S + this.y;
                }

                function x_y_w_h() {
                    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
                }

                /*\
	     * Element.isPointInside
	     [ method ]
	     **
	     * Determine if given point is inside this element’s shape
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the point
	     - y (number) y coordinate of the point
	     = (boolean) `true` if point inside the shape
	    \*/
                elproto.isPointInside = function (x, y) {
                    var rp = this.realPath = getPath[this.type](this);
                    if (this.attr('transform') && this.attr('transform').length) {
                        rp = R.transformPath(rp, this.attr('transform'));
                    }
                    return R.isPointInsidePath(rp, x, y);
                };
                /*\
	     * Element.getBBox
	     [ method ]
	     **
	     * Return bounding box for a given element
	     **
	     > Parameters
	     **
	     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
	     = (object) Bounding box object:
	     o {
	     o     x: (number) top left corner x
	     o     y: (number) top left corner y
	     o     x2: (number) bottom right corner x
	     o     y2: (number) bottom right corner y
	     o     width: (number) width
	     o     height: (number) height
	     o }
	    \*/
                elproto.getBBox = function (isWithoutTransform) {
                    if (this.removed) {
                        return {};
                    }
                    var _ = this._;
                    if (isWithoutTransform) {
                        if (_.dirty || !_.bboxwt) {
                            this.realPath = getPath[this.type](this);
                            _.bboxwt = pathDimensions(this.realPath);
                            _.bboxwt.toString = x_y_w_h;
                            _.dirty = 0;
                        }
                        return _.bboxwt;
                    }
                    if (_.dirty || _.dirtyT || !_.bbox) {
                        if (_.dirty || !this.realPath) {
                            _.bboxwt = 0;
                            this.realPath = getPath[this.type](this);
                        }
                        _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
                        _.bbox.toString = x_y_w_h;
                        _.dirty = _.dirtyT = 0;
                    }
                    return _.bbox;
                };
                /*\
	     * Element.clone
	     [ method ]
	     **
	     = (object) clone of a given element
	     **
	    \*/
                elproto.clone = function () {
                    if (this.removed) {
                        return null;
                    }
                    var out = this.paper[this.type]().attr(this.attr());
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Element.glow
	     [ method ]
	     **
	     * Return set of elements that create glow-like effect around given element. See @Paper.set.
	     *
	     * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
	     **
	     > Parameters
	     **
	     - glow (object) #optional parameters object with all properties optional:
	     o {
	     o     width (number) size of the glow, default is `10`
	     o     fill (boolean) will it be filled, default is `false`
	     o     opacity (number) opacity, default is `0.5`
	     o     offsetx (number) horizontal offset, default is `0`
	     o     offsety (number) vertical offset, default is `0`
	     o     color (string) glow colour, default is `black`
	     o }
	     = (object) @Paper.set of elements that represents glow
	    \*/
                elproto.glow = function (glow) {
                    if (this.type == "text") {
                        return null;
                    }
                    glow = glow || {};
                    var s = {
                            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
                            fill: glow.fill || false,
                            opacity: glow.opacity == null ? .5 : glow.opacity,
                            offsetx: glow.offsetx || 0,
                            offsety: glow.offsety || 0,
                            color: glow.color || "#000"
                        },
                        c = s.width / 2,
                        r = this.paper,
                        out = r.set(),
                        path = this.realPath || getPath[this.type](this);
                    path = this.matrix ? mapPath(path, this.matrix) : path;
                    for (var i = 1; i < c + 1; i++) {
                        out.push(r.path(path).attr({
                            stroke: s.color,
                            fill: s.fill ? s.color : "none",
                            "stroke-linejoin": "round",
                            "stroke-linecap": "round",
                            "stroke-width": +(s.width / c * i).toFixed(3),
                            opacity: +(s.opacity / c).toFixed(3)
                        }));
                    }
                    return out.insertBefore(this).translate(s.offsetx, s.offsety);
                };
                var curveslengths = {},
                    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
                        if (length == null) {
                            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
                        } else {
                            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
                        }
                    },
                    getLengthFactory = function (istotal, subpath) {
                        return function (path, length, onlystart) {
                            path = path2curve(path);
                            var x, y, p, l, sp = "", subpaths = {}, point,
                                len = 0;
                            for (var i = 0, ii = path.length; i < ii; i++) {
                                p = path[i];
                                if (p[0] == "M") {
                                    x = +p[1];
                                    y = +p[2];
                                } else {
                                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                                    if (len + l > length) {
                                        if (subpath && !subpaths.start) {
                                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                            sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                                            if (onlystart) {
                                                return sp;
                                            }
                                            subpaths.start = sp;
                                            sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                                            len += l;
                                            x = +p[5];
                                            y = +p[6];
                                            continue;
                                        }
                                        if (!istotal && !subpath) {
                                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                            return {x: point.x, y: point.y, alpha: point.alpha};
                                        }
                                    }
                                    len += l;
                                    x = +p[5];
                                    y = +p[6];
                                }
                                sp += p.shift() + p;
                            }
                            subpaths.end = sp;
                            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
                            return point;
                        };
                    };
                var getTotalLength = getLengthFactory(1),
                    getPointAtLength = getLengthFactory(),
                    getSubpathsAtLength = getLengthFactory(0, 1);
                /*\
	     * Raphael.getTotalLength
	     [ method ]
	     **
	     * Returns length of the given path in pixels.
	     **
	     > Parameters
	     **
	     - path (string) SVG path string.
	     **
	     = (number) length.
	    \*/
                R.getTotalLength = getTotalLength;
                /*\
	     * Raphael.getPointAtLength
	     [ method ]
	     **
	     * Return coordinates of the point located at the given length on the given path.
	     **
	     > Parameters
	     **
	     - path (string) SVG path string
	     - length (number)
	     **
	     = (object) representation of the point:
	     o {
	     o     x: (number) x coordinate
	     o     y: (number) y coordinate
	     o     alpha: (number) angle of derivative
	     o }
	    \*/
                R.getPointAtLength = getPointAtLength;
                /*\
	     * Raphael.getSubpath
	     [ method ]
	     **
	     * Return subpath of a given path from given length to given length.
	     **
	     > Parameters
	     **
	     - path (string) SVG path string
	     - from (number) position of the start of the segment
	     - to (number) position of the end of the segment
	     **
	     = (string) pathstring for the segment
	    \*/
                R.getSubpath = function (path, from, to) {
                    if (this.getTotalLength(path) - to < 1e-6) {
                        return getSubpathsAtLength(path, from).end;
                    }
                    var a = getSubpathsAtLength(path, to, 1);
                    return from ? getSubpathsAtLength(a, from).end : a;
                };
                /*\
	     * Element.getTotalLength
	     [ method ]
	     **
	     * Returns length of the path in pixels. Only works for element of “path” type.
	     = (number) length.
	    \*/
                elproto.getTotalLength = function () {
                    var path = this.getPath();
                    if (!path) {
                        return;
                    }

                    if (this.node.getTotalLength) {
                        return this.node.getTotalLength();
                    }

                    return getTotalLength(path);
                };
                /*\
	     * Element.getPointAtLength
	     [ method ]
	     **
	     * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.
	     **
	     > Parameters
	     **
	     - length (number)
	     **
	     = (object) representation of the point:
	     o {
	     o     x: (number) x coordinate
	     o     y: (number) y coordinate
	     o     alpha: (number) angle of derivative
	     o }
	    \*/
                elproto.getPointAtLength = function (length) {
                    var path = this.getPath();
                    if (!path) {
                        return;
                    }

                    return getPointAtLength(path, length);
                };
                /*\
	     * Element.getPath
	     [ method ]
	     **
	     * Returns path of the element. Only works for elements of “path” type and simple elements like circle.
	     = (object) path
	     **
	    \*/
                elproto.getPath = function () {
                    var path,
                        getPath = R._getPath[this.type];

                    if (this.type == "text" || this.type == "set") {
                        return;
                    }

                    if (getPath) {
                        path = getPath(this);
                    }

                    return path;
                };
                /*\
	     * Element.getSubpath
	     [ method ]
	     **
	     * Return subpath of a given element from given length to given length. Only works for element of “path” type.
	     **
	     > Parameters
	     **
	     - from (number) position of the start of the segment
	     - to (number) position of the end of the segment
	     **
	     = (string) pathstring for the segment
	    \*/
                elproto.getSubpath = function (from, to) {
                    var path = this.getPath();
                    if (!path) {
                        return;
                    }

                    return R.getSubpath(path, from, to);
                };
                /*\
	     * Raphael.easing_formulas
	     [ property ]
	     **
	     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
	     # <ul>
	     #     <li>“linear”</li>
	     #     <li>“&lt;” or “easeIn” or “ease-in”</li>
	     #     <li>“>” or “easeOut” or “ease-out”</li>
	     #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>
	     #     <li>“backIn” or “back-in”</li>
	     #     <li>“backOut” or “back-out”</li>
	     #     <li>“elastic”</li>
	     #     <li>“bounce”</li>
	     # </ul>
	     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
	    \*/
                var ef = R.easing_formulas = {
                    linear: function (n) {
                        return n;
                    },
                    "<": function (n) {
                        return pow(n, 1.7);
                    },
                    ">": function (n) {
                        return pow(n, .48);
                    },
                    "<>": function (n) {
                        var q = .48 - n / 1.04,
                            Q = math.sqrt(.1734 + q * q),
                            x = Q - q,
                            X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                            y = -Q - q,
                            Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                            t = X + Y + .5;
                        return (1 - t) * 3 * t * t + t * t * t;
                    },
                    backIn: function (n) {
                        var s = 1.70158;
                        return n * n * ((s + 1) * n - s);
                    },
                    backOut: function (n) {
                        n = n - 1;
                        var s = 1.70158;
                        return n * n * ((s + 1) * n + s) + 1;
                    },
                    elastic: function (n) {
                        if (n == !!n) {
                            return n;
                        }
                        return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
                    },
                    bounce: function (n) {
                        var s = 7.5625,
                            p = 2.75,
                            l;
                        if (n < (1 / p)) {
                            l = s * n * n;
                        } else {
                            if (n < (2 / p)) {
                                n -= (1.5 / p);
                                l = s * n * n + .75;
                            } else {
                                if (n < (2.5 / p)) {
                                    n -= (2.25 / p);
                                    l = s * n * n + .9375;
                                } else {
                                    n -= (2.625 / p);
                                    l = s * n * n + .984375;
                                }
                            }
                        }
                        return l;
                    }
                };
                ef.easeIn = ef["ease-in"] = ef["<"];
                ef.easeOut = ef["ease-out"] = ef[">"];
                ef.easeInOut = ef["ease-in-out"] = ef["<>"];
                ef["back-in"] = ef.backIn;
                ef["back-out"] = ef.backOut;

                var animationElements = [],
                    requestAnimFrame = window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function (callback) {
                            setTimeout(callback, 16);
                        },
                    animation = function () {
                        var Now = +new Date,
                            l = 0;
                        for (; l < animationElements.length; l++) {
                            var e = animationElements[l];
                            if (e.el.removed || e.paused) {
                                continue;
                            }
                            var time = Now - e.start,
                                ms = e.ms,
                                easing = e.easing,
                                from = e.from,
                                diff = e.diff,
                                to = e.to,
                                t = e.t,
                                that = e.el,
                                set = {},
                                now,
                                init = {},
                                key;
                            if (e.initstatus) {
                                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                                e.status = e.initstatus;
                                delete e.initstatus;
                                e.stop && animationElements.splice(l--, 1);
                            } else {
                                e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                            }
                            if (time < 0) {
                                continue;
                            }
                            if (time < ms) {
                                var pos = easing(time / ms);
                                for (var attr in from) if (from[has](attr)) {
                                    switch (availableAnimAttrs[attr]) {
                                        case nu:
                                            now = +from[attr] + pos * ms * diff[attr];
                                            break;
                                        case "colour":
                                            now = "rgb(" + [
                                                upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                                upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                                upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                            ].join(",") + ")";
                                            break;
                                        case "path":
                                            now = [];
                                            for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                                now[i] = [from[attr][i][0]];
                                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                    now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                                }
                                                now[i] = now[i].join(S);
                                            }
                                            now = now.join(S);
                                            break;
                                        case "transform":
                                            if (diff[attr].real) {
                                                now = [];
                                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                                    now[i] = [from[attr][i][0]];
                                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                        now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                                    }
                                                }
                                            } else {
                                                var get = function (i) {
                                                    return +from[attr][i] + pos * ms * diff[attr][i];
                                                };
                                                // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                                now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                            }
                                            break;
                                        case "csv":
                                            if (attr == "clip-rect") {
                                                now = [];
                                                i = 4;
                                                while (i--) {
                                                    now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                                }
                                            }
                                            break;
                                        default:
                                            var from2 = [][concat](from[attr]);
                                            now = [];
                                            i = that.paper.customAttributes[attr].length;
                                            while (i--) {
                                                now[i] = +from2[i] + pos * ms * diff[attr][i];
                                            }
                                            break;
                                    }
                                    set[attr] = now;
                                }
                                that.attr(set);
                                (function (id, that, anim) {
                                    setTimeout(function () {
                                        eve("raphael.anim.frame." + id, that, anim);
                                    });
                                })(that.id, that, e.anim);
                            } else {
                                (function (f, el, a) {
                                    setTimeout(function () {
                                        eve("raphael.anim.frame." + el.id, el, a);
                                        eve("raphael.anim.finish." + el.id, el, a);
                                        R.is(f, "function") && f.call(el);
                                    });
                                })(e.callback, that, e.anim);
                                that.attr(to);
                                animationElements.splice(l--, 1);
                                if (e.repeat > 1 && !e.next) {
                                    for (key in to) if (to[has](key)) {
                                        init[key] = e.totalOrigin[key];
                                    }
                                    e.el.attr(init);
                                    runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                                }
                                if (e.next && !e.stop) {
                                    runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                                }
                            }
                        }
                        animationElements.length && requestAnimFrame(animation);
                    },
                    upto255 = function (color) {
                        return color > 255 ? 255 : color < 0 ? 0 : color;
                    };
                /*\
	     * Element.animateWith
	     [ method ]
	     **
	     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
	     **
	     > Parameters
	     **
	     - el (object) element to sync with
	     - anim (object) animation to sync with
	     - params (object) #optional final attributes for the element, see also @Element.attr
	     - ms (number) #optional number of milliseconds for animation to run
	     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
	     - callback (function) #optional callback function. Will be called at the end of animation.
	     * or
	     - element (object) element to sync with
	     - anim (object) animation to sync with
	     - animation (object) #optional animation object, see @Raphael.animation
	     **
	     = (object) original element
	    \*/
                elproto.animateWith = function (el, anim, params, ms, easing, callback) {
                    var element = this;
                    if (element.removed) {
                        callback && callback.call(element);
                        return element;
                    }
                    var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
                        x, y;
                    runAnimation(a, element, a.percents[0], null, element.attr());
                    for (var i = 0, ii = animationElements.length; i < ii; i++) {
                        if (animationElements[i].anim == anim && animationElements[i].el == el) {
                            animationElements[ii - 1].start = animationElements[i].start;
                            break;
                        }
                    }
                    return element;
                    //
                    //
                    // var a = params ? R.animation(params, ms, easing, callback) : anim,
                    //     status = element.status(anim);
                    // return this.animate(a).status(a, status * anim.ms / a.ms);
                };

                function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
                    var cx = 3 * p1x,
                        bx = 3 * (p2x - p1x) - cx,
                        ax = 1 - cx - bx,
                        cy = 3 * p1y,
                        by = 3 * (p2y - p1y) - cy,
                        ay = 1 - cy - by;

                    function sampleCurveX(t) {
                        return ((ax * t + bx) * t + cx) * t;
                    }

                    function solve(x, epsilon) {
                        var t = solveCurveX(x, epsilon);
                        return ((ay * t + by) * t + cy) * t;
                    }

                    function solveCurveX(x, epsilon) {
                        var t0, t1, t2, x2, d2, i;
                        for (t2 = x, i = 0; i < 8; i++) {
                            x2 = sampleCurveX(t2) - x;
                            if (abs(x2) < epsilon) {
                                return t2;
                            }
                            d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                            if (abs(d2) < 1e-6) {
                                break;
                            }
                            t2 = t2 - x2 / d2;
                        }
                        t0 = 0;
                        t1 = 1;
                        t2 = x;
                        if (t2 < t0) {
                            return t0;
                        }
                        if (t2 > t1) {
                            return t1;
                        }
                        while (t0 < t1) {
                            x2 = sampleCurveX(t2);
                            if (abs(x2 - x) < epsilon) {
                                return t2;
                            }
                            if (x > x2) {
                                t0 = t2;
                            } else {
                                t1 = t2;
                            }
                            t2 = (t1 - t0) / 2 + t0;
                        }
                        return t2;
                    }

                    return solve(t, 1 / (200 * duration));
                }

                elproto.onAnimation = function (f) {
                    f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
                    return this;
                };

                function Animation(anim, ms) {
                    var percents = [],
                        newAnim = {};
                    this.ms = ms;
                    this.times = 1;
                    if (anim) {
                        for (var attr in anim) if (anim[has](attr)) {
                            newAnim[toFloat(attr)] = anim[attr];
                            percents.push(toFloat(attr));
                        }
                        percents.sort(sortByNumber);
                    }
                    this.anim = newAnim;
                    this.top = percents[percents.length - 1];
                    this.percents = percents;
                }

                /*\
	     * Animation.delay
	     [ method ]
	     **
	     * Creates a copy of existing animation object with given delay.
	     **
	     > Parameters
	     **
	     - delay (number) number of ms to pass between animation start and actual animation
	     **
	     = (object) new altered Animation object
	     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
	     | circle1.animate(anim); // run the given animation immediately
	     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
	    \*/
                Animation.prototype.delay = function (delay) {
                    var a = new Animation(this.anim, this.ms);
                    a.times = this.times;
                    a.del = +delay || 0;
                    return a;
                };
                /*\
	     * Animation.repeat
	     [ method ]
	     **
	     * Creates a copy of existing animation object with given repetition.
	     **
	     > Parameters
	     **
	     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
	     **
	     = (object) new altered Animation object
	    \*/
                Animation.prototype.repeat = function (times) {
                    var a = new Animation(this.anim, this.ms);
                    a.del = this.del;
                    a.times = math.floor(mmax(times, 0)) || 1;
                    return a;
                };

                function runAnimation(anim, element, percent, status, totalOrigin, times) {
                    percent = toFloat(percent);
                    var params,
                        isInAnim,
                        isInAnimSet,
                        percents = [],
                        next,
                        prev,
                        timestamp,
                        ms = anim.ms,
                        from = {},
                        to = {},
                        diff = {};
                    if (status) {
                        for (i = 0, ii = animationElements.length; i < ii; i++) {
                            var e = animationElements[i];
                            if (e.el.id == element.id && e.anim == anim) {
                                if (e.percent != percent) {
                                    animationElements.splice(i, 1);
                                    isInAnimSet = 1;
                                } else {
                                    isInAnim = e;
                                }
                                element.attr(e.totalOrigin);
                                break;
                            }
                        }
                    } else {
                        status = +to; // NaN
                    }
                    for (var i = 0, ii = anim.percents.length; i < ii; i++) {
                        if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                            percent = anim.percents[i];
                            prev = anim.percents[i - 1] || 0;
                            ms = ms / anim.top * (percent - prev);
                            next = anim.percents[i + 1];
                            params = anim.anim[percent];
                            break;
                        } else if (status) {
                            element.attr(anim.anim[anim.percents[i]]);
                        }
                    }
                    if (!params) {
                        return;
                    }
                    if (!isInAnim) {
                        for (var attr in params) if (params[has](attr)) {
                            if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                                from[attr] = element.attr(attr);
                                (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                                to[attr] = params[attr];
                                switch (availableAnimAttrs[attr]) {
                                    case nu:
                                        diff[attr] = (to[attr] - from[attr]) / ms;
                                        break;
                                    case "colour":
                                        from[attr] = R.getRGB(from[attr]);
                                        var toColour = R.getRGB(to[attr]);
                                        diff[attr] = {
                                            r: (toColour.r - from[attr].r) / ms,
                                            g: (toColour.g - from[attr].g) / ms,
                                            b: (toColour.b - from[attr].b) / ms
                                        };
                                        break;
                                    case "path":
                                        var pathes = path2curve(from[attr], to[attr]),
                                            toPath = pathes[1];
                                        from[attr] = pathes[0];
                                        diff[attr] = [];
                                        for (i = 0, ii = from[attr].length; i < ii; i++) {
                                            diff[attr][i] = [0];
                                            for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                            }
                                        }
                                        break;
                                    case "transform":
                                        var _ = element._,
                                            eq = equaliseTransform(_[attr], to[attr]);
                                        if (eq) {
                                            from[attr] = eq.from;
                                            to[attr] = eq.to;
                                            diff[attr] = [];
                                            diff[attr].real = true;
                                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                                diff[attr][i] = [from[attr][i][0]];
                                                for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                    diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                                }
                                            }
                                        } else {
                                            var m = (element.matrix || new Matrix),
                                                to2 = {
                                                    _: {transform: _.transform},
                                                    getBBox: function () {
                                                        return element.getBBox(1);
                                                    }
                                                };
                                            from[attr] = [
                                                m.a,
                                                m.b,
                                                m.c,
                                                m.d,
                                                m.e,
                                                m.f
                                            ];
                                            extractTransform(to2, to[attr]);
                                            to[attr] = to2._.transform;
                                            diff[attr] = [
                                                (to2.matrix.a - m.a) / ms,
                                                (to2.matrix.b - m.b) / ms,
                                                (to2.matrix.c - m.c) / ms,
                                                (to2.matrix.d - m.d) / ms,
                                                (to2.matrix.e - m.e) / ms,
                                                (to2.matrix.f - m.f) / ms
                                            ];
                                            // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                            // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                            // extractTransform(to2, to[attr]);
                                            // diff[attr] = [
                                            //     (to2._.sx - _.sx) / ms,
                                            //     (to2._.sy - _.sy) / ms,
                                            //     (to2._.deg - _.deg) / ms,
                                            //     (to2._.dx - _.dx) / ms,
                                            //     (to2._.dy - _.dy) / ms
                                            // ];
                                        }
                                        break;
                                    case "csv":
                                        var values = Str(params[attr])[split](separator),
                                            from2 = Str(from[attr])[split](separator);
                                        if (attr == "clip-rect") {
                                            from[attr] = from2;
                                            diff[attr] = [];
                                            i = from2.length;
                                            while (i--) {
                                                diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                            }
                                        }
                                        to[attr] = values;
                                        break;
                                    default:
                                        values = [][concat](params[attr]);
                                        from2 = [][concat](from[attr]);
                                        diff[attr] = [];
                                        i = element.paper.customAttributes[attr].length;
                                        while (i--) {
                                            diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                                        }
                                        break;
                                }
                            }
                        }
                        var easing = params.easing,
                            easyeasy = R.easing_formulas[easing];
                        if (!easyeasy) {
                            easyeasy = Str(easing).match(bezierrg);
                            if (easyeasy && easyeasy.length == 5) {
                                var curve = easyeasy;
                                easyeasy = function (t) {
                                    return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                                };
                            } else {
                                easyeasy = pipe;
                            }
                        }
                        timestamp = params.start || anim.start || +new Date;
                        e = {
                            anim: anim,
                            percent: percent,
                            timestamp: timestamp,
                            start: timestamp + (anim.del || 0),
                            status: 0,
                            initstatus: status || 0,
                            stop: false,
                            ms: ms,
                            easing: easyeasy,
                            from: from,
                            diff: diff,
                            to: to,
                            el: element,
                            callback: params.callback,
                            prev: prev,
                            next: next,
                            repeat: times || anim.times,
                            origin: element.attr(),
                            totalOrigin: totalOrigin
                        };
                        animationElements.push(e);
                        if (status && !isInAnim && !isInAnimSet) {
                            e.stop = true;
                            e.start = new Date - ms * status;
                            if (animationElements.length == 1) {
                                return animation();
                            }
                        }
                        if (isInAnimSet) {
                            e.start = new Date - e.ms * status;
                        }
                        animationElements.length == 1 && requestAnimFrame(animation);
                    } else {
                        isInAnim.initstatus = status;
                        isInAnim.start = new Date - isInAnim.ms * status;
                    }
                    eve("raphael.anim.start." + element.id, element, anim);
                }

                /*\
	     * Raphael.animation
	     [ method ]
	     **
	     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
	     * See also @Animation.delay and @Animation.repeat methods.
	     **
	     > Parameters
	     **
	     - params (object) final attributes for the element, see also @Element.attr
	     - ms (number) number of milliseconds for animation to run
	     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
	     - callback (function) #optional callback function. Will be called at the end of animation.
	     **
	     = (object) @Animation
	    \*/
                R.animation = function (params, ms, easing, callback) {
                    if (params instanceof Animation) {
                        return params;
                    }
                    if (R.is(easing, "function") || !easing) {
                        callback = callback || easing || null;
                        easing = null;
                    }
                    params = Object(params);
                    ms = +ms || 0;
                    var p = {},
                        json,
                        attr;
                    for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
                        json = true;
                        p[attr] = params[attr];
                    }
                    if (!json) {
                        // if percent-like syntax is used and end-of-all animation callback used
                        if (callback) {
                            // find the last one
                            var lastKey = 0;
                            for (var i in params) {
                                var percent = toInt(i);
                                if (params[has](i) && percent > lastKey) {
                                    lastKey = percent;
                                }
                            }
                            lastKey += '%';
                            // if already defined callback in the last keyframe, skip
                            !params[lastKey].callback && (params[lastKey].callback = callback);
                        }
                        return new Animation(params, ms);
                    } else {
                        easing && (p.easing = easing);
                        callback && (p.callback = callback);
                        return new Animation({100: p}, ms);
                    }
                };
                /*\
	     * Element.animate
	     [ method ]
	     **
	     * Creates and starts animation for given element.
	     **
	     > Parameters
	     **
	     - params (object) final attributes for the element, see also @Element.attr
	     - ms (number) number of milliseconds for animation to run
	     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
	     - callback (function) #optional callback function. Will be called at the end of animation.
	     * or
	     - animation (object) animation object, see @Raphael.animation
	     **
	     = (object) original element
	    \*/
                elproto.animate = function (params, ms, easing, callback) {
                    var element = this;
                    if (element.removed) {
                        callback && callback.call(element);
                        return element;
                    }
                    var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
                    runAnimation(anim, element, anim.percents[0], null, element.attr());
                    return element;
                };
                /*\
	     * Element.setTime
	     [ method ]
	     **
	     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
	     **
	     > Parameters
	     **
	     - anim (object) animation object
	     - value (number) number of milliseconds from the beginning of the animation
	     **
	     = (object) original element if `value` is specified
	     * Note, that during animation following events are triggered:
	     *
	     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
	    \*/
                elproto.setTime = function (anim, value) {
                    if (anim && value != null) {
                        this.status(anim, mmin(value, anim.ms) / anim.ms);
                    }
                    return this;
                };
                /*\
	     * Element.status
	     [ method ]
	     **
	     * Gets or sets the status of animation of the element.
	     **
	     > Parameters
	     **
	     - anim (object) #optional animation object
	     - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
	     **
	     = (number) status
	     * or
	     = (array) status if `anim` is not specified. Array of objects in format:
	     o {
	     o     anim: (object) animation object
	     o     status: (number) status
	     o }
	     * or
	     = (object) original element if `value` is specified
	    \*/
                elproto.status = function (anim, value) {
                    var out = [],
                        i = 0,
                        len,
                        e;
                    if (value != null) {
                        runAnimation(anim, this, -1, mmin(value, 1));
                        return this;
                    } else {
                        len = animationElements.length;
                        for (; i < len; i++) {
                            e = animationElements[i];
                            if (e.el.id == this.id && (!anim || e.anim == anim)) {
                                if (anim) {
                                    return e.status;
                                }
                                out.push({
                                    anim: e.anim,
                                    status: e.status
                                });
                            }
                        }
                        if (anim) {
                            return 0;
                        }
                        return out;
                    }
                };
                /*\
	     * Element.pause
	     [ method ]
	     **
	     * Stops animation of the element with ability to resume it later on.
	     **
	     > Parameters
	     **
	     - anim (object) #optional animation object
	     **
	     = (object) original element
	    \*/
                elproto.pause = function (anim) {
                    for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                        if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                            animationElements[i].paused = true;
                        }
                    }
                    return this;
                };
                /*\
	     * Element.resume
	     [ method ]
	     **
	     * Resumes animation if it was paused with @Element.pause method.
	     **
	     > Parameters
	     **
	     - anim (object) #optional animation object
	     **
	     = (object) original element
	    \*/
                elproto.resume = function (anim) {
                    for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                        var e = animationElements[i];
                        if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                            delete e.paused;
                            this.status(e.anim, e.status);
                        }
                    }
                    return this;
                };
                /*\
	     * Element.stop
	     [ method ]
	     **
	     * Stops animation of the element.
	     **
	     > Parameters
	     **
	     - anim (object) #optional animation object
	     **
	     = (object) original element
	    \*/
                elproto.stop = function (anim) {
                    for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                        if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                            animationElements.splice(i--, 1);
                        }
                    }
                    return this;
                };

                function stopAnimation(paper) {
                    for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
                        animationElements.splice(i--, 1);
                    }
                }

                eve.on("raphael.remove", stopAnimation);
                eve.on("raphael.clear", stopAnimation);
                elproto.toString = function () {
                    return "Rapha\xebl\u2019s object";
                };

                // Set
                var Set = function (items) {
                        this.items = [];
                        this.length = 0;
                        this.type = "set";
                        if (items) {
                            for (var i = 0, ii = items.length; i < ii; i++) {
                                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                                    this[this.items.length] = this.items[this.items.length] = items[i];
                                    this.length++;
                                }
                            }
                        }
                    },
                    setproto = Set.prototype;
                /*\
	     * Set.push
	     [ method ]
	     **
	     * Adds each argument to the current set.
	     = (object) original element
	    \*/
                setproto.push = function () {
                    var item,
                        len;
                    for (var i = 0, ii = arguments.length; i < ii; i++) {
                        item = arguments[i];
                        if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                            len = this.items.length;
                            this[len] = this.items[len] = item;
                            this.length++;
                        }
                    }
                    return this;
                };
                /*\
	     * Set.pop
	     [ method ]
	     **
	     * Removes last element and returns it.
	     = (object) element
	    \*/
                setproto.pop = function () {
                    this.length && delete this[this.length--];
                    return this.items.pop();
                };
                /*\
	     * Set.forEach
	     [ method ]
	     **
	     * Executes given function for each element in the set.
	     *
	     * If function returns `false` it will stop loop running.
	     **
	     > Parameters
	     **
	     - callback (function) function to run
	     - thisArg (object) context object for the callback
	     = (object) Set object
	    \*/
                setproto.forEach = function (callback, thisArg) {
                    for (var i = 0, ii = this.items.length; i < ii; i++) {
                        if (callback.call(thisArg, this.items[i], i) === false) {
                            return this;
                        }
                    }
                    return this;
                };
                for (var method in elproto) if (elproto[has](method)) {
                    setproto[method] = (function (methodname) {
                        return function () {
                            var arg = arguments;
                            return this.forEach(function (el) {
                                el[methodname][apply](el, arg);
                            });
                        };
                    })(method);
                }
                setproto.attr = function (name, value) {
                    if (name && R.is(name, array) && R.is(name[0], "object")) {
                        for (var j = 0, jj = name.length; j < jj; j++) {
                            this.items[j].attr(name[j]);
                        }
                    } else {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            this.items[i].attr(name, value);
                        }
                    }
                    return this;
                };
                /*\
	     * Set.clear
	     [ method ]
	     **
	     * Removes all elements from the set
	    \*/
                setproto.clear = function () {
                    while (this.length) {
                        this.pop();
                    }
                };
                /*\
	     * Set.splice
	     [ method ]
	     **
	     * Removes given element from the set
	     **
	     > Parameters
	     **
	     - index (number) position of the deletion
	     - count (number) number of element to remove
	     - insertion… (object) #optional elements to insert
	     = (object) set elements that were deleted
	    \*/
                setproto.splice = function (index, count, insertion) {
                    index = index < 0 ? mmax(this.length + index, 0) : index;
                    count = mmax(0, mmin(this.length - index, count));
                    var tail = [],
                        todel = [],
                        args = [],
                        i;
                    for (i = 2; i < arguments.length; i++) {
                        args.push(arguments[i]);
                    }
                    for (i = 0; i < count; i++) {
                        todel.push(this[index + i]);
                    }
                    for (; i < this.length - index; i++) {
                        tail.push(this[index + i]);
                    }
                    var arglen = args.length;
                    for (i = 0; i < arglen + tail.length; i++) {
                        this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
                    }
                    i = this.items.length = this.length -= count - arglen;
                    while (this[i]) {
                        delete this[i++];
                    }
                    return new Set(todel);
                };
                /*\
	     * Set.exclude
	     [ method ]
	     **
	     * Removes given element from the set
	     **
	     > Parameters
	     **
	     - element (object) element to remove
	     = (boolean) `true` if object was found & removed from the set
	    \*/
                setproto.exclude = function (el) {
                    for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
                        this.splice(i, 1);
                        return true;
                    }
                };
                setproto.animate = function (params, ms, easing, callback) {
                    (R.is(easing, "function") || !easing) && (callback = easing || null);
                    var len = this.items.length,
                        i = len,
                        item,
                        set = this,
                        collector;
                    if (!len) {
                        return this;
                    }
                    callback && (collector = function () {
                        !--len && callback.call(set);
                    });
                    easing = R.is(easing, string) ? easing : collector;
                    var anim = R.animation(params, ms, easing, collector);
                    item = this.items[--i].animate(anim);
                    while (i--) {
                        this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
                        (this.items[i] && !this.items[i].removed) || len--;
                    }
                    return this;
                };
                setproto.insertAfter = function (el) {
                    var i = this.items.length;
                    while (i--) {
                        this.items[i].insertAfter(el);
                    }
                    return this;
                };
                setproto.getBBox = function () {
                    var x = [],
                        y = [],
                        x2 = [],
                        y2 = [];
                    for (var i = this.items.length; i--;) if (!this.items[i].removed) {
                        var box = this.items[i].getBBox();
                        x.push(box.x);
                        y.push(box.y);
                        x2.push(box.x + box.width);
                        y2.push(box.y + box.height);
                    }
                    x = mmin[apply](0, x);
                    y = mmin[apply](0, y);
                    x2 = mmax[apply](0, x2);
                    y2 = mmax[apply](0, y2);
                    return {
                        x: x,
                        y: y,
                        x2: x2,
                        y2: y2,
                        width: x2 - x,
                        height: y2 - y
                    };
                };
                setproto.clone = function (s) {
                    s = this.paper.set();
                    for (var i = 0, ii = this.items.length; i < ii; i++) {
                        s.push(this.items[i].clone());
                    }
                    return s;
                };
                setproto.toString = function () {
                    return "Rapha\xebl\u2018s set";
                };

                setproto.glow = function (glowConfig) {
                    var ret = this.paper.set();
                    this.forEach(function (shape, index) {
                        var g = shape.glow(glowConfig);
                        if (g != null) {
                            g.forEach(function (shape2, index2) {
                                ret.push(shape2);
                            });
                        }
                    });
                    return ret;
                };


                /*\
	     * Set.isPointInside
	     [ method ]
	     **
	     * Determine if given point is inside this set’s elements
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the point
	     - y (number) y coordinate of the point
	     = (boolean) `true` if point is inside any of the set's elements
	     \*/
                setproto.isPointInside = function (x, y) {
                    var isPointInside = false;
                    this.forEach(function (el) {
                        if (el.isPointInside(x, y)) {
                            isPointInside = true;
                            return false; // stop loop
                        }
                    });
                    return isPointInside;
                };

                /*\
	     * Raphael.registerFont
	     [ method ]
	     **
	     * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
	     * Returns original parameter, so it could be used with chaining.
	     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
	     **
	     > Parameters
	     **
	     - font (object) the font to register
	     = (object) the font you passed in
	     > Usage
	     | Cufon.registerFont(Raphael.registerFont({…}));
	    \*/
                R.registerFont = function (font) {
                    if (!font.face) {
                        return font;
                    }
                    this.fonts = this.fonts || {};
                    var fontcopy = {
                            w: font.w,
                            face: {},
                            glyphs: {}
                        },
                        family = font.face["font-family"];
                    for (var prop in font.face) if (font.face[has](prop)) {
                        fontcopy.face[prop] = font.face[prop];
                    }
                    if (this.fonts[family]) {
                        this.fonts[family].push(fontcopy);
                    } else {
                        this.fonts[family] = [fontcopy];
                    }
                    if (!font.svg) {
                        fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
                        for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                            var path = font.glyphs[glyph];
                            fontcopy.glyphs[glyph] = {
                                w: path.w,
                                k: {},
                                d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                                    return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                                }) + "z"
                            };
                            if (path.k) {
                                for (var k in path.k) if (path[has](k)) {
                                    fontcopy.glyphs[glyph].k[k] = path.k[k];
                                }
                            }
                        }
                    }
                    return font;
                };
                /*\
	     * Paper.getFont
	     [ method ]
	     **
	     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
	     **
	     > Parameters
	     **
	     - family (string) font family name or any word from it
	     - weight (string) #optional font weight
	     - style (string) #optional font style
	     - stretch (string) #optional font stretch
	     = (object) the font object
	     > Usage
	     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
	    \*/
                paperproto.getFont = function (family, weight, style, stretch) {
                    stretch = stretch || "normal";
                    style = style || "normal";
                    weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
                    if (!R.fonts) {
                        return;
                    }
                    var font = R.fonts[family];
                    if (!font) {
                        var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
                        for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                            if (name.test(fontName)) {
                                font = R.fonts[fontName];
                                break;
                            }
                        }
                    }
                    var thefont;
                    if (font) {
                        for (var i = 0, ii = font.length; i < ii; i++) {
                            thefont = font[i];
                            if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                                break;
                            }
                        }
                    }
                    return thefont;
                };
                /*\
	     * Paper.print
	     [ method ]
	     **
	     * Creates path that represent given text written using given font at given position with given size.
	     * Result of the method is path element that contains whole text as a separate path.
	     **
	     > Parameters
	     **
	     - x (number) x position of the text
	     - y (number) y position of the text
	     - string (string) text to print
	     - font (object) font object, see @Paper.getFont
	     - size (number) #optional size of the font, default is `16`
	     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
	     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
	     - line_spacing (number) #optional number in range `1..3`, default is `1`
	     = (object) resulting path element, which consist of all letters
	     > Usage
	     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
	    \*/
                paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
                    origin = origin || "middle"; // baseline|middle
                    letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
                    line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
                    var letters = Str(string)[split](E),
                        shift = 0,
                        notfirst = 0,
                        path = E,
                        scale;
                    R.is(font, "string") && (font = this.getFont(font));
                    if (font) {
                        scale = (size || 16) / font.face["units-per-em"];
                        var bb = font.face.bbox[split](separator),
                            top = +bb[0],
                            lineHeight = bb[3] - bb[1],
                            shifty = 0,
                            height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
                        for (var i = 0, ii = letters.length; i < ii; i++) {
                            if (letters[i] == "\n") {
                                shift = 0;
                                curr = 0;
                                notfirst = 0;
                                shifty += lineHeight * line_spacing;
                            } else {
                                var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                                    curr = font.glyphs[letters[i]];
                                shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                                notfirst = 1;
                            }
                            if (curr && curr.d) {
                                path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                            }
                        }
                    }
                    return this.path(path).attr({
                        fill: "#000",
                        stroke: "none"
                    });
                };

                /*\
	     * Paper.add
	     [ method ]
	     **
	     * Imports elements in JSON array in format `{type: type, <attributes>}`
	     **
	     > Parameters
	     **
	     - json (array)
	     = (object) resulting set of imported elements
	     > Usage
	     | paper.add([
	     |     {
	     |         type: "circle",
	     |         cx: 10,
	     |         cy: 10,
	     |         r: 5
	     |     },
	     |     {
	     |         type: "rect",
	     |         x: 10,
	     |         y: 10,
	     |         width: 10,
	     |         height: 10,
	     |         fill: "#fc0"
	     |     }
	     | ]);
	    \*/
                paperproto.add = function (json) {
                    if (R.is(json, "array")) {
                        var res = this.set(),
                            i = 0,
                            ii = json.length,
                            j;
                        for (; i < ii; i++) {
                            j = json[i] || {};
                            elements[has](j.type) && res.push(this[j.type]().attr(j));
                        }
                    }
                    return res;
                };

                /*\
	     * Raphael.format
	     [ method ]
	     **
	     * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.
	     **
	     > Parameters
	     **
	     - token (string) string to format
	     - … (string) rest of arguments will be treated as parameters for replacement
	     = (string) formated string
	     > Usage
	     | var x = 10,
	     |     y = 20,
	     |     width = 40,
	     |     height = 50;
	     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
	     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
	    \*/
                R.format = function (token, params) {
                    var args = R.is(params, array) ? [0][concat](params) : arguments;
                    token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
                        return args[++i] == null ? E : args[i];
                    }));
                    return token || E;
                };
                /*\
	     * Raphael.fullfill
	     [ method ]
	     **
	     * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.
	     **
	     > Parameters
	     **
	     - token (string) string to format
	     - json (object) object which properties will be used as a replacement
	     = (string) formated string
	     > Usage
	     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
	     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
	     |     x: 10,
	     |     y: 20,
	     |     dim: {
	     |         width: 40,
	     |         height: 50,
	     |         "negative width": -40
	     |     }
	     | }));
	    \*/
                R.fullfill = (function () {
                    var tokenRegex = /\{([^\}]+)\}/g,
                        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
                        replacer = function (all, key, obj) {
                            var res = obj;
                            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                                name = name || quotedName;
                                if (res) {
                                    if (name in res) {
                                        res = res[name];
                                    }
                                    typeof res == "function" && isFunc && (res = res());
                                }
                            });
                            res = (res == null || res == obj ? all : res) + "";
                            return res;
                        };
                    return function (str, obj) {
                        return String(str).replace(tokenRegex, function (all, key) {
                            return replacer(all, key, obj);
                        });
                    };
                })();
                /*\
	     * Raphael.ninja
	     [ method ]
	     **
	     * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
	     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
	     **
	     = (object) Raphael object
	     > Usage
	     | (function (local_raphael) {
	     |     var paper = local_raphael(10, 10, 320, 200);
	     |     …
	     | })(Raphael.ninja());
	    \*/
                R.ninja = function () {
                    if (oldRaphael.was) {
                        g.win.Raphael = oldRaphael.is;
                    } else {
                        // IE8 raises an error when deleting window property
                        window.Raphael = undefined;
                        try {
                            delete window.Raphael;
                        } catch (e) {
                        }
                    }
                    return R;
                };
                /*\
	     * Raphael.st
	     [ property (object) ]
	     **
	     * You can add your own method to elements and sets. It is wise to add a set method for each element method
	     * you added, so you will be able to call the same method on sets too.
	     **
	     * See also @Raphael.el.
	     > Usage
	     | Raphael.el.red = function () {
	     |     this.attr({fill: "#f00"});
	     | };
	     | Raphael.st.red = function () {
	     |     this.forEach(function (el) {
	     |         el.red();
	     |     });
	     | };
	     | // then use it
	     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
	    \*/
                R.st = setproto;

                eve.on("raphael.DOMload", function () {
                    loaded = true;
                });

                // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
                (function (doc, loaded, f) {
                    if (doc.readyState == null && doc.addEventListener) {
                        doc.addEventListener(loaded, f = function () {
                            doc.removeEventListener(loaded, f, false);
                            doc.readyState = "complete";
                        }, false);
                        doc.readyState = "loading";
                    }

                    function isLoaded() {
                        (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
                    }

                    isLoaded();
                })(document, "DOMContentLoaded");

                return R;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


            /***/
        },
        /* 2 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
            //
            // Licensed under the Apache License, Version 2.0 (the "License");
            // you may not use this file except in compliance with the License.
            // You may obtain a copy of the License at
            //
            // http://www.apache.org/licenses/LICENSE-2.0
            //
            // Unless required by applicable law or agreed to in writing, software
            // distributed under the License is distributed on an "AS IS" BASIS,
            // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            // See the License for the specific language governing permissions and
            // limitations under the License.
            // ┌────────────────────────────────────────────────────────────┐ \\
            // │ Eve 0.5.0 - JavaScript Events Library                      │ \\
            // ├────────────────────────────────────────────────────────────┤ \\
            // │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
            // └────────────────────────────────────────────────────────────┘ \\

            (function (glob) {
                var version = "0.5.0",
                    has = "hasOwnProperty",
                    separator = /[\.\/]/,
                    comaseparator = /\s*,\s*/,
                    wildcard = "*",
                    fun = function () {
                    },
                    numsort = function (a, b) {
                        return a - b;
                    },
                    current_event,
                    stop,
                    events = {n: {}},
                    firstDefined = function () {
                        for (var i = 0, ii = this.length; i < ii; i++) {
                            if (typeof this[i] != "undefined") {
                                return this[i];
                            }
                        }
                    },
                    lastDefined = function () {
                        var i = this.length;
                        while (--i) {
                            if (typeof this[i] != "undefined") {
                                return this[i];
                            }
                        }
                    },
                    objtos = Object.prototype.toString,
                    Str = String,
                    isArray = Array.isArray || function (ar) {
                        return ar instanceof Array || objtos.call(ar) == "[object Array]";
                    };
                /*\
	     * eve
	     [ method ]

	     * Fires event with given `name`, given scope and other parameters.

	     > Arguments

	     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
	     - scope (object) context for the event handlers
	     - varargs (...) the rest of arguments will be sent to event handlers

	     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
	    \*/
                eve = function (name, scope) {
                    var e = events,
                        oldstop = stop,
                        args = Array.prototype.slice.call(arguments, 2),
                        listeners = eve.listeners(name),
                        z = 0,
                        f = false,
                        l,
                        indexed = [],
                        queue = {},
                        out = [],
                        ce = current_event,
                        errors = [];
                    out.firstDefined = firstDefined;
                    out.lastDefined = lastDefined;
                    current_event = name;
                    stop = 0;
                    for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                        indexed.push(listeners[i].zIndex);
                        if (listeners[i].zIndex < 0) {
                            queue[listeners[i].zIndex] = listeners[i];
                        }
                    }
                    indexed.sort(numsort);
                    while (indexed[z] < 0) {
                        l = queue[indexed[z++]];
                        out.push(l.apply(scope, args));
                        if (stop) {
                            stop = oldstop;
                            return out;
                        }
                    }
                    for (i = 0; i < ii; i++) {
                        l = listeners[i];
                        if ("zIndex" in l) {
                            if (l.zIndex == indexed[z]) {
                                out.push(l.apply(scope, args));
                                if (stop) {
                                    break;
                                }
                                do {
                                    z++;
                                    l = queue[indexed[z]];
                                    l && out.push(l.apply(scope, args));
                                    if (stop) {
                                        break;
                                    }
                                } while (l)
                            } else {
                                queue[l.zIndex] = l;
                            }
                        } else {
                            out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        }
                    }
                    stop = oldstop;
                    current_event = ce;
                    return out;
                };
                // Undocumented. Debug only.
                eve._events = events;
                /*\
	     * eve.listeners
	     [ method ]

	     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

	     > Arguments

	     - name (string) name of the event, dot (`.`) or slash (`/`) separated

	     = (array) array of event handlers
	    \*/
                eve.listeners = function (name) {
                    var names = isArray(name) ? name : name.split(separator),
                        e = events,
                        item,
                        items,
                        k,
                        i,
                        ii,
                        j,
                        jj,
                        nes,
                        es = [e],
                        out = [];
                    for (i = 0, ii = names.length; i < ii; i++) {
                        nes = [];
                        for (j = 0, jj = es.length; j < jj; j++) {
                            e = es[j].n;
                            items = [e[names[i]], e[wildcard]];
                            k = 2;
                            while (k--) {
                                item = items[k];
                                if (item) {
                                    nes.push(item);
                                    out = out.concat(item.f || []);
                                }
                            }
                        }
                        es = nes;
                    }
                    return out;
                };
                /*\
	     * eve.separator
	     [ method ]

	     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours
	     * here. Be aware that if you pass a string longer than one character it will be treated as
	     * a list of characters.

	     - separator (string) new separator. Empty string resets to default: `.` or `/`.
	    \*/
                eve.separator = function (sep) {
                    if (sep) {
                        sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
                        sep = "[" + sep + "]";
                        separator = new RegExp(sep);
                    } else {
                        separator = /[\.\/]/;
                    }
                };
                /*\
	     * eve.on
	     [ method ]
	     **
	     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
	     | eve.on("*.under.*", f);
	     | eve("mouse.under.floor"); // triggers f
	     * Use @eve to trigger the listener.
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	     **
	     - name (array) if you don’t want to use separators, you can use array of strings
	     - f (function) event handler function
	     **
	     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
	     > Example:
	     | eve.on("mouse", eatIt)(2);
	     | eve.on("mouse", scream);
	     | eve.on("mouse", catchIt)(1);
	     * This will ensure that `catchIt` function will be called before `eatIt`.
	     *
	     * If you want to put your handler before non-indexed handlers, specify a negative value.
	     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
	    \*/
                eve.on = function (name, f) {
                    if (typeof f != "function") {
                        return function () {
                        };
                    }
                    var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
                    for (var i = 0, ii = names.length; i < ii; i++) {
                        (function (name) {
                            var names = isArray(name) ? name : Str(name).split(separator),
                                e = events,
                                exist;
                            for (var i = 0, ii = names.length; i < ii; i++) {
                                e = e.n;
                                e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
                            }
                            e.f = e.f || [];
                            for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
                                exist = true;
                                break;
                            }
                            !exist && e.f.push(f);
                        }(names[i]));
                    }
                    return function (zIndex) {
                        if (+zIndex == +zIndex) {
                            f.zIndex = +zIndex;
                        }
                    };
                };
                /*\
	     * eve.f
	     [ method ]
	     **
	     * Returns function that will fire given event with optional arguments.
	     * Arguments that will be passed to the result function will be also
	     * concated to the list of final arguments.
	     | el.onclick = eve.f("click", 1, 2);
	     | eve.on("click", function (a, b, c) {
	     |     console.log(a, b, c); // 1, 2, [event object]
	     | });
	     > Arguments
	     - event (string) event name
	     - varargs (…) and any other arguments
	     = (function) possible event handler function
	    \*/
                eve.f = function (event) {
                    var attrs = [].slice.call(arguments, 1);
                    return function () {
                        eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
                    };
                };
                /*\
	     * eve.stop
	     [ method ]
	     **
	     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
	    \*/
                eve.stop = function () {
                    stop = 1;
                };
                /*\
	     * eve.nt
	     [ method ]
	     **
	     * Could be used inside event handler to figure out actual name of the event.
	     **
	     > Arguments
	     **
	     - subname (string) #optional subname of the event
	     **
	     = (string) name of the event, if `subname` is not specified
	     * or
	     = (boolean) `true`, if current event’s name contains `subname`
	    \*/
                eve.nt = function (subname) {
                    var cur = isArray(current_event) ? current_event.join(".") : current_event;
                    if (subname) {
                        return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
                    }
                    return cur;
                };
                /*\
	     * eve.nts
	     [ method ]
	     **
	     * Could be used inside event handler to figure out actual name of the event.
	     **
	     **
	     = (array) names of the event
	    \*/
                eve.nts = function () {
                    return isArray(current_event) ? current_event : current_event.split(separator);
                };
                /*\
	     * eve.off
	     [ method ]
	     **
	     * Removes given function from the list of event listeners assigned to given name.
	     * If no arguments specified all the events will be cleared.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	    \*/
                /*\
	     * eve.unbind
	     [ method ]
	     **
	     * See @eve.off
	    \*/
                eve.off = eve.unbind = function (name, f) {
                    if (!name) {
                        eve._events = events = {n: {}};
                        return;
                    }
                    var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
                    if (names.length > 1) {
                        for (var i = 0, ii = names.length; i < ii; i++) {
                            eve.off(names[i], f);
                        }
                        return;
                    }
                    names = isArray(name) ? name : Str(name).split(separator);
                    var e,
                        key,
                        splice,
                        i, ii, j, jj,
                        cur = [events];
                    for (i = 0, ii = names.length; i < ii; i++) {
                        for (j = 0; j < cur.length; j += splice.length - 2) {
                            splice = [j, 1];
                            e = cur[j].n;
                            if (names[i] != wildcard) {
                                if (e[names[i]]) {
                                    splice.push(e[names[i]]);
                                }
                            } else {
                                for (key in e) if (e[has](key)) {
                                    splice.push(e[key]);
                                }
                            }
                            cur.splice.apply(cur, splice);
                        }
                    }
                    for (i = 0, ii = cur.length; i < ii; i++) {
                        e = cur[i];
                        while (e.n) {
                            if (f) {
                                if (e.f) {
                                    for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                                        e.f.splice(j, 1);
                                        break;
                                    }
                                    !e.f.length && delete e.f;
                                }
                                for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                                    var funcs = e.n[key].f;
                                    for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                                        funcs.splice(j, 1);
                                        break;
                                    }
                                    !funcs.length && delete e.n[key].f;
                                }
                            } else {
                                delete e.f;
                                for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                                    delete e.n[key].f;
                                }
                            }
                            e = e.n;
                        }
                    }
                };
                /*\
	     * eve.once
	     [ method ]
	     **
	     * Binds given event handler with a given name to only run once then unbind itself.
	     | eve.once("login", f);
	     | eve("login"); // triggers f
	     | eve("login"); // no listeners
	     * Use @eve to trigger the listener.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	     **
	     = (function) same return function as @eve.on
	    \*/
                eve.once = function (name, f) {
                    var f2 = function () {
                        eve.off(name, f2);
                        return f.apply(this, arguments);
                    };
                    return eve.on(name, f2);
                };
                /*\
	     * eve.version
	     [ property (string) ]
	     **
	     * Current version of the library.
	    \*/
                eve.version = version;
                eve.toString = function () {
                    return "You are running Eve " + version;
                };
                (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
                    return eve;
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));
            })(this);


            /***/
        },
        /* 3 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {
                if (R && !R.svg) {
                    return;
                }

                var has = "hasOwnProperty",
                    Str = String,
                    toFloat = parseFloat,
                    toInt = parseInt,
                    math = Math,
                    mmax = math.max,
                    abs = math.abs,
                    pow = math.pow,
                    separator = /[, ]+/,
                    eve = R.eve,
                    E = "",
                    S = " ";
                var xlink = "http://www.w3.org/1999/xlink",
                    markers = {
                        block: "M5,0 0,2.5 5,5z",
                        classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
                        diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
                        open: "M6,1 1,3.5 6,6",
                        oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
                    },
                    markerCounter = {};
                R.toString = function () {
                    return "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
                };
                var $ = function (el, attr) {
                        if (attr) {
                            if (typeof el == "string") {
                                el = $(el);
                            }
                            for (var key in attr) if (attr[has](key)) {
                                if (key.substring(0, 6) == "xlink:") {
                                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                                } else {
                                    el.setAttribute(key, Str(attr[key]));
                                }
                            }
                        } else {
                            el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
                            el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
                        }
                        return el;
                    },
                    addGradientFill = function (element, gradient) {
                        var type = "linear",
                            id = element.id + gradient,
                            fx = .5, fy = .5,
                            o = element.node,
                            SVG = element.paper,
                            s = o.style,
                            el = R._g.doc.getElementById(id);
                        if (!el) {
                            gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                                type = "radial";
                                if (_fx && _fy) {
                                    fx = toFloat(_fx);
                                    fy = toFloat(_fy);
                                    var dir = ((fy > .5) * 2 - 1);
                                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                                    (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                                    fy != .5 &&
                                    (fy = fy.toFixed(5) - 1e-5 * dir);
                                }
                                return E;
                            });
                            gradient = gradient.split(/\s*\-\s*/);
                            if (type == "linear") {
                                var angle = gradient.shift();
                                angle = -toFloat(angle);
                                if (isNaN(angle)) {
                                    return null;
                                }
                                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                                vector[2] *= max;
                                vector[3] *= max;
                                if (vector[2] < 0) {
                                    vector[0] = -vector[2];
                                    vector[2] = 0;
                                }
                                if (vector[3] < 0) {
                                    vector[1] = -vector[3];
                                    vector[3] = 0;
                                }
                            }
                            var dots = R._parseDots(gradient);
                            if (!dots) {
                                return null;
                            }
                            id = id.replace(/[\(\)\s,\xb0#]/g, "_");

                            if (element.gradient && id != element.gradient.id) {
                                SVG.defs.removeChild(element.gradient);
                                delete element.gradient;
                            }

                            if (!element.gradient) {
                                el = $(type + "Gradient", {id: id});
                                element.gradient = el;
                                $(el, type == "radial" ? {
                                    fx: fx,
                                    fy: fy
                                } : {
                                    x1: vector[0],
                                    y1: vector[1],
                                    x2: vector[2],
                                    y2: vector[3],
                                    gradientTransform: element.matrix.invert()
                                });
                                SVG.defs.appendChild(el);
                                for (var i = 0, ii = dots.length; i < ii; i++) {
                                    el.appendChild($("stop", {
                                        offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                                        "stop-color": dots[i].color || "#fff",
                                        "stop-opacity": isFinite(dots[i].opacity) ? dots[i].opacity : 1
                                    }));
                                }
                            }
                        }
                        $(o, {
                            fill: fillurl(id),
                            opacity: 1,
                            "fill-opacity": 1
                        });
                        s.fill = E;
                        s.opacity = 1;
                        s.fillOpacity = 1;
                        return 1;
                    },
                    isIE9or10 = function () {
                        var mode = document.documentMode;
                        return mode && (mode === 9 || mode === 10);
                    },
                    fillurl = function (id) {
                        if (isIE9or10()) {
                            return "url('#" + id + "')";
                        }
                        var location = document.location;
                        var locationString = (
                            location.protocol + '//' +
                            location.host +
                            location.pathname +
                            location.search
                        );
                        return "url('" + locationString + "#" + id + "')";
                    },
                    updatePosition = function (o) {
                        var bbox = o.getBBox(1);
                        $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
                    },
                    addArrow = function (o, value, isEnd) {
                        if (o.type == "path") {
                            var values = Str(value).toLowerCase().split("-"),
                                p = o.paper,
                                se = isEnd ? "end" : "start",
                                node = o.node,
                                attrs = o.attrs,
                                stroke = attrs["stroke-width"],
                                i = values.length,
                                type = "classic",
                                from,
                                to,
                                dx,
                                refX,
                                attr,
                                w = 3,
                                h = 3,
                                t = 5;
                            while (i--) {
                                switch (values[i]) {
                                    case "block":
                                    case "classic":
                                    case "oval":
                                    case "diamond":
                                    case "open":
                                    case "none":
                                        type = values[i];
                                        break;
                                    case "wide":
                                        h = 5;
                                        break;
                                    case "narrow":
                                        h = 2;
                                        break;
                                    case "long":
                                        w = 5;
                                        break;
                                    case "short":
                                        w = 2;
                                        break;
                                }
                            }
                            if (type == "open") {
                                w += 2;
                                h += 2;
                                t += 2;
                                dx = 1;
                                refX = isEnd ? 4 : 1;
                                attr = {
                                    fill: "none",
                                    stroke: attrs.stroke
                                };
                            } else {
                                refX = dx = w / 2;
                                attr = {
                                    fill: attrs.stroke,
                                    stroke: "none"
                                };
                            }
                            if (o._.arrows) {
                                if (isEnd) {
                                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                                } else {
                                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                                }
                            } else {
                                o._.arrows = {};
                            }
                            if (type != "none") {
                                var pathId = "raphael-marker-" + type,
                                    markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
                                if (!R._g.doc.getElementById(pathId)) {
                                    p.defs.appendChild($($("path"), {
                                        "stroke-linecap": "round",
                                        d: markers[type],
                                        id: pathId
                                    }));
                                    markerCounter[pathId] = 1;
                                } else {
                                    markerCounter[pathId]++;
                                }
                                var marker = R._g.doc.getElementById(markerId),
                                    use;
                                if (!marker) {
                                    marker = $($("marker"), {
                                        id: markerId,
                                        markerHeight: h,
                                        markerWidth: w,
                                        orient: "auto",
                                        refX: refX,
                                        refY: h / 2
                                    });
                                    use = $($("use"), {
                                        "xlink:href": "#" + pathId,
                                        transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                                        "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                                    });
                                    marker.appendChild(use);
                                    p.defs.appendChild(marker);
                                    markerCounter[markerId] = 1;
                                } else {
                                    markerCounter[markerId]++;
                                    use = marker.getElementsByTagName("use")[0];
                                }
                                $(use, attr);
                                var delta = dx * (type != "diamond" && type != "oval");
                                if (isEnd) {
                                    from = o._.arrows.startdx * stroke || 0;
                                    to = R.getTotalLength(attrs.path) - delta * stroke;
                                } else {
                                    from = delta * stroke;
                                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                                }
                                attr = {};
                                attr["marker-" + se] = "url(#" + markerId + ")";
                                if (to || from) {
                                    attr.d = R.getSubpath(attrs.path, from, to);
                                }
                                $(node, attr);
                                o._.arrows[se + "Path"] = pathId;
                                o._.arrows[se + "Marker"] = markerId;
                                o._.arrows[se + "dx"] = delta;
                                o._.arrows[se + "Type"] = type;
                                o._.arrows[se + "String"] = value;
                            } else {
                                if (isEnd) {
                                    from = o._.arrows.startdx * stroke || 0;
                                    to = R.getTotalLength(attrs.path) - from;
                                } else {
                                    from = 0;
                                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                                }
                                o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
                                delete o._.arrows[se + "Path"];
                                delete o._.arrows[se + "Marker"];
                                delete o._.arrows[se + "dx"];
                                delete o._.arrows[se + "Type"];
                                delete o._.arrows[se + "String"];
                            }
                            for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                                var item = R._g.doc.getElementById(attr);
                                item && item.parentNode.removeChild(item);
                            }
                        }
                    },
                    dasharray = {
                        "-": [3, 1],
                        ".": [1, 1],
                        "-.": [3, 1, 1, 1],
                        "-..": [3, 1, 1, 1, 1, 1],
                        ". ": [1, 3],
                        "- ": [4, 3],
                        "--": [8, 3],
                        "- .": [4, 3, 1, 3],
                        "--.": [8, 3, 1, 3],
                        "--..": [8, 3, 1, 3, 1, 3]
                    },
                    addDashes = function (o, value, params) {
                        value = dasharray[Str(value).toLowerCase()];
                        if (value) {
                            var width = o.attrs["stroke-width"] || "1",
                                butt = {
                                    round: width,
                                    square: width,
                                    butt: 0
                                }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                                dashes = [],
                                i = value.length;
                            while (i--) {
                                dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                            }
                            $(o.node, {"stroke-dasharray": dashes.join(",")});
                        }
                        else {
                            $(o.node, {"stroke-dasharray": "none"});
                        }
                    },
                    setFillAndStroke = function (o, params) {
                        var node = o.node,
                            attrs = o.attrs,
                            vis = node.style.visibility;
                        node.style.visibility = "hidden";
                        for (var att in params) {
                            if (params[has](att)) {
                                if (!R._availableAttrs[has](att)) {
                                    continue;
                                }
                                var value = params[att];
                                attrs[att] = value;
                                switch (att) {
                                    case "blur":
                                        o.blur(value);
                                        break;
                                    case "title":
                                        var title = node.getElementsByTagName("title");

                                        // Use the existing <title>.
                                        if (title.length && (title = title[0])) {
                                            title.firstChild.nodeValue = value;
                                        } else {
                                            title = $("title");
                                            var val = R._g.doc.createTextNode(value);
                                            title.appendChild(val);
                                            node.appendChild(title);
                                        }
                                        break;
                                    case "href":
                                    case "target":
                                        var pn = node.parentNode;
                                        if (pn.tagName.toLowerCase() != "a") {
                                            var hl = $("a");
                                            pn.insertBefore(hl, node);
                                            hl.appendChild(node);
                                            pn = hl;
                                        }
                                        if (att == "target") {
                                            pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                                        } else {
                                            pn.setAttributeNS(xlink, att, value);
                                        }
                                        break;
                                    case "cursor":
                                        node.style.cursor = value;
                                        break;
                                    case "transform":
                                        o.transform(value);
                                        break;
                                    case "arrow-start":
                                        addArrow(o, value);
                                        break;
                                    case "arrow-end":
                                        addArrow(o, value, 1);
                                        break;
                                    case "clip-rect":
                                        var rect = Str(value).split(separator);
                                        if (rect.length == 4) {
                                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                            var el = $("clipPath"),
                                                rc = $("rect");
                                            el.id = R.createUUID();
                                            $(rc, {
                                                x: rect[0],
                                                y: rect[1],
                                                width: rect[2],
                                                height: rect[3]
                                            });
                                            el.appendChild(rc);
                                            o.paper.defs.appendChild(el);
                                            $(node, {"clip-path": "url(#" + el.id + ")"});
                                            o.clip = rc;
                                        }
                                        if (!value) {
                                            var path = node.getAttribute("clip-path");
                                            if (path) {
                                                var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                                clip && clip.parentNode.removeChild(clip);
                                                $(node, {"clip-path": E});
                                                delete o.clip;
                                            }
                                        }
                                        break;
                                    case "path":
                                        if (o.type == "path") {
                                            $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                                            o._.dirty = 1;
                                            if (o._.arrows) {
                                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                            }
                                        }
                                        break;
                                    case "width":
                                        node.setAttribute(att, value);
                                        o._.dirty = 1;
                                        if (attrs.fx) {
                                            att = "x";
                                            value = attrs.x;
                                        } else {
                                            break;
                                        }
                                    case "x":
                                        if (attrs.fx) {
                                            value = -attrs.x - (attrs.width || 0);
                                        }
                                    case "rx":
                                        if (att == "rx" && o.type == "rect") {
                                            break;
                                        }
                                    case "cx":
                                        node.setAttribute(att, value);
                                        o.pattern && updatePosition(o);
                                        o._.dirty = 1;
                                        break;
                                    case "height":
                                        node.setAttribute(att, value);
                                        o._.dirty = 1;
                                        if (attrs.fy) {
                                            att = "y";
                                            value = attrs.y;
                                        } else {
                                            break;
                                        }
                                    case "y":
                                        if (attrs.fy) {
                                            value = -attrs.y - (attrs.height || 0);
                                        }
                                    case "ry":
                                        if (att == "ry" && o.type == "rect") {
                                            break;
                                        }
                                    case "cy":
                                        node.setAttribute(att, value);
                                        o.pattern && updatePosition(o);
                                        o._.dirty = 1;
                                        break;
                                    case "r":
                                        if (o.type == "rect") {
                                            $(node, {rx: value, ry: value});
                                        } else {
                                            node.setAttribute(att, value);
                                        }
                                        o._.dirty = 1;
                                        break;
                                    case "src":
                                        if (o.type == "image") {
                                            node.setAttributeNS(xlink, "href", value);
                                        }
                                        break;
                                    case "stroke-width":
                                        if (o._.sx != 1 || o._.sy != 1) {
                                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                                        }
                                        node.setAttribute(att, value);
                                        if (attrs["stroke-dasharray"]) {
                                            addDashes(o, attrs["stroke-dasharray"], params);
                                        }
                                        if (o._.arrows) {
                                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                        }
                                        break;
                                    case "stroke-dasharray":
                                        addDashes(o, value, params);
                                        break;
                                    case "fill":
                                        var isURL = Str(value).match(R._ISURL);
                                        if (isURL) {
                                            el = $("pattern");
                                            var ig = $("image");
                                            el.id = R.createUUID();
                                            $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                                            $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                                            el.appendChild(ig);

                                            (function (el) {
                                                R._preload(isURL[1], function () {
                                                    var w = this.offsetWidth,
                                                        h = this.offsetHeight;
                                                    $(el, {width: w, height: h});
                                                    $(ig, {width: w, height: h});
                                                });
                                            })(el);
                                            o.paper.defs.appendChild(el);
                                            $(node, {fill: "url(#" + el.id + ")"});
                                            o.pattern = el;
                                            o.pattern && updatePosition(o);
                                            break;
                                        }
                                        var clr = R.getRGB(value);
                                        if (!clr.error) {
                                            delete params.gradient;
                                            delete attrs.gradient;
                                            !R.is(attrs.opacity, "undefined") &&
                                            R.is(params.opacity, "undefined") &&
                                            $(node, {opacity: attrs.opacity});
                                            !R.is(attrs["fill-opacity"], "undefined") &&
                                            R.is(params["fill-opacity"], "undefined") &&
                                            $(node, {"fill-opacity": attrs["fill-opacity"]});
                                        } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                                            if ("opacity" in attrs || "fill-opacity" in attrs) {
                                                var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                                if (gradient) {
                                                    var stops = gradient.getElementsByTagName("stop");
                                                    $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                                                }
                                            }
                                            attrs.gradient = value;
                                            attrs.fill = "none";
                                            break;
                                        }
                                        clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                                    case "stroke":
                                        clr = R.getRGB(value);
                                        node.setAttribute(att, clr.hex);
                                        att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                                        if (att == "stroke" && o._.arrows) {
                                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                        }
                                        break;
                                    case "gradient":
                                        (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                                        break;
                                    case "opacity":
                                        if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                            $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                                        }
                                    // fall
                                    case "fill-opacity":
                                        if (attrs.gradient) {
                                            gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                            if (gradient) {
                                                stops = gradient.getElementsByTagName("stop");
                                                $(stops[stops.length - 1], {"stop-opacity": value});
                                            }
                                            break;
                                        }
                                    default:
                                        att == "font-size" && (value = toInt(value, 10) + "px");
                                        var cssrule = att.replace(/(\-.)/g, function (w) {
                                            return w.substring(1).toUpperCase();
                                        });
                                        node.style[cssrule] = value;
                                        o._.dirty = 1;
                                        node.setAttribute(att, value);
                                        break;
                                }
                            }
                        }

                        tuneText(o, params);
                        node.style.visibility = vis;
                    },
                    leading = 1.2,
                    tuneText = function (el, params) {
                        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
                            return;
                        }
                        var a = el.attrs,
                            node = el.node,
                            fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

                        if (params[has]("text")) {
                            a.text = params.text;
                            while (node.firstChild) {
                                node.removeChild(node.firstChild);
                            }
                            var texts = Str(params.text).split("\n"),
                                tspans = [],
                                tspan;
                            for (var i = 0, ii = texts.length; i < ii; i++) {
                                tspan = $("tspan");
                                i && $(tspan, {dy: fontSize * leading, x: a.x});
                                tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                                node.appendChild(tspan);
                                tspans[i] = tspan;
                            }
                        } else {
                            tspans = node.getElementsByTagName("tspan");
                            for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                                $(tspans[i], {dy: fontSize * leading, x: a.x});
                            } else {
                                $(tspans[0], {dy: 0});
                            }
                        }
                        $(node, {x: a.x, y: a.y});
                        el._.dirty = 1;
                        var bb = el._getBBox(),
                            dif = a.y - (bb.y + bb.height / 2);
                        dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
                    },
                    getRealNode = function (node) {
                        if (node.parentNode && node.parentNode.tagName.toLowerCase() === "a") {
                            return node.parentNode;
                        } else {
                            return node;
                        }
                    },
                    Element = function (node, svg) {
                        var X = 0,
                            Y = 0;
                        /*\
	         * Element.node
	         [ property (object) ]
	         **
	         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
	         **
	         * Note: Don’t mess with it.
	         > Usage
	         | // draw a circle at coordinate 10,10 with radius of 10
	         | var c = paper.circle(10, 10, 10);
	         | c.node.onclick = function () {
	         |     c.attr("fill", "red");
	         | };
	        \*/
                        this[0] = this.node = node;
                        /*\
	         * Element.raphael
	         [ property (object) ]
	         **
	         * Internal reference to @Raphael object. In case it is not available.
	         > Usage
	         | Raphael.el.red = function () {
	         |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
	         |     hsb.h = 1;
	         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
	         | }
	        \*/
                        node.raphael = true;
                        /*\
	         * Element.id
	         [ property (number) ]
	         **
	         * Unique id of the element. Especially useful when you want to listen to events of the element,
	         * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
	        \*/
                        this.id = guid();
                        node.raphaelid = this.id;

                        /**
                         * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements
                         * @returns {string} id
                         */
                        function guid() {
                            return ("0000" + (Math.random() * Math.pow(36, 5) << 0).toString(36)).slice(-5);
                        }

                        this.matrix = R.matrix();
                        this.realPath = null;
                        /*\
	         * Element.paper
	         [ property (object) ]
	         **
	         * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.
	         > Usage
	         | Raphael.el.cross = function () {
	         |     this.attr({fill: "red"});
	         |     this.paper.path("M10,10L50,50M50,10L10,50")
	         |         .attr({stroke: "red"});
	         | }
	        \*/
                        this.paper = svg;
                        this.attrs = this.attrs || {};
                        this._ = {
                            transform: [],
                            sx: 1,
                            sy: 1,
                            deg: 0,
                            dx: 0,
                            dy: 0,
                            dirty: 1
                        };
                        !svg.bottom && (svg.bottom = this);
                        /*\
	         * Element.prev
	         [ property (object) ]
	         **
	         * Reference to the previous element in the hierarchy.
	        \*/
                        this.prev = svg.top;
                        svg.top && (svg.top.next = this);
                        svg.top = this;
                        /*\
	         * Element.next
	         [ property (object) ]
	         **
	         * Reference to the next element in the hierarchy.
	        \*/
                        this.next = null;
                    },
                    elproto = R.el;

                Element.prototype = elproto;
                elproto.constructor = Element;

                R._engine.path = function (pathString, SVG) {
                    var el = $("path");
                    SVG.canvas && SVG.canvas.appendChild(el);
                    var p = new Element(el, SVG);
                    p.type = "path";
                    setFillAndStroke(p, {
                        fill: "none",
                        stroke: "#000",
                        path: pathString
                    });
                    return p;
                };
                /*\
	     * Element.rotate
	     [ method ]
	     **
	     * Deprecated! Use @Element.transform instead.
	     * Adds rotation by given angle around given point to the list of
	     * transformations of the element.
	     > Parameters
	     - deg (number) angle in degrees
	     - cx (number) #optional x coordinate of the centre of rotation
	     - cy (number) #optional y coordinate of the centre of rotation
	     * If cx & cy aren’t specified centre of the shape is used as a point of rotation.
	     = (object) @Element
	    \*/
                elproto.rotate = function (deg, cx, cy) {
                    if (this.removed) {
                        return this;
                    }
                    deg = Str(deg).split(separator);
                    if (deg.length - 1) {
                        cx = toFloat(deg[1]);
                        cy = toFloat(deg[2]);
                    }
                    deg = toFloat(deg[0]);
                    (cy == null) && (cx = cy);
                    if (cx == null || cy == null) {
                        var bbox = this.getBBox(1);
                        cx = bbox.x + bbox.width / 2;
                        cy = bbox.y + bbox.height / 2;
                    }
                    this.transform(this._.transform.concat([["r", deg, cx, cy]]));
                    return this;
                };
                /*\
	     * Element.scale
	     [ method ]
	     **
	     * Deprecated! Use @Element.transform instead.
	     * Adds scale by given amount relative to given point to the list of
	     * transformations of the element.
	     > Parameters
	     - sx (number) horisontal scale amount
	     - sy (number) vertical scale amount
	     - cx (number) #optional x coordinate of the centre of scale
	     - cy (number) #optional y coordinate of the centre of scale
	     * If cx & cy aren’t specified centre of the shape is used instead.
	     = (object) @Element
	    \*/
                elproto.scale = function (sx, sy, cx, cy) {
                    if (this.removed) {
                        return this;
                    }
                    sx = Str(sx).split(separator);
                    if (sx.length - 1) {
                        sy = toFloat(sx[1]);
                        cx = toFloat(sx[2]);
                        cy = toFloat(sx[3]);
                    }
                    sx = toFloat(sx[0]);
                    (sy == null) && (sy = sx);
                    (cy == null) && (cx = cy);
                    if (cx == null || cy == null) {
                        var bbox = this.getBBox(1);
                    }
                    cx = cx == null ? bbox.x + bbox.width / 2 : cx;
                    cy = cy == null ? bbox.y + bbox.height / 2 : cy;
                    this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
                    return this;
                };
                /*\
	     * Element.translate
	     [ method ]
	     **
	     * Deprecated! Use @Element.transform instead.
	     * Adds translation by given amount to the list of transformations of the element.
	     > Parameters
	     - dx (number) horisontal shift
	     - dy (number) vertical shift
	     = (object) @Element
	    \*/
                elproto.translate = function (dx, dy) {
                    if (this.removed) {
                        return this;
                    }
                    dx = Str(dx).split(separator);
                    if (dx.length - 1) {
                        dy = toFloat(dx[1]);
                    }
                    dx = toFloat(dx[0]) || 0;
                    dy = +dy || 0;
                    this.transform(this._.transform.concat([["t", dx, dy]]));
                    return this;
                };
                /*\
	     * Element.transform
	     [ method ]
	     **
	     * Adds transformation to the element which is separate to other attributes,
	     * i.e. translation doesn’t change `x` or `y` of the rectange. The format
	     * of transformation string is similar to the path string syntax:
	     | "t100,100r30,100,100s2,2,100,100r45s1.5"
	     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
	     * scale and `m` is for matrix.
	     *
	     * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
	     *
	     * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;
	     * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin
	     * coordinates as optional parameters, the default is the centre point of the element.
	     * Matrix accepts six parameters.
	     > Usage
	     | var el = paper.rect(10, 20, 300, 200);
	     | // translate 100, 100, rotate 45°, translate -100, 0
	     | el.transform("t100,100r45t-100,0");
	     | // if you want you can append or prepend transformations
	     | el.transform("...t50,50");
	     | el.transform("s2...");
	     | // or even wrap
	     | el.transform("t50,50...t-50-50");
	     | // to reset transformation call method with empty string
	     | el.transform("");
	     | // to get current value call it without parameters
	     | console.log(el.transform());
	     > Parameters
	     - tstr (string) #optional transformation string
	     * If tstr isn’t specified
	     = (string) current transformation string
	     * else
	     = (object) @Element
	    \*/
                elproto.transform = function (tstr) {
                    var _ = this._;
                    if (tstr == null) {
                        return _.transform;
                    }
                    R._extractTransform(this, tstr);

                    this.clip && $(this.clip, {transform: this.matrix.invert()});
                    this.pattern && updatePosition(this);
                    this.node && $(this.node, {transform: this.matrix});

                    if (_.sx != 1 || _.sy != 1) {
                        var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
                        this.attr({"stroke-width": sw});
                    }

                    return this;
                };
                /*\
	     * Element.hide
	     [ method ]
	     **
	     * Makes element invisible. See @Element.show.
	     = (object) @Element
	    \*/
                elproto.hide = function () {
                    if (!this.removed) this.node.style.display = "none";
                    return this;
                };
                /*\
	     * Element.show
	     [ method ]
	     **
	     * Makes element visible. See @Element.hide.
	     = (object) @Element
	    \*/
                elproto.show = function () {
                    if (!this.removed) this.node.style.display = "";
                    return this;
                };
                /*\
	     * Element.remove
	     [ method ]
	     **
	     * Removes element from the paper.
	    \*/
                elproto.remove = function () {
                    var node = getRealNode(this.node);
                    if (this.removed || !node.parentNode) {
                        return;
                    }
                    var paper = this.paper;
                    paper.__set__ && paper.__set__.exclude(this);
                    eve.unbind("raphael.*.*." + this.id);
                    if (this.gradient) {
                        paper.defs.removeChild(this.gradient);
                    }
                    R._tear(this, paper);

                    node.parentNode.removeChild(node);

                    // Remove custom data for element
                    this.removeData();

                    for (var i in this) {
                        this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                    }
                    this.removed = true;
                };
                elproto._getBBox = function () {
                    if (this.node.style.display == "none") {
                        this.show();
                        var hide = true;
                    }
                    var canvasHidden = false,
                        containerStyle;
                    if (this.paper.canvas.parentElement) {
                        containerStyle = this.paper.canvas.parentElement.style;
                    } //IE10+ can't find parentElement
                    else if (this.paper.canvas.parentNode) {
                        containerStyle = this.paper.canvas.parentNode.style;
                    }

                    if (containerStyle && containerStyle.display == "none") {
                        canvasHidden = true;
                        containerStyle.display = "";
                    }
                    var bbox = {};
                    try {
                        bbox = this.node.getBBox();
                    } catch (e) {
                        // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
                        bbox = {
                            x: this.node.clientLeft,
                            y: this.node.clientTop,
                            width: this.node.clientWidth,
                            height: this.node.clientHeight
                        }
                    } finally {
                        bbox = bbox || {};
                        if (canvasHidden) {
                            containerStyle.display = "none";
                        }
                    }
                    hide && this.hide();
                    return bbox;
                };
                /*\
	     * Element.attr
	     [ method ]
	     **
	     * Sets the attributes of the element.
	     > Parameters
	     - attrName (string) attribute’s name
	     - value (string) value
	     * or
	     - params (object) object of name/value pairs
	     * or
	     - attrName (string) attribute’s name
	     * or
	     - attrNames (array) in this case method returns array of current values for given attribute names
	     = (object) @Element if attrsName & value or params are passed in.
	     = (...) value of the attribute if only attrsName is passed in.
	     = (array) array of values of the attribute if attrsNames is passed in.
	     = (object) object of attributes if nothing is passed in.
	     > Possible parameters
	     # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
	     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
	     o clip-rect (string) comma or space separated values: x, y, width and height
	     o cursor (string) CSS type of the cursor
	     o cx (number) the x-axis coordinate of the center of the circle, or ellipse
	     o cy (number) the y-axis coordinate of the center of the circle, or ellipse
	     o fill (string) colour, gradient or image
	     o fill-opacity (number)
	     o font (string)
	     o font-family (string)
	     o font-size (number) font size in pixels
	     o font-weight (string)
	     o height (number)
	     o href (string) URL, if specified element behaves as hyperlink
	     o opacity (number)
	     o path (string) SVG path string format
	     o r (number) radius of the circle, ellipse or rounded corner on the rect
	     o rx (number) horisontal radius of the ellipse
	     o ry (number) vertical radius of the ellipse
	     o src (string) image URL, only works for @Element.image element
	     o stroke (string) stroke colour
	     o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]
	     o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]
	     o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]
	     o stroke-miterlimit (number)
	     o stroke-opacity (number)
	     o stroke-width (number) stroke width in pixels, default is '1'
	     o target (string) used with href
	     o text (string) contents of the text element. Use `\n` for multiline text
	     o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”
	     o title (string) will create tooltip with a given text
	     o transform (string) see @Element.transform
	     o width (number)
	     o x (number)
	     o y (number)
	     > Gradients
	     * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°
	     * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.
	     *
	     * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –
	     * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point
	     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
	     > Path String
	     # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path’s data attribute’s format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>
	     > Colour Parsing
	     # <ul>
	     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
	     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
	     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
	     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
	     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
	     #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>
	     #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>
	     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
	     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
	     #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>
	     #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
	     #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
	     #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>
	     #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>
	     # </ul>
	    \*/
                elproto.attr = function (name, value) {
                    if (this.removed) {
                        return this;
                    }
                    if (name == null) {
                        var res = {};
                        for (var a in this.attrs) if (this.attrs[has](a)) {
                            res[a] = this.attrs[a];
                        }
                        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                        res.transform = this._.transform;
                        return res;
                    }
                    if (value == null && R.is(name, "string")) {
                        if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                            return this.attrs.gradient;
                        }
                        if (name == "transform") {
                            return this._.transform;
                        }
                        var names = name.split(separator),
                            out = {};
                        for (var i = 0, ii = names.length; i < ii; i++) {
                            name = names[i];
                            if (name in this.attrs) {
                                out[name] = this.attrs[name];
                            } else if (R.is(this.paper.customAttributes[name], "function")) {
                                out[name] = this.paper.customAttributes[name].def;
                            } else {
                                out[name] = R._availableAttrs[name];
                            }
                        }
                        return ii - 1 ? out : out[names[0]];
                    }
                    if (value == null && R.is(name, "array")) {
                        out = {};
                        for (i = 0, ii = name.length; i < ii; i++) {
                            out[name[i]] = this.attr(name[i]);
                        }
                        return out;
                    }
                    if (value != null) {
                        var params = {};
                        params[name] = value;
                    } else if (name != null && R.is(name, "object")) {
                        params = name;
                    }
                    for (var key in params) {
                        eve("raphael.attr." + key + "." + this.id, this, params[key]);
                    }
                    for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                        var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                        this.attrs[key] = params[key];
                        for (var subkey in par) if (par[has](subkey)) {
                            params[subkey] = par[subkey];
                        }
                    }
                    setFillAndStroke(this, params);
                    return this;
                };
                /*\
	     * Element.toFront
	     [ method ]
	     **
	     * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.
	     = (object) @Element
	    \*/
                elproto.toFront = function () {
                    if (this.removed) {
                        return this;
                    }
                    var node = getRealNode(this.node);
                    node.parentNode.appendChild(node);
                    var svg = this.paper;
                    svg.top != this && R._tofront(this, svg);
                    return this;
                };
                /*\
	     * Element.toBack
	     [ method ]
	     **
	     * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.
	     = (object) @Element
	    \*/
                elproto.toBack = function () {
                    if (this.removed) {
                        return this;
                    }
                    var node = getRealNode(this.node);
                    var parentNode = node.parentNode;
                    parentNode.insertBefore(node, parentNode.firstChild);
                    R._toback(this, this.paper);
                    var svg = this.paper;
                    return this;
                };
                /*\
	     * Element.insertAfter
	     [ method ]
	     **
	     * Inserts current object after the given one.
	     = (object) @Element
	    \*/
                elproto.insertAfter = function (element) {
                    if (this.removed || !element) {
                        return this;
                    }

                    var node = getRealNode(this.node);
                    var afterNode = getRealNode(element.node || element[element.length - 1].node);
                    if (afterNode.nextSibling) {
                        afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
                    } else {
                        afterNode.parentNode.appendChild(node);
                    }
                    R._insertafter(this, element, this.paper);
                    return this;
                };
                /*\
	     * Element.insertBefore
	     [ method ]
	     **
	     * Inserts current object before the given one.
	     = (object) @Element
	    \*/
                elproto.insertBefore = function (element) {
                    if (this.removed || !element) {
                        return this;
                    }

                    var node = getRealNode(this.node);
                    var beforeNode = getRealNode(element.node || element[0].node);
                    beforeNode.parentNode.insertBefore(node, beforeNode);
                    R._insertbefore(this, element, this.paper);
                    return this;
                };
                elproto.blur = function (size) {
                    // Experimental. No Safari support. Use it on your own risk.
                    var t = this;
                    if (+size !== 0) {
                        var fltr = $("filter"),
                            blur = $("feGaussianBlur");
                        t.attrs.blur = size;
                        fltr.id = R.createUUID();
                        $(blur, {stdDeviation: +size || 1.5});
                        fltr.appendChild(blur);
                        t.paper.defs.appendChild(fltr);
                        t._blur = fltr;
                        $(t.node, {filter: "url(#" + fltr.id + ")"});
                    } else {
                        if (t._blur) {
                            t._blur.parentNode.removeChild(t._blur);
                            delete t._blur;
                            delete t.attrs.blur;
                        }
                        t.node.removeAttribute("filter");
                    }
                    return t;
                };
                R._engine.circle = function (svg, x, y, r) {
                    var el = $("circle");
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
                    res.type = "circle";
                    $(el, res.attrs);
                    return res;
                };
                R._engine.rect = function (svg, x, y, w, h, r) {
                    var el = $("rect");
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
                    res.type = "rect";
                    $(el, res.attrs);
                    return res;
                };
                R._engine.ellipse = function (svg, x, y, rx, ry) {
                    var el = $("ellipse");
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
                    res.type = "ellipse";
                    $(el, res.attrs);
                    return res;
                };
                R._engine.image = function (svg, src, x, y, w, h) {
                    var el = $("image");
                    $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
                    el.setAttributeNS(xlink, "href", src);
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {x: x, y: y, width: w, height: h, src: src};
                    res.type = "image";
                    return res;
                };
                R._engine.text = function (svg, x, y, text) {
                    var el = $("text");
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {
                        x: x,
                        y: y,
                        "text-anchor": "middle",
                        text: text,
                        "font-family": R._availableAttrs["font-family"],
                        "font-size": R._availableAttrs["font-size"],
                        stroke: "none",
                        fill: "#000"
                    };
                    res.type = "text";
                    setFillAndStroke(res, res.attrs);
                    return res;
                };
                R._engine.setSize = function (width, height) {
                    this.width = width || this.width;
                    this.height = height || this.height;
                    this.canvas.setAttribute("width", this.width);
                    this.canvas.setAttribute("height", this.height);
                    if (this._viewBox) {
                        this.setViewBox.apply(this, this._viewBox);
                    }
                    return this;
                };
                R._engine.create = function () {
                    var con = R._getContainer.apply(0, arguments),
                        container = con && con.container,
                        x = con.x,
                        y = con.y,
                        width = con.width,
                        height = con.height;
                    if (!container) {
                        throw new Error("SVG container not found.");
                    }
                    var cnvs = $("svg"),
                        css = "overflow:hidden;",
                        isFloating;
                    x = x || 0;
                    y = y || 0;
                    width = width || 512;
                    height = height || 342;
                    $(cnvs, {
                        height: height,
                        version: 1.1,
                        width: width,
                        xmlns: "http://www.w3.org/2000/svg",
                        "xmlns:xlink": "http://www.w3.org/1999/xlink"
                    });
                    if (container == 1) {
                        cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
                        R._g.doc.body.appendChild(cnvs);
                        isFloating = 1;
                    } else {
                        cnvs.style.cssText = css + "position:relative";
                        if (container.firstChild) {
                            container.insertBefore(cnvs, container.firstChild);
                        } else {
                            container.appendChild(cnvs);
                        }
                    }
                    container = new R._Paper;
                    container.width = width;
                    container.height = height;
                    container.canvas = cnvs;
                    container.clear();
                    container._left = container._top = 0;
                    isFloating && (container.renderfix = function () {
                    });
                    container.renderfix();
                    return container;
                };
                R._engine.setViewBox = function (x, y, w, h, fit) {
                    eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
                    var paperSize = this.getSize(),
                        size = mmax(w / paperSize.width, h / paperSize.height),
                        top = this.top,
                        aspectRatio = fit ? "xMidYMid meet" : "xMinYMin",
                        vb,
                        sw;
                    if (x == null) {
                        if (this._vbSize) {
                            size = 1;
                        }
                        delete this._vbSize;
                        vb = "0 0 " + this.width + S + this.height;
                    } else {
                        this._vbSize = size;
                        vb = x + S + y + S + w + S + h;
                    }
                    $(this.canvas, {
                        viewBox: vb,
                        preserveAspectRatio: aspectRatio
                    });
                    while (size && top) {
                        sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
                        top.attr({"stroke-width": sw});
                        top._.dirty = 1;
                        top._.dirtyT = 1;
                        top = top.prev;
                    }
                    this._viewBox = [x, y, w, h, !!fit];
                    return this;
                };
                /*\
	     * Paper.renderfix
	     [ method ]
	     **
	     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent
	     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
	     * This method fixes the issue.
	     **
	       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
	    \*/
                R.prototype.renderfix = function () {
                    var cnvs = this.canvas,
                        s = cnvs.style,
                        pos;
                    try {
                        pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
                    } catch (e) {
                        pos = cnvs.createSVGMatrix();
                    }
                    var left = -pos.e % 1,
                        top = -pos.f % 1;
                    if (left || top) {
                        if (left) {
                            this._left = (this._left + left) % 1;
                            s.left = this._left + "px";
                        }
                        if (top) {
                            this._top = (this._top + top) % 1;
                            s.top = this._top + "px";
                        }
                    }
                };
                /*\
	     * Paper.clear
	     [ method ]
	     **
	     * Clears the paper, i.e. removes all the elements.
	    \*/
                R.prototype.clear = function () {
                    R.eve("raphael.clear", this);
                    var c = this.canvas;
                    while (c.firstChild) {
                        c.removeChild(c.firstChild);
                    }
                    this.bottom = this.top = null;
                    (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
                    c.appendChild(this.desc);
                    c.appendChild(this.defs = $("defs"));
                };
                /*\
	     * Paper.remove
	     [ method ]
	     **
	     * Removes the paper from the DOM.
	    \*/
                R.prototype.remove = function () {
                    eve("raphael.remove", this);
                    this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
                    for (var i in this) {
                        this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                    }
                };
                var setproto = R.st;
                for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
                    setproto[method] = (function (methodname) {
                        return function () {
                            var arg = arguments;
                            return this.forEach(function (el) {
                                el[methodname].apply(el, arg);
                            });
                        };
                    })(method);
                }
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


            /***/
        },
        /* 4 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {
                if (R && !R.vml) {
                    return;
                }

                var has = "hasOwnProperty",
                    Str = String,
                    toFloat = parseFloat,
                    math = Math,
                    round = math.round,
                    mmax = math.max,
                    mmin = math.min,
                    abs = math.abs,
                    fillString = "fill",
                    separator = /[, ]+/,
                    eve = R.eve,
                    ms = " progid:DXImageTransform.Microsoft",
                    S = " ",
                    E = "",
                    map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
                    bites = /([clmz]),?([^clmz]*)/gi,
                    blurregexp = / progid:\S+Blur\([^\)]+\)/g,
                    val = /-?[^,\s-]+/g,
                    cssDot = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",
                    zoom = 21600,
                    pathTypes = {path: 1, rect: 1, image: 1},
                    ovalTypes = {circle: 1, ellipse: 1},
                    path2vml = function (path) {
                        var total = /[ahqstv]/ig,
                            command = R._pathToAbsolute;
                        Str(path).match(total) && (command = R._path2curve);
                        total = /[clmz]/g;
                        if (command == R._pathToAbsolute && !Str(path).match(total)) {
                            var res = Str(path).replace(bites, function (all, command, args) {
                                var vals = [],
                                    isMove = command.toLowerCase() == "m",
                                    res = map[command];
                                args.replace(val, function (value) {
                                    if (isMove && vals.length == 2) {
                                        res += vals + map[command == "m" ? "l" : "L"];
                                        vals = [];
                                    }
                                    vals.push(round(value * zoom));
                                });
                                return res + vals;
                            });
                            return res;
                        }
                        var pa = command(path), p, r;
                        res = [];
                        for (var i = 0, ii = pa.length; i < ii; i++) {
                            p = pa[i];
                            r = pa[i][0].toLowerCase();
                            r == "z" && (r = "x");
                            for (var j = 1, jj = p.length; j < jj; j++) {
                                r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                            }
                            res.push(r);
                        }
                        return res.join(S);
                    },
                    compensation = function (deg, dx, dy) {
                        var m = R.matrix();
                        m.rotate(-deg, .5, .5);
                        return {
                            dx: m.x(dx, dy),
                            dy: m.y(dx, dy)
                        };
                    },
                    setCoords = function (p, sx, sy, dx, dy, deg) {
                        var _ = p._,
                            m = p.matrix,
                            fillpos = _.fillpos,
                            o = p.node,
                            s = o.style,
                            y = 1,
                            flip = "",
                            dxdy,
                            kx = zoom / sx,
                            ky = zoom / sy;
                        s.visibility = "hidden";
                        if (!sx || !sy) {
                            return;
                        }
                        o.coordsize = abs(kx) + S + abs(ky);
                        s.rotation = deg * (sx * sy < 0 ? -1 : 1);
                        if (deg) {
                            var c = compensation(deg, dx, dy);
                            dx = c.dx;
                            dy = c.dy;
                        }
                        sx < 0 && (flip += "x");
                        sy < 0 && (flip += " y") && (y = -1);
                        s.flip = flip;
                        o.coordorigin = (dx * -kx) + S + (dy * -ky);
                        if (fillpos || _.fillsize) {
                            var fill = o.getElementsByTagName(fillString);
                            fill = fill && fill[0];
                            o.removeChild(fill);
                            if (fillpos) {
                                c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                                fill.position = c.dx * y + S + c.dy * y;
                            }
                            if (_.fillsize) {
                                fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                            }
                            o.appendChild(fill);
                        }
                        s.visibility = "visible";
                    };
                R.toString = function () {
                    return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
                };
                var addArrow = function (o, value, isEnd) {
                        var values = Str(value).toLowerCase().split("-"),
                            se = isEnd ? "end" : "start",
                            i = values.length,
                            type = "classic",
                            w = "medium",
                            h = "medium";
                        while (i--) {
                            switch (values[i]) {
                                case "block":
                                case "classic":
                                case "oval":
                                case "diamond":
                                case "open":
                                case "none":
                                    type = values[i];
                                    break;
                                case "wide":
                                case "narrow":
                                    h = values[i];
                                    break;
                                case "long":
                                case "short":
                                    w = values[i];
                                    break;
                            }
                        }
                        var stroke = o.node.getElementsByTagName("stroke")[0];
                        stroke[se + "arrow"] = type;
                        stroke[se + "arrowlength"] = w;
                        stroke[se + "arrowwidth"] = h;
                    },
                    setFillAndStroke = function (o, params) {
                        // o.paper.canvas.style.display = "none";
                        o.attrs = o.attrs || {};
                        var node = o.node,
                            a = o.attrs,
                            s = node.style,
                            xy,
                            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
                            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
                            res = o;


                        for (var par in params) if (params[has](par)) {
                            a[par] = params[par];
                        }
                        if (newpath) {
                            a.path = R._getPath[o.type](o);
                            o._.dirty = 1;
                        }
                        params.href && (node.href = params.href);
                        params.title && (node.title = params.title);
                        params.target && (node.target = params.target);
                        params.cursor && (s.cursor = params.cursor);
                        "blur" in params && o.blur(params.blur);
                        if (params.path && o.type == "path" || newpath) {
                            node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
                            o._.dirty = 1;
                            if (o.type == "image") {
                                o._.fillpos = [a.x, a.y];
                                o._.fillsize = [a.width, a.height];
                                setCoords(o, 1, 1, 0, 0, 0);
                            }
                        }
                        "transform" in params && o.transform(params.transform);
                        if (isOval) {
                            var cx = +a.cx,
                                cy = +a.cy,
                                rx = +a.rx || +a.r || 0,
                                ry = +a.ry || +a.r || 0;
                            node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
                            o._.dirty = 1;
                        }
                        if ("clip-rect" in params) {
                            var rect = Str(params["clip-rect"]).split(separator);
                            if (rect.length == 4) {
                                rect[2] = +rect[2] + (+rect[0]);
                                rect[3] = +rect[3] + (+rect[1]);
                                var div = node.clipRect || R._g.doc.createElement("div"),
                                    dstyle = div.style;
                                dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                                if (!node.clipRect) {
                                    dstyle.position = "absolute";
                                    dstyle.top = 0;
                                    dstyle.left = 0;
                                    dstyle.width = o.paper.width + "px";
                                    dstyle.height = o.paper.height + "px";
                                    node.parentNode.insertBefore(div, node);
                                    div.appendChild(node);
                                    node.clipRect = div;
                                }
                            }
                            if (!params["clip-rect"]) {
                                node.clipRect && (node.clipRect.style.clip = "auto");
                            }
                        }
                        if (o.textpath) {
                            var textpathStyle = o.textpath.style;
                            params.font && (textpathStyle.font = params.font);
                            params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
                            params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
                            params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
                            params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
                        }
                        if ("arrow-start" in params) {
                            addArrow(res, params["arrow-start"]);
                        }
                        if ("arrow-end" in params) {
                            addArrow(res, params["arrow-end"], 1);
                        }
                        if (params.opacity != null ||
                            params.fill != null ||
                            params.src != null ||
                            params.stroke != null ||
                            params["stroke-width"] != null ||
                            params["stroke-opacity"] != null ||
                            params["fill-opacity"] != null ||
                            params["stroke-dasharray"] != null ||
                            params["stroke-miterlimit"] != null ||
                            params["stroke-linejoin"] != null ||
                            params["stroke-linecap"] != null) {
                            var fill = node.getElementsByTagName(fillString),
                                newfill = false;
                            fill = fill && fill[0];
                            !fill && (newfill = fill = createNode(fillString));
                            if (o.type == "image" && params.src) {
                                fill.src = params.src;
                            }
                            params.fill && (fill.on = true);
                            if (fill.on == null || params.fill == "none" || params.fill === null) {
                                fill.on = false;
                            }
                            if (fill.on && params.fill) {
                                var isURL = Str(params.fill).match(R._ISURL);
                                if (isURL) {
                                    fill.parentNode == node && node.removeChild(fill);
                                    fill.rotate = true;
                                    fill.src = isURL[1];
                                    fill.type = "tile";
                                    var bbox = o.getBBox(1);
                                    fill.position = bbox.x + S + bbox.y;
                                    o._.fillpos = [bbox.x, bbox.y];

                                    R._preload(isURL[1], function () {
                                        o._.fillsize = [this.offsetWidth, this.offsetHeight];
                                    });
                                } else {
                                    fill.color = R.getRGB(params.fill).hex;
                                    fill.src = E;
                                    fill.type = "solid";
                                    if (R.getRGB(params.fill).error && (res.type in {
                                        circle: 1,
                                        ellipse: 1
                                    } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                                        a.fill = "none";
                                        a.gradient = params.fill;
                                        fill.rotate = false;
                                    }
                                }
                            }
                            if ("fill-opacity" in params || "opacity" in params) {
                                var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                                opacity = mmin(mmax(opacity, 0), 1);
                                fill.opacity = opacity;
                                if (fill.src) {
                                    fill.color = "none";
                                }
                            }
                            node.appendChild(fill);
                            var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                                newstroke = false;
                            !stroke && (newstroke = stroke = createNode("stroke"));
                            if ((params.stroke && params.stroke != "none") ||
                                params["stroke-width"] ||
                                params["stroke-opacity"] != null ||
                                params["stroke-dasharray"] ||
                                params["stroke-miterlimit"] ||
                                params["stroke-linejoin"] ||
                                params["stroke-linecap"]) {
                                stroke.on = true;
                            }
                            (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                            var strokeColor = R.getRGB(params.stroke);
                            stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                            opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
                            var width = (toFloat(params["stroke-width"]) || 1) * .75;
                            opacity = mmin(mmax(opacity, 0), 1);
                            params["stroke-width"] == null && (width = a["stroke-width"]);
                            params["stroke-width"] && (stroke.weight = width);
                            width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                            stroke.opacity = opacity;

                            params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
                            stroke.miterlimit = params["stroke-miterlimit"] || 8;
                            params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                            if ("stroke-dasharray" in params) {
                                var dasharray = {
                                    "-": "shortdash",
                                    ".": "shortdot",
                                    "-.": "shortdashdot",
                                    "-..": "shortdashdotdot",
                                    ". ": "dot",
                                    "- ": "dash",
                                    "--": "longdash",
                                    "- .": "dashdot",
                                    "--.": "longdashdot",
                                    "--..": "longdashdotdot"
                                };
                                stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
                            }
                            newstroke && node.appendChild(stroke);
                        }
                        if (res.type == "text") {
                            res.paper.canvas.style.display = E;
                            var span = res.paper.span,
                                m = 100,
                                fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
                            s = span.style;
                            a.font && (s.font = a.font);
                            a["font-family"] && (s.fontFamily = a["font-family"]);
                            a["font-weight"] && (s.fontWeight = a["font-weight"]);
                            a["font-style"] && (s.fontStyle = a["font-style"]);
                            fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
                            s.fontSize = fontSize * m + "px";
                            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
                            var brect = span.getBoundingClientRect();
                            res.W = a.w = (brect.right - brect.left) / m;
                            res.H = a.h = (brect.bottom - brect.top) / m;
                            // res.paper.canvas.style.display = "none";
                            res.X = a.x;
                            res.Y = a.y + res.H / 2;

                            ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
                            var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
                            for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                                res._.dirty = 1;
                                break;
                            }

                            // text-anchor emulation
                            switch (a["text-anchor"]) {
                                case "start":
                                    res.textpath.style["v-text-align"] = "left";
                                    res.bbx = res.W / 2;
                                    break;
                                case "end":
                                    res.textpath.style["v-text-align"] = "right";
                                    res.bbx = -res.W / 2;
                                    break;
                                default:
                                    res.textpath.style["v-text-align"] = "center";
                                    res.bbx = 0;
                                    break;
                            }
                            res.textpath.style["v-text-kern"] = true;
                        }
                        // res.paper.canvas.style.display = E;
                    },
                    addGradientFill = function (o, gradient, fill) {
                        o.attrs = o.attrs || {};
                        var attrs = o.attrs,
                            pow = Math.pow,
                            opacity,
                            oindex,
                            type = "linear",
                            fxfy = ".5 .5";
                        o.attrs.gradient = gradient;
                        gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
                            type = "radial";
                            if (fx && fy) {
                                fx = toFloat(fx);
                                fy = toFloat(fy);
                                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                                fxfy = fx + S + fy;
                            }
                            return E;
                        });
                        gradient = gradient.split(/\s*\-\s*/);
                        if (type == "linear") {
                            var angle = gradient.shift();
                            angle = -toFloat(angle);
                            if (isNaN(angle)) {
                                return null;
                            }
                        }
                        var dots = R._parseDots(gradient);
                        if (!dots) {
                            return null;
                        }
                        o = o.shape || o.node;
                        if (dots.length) {
                            o.removeChild(fill);
                            fill.on = true;
                            fill.method = "none";
                            fill.color = dots[0].color;
                            fill.color2 = dots[dots.length - 1].color;
                            var clrs = [];
                            for (var i = 0, ii = dots.length; i < ii; i++) {
                                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                            }
                            fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                            if (type == "radial") {
                                fill.type = "gradientTitle";
                                fill.focus = "100%";
                                fill.focussize = "0 0";
                                fill.focusposition = fxfy;
                                fill.angle = 0;
                            } else {
                                // fill.rotate= true;
                                fill.type = "gradient";
                                fill.angle = (270 - angle) % 360;
                            }
                            o.appendChild(fill);
                        }
                        return 1;
                    },
                    Element = function (node, vml) {
                        this[0] = this.node = node;
                        node.raphael = true;
                        this.id = R._oid++;
                        node.raphaelid = this.id;
                        this.X = 0;
                        this.Y = 0;
                        this.attrs = {};
                        this.paper = vml;
                        this.matrix = R.matrix();
                        this._ = {
                            transform: [],
                            sx: 1,
                            sy: 1,
                            dx: 0,
                            dy: 0,
                            deg: 0,
                            dirty: 1,
                            dirtyT: 1
                        };
                        !vml.bottom && (vml.bottom = this);
                        this.prev = vml.top;
                        vml.top && (vml.top.next = this);
                        vml.top = this;
                        this.next = null;
                    };
                var elproto = R.el;

                Element.prototype = elproto;
                elproto.constructor = Element;
                elproto.transform = function (tstr) {
                    if (tstr == null) {
                        return this._.transform;
                    }
                    var vbs = this.paper._viewBoxShift,
                        vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
                        oldt;
                    if (vbs) {
                        oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
                    }
                    R._extractTransform(this, vbt + tstr);
                    var matrix = this.matrix.clone(),
                        skew = this.skew,
                        o = this.node,
                        split,
                        isGrad = ~Str(this.attrs.fill).indexOf("-"),
                        isPatt = !Str(this.attrs.fill).indexOf("url(");
                    matrix.translate(1, 1);
                    if (isPatt || isGrad || this.type == "image") {
                        skew.matrix = "1 0 0 1";
                        skew.offset = "0 0";
                        split = matrix.split();
                        if ((isGrad && split.noRotation) || !split.isSimple) {
                            o.style.filter = matrix.toFilter();
                            var bb = this.getBBox(),
                                bbt = this.getBBox(1),
                                dx = bb.x - bbt.x,
                                dy = bb.y - bbt.y;
                            o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                            setCoords(this, 1, 1, dx, dy, 0);
                        } else {
                            o.style.filter = E;
                            setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
                        }
                    } else {
                        o.style.filter = E;
                        skew.matrix = Str(matrix);
                        skew.offset = matrix.offset();
                    }
                    if (oldt !== null) { // empty string value is true as well
                        this._.transform = oldt;
                        R._extractTransform(this, oldt);
                    }
                    return this;
                };
                elproto.rotate = function (deg, cx, cy) {
                    if (this.removed) {
                        return this;
                    }
                    if (deg == null) {
                        return;
                    }
                    deg = Str(deg).split(separator);
                    if (deg.length - 1) {
                        cx = toFloat(deg[1]);
                        cy = toFloat(deg[2]);
                    }
                    deg = toFloat(deg[0]);
                    (cy == null) && (cx = cy);
                    if (cx == null || cy == null) {
                        var bbox = this.getBBox(1);
                        cx = bbox.x + bbox.width / 2;
                        cy = bbox.y + bbox.height / 2;
                    }
                    this._.dirtyT = 1;
                    this.transform(this._.transform.concat([["r", deg, cx, cy]]));
                    return this;
                };
                elproto.translate = function (dx, dy) {
                    if (this.removed) {
                        return this;
                    }
                    dx = Str(dx).split(separator);
                    if (dx.length - 1) {
                        dy = toFloat(dx[1]);
                    }
                    dx = toFloat(dx[0]) || 0;
                    dy = +dy || 0;
                    if (this._.bbox) {
                        this._.bbox.x += dx;
                        this._.bbox.y += dy;
                    }
                    this.transform(this._.transform.concat([["t", dx, dy]]));
                    return this;
                };
                elproto.scale = function (sx, sy, cx, cy) {
                    if (this.removed) {
                        return this;
                    }
                    sx = Str(sx).split(separator);
                    if (sx.length - 1) {
                        sy = toFloat(sx[1]);
                        cx = toFloat(sx[2]);
                        cy = toFloat(sx[3]);
                        isNaN(cx) && (cx = null);
                        isNaN(cy) && (cy = null);
                    }
                    sx = toFloat(sx[0]);
                    (sy == null) && (sy = sx);
                    (cy == null) && (cx = cy);
                    if (cx == null || cy == null) {
                        var bbox = this.getBBox(1);
                    }
                    cx = cx == null ? bbox.x + bbox.width / 2 : cx;
                    cy = cy == null ? bbox.y + bbox.height / 2 : cy;

                    this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
                    this._.dirtyT = 1;
                    return this;
                };
                elproto.hide = function () {
                    !this.removed && (this.node.style.display = "none");
                    return this;
                };
                elproto.show = function () {
                    !this.removed && (this.node.style.display = E);
                    return this;
                };
                // Needed to fix the vml setViewBox issues
                elproto.auxGetBBox = R.el.getBBox;
                elproto.getBBox = function () {
                    var b = this.auxGetBBox();
                    if (this.paper && this.paper._viewBoxShift) {
                        var c = {};
                        var z = 1 / this.paper._viewBoxShift.scale;
                        c.x = b.x - this.paper._viewBoxShift.dx;
                        c.x *= z;
                        c.y = b.y - this.paper._viewBoxShift.dy;
                        c.y *= z;
                        c.width = b.width * z;
                        c.height = b.height * z;
                        c.x2 = c.x + c.width;
                        c.y2 = c.y + c.height;
                        return c;
                    }
                    return b;
                };
                elproto._getBBox = function () {
                    if (this.removed) {
                        return {};
                    }
                    return {
                        x: this.X + (this.bbx || 0) - this.W / 2,
                        y: this.Y - this.H,
                        width: this.W,
                        height: this.H
                    };
                };
                elproto.remove = function () {
                    if (this.removed || !this.node.parentNode) {
                        return;
                    }
                    this.paper.__set__ && this.paper.__set__.exclude(this);
                    R.eve.unbind("raphael.*.*." + this.id);
                    R._tear(this, this.paper);
                    this.node.parentNode.removeChild(this.node);
                    this.shape && this.shape.parentNode.removeChild(this.shape);
                    for (var i in this) {
                        this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                    }
                    this.removed = true;
                };
                elproto.attr = function (name, value) {
                    if (this.removed) {
                        return this;
                    }
                    if (name == null) {
                        var res = {};
                        for (var a in this.attrs) if (this.attrs[has](a)) {
                            res[a] = this.attrs[a];
                        }
                        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                        res.transform = this._.transform;
                        return res;
                    }
                    if (value == null && R.is(name, "string")) {
                        if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                            return this.attrs.gradient;
                        }
                        var names = name.split(separator),
                            out = {};
                        for (var i = 0, ii = names.length; i < ii; i++) {
                            name = names[i];
                            if (name in this.attrs) {
                                out[name] = this.attrs[name];
                            } else if (R.is(this.paper.customAttributes[name], "function")) {
                                out[name] = this.paper.customAttributes[name].def;
                            } else {
                                out[name] = R._availableAttrs[name];
                            }
                        }
                        return ii - 1 ? out : out[names[0]];
                    }
                    if (this.attrs && value == null && R.is(name, "array")) {
                        out = {};
                        for (i = 0, ii = name.length; i < ii; i++) {
                            out[name[i]] = this.attr(name[i]);
                        }
                        return out;
                    }
                    var params;
                    if (value != null) {
                        params = {};
                        params[name] = value;
                    }
                    value == null && R.is(name, "object") && (params = name);
                    for (var key in params) {
                        eve("raphael.attr." + key + "." + this.id, this, params[key]);
                    }
                    if (params) {
                        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                            this.attrs[key] = params[key];
                            for (var subkey in par) if (par[has](subkey)) {
                                params[subkey] = par[subkey];
                            }
                        }
                        // this.paper.canvas.style.display = "none";
                        if (params.text && this.type == "text") {
                            this.textpath.string = params.text;
                        }
                        setFillAndStroke(this, params);
                        // this.paper.canvas.style.display = E;
                    }
                    return this;
                };
                elproto.toFront = function () {
                    !this.removed && this.node.parentNode.appendChild(this.node);
                    this.paper && this.paper.top != this && R._tofront(this, this.paper);
                    return this;
                };
                elproto.toBack = function () {
                    if (this.removed) {
                        return this;
                    }
                    if (this.node.parentNode.firstChild != this.node) {
                        this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
                        R._toback(this, this.paper);
                    }
                    return this;
                };
                elproto.insertAfter = function (element) {
                    if (this.removed) {
                        return this;
                    }
                    if (element.constructor == R.st.constructor) {
                        element = element[element.length - 1];
                    }
                    if (element.node.nextSibling) {
                        element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
                    } else {
                        element.node.parentNode.appendChild(this.node);
                    }
                    R._insertafter(this, element, this.paper);
                    return this;
                };
                elproto.insertBefore = function (element) {
                    if (this.removed) {
                        return this;
                    }
                    if (element.constructor == R.st.constructor) {
                        element = element[0];
                    }
                    element.node.parentNode.insertBefore(this.node, element.node);
                    R._insertbefore(this, element, this.paper);
                    return this;
                };
                elproto.blur = function (size) {
                    var s = this.node.runtimeStyle,
                        f = s.filter;
                    f = f.replace(blurregexp, E);
                    if (+size !== 0) {
                        this.attrs.blur = size;
                        s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
                        s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
                    } else {
                        s.filter = f;
                        s.margin = 0;
                        delete this.attrs.blur;
                    }
                    return this;
                };

                R._engine.path = function (pathString, vml) {
                    var el = createNode("shape");
                    el.style.cssText = cssDot;
                    el.coordsize = zoom + S + zoom;
                    el.coordorigin = vml.coordorigin;
                    var p = new Element(el, vml),
                        attr = {fill: "none", stroke: "#000"};
                    pathString && (attr.path = pathString);
                    p.type = "path";
                    p.path = [];
                    p.Path = E;
                    setFillAndStroke(p, attr);
                    vml.canvas && vml.canvas.appendChild(el);
                    var skew = createNode("skew");
                    skew.on = true;
                    el.appendChild(skew);
                    p.skew = skew;
                    p.transform(E);
                    return p;
                };
                R._engine.rect = function (vml, x, y, w, h, r) {
                    var path = R._rectPath(x, y, w, h, r),
                        res = vml.path(path),
                        a = res.attrs;
                    res.X = a.x = x;
                    res.Y = a.y = y;
                    res.W = a.width = w;
                    res.H = a.height = h;
                    a.r = r;
                    a.path = path;
                    res.type = "rect";
                    return res;
                };
                R._engine.ellipse = function (vml, x, y, rx, ry) {
                    var res = vml.path(),
                        a = res.attrs;
                    res.X = x - rx;
                    res.Y = y - ry;
                    res.W = rx * 2;
                    res.H = ry * 2;
                    res.type = "ellipse";
                    setFillAndStroke(res, {
                        cx: x,
                        cy: y,
                        rx: rx,
                        ry: ry
                    });
                    return res;
                };
                R._engine.circle = function (vml, x, y, r) {
                    var res = vml.path(),
                        a = res.attrs;
                    res.X = x - r;
                    res.Y = y - r;
                    res.W = res.H = r * 2;
                    res.type = "circle";
                    setFillAndStroke(res, {
                        cx: x,
                        cy: y,
                        r: r
                    });
                    return res;
                };
                R._engine.image = function (vml, src, x, y, w, h) {
                    var path = R._rectPath(x, y, w, h),
                        res = vml.path(path).attr({stroke: "none"}),
                        a = res.attrs,
                        node = res.node,
                        fill = node.getElementsByTagName(fillString)[0];
                    a.src = src;
                    res.X = a.x = x;
                    res.Y = a.y = y;
                    res.W = a.width = w;
                    res.H = a.height = h;
                    a.path = path;
                    res.type = "image";
                    fill.parentNode == node && node.removeChild(fill);
                    fill.rotate = true;
                    fill.src = src;
                    fill.type = "tile";
                    res._.fillpos = [x, y];
                    res._.fillsize = [w, h];
                    node.appendChild(fill);
                    setCoords(res, 1, 1, 0, 0, 0);
                    return res;
                };
                R._engine.text = function (vml, x, y, text) {
                    var el = createNode("shape"),
                        path = createNode("path"),
                        o = createNode("textpath");
                    x = x || 0;
                    y = y || 0;
                    text = text || "";
                    path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
                    path.textpathok = true;
                    o.string = Str(text);
                    o.on = true;
                    el.style.cssText = cssDot;
                    el.coordsize = zoom + S + zoom;
                    el.coordorigin = "0 0";
                    var p = new Element(el, vml),
                        attr = {
                            fill: "#000",
                            stroke: "none",
                            font: R._availableAttrs.font,
                            text: text
                        };
                    p.shape = el;
                    p.path = path;
                    p.textpath = o;
                    p.type = "text";
                    p.attrs.text = Str(text);
                    p.attrs.x = x;
                    p.attrs.y = y;
                    p.attrs.w = 1;
                    p.attrs.h = 1;
                    setFillAndStroke(p, attr);
                    el.appendChild(o);
                    el.appendChild(path);
                    vml.canvas.appendChild(el);
                    var skew = createNode("skew");
                    skew.on = true;
                    el.appendChild(skew);
                    p.skew = skew;
                    p.transform(E);
                    return p;
                };
                R._engine.setSize = function (width, height) {
                    var cs = this.canvas.style;
                    this.width = width;
                    this.height = height;
                    width == +width && (width += "px");
                    height == +height && (height += "px");
                    cs.width = width;
                    cs.height = height;
                    cs.clip = "rect(0 " + width + " " + height + " 0)";
                    if (this._viewBox) {
                        R._engine.setViewBox.apply(this, this._viewBox);
                    }
                    return this;
                };
                R._engine.setViewBox = function (x, y, w, h, fit) {
                    R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
                    var paperSize = this.getSize(),
                        width = paperSize.width,
                        height = paperSize.height,
                        H, W;
                    if (fit) {
                        H = height / h;
                        W = width / w;
                        if (w * H < width) {
                            x -= (width - w * H) / 2 / H;
                        }
                        if (h * W < height) {
                            y -= (height - h * W) / 2 / W;
                        }
                    }
                    this._viewBox = [x, y, w, h, !!fit];
                    this._viewBoxShift = {
                        dx: -x,
                        dy: -y,
                        scale: paperSize
                    };
                    this.forEach(function (el) {
                        el.transform("...");
                    });
                    return this;
                };
                var createNode;
                R._engine.initWin = function (win) {
                    var doc = win.document;
                    if (doc.styleSheets.length < 31) {
                        doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
                    } else {
                        // no more room, add to the existing one
                        // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
                        doc.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
                    }
                    try {
                        !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                        createNode = function (tagName) {
                            return doc.createElement('<rvml:' + tagName + ' class="rvml">');
                        };
                    } catch (e) {
                        createNode = function (tagName) {
                            return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                        };
                    }
                };
                R._engine.initWin(R._g.win);
                R._engine.create = function () {
                    var con = R._getContainer.apply(0, arguments),
                        container = con.container,
                        height = con.height,
                        s,
                        width = con.width,
                        x = con.x,
                        y = con.y;
                    if (!container) {
                        throw new Error("VML container not found.");
                    }
                    var res = new R._Paper,
                        c = res.canvas = R._g.doc.createElement("div"),
                        cs = c.style;
                    x = x || 0;
                    y = y || 0;
                    width = width || 512;
                    height = height || 342;
                    res.width = width;
                    res.height = height;
                    width == +width && (width += "px");
                    height == +height && (height += "px");
                    res.coordsize = zoom * 1e3 + S + zoom * 1e3;
                    res.coordorigin = "0 0";
                    res.span = R._g.doc.createElement("span");
                    res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
                    c.appendChild(res.span);
                    cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
                    if (container == 1) {
                        R._g.doc.body.appendChild(c);
                        cs.left = x + "px";
                        cs.top = y + "px";
                        cs.position = "absolute";
                    } else {
                        if (container.firstChild) {
                            container.insertBefore(c, container.firstChild);
                        } else {
                            container.appendChild(c);
                        }
                    }
                    res.renderfix = function () {
                    };
                    return res;
                };
                R.prototype.clear = function () {
                    R.eve("raphael.clear", this);
                    this.canvas.innerHTML = E;
                    this.span = R._g.doc.createElement("span");
                    this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
                    this.canvas.appendChild(this.span);
                    this.bottom = this.top = null;
                };
                R.prototype.remove = function () {
                    R.eve("raphael.remove", this);
                    this.canvas.parentNode.removeChild(this.canvas);
                    for (var i in this) {
                        this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                    }
                    return true;
                };

                var setproto = R.st;
                for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
                    setproto[method] = (function (methodname) {
                        return function () {
                            var arg = arguments;
                            return this.forEach(function (el) {
                                el[methodname].apply(el, arg);
                            });
                        };
                    })(method);
                }
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


            /***/
        }
        /******/])
});
;
/* @license
morris.js v0.5.0
Copyright 2014 Olly Smith All rights reserved.
Licensed under the BSD-2-Clause License.
*/


(function () {
    var $, Morris, minutesSpecHelper, secondsSpecHelper,
        __slice = [].slice,
        __bind = function (fn, me) {
            return function () {
                return fn.apply(me, arguments);
            };
        },
        __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key];
            }

            function ctor() {
                this.constructor = child;
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        },
        __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };

    Morris = window.Morris = {};

    $ = jQuery;

    Morris.EventEmitter = (function () {
        function EventEmitter() {
        }

        EventEmitter.prototype.on = function (name, handler) {
            if (this.handlers == null) {
                this.handlers = {};
            }
            if (this.handlers[name] == null) {
                this.handlers[name] = [];
            }
            this.handlers[name].push(handler);
            return this;
        };

        EventEmitter.prototype.fire = function () {
            var args, handler, name, _i, _len, _ref, _results;
            name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if ((this.handlers != null) && (this.handlers[name] != null)) {
                _ref = this.handlers[name];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    handler = _ref[_i];
                    _results.push(handler.apply(null, args));
                }
                return _results;
            }
        };

        return EventEmitter;

    })();

    Morris.commas = function (num) {
        var absnum, intnum, ret, strabsnum;
        if (num != null) {
            ret = num < 0 ? "-" : "";
            absnum = Math.abs(num);
            intnum = Math.floor(absnum).toFixed(0);
            ret += intnum.replace(/(?=(?:\d{3})+$)(?!^)/g, ',');
            strabsnum = absnum.toString();
            if (strabsnum.length > intnum.length) {
                ret += strabsnum.slice(intnum.length);
            }
            return ret;
        } else {
            return '-';
        }
    };

    Morris.pad2 = function (number) {
        return (number < 10 ? '0' : '') + number;
    };

    Morris.Grid = (function (_super) {
        __extends(Grid, _super);

        function Grid(options) {
            this.resizeHandler = __bind(this.resizeHandler, this);
            var _this = this;
            if (typeof options.element === 'string') {
                this.el = $(document.getElementById(options.element));
            } else {
                this.el = $(options.element);
            }
            if ((this.el == null) || this.el.length === 0) {
                throw new Error("Graph container element not found");
            }
            if (this.el.css('position') === 'static') {
                this.el.css('position', 'relative');
            }
            this.options = $.extend({}, this.gridDefaults, this.defaults || {}, options);
            if (typeof this.options.units === 'string') {
                this.options.postUnits = options.units;
            }
            this.raphael = new Raphael(this.el[0]);
            this.elementWidth = null;
            this.elementHeight = null;
            this.dirty = false;
            this.selectFrom = null;
            if (this.init) {
                this.init();
            }
            this.setData(this.options.data);
            this.el.bind('mousemove', function (evt) {
                var left, offset, right, width, x;
                offset = _this.el.offset();
                x = evt.pageX - offset.left;
                if (_this.selectFrom) {
                    left = _this.data[_this.hitTest(Math.min(x, _this.selectFrom))]._x;
                    right = _this.data[_this.hitTest(Math.max(x, _this.selectFrom))]._x;
                    width = right - left;
                    return _this.selectionRect.attr({
                        x: left,
                        width: width
                    });
                } else {
                    return _this.fire('hovermove', x, evt.pageY - offset.top);
                }
            });
            this.el.bind('mouseleave', function (evt) {
                if (_this.selectFrom) {
                    _this.selectionRect.hide();
                    _this.selectFrom = null;
                }
                return _this.fire('hoverout');
            });
            this.el.bind('touchstart touchmove touchend', function (evt) {
                var offset, touch;
                touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];
                offset = _this.el.offset();
                return _this.fire('hovermove', touch.pageX - offset.left, touch.pageY - offset.top);
            });
            this.el.bind('click', function (evt) {
                var offset;
                offset = _this.el.offset();
                return _this.fire('gridclick', evt.pageX - offset.left, evt.pageY - offset.top);
            });
            if (this.options.rangeSelect) {
                this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({
                    fill: this.options.rangeSelectColor,
                    stroke: false
                }).toBack().hide();
                this.el.bind('mousedown', function (evt) {
                    var offset;
                    offset = _this.el.offset();
                    return _this.startRange(evt.pageX - offset.left);
                });
                this.el.bind('mouseup', function (evt) {
                    var offset;
                    offset = _this.el.offset();
                    _this.endRange(evt.pageX - offset.left);
                    return _this.fire('hovermove', evt.pageX - offset.left, evt.pageY - offset.top);
                });
            }
            if (this.options.resize) {
                $(window).bind('resize', function (evt) {
                    if (_this.timeoutId != null) {
                        window.clearTimeout(_this.timeoutId);
                    }
                    return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);
                });
            }
            this.el.css('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');
            if (this.postInit) {
                this.postInit();
            }
        }

        Grid.prototype.gridDefaults = {
            dateFormat: null,
            axes: true,
            grid: true,
            gridLineColor: '#aaa',
            gridStrokeWidth: 0.5,
            gridTextColor: '#888',
            gridTextSize: 12,
            gridTextFamily: 'sans-serif',
            gridTextWeight: 'normal',
            hideHover: false,
            yLabelFormat: null,
            xLabelAngle: 0,
            numLines: 5,
            padding: 25,
            parseTime: true,
            postUnits: '',
            preUnits: '',
            ymax: 'auto',
            ymin: 'auto 0',
            goals: [],
            goalStrokeWidth: 1.0,
            goalLineColors: ['#666633', '#999966', '#cc6666', '#663333'],
            events: [],
            eventStrokeWidth: 1.0,
            eventLineColors: ['#005a04', '#ccffbb', '#3a5f0b', '#005502'],
            rangeSelect: null,
            rangeSelectColor: '#eef',
            resize: false
        };

        Grid.prototype.setData = function (data, redraw) {
            var e, idx, index, maxGoal, minGoal, ret, row, step, total, y, ykey, ymax, ymin, yval, _ref;
            if (redraw == null) {
                redraw = true;
            }
            this.options.data = data;
            if ((data == null) || data.length === 0) {
                this.data = [];
                this.raphael.clear();
                if (this.hover != null) {
                    this.hover.hide();
                }
                return;
            }
            ymax = this.cumulative ? 0 : null;
            ymin = this.cumulative ? 0 : null;
            if (this.options.goals.length > 0) {
                minGoal = Math.min.apply(Math, this.options.goals);
                maxGoal = Math.max.apply(Math, this.options.goals);
                ymin = ymin != null ? Math.min(ymin, minGoal) : minGoal;
                ymax = ymax != null ? Math.max(ymax, maxGoal) : maxGoal;
            }
            this.data = (function () {
                var _i, _len, _results;
                _results = [];
                for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
                    row = data[index];
                    ret = {
                        src: row
                    };
                    ret.label = row[this.options.xkey];
                    if (this.options.parseTime) {
                        ret.x = Morris.parseDate(ret.label);
                        if (this.options.dateFormat) {
                            ret.label = this.options.dateFormat(ret.x);
                        } else if (typeof ret.label === 'number') {
                            ret.label = new Date(ret.label).toString();
                        }
                    } else {
                        ret.x = index;
                        if (this.options.xLabelFormat) {
                            ret.label = this.options.xLabelFormat(ret);
                        }
                    }
                    total = 0;
                    ret.y = (function () {
                        var _j, _len1, _ref, _results1;
                        _ref = this.options.ykeys;
                        _results1 = [];
                        for (idx = _j = 0, _len1 = _ref.length; _j < _len1; idx = ++_j) {
                            ykey = _ref[idx];
                            yval = row[ykey];
                            if (typeof yval === 'string') {
                                yval = parseFloat(yval);
                            }
                            if ((yval != null) && typeof yval !== 'number') {
                                yval = null;
                            }
                            if (yval != null) {
                                if (this.cumulative) {
                                    total += yval;
                                } else {
                                    if (ymax != null) {
                                        ymax = Math.max(yval, ymax);
                                        ymin = Math.min(yval, ymin);
                                    } else {
                                        ymax = ymin = yval;
                                    }
                                }
                            }
                            if (this.cumulative && (total != null)) {
                                ymax = Math.max(total, ymax);
                                ymin = Math.min(total, ymin);
                            }
                            _results1.push(yval);
                        }
                        return _results1;
                    }).call(this);
                    _results.push(ret);
                }
                return _results;
            }).call(this);
            if (this.options.parseTime) {
                this.data = this.data.sort(function (a, b) {
                    return (a.x > b.x) - (b.x > a.x);
                });
            }
            this.xmin = this.data[0].x;
            this.xmax = this.data[this.data.length - 1].x;
            this.events = [];
            if (this.options.events.length > 0) {
                if (this.options.parseTime) {
                    this.events = (function () {
                        var _i, _len, _ref, _results;
                        _ref = this.options.events;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            e = _ref[_i];
                            _results.push(Morris.parseDate(e));
                        }
                        return _results;
                    }).call(this);
                } else {
                    this.events = this.options.events;
                }
                this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events));
                this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events));
            }
            if (this.xmin === this.xmax) {
                this.xmin -= 1;
                this.xmax += 1;
            }
            this.ymin = this.yboundary('min', ymin);
            this.ymax = this.yboundary('max', ymax);
            if (this.ymin === this.ymax) {
                if (ymin) {
                    this.ymin -= 1;
                }
                this.ymax += 1;
            }
            if (((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') || this.options.grid === true) {
                if (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin) {
                    this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines);
                    this.ymin = Math.min(this.ymin, this.grid[0]);
                    this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1]);
                } else {
                    step = (this.ymax - this.ymin) / (this.options.numLines - 1);
                    this.grid = (function () {
                        var _i, _ref1, _ref2, _results;
                        _results = [];
                        for (y = _i = _ref1 = this.ymin, _ref2 = this.ymax; step > 0 ? _i <= _ref2 : _i >= _ref2; y = _i += step) {
                            _results.push(y);
                        }
                        return _results;
                    }).call(this);
                }
            }
            this.dirty = true;
            if (redraw) {
                return this.redraw();
            }
        };

        Grid.prototype.yboundary = function (boundaryType, currentValue) {
            var boundaryOption, suggestedValue;
            boundaryOption = this.options["y" + boundaryType];
            if (typeof boundaryOption === 'string') {
                if (boundaryOption.slice(0, 4) === 'auto') {
                    if (boundaryOption.length > 5) {
                        suggestedValue = parseInt(boundaryOption.slice(5), 10);
                        if (currentValue == null) {
                            return suggestedValue;
                        }
                        return Math[boundaryType](currentValue, suggestedValue);
                    } else {
                        if (currentValue != null) {
                            return currentValue;
                        } else {
                            return 0;
                        }
                    }
                } else {
                    return parseInt(boundaryOption, 10);
                }
            } else {
                return boundaryOption;
            }
        };

        Grid.prototype.autoGridLines = function (ymin, ymax, nlines) {
            var gmax, gmin, grid, smag, span, step, unit, y, ymag;
            span = ymax - ymin;
            ymag = Math.floor(Math.log(span) / Math.log(10));
            unit = Math.pow(10, ymag);
            gmin = Math.floor(ymin / unit) * unit;
            gmax = Math.ceil(ymax / unit) * unit;
            step = (gmax - gmin) / (nlines - 1);
            if (unit === 1 && step > 1 && Math.ceil(step) !== step) {
                step = Math.ceil(step);
                gmax = gmin + step * (nlines - 1);
            }
            if (gmin < 0 && gmax > 0) {
                gmin = Math.floor(ymin / step) * step;
                gmax = Math.ceil(ymax / step) * step;
            }
            if (step < 1) {
                smag = Math.floor(Math.log(step) / Math.log(10));
                grid = (function () {
                    var _i, _results;
                    _results = [];
                    for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {
                        _results.push(parseFloat(y.toFixed(1 - smag)));
                    }
                    return _results;
                })();
            } else {
                grid = (function () {
                    var _i, _results;
                    _results = [];
                    for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {
                        _results.push(y);
                    }
                    return _results;
                })();
            }
            return grid;
        };

        Grid.prototype._calc = function () {
            var bottomOffsets, gridLine, h, i, w, yLabelWidths, _ref, _ref1;
            w = this.el.width();
            h = this.el.height();
            if (this.elementWidth !== w || this.elementHeight !== h || this.dirty) {
                this.elementWidth = w;
                this.elementHeight = h;
                this.dirty = false;
                this.left = this.options.padding;
                this.right = this.elementWidth - this.options.padding;
                this.top = this.options.padding;
                this.bottom = this.elementHeight - this.options.padding;
                if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') {
                    yLabelWidths = (function () {
                        var _i, _len, _ref1, _results;
                        _ref1 = this.grid;
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            gridLine = _ref1[_i];
                            _results.push(this.measureText(this.yAxisFormat(gridLine)).width);
                        }
                        return _results;
                    }).call(this);
                    this.left += Math.max.apply(Math, yLabelWidths);
                }
                if ((_ref1 = this.options.axes) === true || _ref1 === 'both' || _ref1 === 'x') {
                    bottomOffsets = (function () {
                        var _i, _ref2, _results;
                        _results = [];
                        for (i = _i = 0, _ref2 = this.data.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                            _results.push(this.measureText(this.data[i].text, -this.options.xLabelAngle).height);
                        }
                        return _results;
                    }).call(this);
                    this.bottom -= Math.max.apply(Math, bottomOffsets);
                }
                this.width = Math.max(1, this.right - this.left);
                this.height = Math.max(1, this.bottom - this.top);
                this.dx = this.width / (this.xmax - this.xmin);
                this.dy = this.height / (this.ymax - this.ymin);
                if (this.calc) {
                    return this.calc();
                }
            }
        };

        Grid.prototype.transY = function (y) {
            return this.bottom - (y - this.ymin) * this.dy;
        };

        Grid.prototype.transX = function (x) {
            if (this.data.length === 1) {
                return (this.left + this.right) / 2;
            } else {
                return this.left + (x - this.xmin) * this.dx;
            }
        };

        Grid.prototype.redraw = function () {
            this.raphael.clear();
            this._calc();
            this.drawGrid();
            this.drawGoals();
            this.drawEvents();
            if (this.draw) {
                return this.draw();
            }
        };

        Grid.prototype.measureText = function (text, angle) {
            var ret, tt;
            if (angle == null) {
                angle = 0;
            }
            tt = this.raphael.text(100, 100, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).rotate(angle);
            ret = tt.getBBox();
            tt.remove();
            return ret;
        };

        Grid.prototype.yAxisFormat = function (label) {
            return this.yLabelFormat(label);
        };

        Grid.prototype.yLabelFormat = function (label) {
            if (typeof this.options.yLabelFormat === 'function') {
                return this.options.yLabelFormat(label);
            } else {
                return "" + this.options.preUnits + (Morris.commas(label)) + this.options.postUnits;
            }
        };

        Grid.prototype.drawGrid = function () {
            var lineY, y, _i, _len, _ref, _ref1, _ref2, _results;
            if (this.options.grid === false && ((_ref = this.options.axes) !== true && _ref !== 'both' && _ref !== 'y')) {
                return;
            }
            _ref1 = this.grid;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                lineY = _ref1[_i];
                y = this.transY(lineY);
                if ((_ref2 = this.options.axes) === true || _ref2 === 'both' || _ref2 === 'y') {
                    this.drawYAxisLabel(this.left - this.options.padding / 2, y, this.yAxisFormat(lineY));
                }
                if (this.options.grid) {
                    _results.push(this.drawGridLine("M" + this.left + "," + y + "H" + (this.left + this.width)));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };

        Grid.prototype.drawGoals = function () {
            var color, goal, i, _i, _len, _ref, _results;
            _ref = this.options.goals;
            _results = [];
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                goal = _ref[i];
                color = this.options.goalLineColors[i % this.options.goalLineColors.length];
                _results.push(this.drawGoal(goal, color));
            }
            return _results;
        };

        Grid.prototype.drawEvents = function () {
            var color, event, i, _i, _len, _ref, _results;
            _ref = this.events;
            _results = [];
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                event = _ref[i];
                color = this.options.eventLineColors[i % this.options.eventLineColors.length];
                _results.push(this.drawEvent(event, color));
            }
            return _results;
        };

        Grid.prototype.drawGoal = function (goal, color) {
            return this.raphael.path("M" + this.left + "," + (this.transY(goal)) + "H" + this.right).attr('stroke', color).attr('stroke-width', this.options.goalStrokeWidth);
        };

        Grid.prototype.drawEvent = function (event, color) {
            return this.raphael.path("M" + (this.transX(event)) + "," + this.bottom + "V" + this.top).attr('stroke', color).attr('stroke-width', this.options.eventStrokeWidth);
        };

        Grid.prototype.drawYAxisLabel = function (xPos, yPos, text) {
            return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor).attr('text-anchor', 'end');
        };

        Grid.prototype.drawGridLine = function (path) {
            return this.raphael.path(path).attr('stroke', this.options.gridLineColor).attr('stroke-width', this.options.gridStrokeWidth);
        };

        Grid.prototype.startRange = function (x) {
            this.hover.hide();
            this.selectFrom = x;
            return this.selectionRect.attr({
                x: x,
                width: 0
            }).show();
        };

        Grid.prototype.endRange = function (x) {
            var end, start;
            if (this.selectFrom) {
                start = Math.min(this.selectFrom, x);
                end = Math.max(this.selectFrom, x);
                this.options.rangeSelect.call(this.el, {
                    start: this.data[this.hitTest(start)].x,
                    end: this.data[this.hitTest(end)].x
                });
                return this.selectFrom = null;
            }
        };

        Grid.prototype.resizeHandler = function () {
            this.timeoutId = null;
            this.raphael.setSize(this.el.width(), this.el.height());
            return this.redraw();
        };

        return Grid;

    })(Morris.EventEmitter);

    Morris.parseDate = function (date) {
        var isecs, m, msecs, n, o, offsetmins, p, q, r, ret, secs;
        if (typeof date === 'number') {
            return date;
        }
        m = date.match(/^(\d+) Q(\d)$/);
        n = date.match(/^(\d+)-(\d+)$/);
        o = date.match(/^(\d+)-(\d+)-(\d+)$/);
        p = date.match(/^(\d+) W(\d+)$/);
        q = date.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+)(Z|([+-])(\d\d):?(\d\d))?$/);
        r = date.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+):(\d+(\.\d+)?)(Z|([+-])(\d\d):?(\d\d))?$/);
        if (m) {
            return new Date(parseInt(m[1], 10), parseInt(m[2], 10) * 3 - 1, 1).getTime();
        } else if (n) {
            return new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, 1).getTime();
        } else if (o) {
            return new Date(parseInt(o[1], 10), parseInt(o[2], 10) - 1, parseInt(o[3], 10)).getTime();
        } else if (p) {
            ret = new Date(parseInt(p[1], 10), 0, 1);
            if (ret.getDay() !== 4) {
                ret.setMonth(0, 1 + ((4 - ret.getDay()) + 7) % 7);
            }
            return ret.getTime() + parseInt(p[2], 10) * 604800000;
        } else if (q) {
            if (!q[6]) {
                return new Date(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10)).getTime();
            } else {
                offsetmins = 0;
                if (q[6] !== 'Z') {
                    offsetmins = parseInt(q[8], 10) * 60 + parseInt(q[9], 10);
                    if (q[7] === '+') {
                        offsetmins = 0 - offsetmins;
                    }
                }
                return Date.UTC(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10) + offsetmins);
            }
        } else if (r) {
            secs = parseFloat(r[6]);
            isecs = Math.floor(secs);
            msecs = Math.round((secs - isecs) * 1000);
            if (!r[8]) {
                return new Date(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10), isecs, msecs).getTime();
            } else {
                offsetmins = 0;
                if (r[8] !== 'Z') {
                    offsetmins = parseInt(r[10], 10) * 60 + parseInt(r[11], 10);
                    if (r[9] === '+') {
                        offsetmins = 0 - offsetmins;
                    }
                }
                return Date.UTC(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10) + offsetmins, isecs, msecs);
            }
        } else {
            return new Date(parseInt(date, 10), 0, 1).getTime();
        }
    };

    Morris.Hover = (function () {
        Hover.defaults = {
            "class": 'morris-hover morris-default-style'
        };

        function Hover(options) {
            if (options == null) {
                options = {};
            }
            this.options = $.extend({}, Morris.Hover.defaults, options);
            this.el = $("<div class='" + this.options["class"] + "'></div>");
            this.el.hide();
            this.options.parent.append(this.el);
        }

        Hover.prototype.update = function (html, x, y) {
            if (!html) {
                return this.hide();
            } else {
                this.html(html);
                this.show();
                return this.moveTo(x, y);
            }
        };

        Hover.prototype.html = function (content) {
            return this.el.html(content);
        };

        Hover.prototype.moveTo = function (x, y) {
            var hoverHeight, hoverWidth, left, parentHeight, parentWidth, top;
            parentWidth = this.options.parent.innerWidth();
            parentHeight = this.options.parent.innerHeight();
            hoverWidth = this.el.outerWidth();
            hoverHeight = this.el.outerHeight();
            left = Math.min(Math.max(0, x - hoverWidth / 2), parentWidth - hoverWidth);
            if (y != null) {
                top = y - hoverHeight - 10;
                if (top < 0) {
                    top = y + 10;
                    if (top + hoverHeight > parentHeight) {
                        top = parentHeight / 2 - hoverHeight / 2;
                    }
                }
            } else {
                top = parentHeight / 2 - hoverHeight / 2;
            }
            return this.el.css({
                left: left + "px",
                top: parseInt(top) + "px"
            });
        };

        Hover.prototype.show = function () {
            return this.el.show();
        };

        Hover.prototype.hide = function () {
            return this.el.hide();
        };

        return Hover;

    })();

    Morris.Line = (function (_super) {
        __extends(Line, _super);

        function Line(options) {
            this.hilight = __bind(this.hilight, this);
            this.onHoverOut = __bind(this.onHoverOut, this);
            this.onHoverMove = __bind(this.onHoverMove, this);
            this.onGridClick = __bind(this.onGridClick, this);
            if (!(this instanceof Morris.Line)) {
                return new Morris.Line(options);
            }
            Line.__super__.constructor.call(this, options);
        }

        Line.prototype.init = function () {
            if (this.options.hideHover !== 'always') {
                this.hover = new Morris.Hover({
                    parent: this.el
                });
                this.on('hovermove', this.onHoverMove);
                this.on('hoverout', this.onHoverOut);
                return this.on('gridclick', this.onGridClick);
            }
        };

        Line.prototype.defaults = {
            lineWidth: 3,
            pointSize: 4,
            lineColors: ['#0b62a4', '#7A92A3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],
            pointStrokeWidths: [1],
            pointStrokeColors: ['#ffffff'],
            pointFillColors: [],
            smooth: true,
            xLabels: 'auto',
            xLabelFormat: null,
            xLabelMargin: 24,
            hideHover: false
        };

        Line.prototype.calc = function () {
            this.calcPoints();
            return this.generatePaths();
        };

        Line.prototype.calcPoints = function () {
            var row, y, _i, _len, _ref, _results;
            _ref = this.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                row = _ref[_i];
                row._x = this.transX(row.x);
                row._y = (function () {
                    var _j, _len1, _ref1, _results1;
                    _ref1 = row.y;
                    _results1 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        y = _ref1[_j];
                        if (y != null) {
                            _results1.push(this.transY(y));
                        } else {
                            _results1.push(y);
                        }
                    }
                    return _results1;
                }).call(this);
                _results.push(row._ymax = Math.min.apply(Math, [this.bottom].concat((function () {
                    var _j, _len1, _ref1, _results1;
                    _ref1 = row._y;
                    _results1 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        y = _ref1[_j];
                        if (y != null) {
                            _results1.push(y);
                        }
                    }
                    return _results1;
                })())));
            }
            return _results;
        };

        Line.prototype.hitTest = function (x) {
            var index, r, _i, _len, _ref;
            if (this.data.length === 0) {
                return null;
            }
            _ref = this.data.slice(1);
            for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
                r = _ref[index];
                if (x < (r._x + this.data[index]._x) / 2) {
                    break;
                }
            }
            return index;
        };

        Line.prototype.onGridClick = function (x, y) {
            var index;
            index = this.hitTest(x);
            return this.fire('click', index, this.data[index].src, x, y);
        };

        Line.prototype.onHoverMove = function (x, y) {
            var index;
            index = this.hitTest(x);
            return this.displayHoverForRow(index);
        };

        Line.prototype.onHoverOut = function () {
            if (this.options.hideHover !== false) {
                return this.displayHoverForRow(null);
            }
        };

        Line.prototype.displayHoverForRow = function (index) {
            var _ref;
            if (index != null) {
                (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
                return this.hilight(index);
            } else {
                this.hover.hide();
                return this.hilight();
            }
        };

        Line.prototype.hoverContentForRow = function (index) {
            var content, j, row, y, _i, _len, _ref;
            row = this.data[index];
            content = "<div class='morris-hover-row-label'>" + row.label + "</div>";
            _ref = row.y;
            for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
                y = _ref[j];
                content += "<div class='morris-hover-point' style='color: " + (this.colorFor(row, j, 'label')) + "'>\n  " + this.options.labels[j] + ":\n  " + (this.yLabelFormat(y)) + "\n</div>";
            }
            if (typeof this.options.hoverCallback === 'function') {
                content = this.options.hoverCallback(index, this.options, content, row.src);
            }
            return [content, row._x, row._ymax];
        };

        Line.prototype.generatePaths = function () {
            var coords, i, r, smooth;
            return this.paths = (function () {
                var _i, _ref, _ref1, _results;
                _results = [];
                for (i = _i = 0, _ref = this.options.ykeys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                    smooth = typeof this.options.smooth === "boolean" ? this.options.smooth : (_ref1 = this.options.ykeys[i], __indexOf.call(this.options.smooth, _ref1) >= 0);
                    coords = (function () {
                        var _j, _len, _ref2, _results1;
                        _ref2 = this.data;
                        _results1 = [];
                        for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
                            r = _ref2[_j];
                            if (r._y[i] !== void 0) {
                                _results1.push({
                                    x: r._x,
                                    y: r._y[i]
                                });
                            }
                        }
                        return _results1;
                    }).call(this);
                    if (coords.length > 1) {
                        _results.push(Morris.Line.createPath(coords, smooth, this.bottom));
                    } else {
                        _results.push(null);
                    }
                }
                return _results;
            }).call(this);
        };

        Line.prototype.draw = function () {
            var _ref;
            if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
                this.drawXAxis();
            }
            this.drawSeries();
            if (this.options.hideHover === false) {
                return this.displayHoverForRow(this.data.length - 1);
            }
        };

        Line.prototype.drawXAxis = function () {
            var drawLabel, l, labels, prevAngleMargin, prevLabelMargin, row, ypos, _i, _len, _results,
                _this = this;
            ypos = this.bottom + this.options.padding / 2;
            prevLabelMargin = null;
            prevAngleMargin = null;
            drawLabel = function (labelText, xpos) {
                var label, labelBox, margin, offset, textBox;
                label = _this.drawXAxisLabel(_this.transX(xpos), ypos, labelText);
                textBox = label.getBBox();
                label.transform("r" + (-_this.options.xLabelAngle));
                labelBox = label.getBBox();
                label.transform("t0," + (labelBox.height / 2) + "...");
                if (_this.options.xLabelAngle !== 0) {
                    offset = -0.5 * textBox.width * Math.cos(_this.options.xLabelAngle * Math.PI / 180.0);
                    label.transform("t" + offset + ",0...");
                }
                labelBox = label.getBBox();
                if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < _this.el.width()) {
                    if (_this.options.xLabelAngle !== 0) {
                        margin = 1.25 * _this.options.gridTextSize / Math.sin(_this.options.xLabelAngle * Math.PI / 180.0);
                        prevAngleMargin = labelBox.x - margin;
                    }
                    return prevLabelMargin = labelBox.x - _this.options.xLabelMargin;
                } else {
                    return label.remove();
                }
            };
            if (this.options.parseTime) {
                if (this.data.length === 1 && this.options.xLabels === 'auto') {
                    labels = [[this.data[0].label, this.data[0].x]];
                } else {
                    labels = Morris.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat);
                }
            } else {
                labels = (function () {
                    var _i, _len, _ref, _results;
                    _ref = this.data;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        row = _ref[_i];
                        _results.push([row.label, row.x]);
                    }
                    return _results;
                }).call(this);
            }
            labels.reverse();
            _results = [];
            for (_i = 0, _len = labels.length; _i < _len; _i++) {
                l = labels[_i];
                _results.push(drawLabel(l[0], l[1]));
            }
            return _results;
        };

        Line.prototype.drawSeries = function () {
            var i, _i, _j, _ref, _ref1, _results;
            this.seriesPoints = [];
            for (i = _i = _ref = this.options.ykeys.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
                this._drawLineFor(i);
            }
            _results = [];
            for (i = _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; i = _ref1 <= 0 ? ++_j : --_j) {
                _results.push(this._drawPointFor(i));
            }
            return _results;
        };

        Line.prototype._drawPointFor = function (index) {
            var circle, row, _i, _len, _ref, _results;
            this.seriesPoints[index] = [];
            _ref = this.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                row = _ref[_i];
                circle = null;
                if (row._y[index] != null) {
                    circle = this.drawLinePoint(row._x, row._y[index], this.colorFor(row, index, 'point'), index);
                }
                _results.push(this.seriesPoints[index].push(circle));
            }
            return _results;
        };

        Line.prototype._drawLineFor = function (index) {
            var path;
            path = this.paths[index];
            if (path !== null) {
                return this.drawLinePath(path, this.colorFor(null, index, 'line'), index);
            }
        };

        Line.createPath = function (coords, smooth, bottom) {
            var coord, g, grads, i, ix, lg, path, prevCoord, x1, x2, y1, y2, _i, _len;
            path = "";
            if (smooth) {
                grads = Morris.Line.gradients(coords);
            }
            prevCoord = {
                y: null
            };
            for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {
                coord = coords[i];
                if (coord.y != null) {
                    if (prevCoord.y != null) {
                        if (smooth) {
                            g = grads[i];
                            lg = grads[i - 1];
                            ix = (coord.x - prevCoord.x) / 4;
                            x1 = prevCoord.x + ix;
                            y1 = Math.min(bottom, prevCoord.y + ix * lg);
                            x2 = coord.x - ix;
                            y2 = Math.min(bottom, coord.y - ix * g);
                            path += "C" + x1 + "," + y1 + "," + x2 + "," + y2 + "," + coord.x + "," + coord.y;
                        } else {
                            path += "L" + coord.x + "," + coord.y;
                        }
                    } else {
                        if (!smooth || (grads[i] != null)) {
                            path += "M" + coord.x + "," + coord.y;
                        }
                    }
                }
                prevCoord = coord;
            }
            return path;
        };

        Line.gradients = function (coords) {
            var coord, grad, i, nextCoord, prevCoord, _i, _len, _results;
            grad = function (a, b) {
                return (a.y - b.y) / (a.x - b.x);
            };
            _results = [];
            for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {
                coord = coords[i];
                if (coord.y != null) {
                    nextCoord = coords[i + 1] || {
                        y: null
                    };
                    prevCoord = coords[i - 1] || {
                        y: null
                    };
                    if ((prevCoord.y != null) && (nextCoord.y != null)) {
                        _results.push(grad(prevCoord, nextCoord));
                    } else if (prevCoord.y != null) {
                        _results.push(grad(prevCoord, coord));
                    } else if (nextCoord.y != null) {
                        _results.push(grad(coord, nextCoord));
                    } else {
                        _results.push(null);
                    }
                } else {
                    _results.push(null);
                }
            }
            return _results;
        };

        Line.prototype.hilight = function (index) {
            var i, _i, _j, _ref, _ref1;
            if (this.prevHilight !== null && this.prevHilight !== index) {
                for (i = _i = 0, _ref = this.seriesPoints.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                    if (this.seriesPoints[i][this.prevHilight]) {
                        this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));
                    }
                }
            }
            if (index !== null && this.prevHilight !== index) {
                for (i = _j = 0, _ref1 = this.seriesPoints.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                    if (this.seriesPoints[i][index]) {
                        this.seriesPoints[i][index].animate(this.pointGrowSeries(i));
                    }
                }
            }
            return this.prevHilight = index;
        };

        Line.prototype.colorFor = function (row, sidx, type) {
            if (typeof this.options.lineColors === 'function') {
                return this.options.lineColors.call(this, row, sidx, type);
            } else if (type === 'point') {
                return this.options.pointFillColors[sidx % this.options.pointFillColors.length] || this.options.lineColors[sidx % this.options.lineColors.length];
            } else {
                return this.options.lineColors[sidx % this.options.lineColors.length];
            }
        };

        Line.prototype.drawXAxisLabel = function (xPos, yPos, text) {
            return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);
        };

        Line.prototype.drawLinePath = function (path, lineColor, lineIndex) {
            return this.raphael.path(path).attr('stroke', lineColor).attr('stroke-width', this.lineWidthForSeries(lineIndex));
        };

        Line.prototype.drawLinePoint = function (xPos, yPos, pointColor, lineIndex) {
            return this.raphael.circle(xPos, yPos, this.pointSizeForSeries(lineIndex)).attr('fill', pointColor).attr('stroke-width', this.pointStrokeWidthForSeries(lineIndex)).attr('stroke', this.pointStrokeColorForSeries(lineIndex));
        };

        Line.prototype.pointStrokeWidthForSeries = function (index) {
            return this.options.pointStrokeWidths[index % this.options.pointStrokeWidths.length];
        };

        Line.prototype.pointStrokeColorForSeries = function (index) {
            return this.options.pointStrokeColors[index % this.options.pointStrokeColors.length];
        };

        Line.prototype.lineWidthForSeries = function (index) {
            if (this.options.lineWidth instanceof Array) {
                return this.options.lineWidth[index % this.options.lineWidth.length];
            } else {
                return this.options.lineWidth;
            }
        };

        Line.prototype.pointSizeForSeries = function (index) {
            if (this.options.pointSize instanceof Array) {
                return this.options.pointSize[index % this.options.pointSize.length];
            } else {
                return this.options.pointSize;
            }
        };

        Line.prototype.pointGrowSeries = function (index) {
            return Raphael.animation({
                r: this.pointSizeForSeries(index) + 3
            }, 25, 'linear');
        };

        Line.prototype.pointShrinkSeries = function (index) {
            return Raphael.animation({
                r: this.pointSizeForSeries(index)
            }, 25, 'linear');
        };

        return Line;

    })(Morris.Grid);

    Morris.labelSeries = function (dmin, dmax, pxwidth, specName, xLabelFormat) {
        var d, d0, ddensity, name, ret, s, spec, t, _i, _len, _ref;
        ddensity = 200 * (dmax - dmin) / pxwidth;
        d0 = new Date(dmin);
        spec = Morris.LABEL_SPECS[specName];
        if (spec === void 0) {
            _ref = Morris.AUTO_LABEL_ORDER;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                name = _ref[_i];
                s = Morris.LABEL_SPECS[name];
                if (ddensity >= s.span) {
                    spec = s;
                    break;
                }
            }
        }
        if (spec === void 0) {
            spec = Morris.LABEL_SPECS["second"];
        }
        if (xLabelFormat) {
            spec = $.extend({}, spec, {
                fmt: xLabelFormat
            });
        }
        d = spec.start(d0);
        ret = [];
        while ((t = d.getTime()) <= dmax) {
            if (t >= dmin) {
                ret.push([spec.fmt(d), t]);
            }
            spec.incr(d);
        }
        return ret;
    };

    minutesSpecHelper = function (interval) {
        return {
            span: interval * 60 * 1000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());
            },
            fmt: function (d) {
                return "" + (Morris.pad2(d.getHours())) + ":" + (Morris.pad2(d.getMinutes()));
            },
            incr: function (d) {
                return d.setUTCMinutes(d.getUTCMinutes() + interval);
            }
        };
    };

    secondsSpecHelper = function (interval) {
        return {
            span: interval * 1000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
            },
            fmt: function (d) {
                return "" + (Morris.pad2(d.getHours())) + ":" + (Morris.pad2(d.getMinutes())) + ":" + (Morris.pad2(d.getSeconds()));
            },
            incr: function (d) {
                return d.setUTCSeconds(d.getUTCSeconds() + interval);
            }
        };
    };

    Morris.LABEL_SPECS = {
        "decade": {
            span: 172800000000,
            start: function (d) {
                return new Date(d.getFullYear() - d.getFullYear() % 10, 0, 1);
            },
            fmt: function (d) {
                return "" + (d.getFullYear());
            },
            incr: function (d) {
                return d.setFullYear(d.getFullYear() + 10);
            }
        },
        "year": {
            span: 17280000000,
            start: function (d) {
                return new Date(d.getFullYear(), 0, 1);
            },
            fmt: function (d) {
                return "" + (d.getFullYear());
            },
            incr: function (d) {
                return d.setFullYear(d.getFullYear() + 1);
            }
        },
        "month": {
            span: 2419200000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), 1);
            },
            fmt: function (d) {
                return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1));
            },
            incr: function (d) {
                return d.setMonth(d.getMonth() + 1);
            }
        },
        "week": {
            span: 604800000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), d.getDate());
            },
            fmt: function (d) {
                return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1)) + "-" + (Morris.pad2(d.getDate()));
            },
            incr: function (d) {
                return d.setDate(d.getDate() + 7);
            }
        },
        "day": {
            span: 86400000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), d.getDate());
            },
            fmt: function (d) {
                return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1)) + "-" + (Morris.pad2(d.getDate()));
            },
            incr: function (d) {
                return d.setDate(d.getDate() + 1);
            }
        },
        "hour": minutesSpecHelper(60),
        "30min": minutesSpecHelper(30),
        "15min": minutesSpecHelper(15),
        "10min": minutesSpecHelper(10),
        "5min": minutesSpecHelper(5),
        "minute": minutesSpecHelper(1),
        "30sec": secondsSpecHelper(30),
        "15sec": secondsSpecHelper(15),
        "10sec": secondsSpecHelper(10),
        "5sec": secondsSpecHelper(5),
        "second": secondsSpecHelper(1)
    };

    Morris.AUTO_LABEL_ORDER = ["decade", "year", "month", "week", "day", "hour", "30min", "15min", "10min", "5min", "minute", "30sec", "15sec", "10sec", "5sec", "second"];

    Morris.Area = (function (_super) {
        var areaDefaults;

        __extends(Area, _super);

        areaDefaults = {
            fillOpacity: 'auto',
            behaveLikeLine: false
        };

        function Area(options) {
            var areaOptions;
            if (!(this instanceof Morris.Area)) {
                return new Morris.Area(options);
            }
            areaOptions = $.extend({}, areaDefaults, options);
            this.cumulative = !areaOptions.behaveLikeLine;
            if (areaOptions.fillOpacity === 'auto') {
                areaOptions.fillOpacity = areaOptions.behaveLikeLine ? .8 : 1;
            }
            Area.__super__.constructor.call(this, areaOptions);
        }

        Area.prototype.calcPoints = function () {
            var row, total, y, _i, _len, _ref, _results;
            _ref = this.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                row = _ref[_i];
                row._x = this.transX(row.x);
                total = 0;
                row._y = (function () {
                    var _j, _len1, _ref1, _results1;
                    _ref1 = row.y;
                    _results1 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        y = _ref1[_j];
                        if (this.options.behaveLikeLine) {
                            _results1.push(this.transY(y));
                        } else {
                            total += y || 0;
                            _results1.push(this.transY(total));
                        }
                    }
                    return _results1;
                }).call(this);
                _results.push(row._ymax = Math.max.apply(Math, row._y));
            }
            return _results;
        };

        Area.prototype.drawSeries = function () {
            var i, range, _i, _j, _k, _len, _ref, _ref1, _results, _results1, _results2;
            this.seriesPoints = [];
            if (this.options.behaveLikeLine) {
                range = (function () {
                    _results = [];
                    for (var _i = 0, _ref = this.options.ykeys.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--) {
                        _results.push(_i);
                    }
                    return _results;
                }).apply(this);
            } else {
                range = (function () {
                    _results1 = [];
                    for (var _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--) {
                        _results1.push(_j);
                    }
                    return _results1;
                }).apply(this);
            }
            _results2 = [];
            for (_k = 0, _len = range.length; _k < _len; _k++) {
                i = range[_k];
                this._drawFillFor(i);
                this._drawLineFor(i);
                _results2.push(this._drawPointFor(i));
            }
            return _results2;
        };

        Area.prototype._drawFillFor = function (index) {
            var path;
            path = this.paths[index];
            if (path !== null) {
                path = path + ("L" + (this.transX(this.xmax)) + "," + this.bottom + "L" + (this.transX(this.xmin)) + "," + this.bottom + "Z");
                return this.drawFilledPath(path, this.fillForSeries(index));
            }
        };

        Area.prototype.fillForSeries = function (i) {
            var color;
            color = Raphael.rgb2hsl(this.colorFor(this.data[i], i, 'line'));
            return Raphael.hsl(color.h, this.options.behaveLikeLine ? color.s * 0.9 : color.s * 0.75, Math.min(0.98, this.options.behaveLikeLine ? color.l * 1.2 : color.l * 1.25));
        };

        Area.prototype.drawFilledPath = function (path, fill) {
            return this.raphael.path(path).attr('fill', fill).attr('fill-opacity', this.options.fillOpacity).attr('stroke', 'none');
        };

        return Area;

    })(Morris.Line);

    Morris.Bar = (function (_super) {
        __extends(Bar, _super);

        function Bar(options) {
            this.onHoverOut = __bind(this.onHoverOut, this);
            this.onHoverMove = __bind(this.onHoverMove, this);
            this.onGridClick = __bind(this.onGridClick, this);
            if (!(this instanceof Morris.Bar)) {
                return new Morris.Bar(options);
            }
            Bar.__super__.constructor.call(this, $.extend({}, options, {
                parseTime: false
            }));
        }

        Bar.prototype.init = function () {
            this.cumulative = this.options.stacked;
            if (this.options.hideHover !== 'always') {
                this.hover = new Morris.Hover({
                    parent: this.el
                });
                this.on('hovermove', this.onHoverMove);
                this.on('hoverout', this.onHoverOut);
                return this.on('gridclick', this.onGridClick);
            }
        };

        Bar.prototype.defaults = {
            barSizeRatio: 0.75,
            barGap: 3,
            barColors: ['#0b62a4', '#7a92a3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],
            barOpacity: 1.0,
            barRadius: [0, 0, 0, 0],
            xLabelMargin: 50
        };

        Bar.prototype.calc = function () {
            var _ref;
            this.calcBars();
            if (this.options.hideHover === false) {
                return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(this.data.length - 1));
            }
        };

        Bar.prototype.calcBars = function () {
            var idx, row, y, _i, _len, _ref, _results;
            _ref = this.data;
            _results = [];
            for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
                row = _ref[idx];
                row._x = this.left + this.width * (idx + 0.5) / this.data.length;
                _results.push(row._y = (function () {
                    var _j, _len1, _ref1, _results1;
                    _ref1 = row.y;
                    _results1 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        y = _ref1[_j];
                        if (y != null) {
                            _results1.push(this.transY(y));
                        } else {
                            _results1.push(null);
                        }
                    }
                    return _results1;
                }).call(this));
            }
            return _results;
        };

        Bar.prototype.draw = function () {
            var _ref;
            if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
                this.drawXAxis();
            }
            return this.drawSeries();
        };

        Bar.prototype.drawXAxis = function () {
            var i, label, labelBox, margin, offset, prevAngleMargin, prevLabelMargin, row, textBox, ypos, _i, _ref,
                _results;
            ypos = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);
            prevLabelMargin = null;
            prevAngleMargin = null;
            _results = [];
            for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                row = this.data[this.data.length - 1 - i];
                label = this.drawXAxisLabel(row._x, ypos, row.label);
                textBox = label.getBBox();
                label.transform("r" + (-this.options.xLabelAngle));
                labelBox = label.getBBox();
                label.transform("t0," + (labelBox.height / 2) + "...");
                if (this.options.xLabelAngle !== 0) {
                    offset = -0.5 * textBox.width * Math.cos(this.options.xLabelAngle * Math.PI / 180.0);
                    label.transform("t" + offset + ",0...");
                }
                if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < this.el.width()) {
                    if (this.options.xLabelAngle !== 0) {
                        margin = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180.0);
                        prevAngleMargin = labelBox.x - margin;
                    }
                    _results.push(prevLabelMargin = labelBox.x - this.options.xLabelMargin);
                } else {
                    _results.push(label.remove());
                }
            }
            return _results;
        };

        Bar.prototype.drawSeries = function () {
            var barWidth, bottom, groupWidth, idx, lastTop, left, leftPadding, numBars, row, sidx, size, spaceLeft, top,
                ypos, zeroPos;
            groupWidth = this.width / this.options.data.length;
            numBars = this.options.stacked ? 1 : this.options.ykeys.length;
            barWidth = (groupWidth * this.options.barSizeRatio - this.options.barGap * (numBars - 1)) / numBars;
            if (this.options.barSize) {
                barWidth = Math.min(barWidth, this.options.barSize);
            }
            spaceLeft = groupWidth - barWidth * numBars - this.options.barGap * (numBars - 1);
            leftPadding = spaceLeft / 2;
            zeroPos = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null;
            return this.bars = (function () {
                var _i, _len, _ref, _results;
                _ref = this.data;
                _results = [];
                for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
                    row = _ref[idx];
                    lastTop = 0;
                    _results.push((function () {
                        var _j, _len1, _ref1, _results1;
                        _ref1 = row._y;
                        _results1 = [];
                        for (sidx = _j = 0, _len1 = _ref1.length; _j < _len1; sidx = ++_j) {
                            ypos = _ref1[sidx];
                            if (ypos !== null) {
                                if (zeroPos) {
                                    top = Math.min(ypos, zeroPos);
                                    bottom = Math.max(ypos, zeroPos);
                                } else {
                                    top = ypos;
                                    bottom = this.bottom;
                                }
                                left = this.left + idx * groupWidth + leftPadding;
                                if (!this.options.stacked) {
                                    left += sidx * (barWidth + this.options.barGap);
                                }
                                size = bottom - top;
                                if (this.options.verticalGridCondition && this.options.verticalGridCondition(row.x)) {
                                    this.drawBar(this.left + idx * groupWidth, this.top, groupWidth, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);
                                }
                                if (this.options.stacked) {
                                    top -= lastTop;
                                }
                                this.drawBar(left, top, barWidth, size, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius);
                                _results1.push(lastTop += size);
                            } else {
                                _results1.push(null);
                            }
                        }
                        return _results1;
                    }).call(this));
                }
                return _results;
            }).call(this);
        };

        Bar.prototype.colorFor = function (row, sidx, type) {
            var r, s;
            if (typeof this.options.barColors === 'function') {
                r = {
                    x: row.x,
                    y: row.y[sidx],
                    label: row.label
                };
                s = {
                    index: sidx,
                    key: this.options.ykeys[sidx],
                    label: this.options.labels[sidx]
                };
                return this.options.barColors.call(this, r, s, type);
            } else {
                return this.options.barColors[sidx % this.options.barColors.length];
            }
        };

        Bar.prototype.hitTest = function (x) {
            if (this.data.length === 0) {
                return null;
            }
            x = Math.max(Math.min(x, this.right), this.left);
            return Math.min(this.data.length - 1, Math.floor((x - this.left) / (this.width / this.data.length)));
        };

        Bar.prototype.onGridClick = function (x, y) {
            var index;
            index = this.hitTest(x);
            return this.fire('click', index, this.data[index].src, x, y);
        };

        Bar.prototype.onHoverMove = function (x, y) {
            var index, _ref;
            index = this.hitTest(x);
            return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
        };

        Bar.prototype.onHoverOut = function () {
            if (this.options.hideHover !== false) {
                return this.hover.hide();
            }
        };

        Bar.prototype.hoverContentForRow = function (index) {
            var content, j, row, x, y, _i, _len, _ref;
            row = this.data[index];
            content = "<div class='morris-hover-row-label'>" + row.label + "</div>";
            _ref = row.y;
            for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
                y = _ref[j];
                content += "<div class='morris-hover-point' style='color: " + (this.colorFor(row, j, 'label')) + "'>\n  " + this.options.labels[j] + ":\n  " + (this.yLabelFormat(y)) + "\n</div>";
            }
            if (typeof this.options.hoverCallback === 'function') {
                content = this.options.hoverCallback(index, this.options, content, row.src);
            }
            x = this.left + (index + 0.5) * this.width / this.data.length;
            return [content, x];
        };

        Bar.prototype.drawXAxisLabel = function (xPos, yPos, text) {
            var label;
            return label = this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);
        };

        Bar.prototype.drawBar = function (xPos, yPos, width, height, barColor, opacity, radiusArray) {
            var maxRadius, path;
            maxRadius = Math.max.apply(Math, radiusArray);
            if (maxRadius === 0 || maxRadius > height) {
                path = this.raphael.rect(xPos, yPos, width, height);
            } else {
                path = this.raphael.path(this.roundedRect(xPos, yPos, width, height, radiusArray));
            }
            return path.attr('fill', barColor).attr('fill-opacity', opacity).attr('stroke', 'none');
        };

        Bar.prototype.roundedRect = function (x, y, w, h, r) {
            if (r == null) {
                r = [0, 0, 0, 0];
            }
            return ["M", x, r[0] + y, "Q", x, y, x + r[0], y, "L", x + w - r[1], y, "Q", x + w, y, x + w, y + r[1], "L", x + w, y + h - r[2], "Q", x + w, y + h, x + w - r[2], y + h, "L", x + r[3], y + h, "Q", x, y + h, x, y + h - r[3], "Z"];
        };

        return Bar;

    })(Morris.Grid);

    Morris.Donut = (function (_super) {
        __extends(Donut, _super);

        Donut.prototype.defaults = {
            colors: ['#0B62A4', '#3980B5', '#679DC6', '#95BBD7', '#B0CCE1', '#095791', '#095085', '#083E67', '#052C48', '#042135'],
            backgroundColor: '#FFFFFF',
            labelColor: '#000000',
            formatter: Morris.commas,
            resize: false
        };

        function Donut(options) {
            this.resizeHandler = __bind(this.resizeHandler, this);
            this.select = __bind(this.select, this);
            this.click = __bind(this.click, this);
            var _this = this;
            if (!(this instanceof Morris.Donut)) {
                return new Morris.Donut(options);
            }
            this.options = $.extend({}, this.defaults, options);
            if (typeof options.element === 'string') {
                this.el = $(document.getElementById(options.element));
            } else {
                this.el = $(options.element);
            }
            if (this.el === null || this.el.length === 0) {
                throw new Error("Graph placeholder not found.");
            }
            if (options.data === void 0 || options.data.length === 0) {
                return;
            }
            this.raphael = new Raphael(this.el[0]);
            if (this.options.resize) {
                $(window).bind('resize', function (evt) {
                    if (_this.timeoutId != null) {
                        window.clearTimeout(_this.timeoutId);
                    }
                    return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);
                });
            }
            this.setData(options.data);
        }

        Donut.prototype.redraw = function () {
            var C, cx, cy, i, idx, last, max_value, min, next, seg, total, value, w, _i, _j, _k, _len, _len1, _len2,
                _ref, _ref1, _ref2, _results;
            this.raphael.clear();
            cx = this.el.width() / 2;
            cy = this.el.height() / 2;
            w = (Math.min(cx, cy) - 10) / 3;
            total = 0;
            _ref = this.values;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                value = _ref[_i];
                total += value;
            }
            min = 5 / (2 * w);
            C = 1.9999 * Math.PI - min * this.data.length;
            last = 0;
            idx = 0;
            this.segments = [];
            _ref1 = this.values;
            for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                value = _ref1[i];
                next = last + min + C * (value / total);
                seg = new Morris.DonutSegment(cx, cy, w * 2, w, last, next, this.data[i].color || this.options.colors[idx % this.options.colors.length], this.options.backgroundColor, idx, this.raphael);
                seg.render();
                this.segments.push(seg);
                seg.on('hover', this.select);
                seg.on('click', this.click);
                last = next;
                idx += 1;
            }
            this.text1 = this.drawEmptyDonutLabel(cx, cy - 10, this.options.labelColor, 15, 800);
            this.text2 = this.drawEmptyDonutLabel(cx, cy + 10, this.options.labelColor, 14);
            max_value = Math.max.apply(Math, this.values);
            idx = 0;
            _ref2 = this.values;
            _results = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                value = _ref2[_k];
                if (value === max_value) {
                    this.select(idx);
                    break;
                }
                _results.push(idx += 1);
            }
            return _results;
        };

        Donut.prototype.setData = function (data) {
            var row;
            this.data = data;
            this.values = (function () {
                var _i, _len, _ref, _results;
                _ref = this.data;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    row = _ref[_i];
                    _results.push(parseFloat(row.value));
                }
                return _results;
            }).call(this);
            return this.redraw();
        };

        Donut.prototype.click = function (idx) {
            return this.fire('click', idx, this.data[idx]);
        };

        Donut.prototype.select = function (idx) {
            var row, s, segment, _i, _len, _ref;
            _ref = this.segments;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                s.deselect();
            }
            segment = this.segments[idx];
            segment.select();
            row = this.data[idx];
            return this.setLabels(row.label, this.options.formatter(row.value, row));
        };

        Donut.prototype.setLabels = function (label1, label2) {
            var inner, maxHeightBottom, maxHeightTop, maxWidth, text1bbox, text1scale, text2bbox, text2scale;
            inner = (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) * 2 / 3;
            maxWidth = 1.8 * inner;
            maxHeightTop = inner / 2;
            maxHeightBottom = inner / 3;
            this.text1.attr({
                text: label1,
                transform: ''
            });
            text1bbox = this.text1.getBBox();
            text1scale = Math.min(maxWidth / text1bbox.width, maxHeightTop / text1bbox.height);
            this.text1.attr({
                transform: "S" + text1scale + "," + text1scale + "," + (text1bbox.x + text1bbox.width / 2) + "," + (text1bbox.y + text1bbox.height)
            });
            this.text2.attr({
                text: label2,
                transform: ''
            });
            text2bbox = this.text2.getBBox();
            text2scale = Math.min(maxWidth / text2bbox.width, maxHeightBottom / text2bbox.height);
            return this.text2.attr({
                transform: "S" + text2scale + "," + text2scale + "," + (text2bbox.x + text2bbox.width / 2) + "," + text2bbox.y
            });
        };

        Donut.prototype.drawEmptyDonutLabel = function (xPos, yPos, color, fontSize, fontWeight) {
            var text;
            text = this.raphael.text(xPos, yPos, '').attr('font-size', fontSize).attr('fill', color);
            if (fontWeight != null) {
                text.attr('font-weight', fontWeight);
            }
            return text;
        };

        Donut.prototype.resizeHandler = function () {
            this.timeoutId = null;
            this.raphael.setSize(this.el.width(), this.el.height());
            return this.redraw();
        };

        return Donut;

    })(Morris.EventEmitter);

    Morris.DonutSegment = (function (_super) {
        __extends(DonutSegment, _super);

        function DonutSegment(cx, cy, inner, outer, p0, p1, color, backgroundColor, index, raphael) {
            this.cx = cx;
            this.cy = cy;
            this.inner = inner;
            this.outer = outer;
            this.color = color;
            this.backgroundColor = backgroundColor;
            this.index = index;
            this.raphael = raphael;
            this.deselect = __bind(this.deselect, this);
            this.select = __bind(this.select, this);
            this.sin_p0 = Math.sin(p0);
            this.cos_p0 = Math.cos(p0);
            this.sin_p1 = Math.sin(p1);
            this.cos_p1 = Math.cos(p1);
            this.is_long = (p1 - p0) > Math.PI ? 1 : 0;
            this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5);
            this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer);
            this.hilight = this.calcArc(this.inner);
        }

        DonutSegment.prototype.calcArcPoints = function (r) {
            return [this.cx + r * this.sin_p0, this.cy + r * this.cos_p0, this.cx + r * this.sin_p1, this.cy + r * this.cos_p1];
        };

        DonutSegment.prototype.calcSegment = function (r1, r2) {
            var ix0, ix1, iy0, iy1, ox0, ox1, oy0, oy1, _ref, _ref1;
            _ref = this.calcArcPoints(r1), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];
            _ref1 = this.calcArcPoints(r2), ox0 = _ref1[0], oy0 = _ref1[1], ox1 = _ref1[2], oy1 = _ref1[3];
            return ("M" + ix0 + "," + iy0) + ("A" + r1 + "," + r1 + ",0," + this.is_long + ",0," + ix1 + "," + iy1) + ("L" + ox1 + "," + oy1) + ("A" + r2 + "," + r2 + ",0," + this.is_long + ",1," + ox0 + "," + oy0) + "Z";
        };

        DonutSegment.prototype.calcArc = function (r) {
            var ix0, ix1, iy0, iy1, _ref;
            _ref = this.calcArcPoints(r), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];
            return ("M" + ix0 + "," + iy0) + ("A" + r + "," + r + ",0," + this.is_long + ",0," + ix1 + "," + iy1);
        };

        DonutSegment.prototype.render = function () {
            var _this = this;
            this.arc = this.drawDonutArc(this.hilight, this.color);
            return this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function () {
                return _this.fire('hover', _this.index);
            }, function () {
                return _this.fire('click', _this.index);
            });
        };

        DonutSegment.prototype.drawDonutArc = function (path, color) {
            return this.raphael.path(path).attr({
                stroke: color,
                'stroke-width': 2,
                opacity: 0
            });
        };

        DonutSegment.prototype.drawDonutSegment = function (path, fillColor, strokeColor, hoverFunction, clickFunction) {
            return this.raphael.path(path).attr({
                fill: fillColor,
                stroke: strokeColor,
                'stroke-width': 3
            }).hover(hoverFunction).click(clickFunction);
        };

        DonutSegment.prototype.select = function () {
            if (!this.selected) {
                this.seg.animate({
                    path: this.selectedPath
                }, 150, '<>');
                this.arc.animate({
                    opacity: 1
                }, 150, '<>');
                return this.selected = true;
            }
        };

        DonutSegment.prototype.deselect = function () {
            if (this.selected) {
                this.seg.animate({
                    path: this.path
                }, 150, '<>');
                this.arc.animate({
                    opacity: 0
                }, 150, '<>');
                return this.selected = false;
            }
        };

        return DonutSegment;

    })(Morris.EventEmitter);

}).call(this);

/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.7.3
 *
 * Copyright 2018 Chart.js Contributors
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
(function (f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f()
    } else if (typeof define === "function" && define.amd) {
        define([], f)
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window
        } else if (typeof global !== "undefined") {
            g = global
        } else if (typeof self !== "undefined") {
            g = self
        } else {
            g = this
        }
        g.Chart = f()
    }
})(function () {
    var define, module, exports;
    return (function () {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw a.code = "MODULE_NOT_FOUND", a
                    }
                    var p = n[i] = {exports: {}};
                    e[i][0].call(p.exports, function (r) {
                        var n = e[i][1][r];
                        return o(n || r)
                    }, p, p.exports, r, e, n, t)
                }
                return n[i].exports
            }

            for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
            return o
        }

        return r
    })()({
        1: [function (require, module, exports) {
            /* MIT license */
            var colorNames = require(5);

            module.exports = {
                getRgba: getRgba,
                getHsla: getHsla,
                getRgb: getRgb,
                getHsl: getHsl,
                getHwb: getHwb,
                getAlpha: getAlpha,

                hexString: hexString,
                rgbString: rgbString,
                rgbaString: rgbaString,
                percentString: percentString,
                percentaString: percentaString,
                hslString: hslString,
                hslaString: hslaString,
                hwbString: hwbString,
                keyword: keyword
            }

            function getRgba(string) {
                if (!string) {
                    return;
                }
                var abbr = /^#([a-fA-F0-9]{3})$/i,
                    hex = /^#([a-fA-F0-9]{6})$/i,
                    rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
                    per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
                    keyword = /(\w+)/;

                var rgb = [0, 0, 0],
                    a = 1,
                    match = string.match(abbr);
                if (match) {
                    match = match[1];
                    for (var i = 0; i < rgb.length; i++) {
                        rgb[i] = parseInt(match[i] + match[i], 16);
                    }
                }
                else if (match = string.match(hex)) {
                    match = match[1];
                    for (var i = 0; i < rgb.length; i++) {
                        rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
                    }
                }
                else if (match = string.match(rgba)) {
                    for (var i = 0; i < rgb.length; i++) {
                        rgb[i] = parseInt(match[i + 1]);
                    }
                    a = parseFloat(match[4]);
                }
                else if (match = string.match(per)) {
                    for (var i = 0; i < rgb.length; i++) {
                        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
                    }
                    a = parseFloat(match[4]);
                }
                else if (match = string.match(keyword)) {
                    if (match[1] == "transparent") {
                        return [0, 0, 0, 0];
                    }
                    rgb = colorNames[match[1]];
                    if (!rgb) {
                        return;
                    }
                }

                for (var i = 0; i < rgb.length; i++) {
                    rgb[i] = scale(rgb[i], 0, 255);
                }
                if (!a && a != 0) {
                    a = 1;
                }
                else {
                    a = scale(a, 0, 1);
                }
                rgb[3] = a;
                return rgb;
            }

            function getHsla(string) {
                if (!string) {
                    return;
                }
                var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
                var match = string.match(hsl);
                if (match) {
                    var alpha = parseFloat(match[4]);
                    var h = scale(parseInt(match[1]), 0, 360),
                        s = scale(parseFloat(match[2]), 0, 100),
                        l = scale(parseFloat(match[3]), 0, 100),
                        a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
                    return [h, s, l, a];
                }
            }

            function getHwb(string) {
                if (!string) {
                    return;
                }
                var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
                var match = string.match(hwb);
                if (match) {
                    var alpha = parseFloat(match[4]);
                    var h = scale(parseInt(match[1]), 0, 360),
                        w = scale(parseFloat(match[2]), 0, 100),
                        b = scale(parseFloat(match[3]), 0, 100),
                        a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
                    return [h, w, b, a];
                }
            }

            function getRgb(string) {
                var rgba = getRgba(string);
                return rgba && rgba.slice(0, 3);
            }

            function getHsl(string) {
                var hsla = getHsla(string);
                return hsla && hsla.slice(0, 3);
            }

            function getAlpha(string) {
                var vals = getRgba(string);
                if (vals) {
                    return vals[3];
                }
                else if (vals = getHsla(string)) {
                    return vals[3];
                }
                else if (vals = getHwb(string)) {
                    return vals[3];
                }
            }

// generators
            function hexString(rgb) {
                return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
                    + hexDouble(rgb[2]);
            }

            function rgbString(rgba, alpha) {
                if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
                    return rgbaString(rgba, alpha);
                }
                return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
            }

            function rgbaString(rgba, alpha) {
                if (alpha === undefined) {
                    alpha = (rgba[3] !== undefined ? rgba[3] : 1);
                }
                return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
                    + ", " + alpha + ")";
            }

            function percentString(rgba, alpha) {
                if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
                    return percentaString(rgba, alpha);
                }
                var r = Math.round(rgba[0] / 255 * 100),
                    g = Math.round(rgba[1] / 255 * 100),
                    b = Math.round(rgba[2] / 255 * 100);

                return "rgb(" + r + "%, " + g + "%, " + b + "%)";
            }

            function percentaString(rgba, alpha) {
                var r = Math.round(rgba[0] / 255 * 100),
                    g = Math.round(rgba[1] / 255 * 100),
                    b = Math.round(rgba[2] / 255 * 100);
                return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
            }

            function hslString(hsla, alpha) {
                if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
                    return hslaString(hsla, alpha);
                }
                return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
            }

            function hslaString(hsla, alpha) {
                if (alpha === undefined) {
                    alpha = (hsla[3] !== undefined ? hsla[3] : 1);
                }
                return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
                    + alpha + ")";
            }

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
            function hwbString(hwb, alpha) {
                if (alpha === undefined) {
                    alpha = (hwb[3] !== undefined ? hwb[3] : 1);
                }
                return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
                    + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
            }

            function keyword(rgb) {
                return reverseNames[rgb.slice(0, 3)];
            }

// helpers
            function scale(num, min, max) {
                return Math.min(Math.max(min, num), max);
            }

            function hexDouble(num) {
                var str = num.toString(16).toUpperCase();
                return (str.length < 2) ? "0" + str : str;
            }


//create a list of reverse color names
            var reverseNames = {};
            for (var name in colorNames) {
                reverseNames[colorNames[name]] = name;
            }

        }, {"5": 5}],
        2: [function (require, module, exports) {
            /* MIT license */
            var convert = require(4);
            var string = require(1);

            var Color = function (obj) {
                if (obj instanceof Color) {
                    return obj;
                }
                if (!(this instanceof Color)) {
                    return new Color(obj);
                }

                this.valid = false;
                this.values = {
                    rgb: [0, 0, 0],
                    hsl: [0, 0, 0],
                    hsv: [0, 0, 0],
                    hwb: [0, 0, 0],
                    cmyk: [0, 0, 0, 0],
                    alpha: 1
                };

                // parse Color() argument
                var vals;
                if (typeof obj === 'string') {
                    vals = string.getRgba(obj);
                    if (vals) {
                        this.setValues('rgb', vals);
                    } else if (vals = string.getHsla(obj)) {
                        this.setValues('hsl', vals);
                    } else if (vals = string.getHwb(obj)) {
                        this.setValues('hwb', vals);
                    }
                } else if (typeof obj === 'object') {
                    vals = obj;
                    if (vals.r !== undefined || vals.red !== undefined) {
                        this.setValues('rgb', vals);
                    } else if (vals.l !== undefined || vals.lightness !== undefined) {
                        this.setValues('hsl', vals);
                    } else if (vals.v !== undefined || vals.value !== undefined) {
                        this.setValues('hsv', vals);
                    } else if (vals.w !== undefined || vals.whiteness !== undefined) {
                        this.setValues('hwb', vals);
                    } else if (vals.c !== undefined || vals.cyan !== undefined) {
                        this.setValues('cmyk', vals);
                    }
                }
            };

            Color.prototype = {
                isValid: function () {
                    return this.valid;
                },
                rgb: function () {
                    return this.setSpace('rgb', arguments);
                },
                hsl: function () {
                    return this.setSpace('hsl', arguments);
                },
                hsv: function () {
                    return this.setSpace('hsv', arguments);
                },
                hwb: function () {
                    return this.setSpace('hwb', arguments);
                },
                cmyk: function () {
                    return this.setSpace('cmyk', arguments);
                },

                rgbArray: function () {
                    return this.values.rgb;
                },
                hslArray: function () {
                    return this.values.hsl;
                },
                hsvArray: function () {
                    return this.values.hsv;
                },
                hwbArray: function () {
                    var values = this.values;
                    if (values.alpha !== 1) {
                        return values.hwb.concat([values.alpha]);
                    }
                    return values.hwb;
                },
                cmykArray: function () {
                    return this.values.cmyk;
                },
                rgbaArray: function () {
                    var values = this.values;
                    return values.rgb.concat([values.alpha]);
                },
                hslaArray: function () {
                    var values = this.values;
                    return values.hsl.concat([values.alpha]);
                },
                alpha: function (val) {
                    if (val === undefined) {
                        return this.values.alpha;
                    }
                    this.setValues('alpha', val);
                    return this;
                },

                red: function (val) {
                    return this.setChannel('rgb', 0, val);
                },
                green: function (val) {
                    return this.setChannel('rgb', 1, val);
                },
                blue: function (val) {
                    return this.setChannel('rgb', 2, val);
                },
                hue: function (val) {
                    if (val) {
                        val %= 360;
                        val = val < 0 ? 360 + val : val;
                    }
                    return this.setChannel('hsl', 0, val);
                },
                saturation: function (val) {
                    return this.setChannel('hsl', 1, val);
                },
                lightness: function (val) {
                    return this.setChannel('hsl', 2, val);
                },
                saturationv: function (val) {
                    return this.setChannel('hsv', 1, val);
                },
                whiteness: function (val) {
                    return this.setChannel('hwb', 1, val);
                },
                blackness: function (val) {
                    return this.setChannel('hwb', 2, val);
                },
                value: function (val) {
                    return this.setChannel('hsv', 2, val);
                },
                cyan: function (val) {
                    return this.setChannel('cmyk', 0, val);
                },
                magenta: function (val) {
                    return this.setChannel('cmyk', 1, val);
                },
                yellow: function (val) {
                    return this.setChannel('cmyk', 2, val);
                },
                black: function (val) {
                    return this.setChannel('cmyk', 3, val);
                },

                hexString: function () {
                    return string.hexString(this.values.rgb);
                },
                rgbString: function () {
                    return string.rgbString(this.values.rgb, this.values.alpha);
                },
                rgbaString: function () {
                    return string.rgbaString(this.values.rgb, this.values.alpha);
                },
                percentString: function () {
                    return string.percentString(this.values.rgb, this.values.alpha);
                },
                hslString: function () {
                    return string.hslString(this.values.hsl, this.values.alpha);
                },
                hslaString: function () {
                    return string.hslaString(this.values.hsl, this.values.alpha);
                },
                hwbString: function () {
                    return string.hwbString(this.values.hwb, this.values.alpha);
                },
                keyword: function () {
                    return string.keyword(this.values.rgb, this.values.alpha);
                },

                rgbNumber: function () {
                    var rgb = this.values.rgb;
                    return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
                },

                luminosity: function () {
                    // http://www.w3.org/TR/WCAG20/#relativeluminancedef
                    var rgb = this.values.rgb;
                    var lum = [];
                    for (var i = 0; i < rgb.length; i++) {
                        var chan = rgb[i] / 255;
                        lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
                    }
                    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
                },

                contrast: function (color2) {
                    // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
                    var lum1 = this.luminosity();
                    var lum2 = color2.luminosity();
                    if (lum1 > lum2) {
                        return (lum1 + 0.05) / (lum2 + 0.05);
                    }
                    return (lum2 + 0.05) / (lum1 + 0.05);
                },

                level: function (color2) {
                    var contrastRatio = this.contrast(color2);
                    if (contrastRatio >= 7.1) {
                        return 'AAA';
                    }

                    return (contrastRatio >= 4.5) ? 'AA' : '';
                },

                dark: function () {
                    // YIQ equation from http://24ways.org/2010/calculating-color-contrast
                    var rgb = this.values.rgb;
                    var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
                    return yiq < 128;
                },

                light: function () {
                    return !this.dark();
                },

                negate: function () {
                    var rgb = [];
                    for (var i = 0; i < 3; i++) {
                        rgb[i] = 255 - this.values.rgb[i];
                    }
                    this.setValues('rgb', rgb);
                    return this;
                },

                lighten: function (ratio) {
                    var hsl = this.values.hsl;
                    hsl[2] += hsl[2] * ratio;
                    this.setValues('hsl', hsl);
                    return this;
                },

                darken: function (ratio) {
                    var hsl = this.values.hsl;
                    hsl[2] -= hsl[2] * ratio;
                    this.setValues('hsl', hsl);
                    return this;
                },

                saturate: function (ratio) {
                    var hsl = this.values.hsl;
                    hsl[1] += hsl[1] * ratio;
                    this.setValues('hsl', hsl);
                    return this;
                },

                desaturate: function (ratio) {
                    var hsl = this.values.hsl;
                    hsl[1] -= hsl[1] * ratio;
                    this.setValues('hsl', hsl);
                    return this;
                },

                whiten: function (ratio) {
                    var hwb = this.values.hwb;
                    hwb[1] += hwb[1] * ratio;
                    this.setValues('hwb', hwb);
                    return this;
                },

                blacken: function (ratio) {
                    var hwb = this.values.hwb;
                    hwb[2] += hwb[2] * ratio;
                    this.setValues('hwb', hwb);
                    return this;
                },

                greyscale: function () {
                    var rgb = this.values.rgb;
                    // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
                    var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
                    this.setValues('rgb', [val, val, val]);
                    return this;
                },

                clearer: function (ratio) {
                    var alpha = this.values.alpha;
                    this.setValues('alpha', alpha - (alpha * ratio));
                    return this;
                },

                opaquer: function (ratio) {
                    var alpha = this.values.alpha;
                    this.setValues('alpha', alpha + (alpha * ratio));
                    return this;
                },

                rotate: function (degrees) {
                    var hsl = this.values.hsl;
                    var hue = (hsl[0] + degrees) % 360;
                    hsl[0] = hue < 0 ? 360 + hue : hue;
                    this.setValues('hsl', hsl);
                    return this;
                },

                /**
                 * Ported from sass implementation in C
                 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
                 */
                mix: function (mixinColor, weight) {
                    var color1 = this;
                    var color2 = mixinColor;
                    var p = weight === undefined ? 0.5 : weight;

                    var w = 2 * p - 1;
                    var a = color1.alpha() - color2.alpha();

                    var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
                    var w2 = 1 - w1;

                    return this
                        .rgb(
                            w1 * color1.red() + w2 * color2.red(),
                            w1 * color1.green() + w2 * color2.green(),
                            w1 * color1.blue() + w2 * color2.blue()
                        )
                        .alpha(color1.alpha() * p + color2.alpha() * (1 - p));
                },

                toJSON: function () {
                    return this.rgb();
                },

                clone: function () {
                    // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
                    // making the final build way to big to embed in Chart.js. So let's do it manually,
                    // assuming that values to clone are 1 dimension arrays containing only numbers,
                    // except 'alpha' which is a number.
                    var result = new Color();
                    var source = this.values;
                    var target = result.values;
                    var value, type;

                    for (var prop in source) {
                        if (source.hasOwnProperty(prop)) {
                            value = source[prop];
                            type = ({}).toString.call(value);
                            if (type === '[object Array]') {
                                target[prop] = value.slice(0);
                            } else if (type === '[object Number]') {
                                target[prop] = value;
                            } else {
                                console.error('unexpected color value:', value);
                            }
                        }
                    }

                    return result;
                }
            };

            Color.prototype.spaces = {
                rgb: ['red', 'green', 'blue'],
                hsl: ['hue', 'saturation', 'lightness'],
                hsv: ['hue', 'saturation', 'value'],
                hwb: ['hue', 'whiteness', 'blackness'],
                cmyk: ['cyan', 'magenta', 'yellow', 'black']
            };

            Color.prototype.maxes = {
                rgb: [255, 255, 255],
                hsl: [360, 100, 100],
                hsv: [360, 100, 100],
                hwb: [360, 100, 100],
                cmyk: [100, 100, 100, 100]
            };

            Color.prototype.getValues = function (space) {
                var values = this.values;
                var vals = {};

                for (var i = 0; i < space.length; i++) {
                    vals[space.charAt(i)] = values[space][i];
                }

                if (values.alpha !== 1) {
                    vals.a = values.alpha;
                }

                // {r: 255, g: 255, b: 255, a: 0.4}
                return vals;
            };

            Color.prototype.setValues = function (space, vals) {
                var values = this.values;
                var spaces = this.spaces;
                var maxes = this.maxes;
                var alpha = 1;
                var i;

                this.valid = true;

                if (space === 'alpha') {
                    alpha = vals;
                } else if (vals.length) {
                    // [10, 10, 10]
                    values[space] = vals.slice(0, space.length);
                    alpha = vals[space.length];
                } else if (vals[space.charAt(0)] !== undefined) {
                    // {r: 10, g: 10, b: 10}
                    for (i = 0; i < space.length; i++) {
                        values[space][i] = vals[space.charAt(i)];
                    }

                    alpha = vals.a;
                } else if (vals[spaces[space][0]] !== undefined) {
                    // {red: 10, green: 10, blue: 10}
                    var chans = spaces[space];

                    for (i = 0; i < space.length; i++) {
                        values[space][i] = vals[chans[i]];
                    }

                    alpha = vals.alpha;
                }

                values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));

                if (space === 'alpha') {
                    return false;
                }

                var capped;

                // cap values of the space prior converting all values
                for (i = 0; i < space.length; i++) {
                    capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
                    values[space][i] = Math.round(capped);
                }

                // convert to all the other color spaces
                for (var sname in spaces) {
                    if (sname !== space) {
                        values[sname] = convert[space][sname](values[space]);
                    }
                }

                return true;
            };

            Color.prototype.setSpace = function (space, args) {
                var vals = args[0];

                if (vals === undefined) {
                    // color.rgb()
                    return this.getValues(space);
                }

                // color.rgb(10, 10, 10)
                if (typeof vals === 'number') {
                    vals = Array.prototype.slice.call(args);
                }

                this.setValues(space, vals);
                return this;
            };

            Color.prototype.setChannel = function (space, index, val) {
                var svalues = this.values[space];
                if (val === undefined) {
                    // color.red()
                    return svalues[index];
                } else if (val === svalues[index]) {
                    // color.red(color.red())
                    return this;
                }

                // color.red(100)
                svalues[index] = val;
                this.setValues(space, svalues);

                return this;
            };

            if (typeof window !== 'undefined') {
                window.Color = Color;
            }

            module.exports = Color;

        }, {"1": 1, "4": 4}],
        3: [function (require, module, exports) {
            /* MIT license */

            module.exports = {
                rgb2hsl: rgb2hsl,
                rgb2hsv: rgb2hsv,
                rgb2hwb: rgb2hwb,
                rgb2cmyk: rgb2cmyk,
                rgb2keyword: rgb2keyword,
                rgb2xyz: rgb2xyz,
                rgb2lab: rgb2lab,
                rgb2lch: rgb2lch,

                hsl2rgb: hsl2rgb,
                hsl2hsv: hsl2hsv,
                hsl2hwb: hsl2hwb,
                hsl2cmyk: hsl2cmyk,
                hsl2keyword: hsl2keyword,

                hsv2rgb: hsv2rgb,
                hsv2hsl: hsv2hsl,
                hsv2hwb: hsv2hwb,
                hsv2cmyk: hsv2cmyk,
                hsv2keyword: hsv2keyword,

                hwb2rgb: hwb2rgb,
                hwb2hsl: hwb2hsl,
                hwb2hsv: hwb2hsv,
                hwb2cmyk: hwb2cmyk,
                hwb2keyword: hwb2keyword,

                cmyk2rgb: cmyk2rgb,
                cmyk2hsl: cmyk2hsl,
                cmyk2hsv: cmyk2hsv,
                cmyk2hwb: cmyk2hwb,
                cmyk2keyword: cmyk2keyword,

                keyword2rgb: keyword2rgb,
                keyword2hsl: keyword2hsl,
                keyword2hsv: keyword2hsv,
                keyword2hwb: keyword2hwb,
                keyword2cmyk: keyword2cmyk,
                keyword2lab: keyword2lab,
                keyword2xyz: keyword2xyz,

                xyz2rgb: xyz2rgb,
                xyz2lab: xyz2lab,
                xyz2lch: xyz2lch,

                lab2xyz: lab2xyz,
                lab2rgb: lab2rgb,
                lab2lch: lab2lch,

                lch2lab: lch2lab,
                lch2xyz: lch2xyz,
                lch2rgb: lch2rgb
            }


            function rgb2hsl(rgb) {
                var r = rgb[0] / 255,
                    g = rgb[1] / 255,
                    b = rgb[2] / 255,
                    min = Math.min(r, g, b),
                    max = Math.max(r, g, b),
                    delta = max - min,
                    h, s, l;

                if (max == min)
                    h = 0;
                else if (r == max)
                    h = (g - b) / delta;
                else if (g == max)
                    h = 2 + (b - r) / delta;
                else if (b == max)
                    h = 4 + (r - g) / delta;

                h = Math.min(h * 60, 360);

                if (h < 0)
                    h += 360;

                l = (min + max) / 2;

                if (max == min)
                    s = 0;
                else if (l <= 0.5)
                    s = delta / (max + min);
                else
                    s = delta / (2 - max - min);

                return [h, s * 100, l * 100];
            }

            function rgb2hsv(rgb) {
                var r = rgb[0],
                    g = rgb[1],
                    b = rgb[2],
                    min = Math.min(r, g, b),
                    max = Math.max(r, g, b),
                    delta = max - min,
                    h, s, v;

                if (max == 0)
                    s = 0;
                else
                    s = (delta / max * 1000) / 10;

                if (max == min)
                    h = 0;
                else if (r == max)
                    h = (g - b) / delta;
                else if (g == max)
                    h = 2 + (b - r) / delta;
                else if (b == max)
                    h = 4 + (r - g) / delta;

                h = Math.min(h * 60, 360);

                if (h < 0)
                    h += 360;

                v = ((max / 255) * 1000) / 10;

                return [h, s, v];
            }

            function rgb2hwb(rgb) {
                var r = rgb[0],
                    g = rgb[1],
                    b = rgb[2],
                    h = rgb2hsl(rgb)[0],
                    w = 1 / 255 * Math.min(r, Math.min(g, b)),
                    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

                return [h, w * 100, b * 100];
            }

            function rgb2cmyk(rgb) {
                var r = rgb[0] / 255,
                    g = rgb[1] / 255,
                    b = rgb[2] / 255,
                    c, m, y, k;

                k = Math.min(1 - r, 1 - g, 1 - b);
                c = (1 - r - k) / (1 - k) || 0;
                m = (1 - g - k) / (1 - k) || 0;
                y = (1 - b - k) / (1 - k) || 0;
                return [c * 100, m * 100, y * 100, k * 100];
            }

            function rgb2keyword(rgb) {
                return reverseKeywords[JSON.stringify(rgb)];
            }

            function rgb2xyz(rgb) {
                var r = rgb[0] / 255,
                    g = rgb[1] / 255,
                    b = rgb[2] / 255;

                // assume sRGB
                r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
                g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
                b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

                var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
                var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
                var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

                return [x * 100, y * 100, z * 100];
            }

            function rgb2lab(rgb) {
                var xyz = rgb2xyz(rgb),
                    x = xyz[0],
                    y = xyz[1],
                    z = xyz[2],
                    l, a, b;

                x /= 95.047;
                y /= 100;
                z /= 108.883;

                x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
                y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
                z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

                l = (116 * y) - 16;
                a = 500 * (x - y);
                b = 200 * (y - z);

                return [l, a, b];
            }

            function rgb2lch(args) {
                return lab2lch(rgb2lab(args));
            }

            function hsl2rgb(hsl) {
                var h = hsl[0] / 360,
                    s = hsl[1] / 100,
                    l = hsl[2] / 100,
                    t1, t2, t3, rgb, val;

                if (s == 0) {
                    val = l * 255;
                    return [val, val, val];
                }

                if (l < 0.5)
                    t2 = l * (1 + s);
                else
                    t2 = l + s - l * s;
                t1 = 2 * l - t2;

                rgb = [0, 0, 0];
                for (var i = 0; i < 3; i++) {
                    t3 = h + 1 / 3 * -(i - 1);
                    t3 < 0 && t3++;
                    t3 > 1 && t3--;

                    if (6 * t3 < 1)
                        val = t1 + (t2 - t1) * 6 * t3;
                    else if (2 * t3 < 1)
                        val = t2;
                    else if (3 * t3 < 2)
                        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                    else
                        val = t1;

                    rgb[i] = val * 255;
                }

                return rgb;
            }

            function hsl2hsv(hsl) {
                var h = hsl[0],
                    s = hsl[1] / 100,
                    l = hsl[2] / 100,
                    sv, v;

                if (l === 0) {
                    // no need to do calc on black
                    // also avoids divide by 0 error
                    return [0, 0, 0];
                }

                l *= 2;
                s *= (l <= 1) ? l : 2 - l;
                v = (l + s) / 2;
                sv = (2 * s) / (l + s);
                return [h, sv * 100, v * 100];
            }

            function hsl2hwb(args) {
                return rgb2hwb(hsl2rgb(args));
            }

            function hsl2cmyk(args) {
                return rgb2cmyk(hsl2rgb(args));
            }

            function hsl2keyword(args) {
                return rgb2keyword(hsl2rgb(args));
            }


            function hsv2rgb(hsv) {
                var h = hsv[0] / 60,
                    s = hsv[1] / 100,
                    v = hsv[2] / 100,
                    hi = Math.floor(h) % 6;

                var f = h - Math.floor(h),
                    p = 255 * v * (1 - s),
                    q = 255 * v * (1 - (s * f)),
                    t = 255 * v * (1 - (s * (1 - f))),
                    v = 255 * v;

                switch (hi) {
                    case 0:
                        return [v, t, p];
                    case 1:
                        return [q, v, p];
                    case 2:
                        return [p, v, t];
                    case 3:
                        return [p, q, v];
                    case 4:
                        return [t, p, v];
                    case 5:
                        return [v, p, q];
                }
            }

            function hsv2hsl(hsv) {
                var h = hsv[0],
                    s = hsv[1] / 100,
                    v = hsv[2] / 100,
                    sl, l;

                l = (2 - s) * v;
                sl = s * v;
                sl /= (l <= 1) ? l : 2 - l;
                sl = sl || 0;
                l /= 2;
                return [h, sl * 100, l * 100];
            }

            function hsv2hwb(args) {
                return rgb2hwb(hsv2rgb(args))
            }

            function hsv2cmyk(args) {
                return rgb2cmyk(hsv2rgb(args));
            }

            function hsv2keyword(args) {
                return rgb2keyword(hsv2rgb(args));
            }

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
            function hwb2rgb(hwb) {
                var h = hwb[0] / 360,
                    wh = hwb[1] / 100,
                    bl = hwb[2] / 100,
                    ratio = wh + bl,
                    i, v, f, n;

                // wh + bl cant be > 1
                if (ratio > 1) {
                    wh /= ratio;
                    bl /= ratio;
                }

                i = Math.floor(6 * h);
                v = 1 - bl;
                f = 6 * h - i;
                if ((i & 0x01) != 0) {
                    f = 1 - f;
                }
                n = wh + f * (v - wh);  // linear interpolation

                switch (i) {
                    default:
                    case 6:
                    case 0:
                        r = v;
                        g = n;
                        b = wh;
                        break;
                    case 1:
                        r = n;
                        g = v;
                        b = wh;
                        break;
                    case 2:
                        r = wh;
                        g = v;
                        b = n;
                        break;
                    case 3:
                        r = wh;
                        g = n;
                        b = v;
                        break;
                    case 4:
                        r = n;
                        g = wh;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = wh;
                        b = n;
                        break;
                }

                return [r * 255, g * 255, b * 255];
            }

            function hwb2hsl(args) {
                return rgb2hsl(hwb2rgb(args));
            }

            function hwb2hsv(args) {
                return rgb2hsv(hwb2rgb(args));
            }

            function hwb2cmyk(args) {
                return rgb2cmyk(hwb2rgb(args));
            }

            function hwb2keyword(args) {
                return rgb2keyword(hwb2rgb(args));
            }

            function cmyk2rgb(cmyk) {
                var c = cmyk[0] / 100,
                    m = cmyk[1] / 100,
                    y = cmyk[2] / 100,
                    k = cmyk[3] / 100,
                    r, g, b;

                r = 1 - Math.min(1, c * (1 - k) + k);
                g = 1 - Math.min(1, m * (1 - k) + k);
                b = 1 - Math.min(1, y * (1 - k) + k);
                return [r * 255, g * 255, b * 255];
            }

            function cmyk2hsl(args) {
                return rgb2hsl(cmyk2rgb(args));
            }

            function cmyk2hsv(args) {
                return rgb2hsv(cmyk2rgb(args));
            }

            function cmyk2hwb(args) {
                return rgb2hwb(cmyk2rgb(args));
            }

            function cmyk2keyword(args) {
                return rgb2keyword(cmyk2rgb(args));
            }


            function xyz2rgb(xyz) {
                var x = xyz[0] / 100,
                    y = xyz[1] / 100,
                    z = xyz[2] / 100,
                    r, g, b;

                r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
                g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
                b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

                // assume sRGB
                r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
                    : r = (r * 12.92);

                g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
                    : g = (g * 12.92);

                b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
                    : b = (b * 12.92);

                r = Math.min(Math.max(0, r), 1);
                g = Math.min(Math.max(0, g), 1);
                b = Math.min(Math.max(0, b), 1);

                return [r * 255, g * 255, b * 255];
            }

            function xyz2lab(xyz) {
                var x = xyz[0],
                    y = xyz[1],
                    z = xyz[2],
                    l, a, b;

                x /= 95.047;
                y /= 100;
                z /= 108.883;

                x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
                y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
                z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

                l = (116 * y) - 16;
                a = 500 * (x - y);
                b = 200 * (y - z);

                return [l, a, b];
            }

            function xyz2lch(args) {
                return lab2lch(xyz2lab(args));
            }

            function lab2xyz(lab) {
                var l = lab[0],
                    a = lab[1],
                    b = lab[2],
                    x, y, z, y2;

                if (l <= 8) {
                    y = (l * 100) / 903.3;
                    y2 = (7.787 * (y / 100)) + (16 / 116);
                } else {
                    y = 100 * Math.pow((l + 16) / 116, 3);
                    y2 = Math.pow(y / 100, 1 / 3);
                }

                x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

                z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

                return [x, y, z];
            }

            function lab2lch(lab) {
                var l = lab[0],
                    a = lab[1],
                    b = lab[2],
                    hr, h, c;

                hr = Math.atan2(b, a);
                h = hr * 360 / 2 / Math.PI;
                if (h < 0) {
                    h += 360;
                }
                c = Math.sqrt(a * a + b * b);
                return [l, c, h];
            }

            function lab2rgb(args) {
                return xyz2rgb(lab2xyz(args));
            }

            function lch2lab(lch) {
                var l = lch[0],
                    c = lch[1],
                    h = lch[2],
                    a, b, hr;

                hr = h / 360 * 2 * Math.PI;
                a = c * Math.cos(hr);
                b = c * Math.sin(hr);
                return [l, a, b];
            }

            function lch2xyz(args) {
                return lab2xyz(lch2lab(args));
            }

            function lch2rgb(args) {
                return lab2rgb(lch2lab(args));
            }

            function keyword2rgb(keyword) {
                return cssKeywords[keyword];
            }

            function keyword2hsl(args) {
                return rgb2hsl(keyword2rgb(args));
            }

            function keyword2hsv(args) {
                return rgb2hsv(keyword2rgb(args));
            }

            function keyword2hwb(args) {
                return rgb2hwb(keyword2rgb(args));
            }

            function keyword2cmyk(args) {
                return rgb2cmyk(keyword2rgb(args));
            }

            function keyword2lab(args) {
                return rgb2lab(keyword2rgb(args));
            }

            function keyword2xyz(args) {
                return rgb2xyz(keyword2rgb(args));
            }

            var cssKeywords = {
                aliceblue: [240, 248, 255],
                antiquewhite: [250, 235, 215],
                aqua: [0, 255, 255],
                aquamarine: [127, 255, 212],
                azure: [240, 255, 255],
                beige: [245, 245, 220],
                bisque: [255, 228, 196],
                black: [0, 0, 0],
                blanchedalmond: [255, 235, 205],
                blue: [0, 0, 255],
                blueviolet: [138, 43, 226],
                brown: [165, 42, 42],
                burlywood: [222, 184, 135],
                cadetblue: [95, 158, 160],
                chartreuse: [127, 255, 0],
                chocolate: [210, 105, 30],
                coral: [255, 127, 80],
                cornflowerblue: [100, 149, 237],
                cornsilk: [255, 248, 220],
                crimson: [220, 20, 60],
                cyan: [0, 255, 255],
                darkblue: [0, 0, 139],
                darkcyan: [0, 139, 139],
                darkgoldenrod: [184, 134, 11],
                darkgray: [169, 169, 169],
                darkgreen: [0, 100, 0],
                darkgrey: [169, 169, 169],
                darkkhaki: [189, 183, 107],
                darkmagenta: [139, 0, 139],
                darkolivegreen: [85, 107, 47],
                darkorange: [255, 140, 0],
                darkorchid: [153, 50, 204],
                darkred: [139, 0, 0],
                darksalmon: [233, 150, 122],
                darkseagreen: [143, 188, 143],
                darkslateblue: [72, 61, 139],
                darkslategray: [47, 79, 79],
                darkslategrey: [47, 79, 79],
                darkturquoise: [0, 206, 209],
                darkviolet: [148, 0, 211],
                deeppink: [255, 20, 147],
                deepskyblue: [0, 191, 255],
                dimgray: [105, 105, 105],
                dimgrey: [105, 105, 105],
                dodgerblue: [30, 144, 255],
                firebrick: [178, 34, 34],
                floralwhite: [255, 250, 240],
                forestgreen: [34, 139, 34],
                fuchsia: [255, 0, 255],
                gainsboro: [220, 220, 220],
                ghostwhite: [248, 248, 255],
                gold: [255, 215, 0],
                goldenrod: [218, 165, 32],
                gray: [128, 128, 128],
                green: [0, 128, 0],
                greenyellow: [173, 255, 47],
                grey: [128, 128, 128],
                honeydew: [240, 255, 240],
                hotpink: [255, 105, 180],
                indianred: [205, 92, 92],
                indigo: [75, 0, 130],
                ivory: [255, 255, 240],
                khaki: [240, 230, 140],
                lavender: [230, 230, 250],
                lavenderblush: [255, 240, 245],
                lawngreen: [124, 252, 0],
                lemonchiffon: [255, 250, 205],
                lightblue: [173, 216, 230],
                lightcoral: [240, 128, 128],
                lightcyan: [224, 255, 255],
                lightgoldenrodyellow: [250, 250, 210],
                lightgray: [211, 211, 211],
                lightgreen: [144, 238, 144],
                lightgrey: [211, 211, 211],
                lightpink: [255, 182, 193],
                lightsalmon: [255, 160, 122],
                lightseagreen: [32, 178, 170],
                lightskyblue: [135, 206, 250],
                lightslategray: [119, 136, 153],
                lightslategrey: [119, 136, 153],
                lightsteelblue: [176, 196, 222],
                lightyellow: [255, 255, 224],
                lime: [0, 255, 0],
                limegreen: [50, 205, 50],
                linen: [250, 240, 230],
                magenta: [255, 0, 255],
                maroon: [128, 0, 0],
                mediumaquamarine: [102, 205, 170],
                mediumblue: [0, 0, 205],
                mediumorchid: [186, 85, 211],
                mediumpurple: [147, 112, 219],
                mediumseagreen: [60, 179, 113],
                mediumslateblue: [123, 104, 238],
                mediumspringgreen: [0, 250, 154],
                mediumturquoise: [72, 209, 204],
                mediumvioletred: [199, 21, 133],
                midnightblue: [25, 25, 112],
                mintcream: [245, 255, 250],
                mistyrose: [255, 228, 225],
                moccasin: [255, 228, 181],
                navajowhite: [255, 222, 173],
                navy: [0, 0, 128],
                oldlace: [253, 245, 230],
                olive: [128, 128, 0],
                olivedrab: [107, 142, 35],
                orange: [255, 165, 0],
                orangered: [255, 69, 0],
                orchid: [218, 112, 214],
                palegoldenrod: [238, 232, 170],
                palegreen: [152, 251, 152],
                paleturquoise: [175, 238, 238],
                palevioletred: [219, 112, 147],
                papayawhip: [255, 239, 213],
                peachpuff: [255, 218, 185],
                peru: [205, 133, 63],
                pink: [255, 192, 203],
                plum: [221, 160, 221],
                powderblue: [176, 224, 230],
                purple: [128, 0, 128],
                rebeccapurple: [102, 51, 153],
                red: [255, 0, 0],
                rosybrown: [188, 143, 143],
                royalblue: [65, 105, 225],
                saddlebrown: [139, 69, 19],
                salmon: [250, 128, 114],
                sandybrown: [244, 164, 96],
                seagreen: [46, 139, 87],
                seashell: [255, 245, 238],
                sienna: [160, 82, 45],
                silver: [192, 192, 192],
                skyblue: [135, 206, 235],
                slateblue: [106, 90, 205],
                slategray: [112, 128, 144],
                slategrey: [112, 128, 144],
                snow: [255, 250, 250],
                springgreen: [0, 255, 127],
                steelblue: [70, 130, 180],
                tan: [210, 180, 140],
                teal: [0, 128, 128],
                thistle: [216, 191, 216],
                tomato: [255, 99, 71],
                turquoise: [64, 224, 208],
                violet: [238, 130, 238],
                wheat: [245, 222, 179],
                white: [255, 255, 255],
                whitesmoke: [245, 245, 245],
                yellow: [255, 255, 0],
                yellowgreen: [154, 205, 50]
            };

            var reverseKeywords = {};
            for (var key in cssKeywords) {
                reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
            }

        }, {}],
        4: [function (require, module, exports) {
            var conversions = require(3);

            var convert = function () {
                return new Converter();
            }

            for (var func in conversions) {
                // export Raw versions
                convert[func + "Raw"] = (function (func) {
                    // accept array or plain args
                    return function (arg) {
                        if (typeof arg == "number")
                            arg = Array.prototype.slice.call(arguments);
                        return conversions[func](arg);
                    }
                })(func);

                var pair = /(\w+)2(\w+)/.exec(func),
                    from = pair[1],
                    to = pair[2];

                // export rgb2hsl and ["rgb"]["hsl"]
                convert[from] = convert[from] || {};

                convert[from][to] = convert[func] = (function (func) {
                    return function (arg) {
                        if (typeof arg == "number")
                            arg = Array.prototype.slice.call(arguments);

                        var val = conversions[func](arg);
                        if (typeof val == "string" || val === undefined)
                            return val; // keyword

                        for (var i = 0; i < val.length; i++)
                            val[i] = Math.round(val[i]);
                        return val;
                    }
                })(func);
            }


            /* Converter does lazy conversion and caching */
            var Converter = function () {
                this.convs = {};
            };

            /* Either get the values for a space or
  set the values for a space, depending on args */
            Converter.prototype.routeSpace = function (space, args) {
                var values = args[0];
                if (values === undefined) {
                    // color.rgb()
                    return this.getValues(space);
                }
                // color.rgb(10, 10, 10)
                if (typeof values == "number") {
                    values = Array.prototype.slice.call(args);
                }

                return this.setValues(space, values);
            };

            /* Set the values for a space, invalidating cache */
            Converter.prototype.setValues = function (space, values) {
                this.space = space;
                this.convs = {};
                this.convs[space] = values;
                return this;
            };

            /* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
            Converter.prototype.getValues = function (space) {
                var vals = this.convs[space];
                if (!vals) {
                    var fspace = this.space,
                        from = this.convs[fspace];
                    vals = convert[fspace][space](from);

                    this.convs[space] = vals;
                }
                return vals;
            };

            ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
                Converter.prototype[space] = function (vals) {
                    return this.routeSpace(space, arguments);
                }
            });

            module.exports = convert;
        }, {"3": 3}],
        5: [function (require, module, exports) {
            'use strict'

            module.exports = {
                "aliceblue": [240, 248, 255],
                "antiquewhite": [250, 235, 215],
                "aqua": [0, 255, 255],
                "aquamarine": [127, 255, 212],
                "azure": [240, 255, 255],
                "beige": [245, 245, 220],
                "bisque": [255, 228, 196],
                "black": [0, 0, 0],
                "blanchedalmond": [255, 235, 205],
                "blue": [0, 0, 255],
                "blueviolet": [138, 43, 226],
                "brown": [165, 42, 42],
                "burlywood": [222, 184, 135],
                "cadetblue": [95, 158, 160],
                "chartreuse": [127, 255, 0],
                "chocolate": [210, 105, 30],
                "coral": [255, 127, 80],
                "cornflowerblue": [100, 149, 237],
                "cornsilk": [255, 248, 220],
                "crimson": [220, 20, 60],
                "cyan": [0, 255, 255],
                "darkblue": [0, 0, 139],
                "darkcyan": [0, 139, 139],
                "darkgoldenrod": [184, 134, 11],
                "darkgray": [169, 169, 169],
                "darkgreen": [0, 100, 0],
                "darkgrey": [169, 169, 169],
                "darkkhaki": [189, 183, 107],
                "darkmagenta": [139, 0, 139],
                "darkolivegreen": [85, 107, 47],
                "darkorange": [255, 140, 0],
                "darkorchid": [153, 50, 204],
                "darkred": [139, 0, 0],
                "darksalmon": [233, 150, 122],
                "darkseagreen": [143, 188, 143],
                "darkslateblue": [72, 61, 139],
                "darkslategray": [47, 79, 79],
                "darkslategrey": [47, 79, 79],
                "darkturquoise": [0, 206, 209],
                "darkviolet": [148, 0, 211],
                "deeppink": [255, 20, 147],
                "deepskyblue": [0, 191, 255],
                "dimgray": [105, 105, 105],
                "dimgrey": [105, 105, 105],
                "dodgerblue": [30, 144, 255],
                "firebrick": [178, 34, 34],
                "floralwhite": [255, 250, 240],
                "forestgreen": [34, 139, 34],
                "fuchsia": [255, 0, 255],
                "gainsboro": [220, 220, 220],
                "ghostwhite": [248, 248, 255],
                "gold": [255, 215, 0],
                "goldenrod": [218, 165, 32],
                "gray": [128, 128, 128],
                "green": [0, 128, 0],
                "greenyellow": [173, 255, 47],
                "grey": [128, 128, 128],
                "honeydew": [240, 255, 240],
                "hotpink": [255, 105, 180],
                "indianred": [205, 92, 92],
                "indigo": [75, 0, 130],
                "ivory": [255, 255, 240],
                "khaki": [240, 230, 140],
                "lavender": [230, 230, 250],
                "lavenderblush": [255, 240, 245],
                "lawngreen": [124, 252, 0],
                "lemonchiffon": [255, 250, 205],
                "lightblue": [173, 216, 230],
                "lightcoral": [240, 128, 128],
                "lightcyan": [224, 255, 255],
                "lightgoldenrodyellow": [250, 250, 210],
                "lightgray": [211, 211, 211],
                "lightgreen": [144, 238, 144],
                "lightgrey": [211, 211, 211],
                "lightpink": [255, 182, 193],
                "lightsalmon": [255, 160, 122],
                "lightseagreen": [32, 178, 170],
                "lightskyblue": [135, 206, 250],
                "lightslategray": [119, 136, 153],
                "lightslategrey": [119, 136, 153],
                "lightsteelblue": [176, 196, 222],
                "lightyellow": [255, 255, 224],
                "lime": [0, 255, 0],
                "limegreen": [50, 205, 50],
                "linen": [250, 240, 230],
                "magenta": [255, 0, 255],
                "maroon": [128, 0, 0],
                "mediumaquamarine": [102, 205, 170],
                "mediumblue": [0, 0, 205],
                "mediumorchid": [186, 85, 211],
                "mediumpurple": [147, 112, 219],
                "mediumseagreen": [60, 179, 113],
                "mediumslateblue": [123, 104, 238],
                "mediumspringgreen": [0, 250, 154],
                "mediumturquoise": [72, 209, 204],
                "mediumvioletred": [199, 21, 133],
                "midnightblue": [25, 25, 112],
                "mintcream": [245, 255, 250],
                "mistyrose": [255, 228, 225],
                "moccasin": [255, 228, 181],
                "navajowhite": [255, 222, 173],
                "navy": [0, 0, 128],
                "oldlace": [253, 245, 230],
                "olive": [128, 128, 0],
                "olivedrab": [107, 142, 35],
                "orange": [255, 165, 0],
                "orangered": [255, 69, 0],
                "orchid": [218, 112, 214],
                "palegoldenrod": [238, 232, 170],
                "palegreen": [152, 251, 152],
                "paleturquoise": [175, 238, 238],
                "palevioletred": [219, 112, 147],
                "papayawhip": [255, 239, 213],
                "peachpuff": [255, 218, 185],
                "peru": [205, 133, 63],
                "pink": [255, 192, 203],
                "plum": [221, 160, 221],
                "powderblue": [176, 224, 230],
                "purple": [128, 0, 128],
                "rebeccapurple": [102, 51, 153],
                "red": [255, 0, 0],
                "rosybrown": [188, 143, 143],
                "royalblue": [65, 105, 225],
                "saddlebrown": [139, 69, 19],
                "salmon": [250, 128, 114],
                "sandybrown": [244, 164, 96],
                "seagreen": [46, 139, 87],
                "seashell": [255, 245, 238],
                "sienna": [160, 82, 45],
                "silver": [192, 192, 192],
                "skyblue": [135, 206, 235],
                "slateblue": [106, 90, 205],
                "slategray": [112, 128, 144],
                "slategrey": [112, 128, 144],
                "snow": [255, 250, 250],
                "springgreen": [0, 255, 127],
                "steelblue": [70, 130, 180],
                "tan": [210, 180, 140],
                "teal": [0, 128, 128],
                "thistle": [216, 191, 216],
                "tomato": [255, 99, 71],
                "turquoise": [64, 224, 208],
                "violet": [238, 130, 238],
                "wheat": [245, 222, 179],
                "white": [255, 255, 255],
                "whitesmoke": [245, 245, 245],
                "yellow": [255, 255, 0],
                "yellowgreen": [154, 205, 50]
            };

        }, {}],
        6: [function (require, module, exports) {
//! moment.js

            ;(function (global, factory) {
                typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
                    typeof define === 'function' && define.amd ? define(factory) :
                        global.moment = factory()
            }(this, (function () {
                'use strict';

                var hookCallback;

                function hooks() {
                    return hookCallback.apply(null, arguments);
                }

                // This is done to register the method called with moment()
                // without creating circular dependencies.
                function setHookCallback(callback) {
                    hookCallback = callback;
                }

                function isArray(input) {
                    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
                }

                function isObject(input) {
                    // IE8 will treat undefined and null as object if it wasn't for
                    // input != null
                    return input != null && Object.prototype.toString.call(input) === '[object Object]';
                }

                function isObjectEmpty(obj) {
                    if (Object.getOwnPropertyNames) {
                        return (Object.getOwnPropertyNames(obj).length === 0);
                    } else {
                        var k;
                        for (k in obj) {
                            if (obj.hasOwnProperty(k)) {
                                return false;
                            }
                        }
                        return true;
                    }
                }

                function isUndefined(input) {
                    return input === void 0;
                }

                function isNumber(input) {
                    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
                }

                function isDate(input) {
                    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
                }

                function map(arr, fn) {
                    var res = [], i;
                    for (i = 0; i < arr.length; ++i) {
                        res.push(fn(arr[i], i));
                    }
                    return res;
                }

                function hasOwnProp(a, b) {
                    return Object.prototype.hasOwnProperty.call(a, b);
                }

                function extend(a, b) {
                    for (var i in b) {
                        if (hasOwnProp(b, i)) {
                            a[i] = b[i];
                        }
                    }

                    if (hasOwnProp(b, 'toString')) {
                        a.toString = b.toString;
                    }

                    if (hasOwnProp(b, 'valueOf')) {
                        a.valueOf = b.valueOf;
                    }

                    return a;
                }

                function createUTC(input, format, locale, strict) {
                    return createLocalOrUTC(input, format, locale, strict, true).utc();
                }

                function defaultParsingFlags() {
                    // We need to deep clone this object.
                    return {
                        empty: false,
                        unusedTokens: [],
                        unusedInput: [],
                        overflow: -2,
                        charsLeftOver: 0,
                        nullInput: false,
                        invalidMonth: null,
                        invalidFormat: false,
                        userInvalidated: false,
                        iso: false,
                        parsedDateParts: [],
                        meridiem: null,
                        rfc2822: false,
                        weekdayMismatch: false
                    };
                }

                function getParsingFlags(m) {
                    if (m._pf == null) {
                        m._pf = defaultParsingFlags();
                    }
                    return m._pf;
                }

                var some;
                if (Array.prototype.some) {
                    some = Array.prototype.some;
                } else {
                    some = function (fun) {
                        var t = Object(this);
                        var len = t.length >>> 0;

                        for (var i = 0; i < len; i++) {
                            if (i in t && fun.call(this, t[i], i, t)) {
                                return true;
                            }
                        }

                        return false;
                    };
                }

                function isValid(m) {
                    if (m._isValid == null) {
                        var flags = getParsingFlags(m);
                        var parsedParts = some.call(flags.parsedDateParts, function (i) {
                            return i != null;
                        });
                        var isNowValid = !isNaN(m._d.getTime()) &&
                            flags.overflow < 0 &&
                            !flags.empty &&
                            !flags.invalidMonth &&
                            !flags.invalidWeekday &&
                            !flags.weekdayMismatch &&
                            !flags.nullInput &&
                            !flags.invalidFormat &&
                            !flags.userInvalidated &&
                            (!flags.meridiem || (flags.meridiem && parsedParts));

                        if (m._strict) {
                            isNowValid = isNowValid &&
                                flags.charsLeftOver === 0 &&
                                flags.unusedTokens.length === 0 &&
                                flags.bigHour === undefined;
                        }

                        if (Object.isFrozen == null || !Object.isFrozen(m)) {
                            m._isValid = isNowValid;
                        }
                        else {
                            return isNowValid;
                        }
                    }
                    return m._isValid;
                }

                function createInvalid(flags) {
                    var m = createUTC(NaN);
                    if (flags != null) {
                        extend(getParsingFlags(m), flags);
                    }
                    else {
                        getParsingFlags(m).userInvalidated = true;
                    }

                    return m;
                }

                // Plugins that add properties should also add the key here (null value),
                // so we can properly clone ourselves.
                var momentProperties = hooks.momentProperties = [];

                function copyConfig(to, from) {
                    var i, prop, val;

                    if (!isUndefined(from._isAMomentObject)) {
                        to._isAMomentObject = from._isAMomentObject;
                    }
                    if (!isUndefined(from._i)) {
                        to._i = from._i;
                    }
                    if (!isUndefined(from._f)) {
                        to._f = from._f;
                    }
                    if (!isUndefined(from._l)) {
                        to._l = from._l;
                    }
                    if (!isUndefined(from._strict)) {
                        to._strict = from._strict;
                    }
                    if (!isUndefined(from._tzm)) {
                        to._tzm = from._tzm;
                    }
                    if (!isUndefined(from._isUTC)) {
                        to._isUTC = from._isUTC;
                    }
                    if (!isUndefined(from._offset)) {
                        to._offset = from._offset;
                    }
                    if (!isUndefined(from._pf)) {
                        to._pf = getParsingFlags(from);
                    }
                    if (!isUndefined(from._locale)) {
                        to._locale = from._locale;
                    }

                    if (momentProperties.length > 0) {
                        for (i = 0; i < momentProperties.length; i++) {
                            prop = momentProperties[i];
                            val = from[prop];
                            if (!isUndefined(val)) {
                                to[prop] = val;
                            }
                        }
                    }

                    return to;
                }

                var updateInProgress = false;

                // Moment prototype object
                function Moment(config) {
                    copyConfig(this, config);
                    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                    if (!this.isValid()) {
                        this._d = new Date(NaN);
                    }
                    // Prevent infinite loop in case updateOffset creates new moment
                    // objects.
                    if (updateInProgress === false) {
                        updateInProgress = true;
                        hooks.updateOffset(this);
                        updateInProgress = false;
                    }
                }

                function isMoment(obj) {
                    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
                }

                function absFloor(number) {
                    if (number < 0) {
                        // -0 -> 0
                        return Math.ceil(number) || 0;
                    } else {
                        return Math.floor(number);
                    }
                }

                function toInt(argumentForCoercion) {
                    var coercedNumber = +argumentForCoercion,
                        value = 0;

                    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                        value = absFloor(coercedNumber);
                    }

                    return value;
                }

                // compare two arrays, return the number of differences
                function compareArrays(array1, array2, dontConvert) {
                    var len = Math.min(array1.length, array2.length),
                        lengthDiff = Math.abs(array1.length - array2.length),
                        diffs = 0,
                        i;
                    for (i = 0; i < len; i++) {
                        if ((dontConvert && array1[i] !== array2[i]) ||
                            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                            diffs++;
                        }
                    }
                    return diffs + lengthDiff;
                }

                function warn(msg) {
                    if (hooks.suppressDeprecationWarnings === false &&
                        (typeof console !== 'undefined') && console.warn) {
                        console.warn('Deprecation warning: ' + msg);
                    }
                }

                function deprecate(msg, fn) {
                    var firstTime = true;

                    return extend(function () {
                        if (hooks.deprecationHandler != null) {
                            hooks.deprecationHandler(null, msg);
                        }
                        if (firstTime) {
                            var args = [];
                            var arg;
                            for (var i = 0; i < arguments.length; i++) {
                                arg = '';
                                if (typeof arguments[i] === 'object') {
                                    arg += '\n[' + i + '] ';
                                    for (var key in arguments[0]) {
                                        arg += key + ': ' + arguments[0][key] + ', ';
                                    }
                                    arg = arg.slice(0, -2); // Remove trailing comma and space
                                } else {
                                    arg = arguments[i];
                                }
                                args.push(arg);
                            }
                            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                            firstTime = false;
                        }
                        return fn.apply(this, arguments);
                    }, fn);
                }

                var deprecations = {};

                function deprecateSimple(name, msg) {
                    if (hooks.deprecationHandler != null) {
                        hooks.deprecationHandler(name, msg);
                    }
                    if (!deprecations[name]) {
                        warn(msg);
                        deprecations[name] = true;
                    }
                }

                hooks.suppressDeprecationWarnings = false;
                hooks.deprecationHandler = null;

                function isFunction(input) {
                    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
                }

                function set(config) {
                    var prop, i;
                    for (i in config) {
                        prop = config[i];
                        if (isFunction(prop)) {
                            this[i] = prop;
                        } else {
                            this['_' + i] = prop;
                        }
                    }
                    this._config = config;
                    // Lenient ordinal parsing accepts just a number in addition to
                    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
                    // TODO: Remove "ordinalParse" fallback in next major release.
                    this._dayOfMonthOrdinalParseLenient = new RegExp(
                        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                        '|' + (/\d{1,2}/).source);
                }

                function mergeConfigs(parentConfig, childConfig) {
                    var res = extend({}, parentConfig), prop;
                    for (prop in childConfig) {
                        if (hasOwnProp(childConfig, prop)) {
                            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                                res[prop] = {};
                                extend(res[prop], parentConfig[prop]);
                                extend(res[prop], childConfig[prop]);
                            } else if (childConfig[prop] != null) {
                                res[prop] = childConfig[prop];
                            } else {
                                delete res[prop];
                            }
                        }
                    }
                    for (prop in parentConfig) {
                        if (hasOwnProp(parentConfig, prop) &&
                            !hasOwnProp(childConfig, prop) &&
                            isObject(parentConfig[prop])) {
                            // make sure changes to properties don't modify parent config
                            res[prop] = extend({}, res[prop]);
                        }
                    }
                    return res;
                }

                function Locale(config) {
                    if (config != null) {
                        this.set(config);
                    }
                }

                var keys;

                if (Object.keys) {
                    keys = Object.keys;
                } else {
                    keys = function (obj) {
                        var i, res = [];
                        for (i in obj) {
                            if (hasOwnProp(obj, i)) {
                                res.push(i);
                            }
                        }
                        return res;
                    };
                }

                var defaultCalendar = {
                    sameDay: '[Today at] LT',
                    nextDay: '[Tomorrow at] LT',
                    nextWeek: 'dddd [at] LT',
                    lastDay: '[Yesterday at] LT',
                    lastWeek: '[Last] dddd [at] LT',
                    sameElse: 'L'
                };

                function calendar(key, mom, now) {
                    var output = this._calendar[key] || this._calendar['sameElse'];
                    return isFunction(output) ? output.call(mom, now) : output;
                }

                var defaultLongDateFormat = {
                    LTS: 'h:mm:ss A',
                    LT: 'h:mm A',
                    L: 'MM/DD/YYYY',
                    LL: 'MMMM D, YYYY',
                    LLL: 'MMMM D, YYYY h:mm A',
                    LLLL: 'dddd, MMMM D, YYYY h:mm A'
                };

                function longDateFormat(key) {
                    var format = this._longDateFormat[key],
                        formatUpper = this._longDateFormat[key.toUpperCase()];

                    if (format || !formatUpper) {
                        return format;
                    }

                    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
                        return val.slice(1);
                    });

                    return this._longDateFormat[key];
                }

                var defaultInvalidDate = 'Invalid date';

                function invalidDate() {
                    return this._invalidDate;
                }

                var defaultOrdinal = '%d';
                var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

                function ordinal(number) {
                    return this._ordinal.replace('%d', number);
                }

                var defaultRelativeTime = {
                    future: 'in %s',
                    past: '%s ago',
                    s: 'a few seconds',
                    ss: '%d seconds',
                    m: 'a minute',
                    mm: '%d minutes',
                    h: 'an hour',
                    hh: '%d hours',
                    d: 'a day',
                    dd: '%d days',
                    M: 'a month',
                    MM: '%d months',
                    y: 'a year',
                    yy: '%d years'
                };

                function relativeTime(number, withoutSuffix, string, isFuture) {
                    var output = this._relativeTime[string];
                    return (isFunction(output)) ?
                        output(number, withoutSuffix, string, isFuture) :
                        output.replace(/%d/i, number);
                }

                function pastFuture(diff, output) {
                    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
                    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
                }

                var aliases = {};

                function addUnitAlias(unit, shorthand) {
                    var lowerCase = unit.toLowerCase();
                    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
                }

                function normalizeUnits(units) {
                    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
                }

                function normalizeObjectUnits(inputObject) {
                    var normalizedInput = {},
                        normalizedProp,
                        prop;

                    for (prop in inputObject) {
                        if (hasOwnProp(inputObject, prop)) {
                            normalizedProp = normalizeUnits(prop);
                            if (normalizedProp) {
                                normalizedInput[normalizedProp] = inputObject[prop];
                            }
                        }
                    }

                    return normalizedInput;
                }

                var priorities = {};

                function addUnitPriority(unit, priority) {
                    priorities[unit] = priority;
                }

                function getPrioritizedUnits(unitsObj) {
                    var units = [];
                    for (var u in unitsObj) {
                        units.push({unit: u, priority: priorities[u]});
                    }
                    units.sort(function (a, b) {
                        return a.priority - b.priority;
                    });
                    return units;
                }

                function zeroFill(number, targetLength, forceSign) {
                    var absNumber = '' + Math.abs(number),
                        zerosToFill = targetLength - absNumber.length,
                        sign = number >= 0;
                    return (sign ? (forceSign ? '+' : '') : '-') +
                        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
                }

                var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

                var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

                var formatFunctions = {};

                var formatTokenFunctions = {};

                // token:    'M'
                // padded:   ['MM', 2]
                // ordinal:  'Mo'
                // callback: function () { this.month() + 1 }
                function addFormatToken(token, padded, ordinal, callback) {
                    var func = callback;
                    if (typeof callback === 'string') {
                        func = function () {
                            return this[callback]();
                        };
                    }
                    if (token) {
                        formatTokenFunctions[token] = func;
                    }
                    if (padded) {
                        formatTokenFunctions[padded[0]] = function () {
                            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                        };
                    }
                    if (ordinal) {
                        formatTokenFunctions[ordinal] = function () {
                            return this.localeData().ordinal(func.apply(this, arguments), token);
                        };
                    }
                }

                function removeFormattingTokens(input) {
                    if (input.match(/\[[\s\S]/)) {
                        return input.replace(/^\[|\]$/g, '');
                    }
                    return input.replace(/\\/g, '');
                }

                function makeFormatFunction(format) {
                    var array = format.match(formattingTokens), i, length;

                    for (i = 0, length = array.length; i < length; i++) {
                        if (formatTokenFunctions[array[i]]) {
                            array[i] = formatTokenFunctions[array[i]];
                        } else {
                            array[i] = removeFormattingTokens(array[i]);
                        }
                    }

                    return function (mom) {
                        var output = '', i;
                        for (i = 0; i < length; i++) {
                            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
                        }
                        return output;
                    };
                }

                // format date using native date object
                function formatMoment(m, format) {
                    if (!m.isValid()) {
                        return m.localeData().invalidDate();
                    }

                    format = expandFormat(format, m.localeData());
                    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

                    return formatFunctions[format](m);
                }

                function expandFormat(format, locale) {
                    var i = 5;

                    function replaceLongDateFormatTokens(input) {
                        return locale.longDateFormat(input) || input;
                    }

                    localFormattingTokens.lastIndex = 0;
                    while (i >= 0 && localFormattingTokens.test(format)) {
                        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                        localFormattingTokens.lastIndex = 0;
                        i -= 1;
                    }

                    return format;
                }

                var match1 = /\d/;            //       0 - 9
                var match2 = /\d\d/;          //      00 - 99
                var match3 = /\d{3}/;         //     000 - 999
                var match4 = /\d{4}/;         //    0000 - 9999
                var match6 = /[+-]?\d{6}/;    // -999999 - 999999
                var match1to2 = /\d\d?/;         //       0 - 99
                var match3to4 = /\d\d\d\d?/;     //     999 - 9999
                var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
                var match1to3 = /\d{1,3}/;       //       0 - 999
                var match1to4 = /\d{1,4}/;       //       0 - 9999
                var match1to6 = /[+-]?\d{1,6}/;  // -999999 - 999999

                var matchUnsigned = /\d+/;           //       0 - inf
                var matchSigned = /[+-]?\d+/;      //    -inf - inf

                var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
                var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

                var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

                // any word (or two) characters or numbers including two/three word month in arabic.
                // includes scottish gaelic two word and hyphenated months
                var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

                var regexes = {};

                function addRegexToken(token, regex, strictRegex) {
                    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
                        return (isStrict && strictRegex) ? strictRegex : regex;
                    };
                }

                function getParseRegexForToken(token, config) {
                    if (!hasOwnProp(regexes, token)) {
                        return new RegExp(unescapeFormat(token));
                    }

                    return regexes[token](config._strict, config._locale);
                }

                // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
                function unescapeFormat(s) {
                    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }));
                }

                function regexEscape(s) {
                    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                }

                var tokens = {};

                function addParseToken(token, callback) {
                    var i, func = callback;
                    if (typeof token === 'string') {
                        token = [token];
                    }
                    if (isNumber(callback)) {
                        func = function (input, array) {
                            array[callback] = toInt(input);
                        };
                    }
                    for (i = 0; i < token.length; i++) {
                        tokens[token[i]] = func;
                    }
                }

                function addWeekParseToken(token, callback) {
                    addParseToken(token, function (input, array, config, token) {
                        config._w = config._w || {};
                        callback(input, config._w, config, token);
                    });
                }

                function addTimeToArrayFromToken(token, input, config) {
                    if (input != null && hasOwnProp(tokens, token)) {
                        tokens[token](input, config._a, config, token);
                    }
                }

                var YEAR = 0;
                var MONTH = 1;
                var DATE = 2;
                var HOUR = 3;
                var MINUTE = 4;
                var SECOND = 5;
                var MILLISECOND = 6;
                var WEEK = 7;
                var WEEKDAY = 8;

                // FORMATTING

                addFormatToken('Y', 0, 0, function () {
                    var y = this.year();
                    return y <= 9999 ? '' + y : '+' + y;
                });

                addFormatToken(0, ['YY', 2], 0, function () {
                    return this.year() % 100;
                });

                addFormatToken(0, ['YYYY', 4], 0, 'year');
                addFormatToken(0, ['YYYYY', 5], 0, 'year');
                addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

                // ALIASES

                addUnitAlias('year', 'y');

                // PRIORITIES

                addUnitPriority('year', 1);

                // PARSING

                addRegexToken('Y', matchSigned);
                addRegexToken('YY', match1to2, match2);
                addRegexToken('YYYY', match1to4, match4);
                addRegexToken('YYYYY', match1to6, match6);
                addRegexToken('YYYYYY', match1to6, match6);

                addParseToken(['YYYYY', 'YYYYYY'], YEAR);
                addParseToken('YYYY', function (input, array) {
                    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
                });
                addParseToken('YY', function (input, array) {
                    array[YEAR] = hooks.parseTwoDigitYear(input);
                });
                addParseToken('Y', function (input, array) {
                    array[YEAR] = parseInt(input, 10);
                });

                // HELPERS

                function daysInYear(year) {
                    return isLeapYear(year) ? 366 : 365;
                }

                function isLeapYear(year) {
                    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                }

                // HOOKS

                hooks.parseTwoDigitYear = function (input) {
                    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
                };

                // MOMENTS

                var getSetYear = makeGetSet('FullYear', true);

                function getIsLeapYear() {
                    return isLeapYear(this.year());
                }

                function makeGetSet(unit, keepTime) {
                    return function (value) {
                        if (value != null) {
                            set$1(this, unit, value);
                            hooks.updateOffset(this, keepTime);
                            return this;
                        } else {
                            return get(this, unit);
                        }
                    };
                }

                function get(mom, unit) {
                    return mom.isValid() ?
                        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
                }

                function set$1(mom, unit, value) {
                    if (mom.isValid() && !isNaN(value)) {
                        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
                        }
                        else {
                            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                        }
                    }
                }

                // MOMENTS

                function stringGet(units) {
                    units = normalizeUnits(units);
                    if (isFunction(this[units])) {
                        return this[units]();
                    }
                    return this;
                }


                function stringSet(units, value) {
                    if (typeof units === 'object') {
                        units = normalizeObjectUnits(units);
                        var prioritized = getPrioritizedUnits(units);
                        for (var i = 0; i < prioritized.length; i++) {
                            this[prioritized[i].unit](units[prioritized[i].unit]);
                        }
                    } else {
                        units = normalizeUnits(units);
                        if (isFunction(this[units])) {
                            return this[units](value);
                        }
                    }
                    return this;
                }

                function mod(n, x) {
                    return ((n % x) + x) % x;
                }

                var indexOf;

                if (Array.prototype.indexOf) {
                    indexOf = Array.prototype.indexOf;
                } else {
                    indexOf = function (o) {
                        // I know
                        var i;
                        for (i = 0; i < this.length; ++i) {
                            if (this[i] === o) {
                                return i;
                            }
                        }
                        return -1;
                    };
                }

                function daysInMonth(year, month) {
                    if (isNaN(year) || isNaN(month)) {
                        return NaN;
                    }
                    var modMonth = mod(month, 12);
                    year += (month - modMonth) / 12;
                    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
                }

                // FORMATTING

                addFormatToken('M', ['MM', 2], 'Mo', function () {
                    return this.month() + 1;
                });

                addFormatToken('MMM', 0, 0, function (format) {
                    return this.localeData().monthsShort(this, format);
                });

                addFormatToken('MMMM', 0, 0, function (format) {
                    return this.localeData().months(this, format);
                });

                // ALIASES

                addUnitAlias('month', 'M');

                // PRIORITY

                addUnitPriority('month', 8);

                // PARSING

                addRegexToken('M', match1to2);
                addRegexToken('MM', match1to2, match2);
                addRegexToken('MMM', function (isStrict, locale) {
                    return locale.monthsShortRegex(isStrict);
                });
                addRegexToken('MMMM', function (isStrict, locale) {
                    return locale.monthsRegex(isStrict);
                });

                addParseToken(['M', 'MM'], function (input, array) {
                    array[MONTH] = toInt(input) - 1;
                });

                addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
                    var month = config._locale.monthsParse(input, token, config._strict);
                    // if we didn't find a month name, mark the date as invalid.
                    if (month != null) {
                        array[MONTH] = month;
                    } else {
                        getParsingFlags(config).invalidMonth = input;
                    }
                });

                // LOCALES

                var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
                var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

                function localeMonths(m, format) {
                    if (!m) {
                        return isArray(this._months) ? this._months :
                            this._months['standalone'];
                    }
                    return isArray(this._months) ? this._months[m.month()] :
                        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
                }

                var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

                function localeMonthsShort(m, format) {
                    if (!m) {
                        return isArray(this._monthsShort) ? this._monthsShort :
                            this._monthsShort['standalone'];
                    }
                    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
                        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
                }

                function handleStrictParse(monthName, format, strict) {
                    var i, ii, mom, llc = monthName.toLocaleLowerCase();
                    if (!this._monthsParse) {
                        // this is not used
                        this._monthsParse = [];
                        this._longMonthsParse = [];
                        this._shortMonthsParse = [];
                        for (i = 0; i < 12; ++i) {
                            mom = createUTC([2000, i]);
                            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                        }
                    }

                    if (strict) {
                        if (format === 'MMM') {
                            ii = indexOf.call(this._shortMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf.call(this._longMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    } else {
                        if (format === 'MMM') {
                            ii = indexOf.call(this._shortMonthsParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._longMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf.call(this._longMonthsParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._shortMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    }
                }

                function localeMonthsParse(monthName, format, strict) {
                    var i, mom, regex;

                    if (this._monthsParseExact) {
                        return handleStrictParse.call(this, monthName, format, strict);
                    }

                    if (!this._monthsParse) {
                        this._monthsParse = [];
                        this._longMonthsParse = [];
                        this._shortMonthsParse = [];
                    }

                    // TODO: add sorting
                    // Sorting makes sure if one month (or abbr) is a prefix of another
                    // see sorting in computeMonthsParse
                    for (i = 0; i < 12; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, i]);
                        if (strict && !this._longMonthsParse[i]) {
                            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                        }
                        if (!strict && !this._monthsParse[i]) {
                            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                        }
                        // test the regex
                        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                            return i;
                        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                            return i;
                        } else if (!strict && this._monthsParse[i].test(monthName)) {
                            return i;
                        }
                    }
                }

                // MOMENTS

                function setMonth(mom, value) {
                    var dayOfMonth;

                    if (!mom.isValid()) {
                        // No op
                        return mom;
                    }

                    if (typeof value === 'string') {
                        if (/^\d+$/.test(value)) {
                            value = toInt(value);
                        } else {
                            value = mom.localeData().monthsParse(value);
                            // TODO: Another silent failure?
                            if (!isNumber(value)) {
                                return mom;
                            }
                        }
                    }

                    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
                    return mom;
                }

                function getSetMonth(value) {
                    if (value != null) {
                        setMonth(this, value);
                        hooks.updateOffset(this, true);
                        return this;
                    } else {
                        return get(this, 'Month');
                    }
                }

                function getDaysInMonth() {
                    return daysInMonth(this.year(), this.month());
                }

                var defaultMonthsShortRegex = matchWord;

                function monthsShortRegex(isStrict) {
                    if (this._monthsParseExact) {
                        if (!hasOwnProp(this, '_monthsRegex')) {
                            computeMonthsParse.call(this);
                        }
                        if (isStrict) {
                            return this._monthsShortStrictRegex;
                        } else {
                            return this._monthsShortRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_monthsShortRegex')) {
                            this._monthsShortRegex = defaultMonthsShortRegex;
                        }
                        return this._monthsShortStrictRegex && isStrict ?
                            this._monthsShortStrictRegex : this._monthsShortRegex;
                    }
                }

                var defaultMonthsRegex = matchWord;

                function monthsRegex(isStrict) {
                    if (this._monthsParseExact) {
                        if (!hasOwnProp(this, '_monthsRegex')) {
                            computeMonthsParse.call(this);
                        }
                        if (isStrict) {
                            return this._monthsStrictRegex;
                        } else {
                            return this._monthsRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_monthsRegex')) {
                            this._monthsRegex = defaultMonthsRegex;
                        }
                        return this._monthsStrictRegex && isStrict ?
                            this._monthsStrictRegex : this._monthsRegex;
                    }
                }

                function computeMonthsParse() {
                    function cmpLenRev(a, b) {
                        return b.length - a.length;
                    }

                    var shortPieces = [], longPieces = [], mixedPieces = [],
                        i, mom;
                    for (i = 0; i < 12; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, i]);
                        shortPieces.push(this.monthsShort(mom, ''));
                        longPieces.push(this.months(mom, ''));
                        mixedPieces.push(this.months(mom, ''));
                        mixedPieces.push(this.monthsShort(mom, ''));
                    }
                    // Sorting makes sure if one month (or abbr) is a prefix of another it
                    // will match the longer piece.
                    shortPieces.sort(cmpLenRev);
                    longPieces.sort(cmpLenRev);
                    mixedPieces.sort(cmpLenRev);
                    for (i = 0; i < 12; i++) {
                        shortPieces[i] = regexEscape(shortPieces[i]);
                        longPieces[i] = regexEscape(longPieces[i]);
                    }
                    for (i = 0; i < 24; i++) {
                        mixedPieces[i] = regexEscape(mixedPieces[i]);
                    }

                    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                    this._monthsShortRegex = this._monthsRegex;
                    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
                }

                function createDate(y, m, d, h, M, s, ms) {
                    // can't just apply() to create a date:
                    // https://stackoverflow.com/q/181348
                    var date = new Date(y, m, d, h, M, s, ms);

                    // the date constructor remaps years 0-99 to 1900-1999
                    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
                        date.setFullYear(y);
                    }
                    return date;
                }

                function createUTCDate(y) {
                    var date = new Date(Date.UTC.apply(null, arguments));

                    // the Date.UTC function remaps years 0-99 to 1900-1999
                    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
                        date.setUTCFullYear(y);
                    }
                    return date;
                }

                // start-of-first-week - start-of-year
                function firstWeekOffset(year, dow, doy) {
                    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                        fwd = 7 + dow - doy,
                        // first-week day local weekday -- which local weekday is fwd
                        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

                    return -fwdlw + fwd - 1;
                }

                // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
                function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                    var localWeekday = (7 + weekday - dow) % 7,
                        weekOffset = firstWeekOffset(year, dow, doy),
                        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                        resYear, resDayOfYear;

                    if (dayOfYear <= 0) {
                        resYear = year - 1;
                        resDayOfYear = daysInYear(resYear) + dayOfYear;
                    } else if (dayOfYear > daysInYear(year)) {
                        resYear = year + 1;
                        resDayOfYear = dayOfYear - daysInYear(year);
                    } else {
                        resYear = year;
                        resDayOfYear = dayOfYear;
                    }

                    return {
                        year: resYear,
                        dayOfYear: resDayOfYear
                    };
                }

                function weekOfYear(mom, dow, doy) {
                    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                        resWeek, resYear;

                    if (week < 1) {
                        resYear = mom.year() - 1;
                        resWeek = week + weeksInYear(resYear, dow, doy);
                    } else if (week > weeksInYear(mom.year(), dow, doy)) {
                        resWeek = week - weeksInYear(mom.year(), dow, doy);
                        resYear = mom.year() + 1;
                    } else {
                        resYear = mom.year();
                        resWeek = week;
                    }

                    return {
                        week: resWeek,
                        year: resYear
                    };
                }

                function weeksInYear(year, dow, doy) {
                    var weekOffset = firstWeekOffset(year, dow, doy),
                        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
                }

                // FORMATTING

                addFormatToken('w', ['ww', 2], 'wo', 'week');
                addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

                // ALIASES

                addUnitAlias('week', 'w');
                addUnitAlias('isoWeek', 'W');

                // PRIORITIES

                addUnitPriority('week', 5);
                addUnitPriority('isoWeek', 5);

                // PARSING

                addRegexToken('w', match1to2);
                addRegexToken('ww', match1to2, match2);
                addRegexToken('W', match1to2);
                addRegexToken('WW', match1to2, match2);

                addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
                    week[token.substr(0, 1)] = toInt(input);
                });

                // HELPERS

                // LOCALES

                function localeWeek(mom) {
                    return weekOfYear(mom, this._week.dow, this._week.doy).week;
                }

                var defaultLocaleWeek = {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6  // The week that contains Jan 1st is the first week of the year.
                };

                function localeFirstDayOfWeek() {
                    return this._week.dow;
                }

                function localeFirstDayOfYear() {
                    return this._week.doy;
                }

                // MOMENTS

                function getSetWeek(input) {
                    var week = this.localeData().week(this);
                    return input == null ? week : this.add((input - week) * 7, 'd');
                }

                function getSetISOWeek(input) {
                    var week = weekOfYear(this, 1, 4).week;
                    return input == null ? week : this.add((input - week) * 7, 'd');
                }

                // FORMATTING

                addFormatToken('d', 0, 'do', 'day');

                addFormatToken('dd', 0, 0, function (format) {
                    return this.localeData().weekdaysMin(this, format);
                });

                addFormatToken('ddd', 0, 0, function (format) {
                    return this.localeData().weekdaysShort(this, format);
                });

                addFormatToken('dddd', 0, 0, function (format) {
                    return this.localeData().weekdays(this, format);
                });

                addFormatToken('e', 0, 0, 'weekday');
                addFormatToken('E', 0, 0, 'isoWeekday');

                // ALIASES

                addUnitAlias('day', 'd');
                addUnitAlias('weekday', 'e');
                addUnitAlias('isoWeekday', 'E');

                // PRIORITY
                addUnitPriority('day', 11);
                addUnitPriority('weekday', 11);
                addUnitPriority('isoWeekday', 11);

                // PARSING

                addRegexToken('d', match1to2);
                addRegexToken('e', match1to2);
                addRegexToken('E', match1to2);
                addRegexToken('dd', function (isStrict, locale) {
                    return locale.weekdaysMinRegex(isStrict);
                });
                addRegexToken('ddd', function (isStrict, locale) {
                    return locale.weekdaysShortRegex(isStrict);
                });
                addRegexToken('dddd', function (isStrict, locale) {
                    return locale.weekdaysRegex(isStrict);
                });

                addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
                    var weekday = config._locale.weekdaysParse(input, token, config._strict);
                    // if we didn't get a weekday name, mark the date as invalid
                    if (weekday != null) {
                        week.d = weekday;
                    } else {
                        getParsingFlags(config).invalidWeekday = input;
                    }
                });

                addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
                    week[token] = toInt(input);
                });

                // HELPERS

                function parseWeekday(input, locale) {
                    if (typeof input !== 'string') {
                        return input;
                    }

                    if (!isNaN(input)) {
                        return parseInt(input, 10);
                    }

                    input = locale.weekdaysParse(input);
                    if (typeof input === 'number') {
                        return input;
                    }

                    return null;
                }

                function parseIsoWeekday(input, locale) {
                    if (typeof input === 'string') {
                        return locale.weekdaysParse(input) % 7 || 7;
                    }
                    return isNaN(input) ? null : input;
                }

                // LOCALES

                var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

                function localeWeekdays(m, format) {
                    if (!m) {
                        return isArray(this._weekdays) ? this._weekdays :
                            this._weekdays['standalone'];
                    }
                    return isArray(this._weekdays) ? this._weekdays[m.day()] :
                        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
                }

                var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

                function localeWeekdaysShort(m) {
                    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
                }

                var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

                function localeWeekdaysMin(m) {
                    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
                }

                function handleStrictParse$1(weekdayName, format, strict) {
                    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                        this._shortWeekdaysParse = [];
                        this._minWeekdaysParse = [];

                        for (i = 0; i < 7; ++i) {
                            mom = createUTC([2000, 1]).day(i);
                            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                        }
                    }

                    if (strict) {
                        if (format === 'dddd') {
                            ii = indexOf.call(this._weekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else if (format === 'ddd') {
                            ii = indexOf.call(this._shortWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    } else {
                        if (format === 'dddd') {
                            ii = indexOf.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._shortWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else if (format === 'ddd') {
                            ii = indexOf.call(this._shortWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf.call(this._minWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._shortWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    }
                }

                function localeWeekdaysParse(weekdayName, format, strict) {
                    var i, mom, regex;

                    if (this._weekdaysParseExact) {
                        return handleStrictParse$1.call(this, weekdayName, format, strict);
                    }

                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                        this._minWeekdaysParse = [];
                        this._shortWeekdaysParse = [];
                        this._fullWeekdaysParse = [];
                    }

                    for (i = 0; i < 7; i++) {
                        // make the regex if we don't have it already

                        mom = createUTC([2000, 1]).day(i);
                        if (strict && !this._fullWeekdaysParse[i]) {
                            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
                        }
                        if (!this._weekdaysParse[i]) {
                            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                        }
                        // test the regex
                        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                            return i;
                        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                            return i;
                        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                            return i;
                        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                            return i;
                        }
                    }
                }

                // MOMENTS

                function getSetDayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                    if (input != null) {
                        input = parseWeekday(input, this.localeData());
                        return this.add(input - day, 'd');
                    } else {
                        return day;
                    }
                }

                function getSetLocaleDayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                    return input == null ? weekday : this.add(input - weekday, 'd');
                }

                function getSetISODayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }

                    // behaves the same as moment#day except
                    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
                    // as a setter, sunday should belong to the previous week.

                    if (input != null) {
                        var weekday = parseIsoWeekday(input, this.localeData());
                        return this.day(this.day() % 7 ? weekday : weekday - 7);
                    } else {
                        return this.day() || 7;
                    }
                }

                var defaultWeekdaysRegex = matchWord;

                function weekdaysRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, '_weekdaysRegex')) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysStrictRegex;
                        } else {
                            return this._weekdaysRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_weekdaysRegex')) {
                            this._weekdaysRegex = defaultWeekdaysRegex;
                        }
                        return this._weekdaysStrictRegex && isStrict ?
                            this._weekdaysStrictRegex : this._weekdaysRegex;
                    }
                }

                var defaultWeekdaysShortRegex = matchWord;

                function weekdaysShortRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, '_weekdaysRegex')) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysShortStrictRegex;
                        } else {
                            return this._weekdaysShortRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                        }
                        return this._weekdaysShortStrictRegex && isStrict ?
                            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                    }
                }

                var defaultWeekdaysMinRegex = matchWord;

                function weekdaysMinRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, '_weekdaysRegex')) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysMinStrictRegex;
                        } else {
                            return this._weekdaysMinRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                        }
                        return this._weekdaysMinStrictRegex && isStrict ?
                            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                    }
                }


                function computeWeekdaysParse() {
                    function cmpLenRev(a, b) {
                        return b.length - a.length;
                    }

                    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
                        i, mom, minp, shortp, longp;
                    for (i = 0; i < 7; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, 1]).day(i);
                        minp = this.weekdaysMin(mom, '');
                        shortp = this.weekdaysShort(mom, '');
                        longp = this.weekdays(mom, '');
                        minPieces.push(minp);
                        shortPieces.push(shortp);
                        longPieces.push(longp);
                        mixedPieces.push(minp);
                        mixedPieces.push(shortp);
                        mixedPieces.push(longp);
                    }
                    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
                    // will match the longer piece.
                    minPieces.sort(cmpLenRev);
                    shortPieces.sort(cmpLenRev);
                    longPieces.sort(cmpLenRev);
                    mixedPieces.sort(cmpLenRev);
                    for (i = 0; i < 7; i++) {
                        shortPieces[i] = regexEscape(shortPieces[i]);
                        longPieces[i] = regexEscape(longPieces[i]);
                        mixedPieces[i] = regexEscape(mixedPieces[i]);
                    }

                    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                    this._weekdaysShortRegex = this._weekdaysRegex;
                    this._weekdaysMinRegex = this._weekdaysRegex;

                    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
                    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
                }

                // FORMATTING

                function hFormat() {
                    return this.hours() % 12 || 12;
                }

                function kFormat() {
                    return this.hours() || 24;
                }

                addFormatToken('H', ['HH', 2], 0, 'hour');
                addFormatToken('h', ['hh', 2], 0, hFormat);
                addFormatToken('k', ['kk', 2], 0, kFormat);

                addFormatToken('hmm', 0, 0, function () {
                    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
                });

                addFormatToken('hmmss', 0, 0, function () {
                    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
                        zeroFill(this.seconds(), 2);
                });

                addFormatToken('Hmm', 0, 0, function () {
                    return '' + this.hours() + zeroFill(this.minutes(), 2);
                });

                addFormatToken('Hmmss', 0, 0, function () {
                    return '' + this.hours() + zeroFill(this.minutes(), 2) +
                        zeroFill(this.seconds(), 2);
                });

                function meridiem(token, lowercase) {
                    addFormatToken(token, 0, 0, function () {
                        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                    });
                }

                meridiem('a', true);
                meridiem('A', false);

                // ALIASES

                addUnitAlias('hour', 'h');

                // PRIORITY
                addUnitPriority('hour', 13);

                // PARSING

                function matchMeridiem(isStrict, locale) {
                    return locale._meridiemParse;
                }

                addRegexToken('a', matchMeridiem);
                addRegexToken('A', matchMeridiem);
                addRegexToken('H', match1to2);
                addRegexToken('h', match1to2);
                addRegexToken('k', match1to2);
                addRegexToken('HH', match1to2, match2);
                addRegexToken('hh', match1to2, match2);
                addRegexToken('kk', match1to2, match2);

                addRegexToken('hmm', match3to4);
                addRegexToken('hmmss', match5to6);
                addRegexToken('Hmm', match3to4);
                addRegexToken('Hmmss', match5to6);

                addParseToken(['H', 'HH'], HOUR);
                addParseToken(['k', 'kk'], function (input, array, config) {
                    var kInput = toInt(input);
                    array[HOUR] = kInput === 24 ? 0 : kInput;
                });
                addParseToken(['a', 'A'], function (input, array, config) {
                    config._isPm = config._locale.isPM(input);
                    config._meridiem = input;
                });
                addParseToken(['h', 'hh'], function (input, array, config) {
                    array[HOUR] = toInt(input);
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken('hmm', function (input, array, config) {
                    var pos = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos));
                    array[MINUTE] = toInt(input.substr(pos));
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken('hmmss', function (input, array, config) {
                    var pos1 = input.length - 4;
                    var pos2 = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos1));
                    array[MINUTE] = toInt(input.substr(pos1, 2));
                    array[SECOND] = toInt(input.substr(pos2));
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken('Hmm', function (input, array, config) {
                    var pos = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos));
                    array[MINUTE] = toInt(input.substr(pos));
                });
                addParseToken('Hmmss', function (input, array, config) {
                    var pos1 = input.length - 4;
                    var pos2 = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos1));
                    array[MINUTE] = toInt(input.substr(pos1, 2));
                    array[SECOND] = toInt(input.substr(pos2));
                });

                // LOCALES

                function localeIsPM(input) {
                    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
                    // Using charAt should be more compatible.
                    return ((input + '').toLowerCase().charAt(0) === 'p');
                }

                var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

                function localeMeridiem(hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? 'pm' : 'PM';
                    } else {
                        return isLower ? 'am' : 'AM';
                    }
                }


                // MOMENTS

                // Setting the hour should keep the time, because the user explicitly
                // specified which hour they want. So trying to maintain the same hour (in
                // a new timezone) makes sense. Adding/subtracting hours does not follow
                // this rule.
                var getSetHour = makeGetSet('Hours', true);

                var baseConfig = {
                    calendar: defaultCalendar,
                    longDateFormat: defaultLongDateFormat,
                    invalidDate: defaultInvalidDate,
                    ordinal: defaultOrdinal,
                    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                    relativeTime: defaultRelativeTime,

                    months: defaultLocaleMonths,
                    monthsShort: defaultLocaleMonthsShort,

                    week: defaultLocaleWeek,

                    weekdays: defaultLocaleWeekdays,
                    weekdaysMin: defaultLocaleWeekdaysMin,
                    weekdaysShort: defaultLocaleWeekdaysShort,

                    meridiemParse: defaultLocaleMeridiemParse
                };

                // internal storage for locale config files
                var locales = {};
                var localeFamilies = {};
                var globalLocale;

                function normalizeLocale(key) {
                    return key ? key.toLowerCase().replace('_', '-') : key;
                }

                // pick the locale from the array
                // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
                // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
                function chooseLocale(names) {
                    var i = 0, j, next, locale, split;

                    while (i < names.length) {
                        split = normalizeLocale(names[i]).split('-');
                        j = split.length;
                        next = normalizeLocale(names[i + 1]);
                        next = next ? next.split('-') : null;
                        while (j > 0) {
                            locale = loadLocale(split.slice(0, j).join('-'));
                            if (locale) {
                                return locale;
                            }
                            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                                //the next array item is better than a shallower substring of this one
                                break;
                            }
                            j--;
                        }
                        i++;
                    }
                    return globalLocale;
                }

                function loadLocale(name) {
                    var oldLocale = null;
                    // TODO: Find a better way to register and load all the locales in Node
                    if (!locales[name] && (typeof module !== 'undefined') &&
                        module && module.exports) {
                        try {
                            oldLocale = globalLocale._abbr;
                            var aliasedRequire = require;
                            aliasedRequire('./locale/' + name);
                            getSetGlobalLocale(oldLocale);
                        } catch (e) {
                        }
                    }
                    return locales[name];
                }

                // This function will load locale and then set the global locale.  If
                // no arguments are passed in, it will simply return the current global
                // locale key.
                function getSetGlobalLocale(key, values) {
                    var data;
                    if (key) {
                        if (isUndefined(values)) {
                            data = getLocale(key);
                        }
                        else {
                            data = defineLocale(key, values);
                        }

                        if (data) {
                            // moment.duration._locale = moment._locale = data;
                            globalLocale = data;
                        }
                        else {
                            if ((typeof console !== 'undefined') && console.warn) {
                                //warn user if arguments are passed but the locale could not be set
                                console.warn('Locale ' + key + ' not found. Did you forget to load it?');
                            }
                        }
                    }

                    return globalLocale._abbr;
                }

                function defineLocale(name, config) {
                    if (config !== null) {
                        var locale, parentConfig = baseConfig;
                        config.abbr = name;
                        if (locales[name] != null) {
                            deprecateSimple('defineLocaleOverride',
                                'use moment.updateLocale(localeName, config) to change ' +
                                'an existing locale. moment.defineLocale(localeName, ' +
                                'config) should only be used for creating a new locale ' +
                                'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                            parentConfig = locales[name]._config;
                        } else if (config.parentLocale != null) {
                            if (locales[config.parentLocale] != null) {
                                parentConfig = locales[config.parentLocale]._config;
                            } else {
                                locale = loadLocale(config.parentLocale);
                                if (locale != null) {
                                    parentConfig = locale._config;
                                } else {
                                    if (!localeFamilies[config.parentLocale]) {
                                        localeFamilies[config.parentLocale] = [];
                                    }
                                    localeFamilies[config.parentLocale].push({
                                        name: name,
                                        config: config
                                    });
                                    return null;
                                }
                            }
                        }
                        locales[name] = new Locale(mergeConfigs(parentConfig, config));

                        if (localeFamilies[name]) {
                            localeFamilies[name].forEach(function (x) {
                                defineLocale(x.name, x.config);
                            });
                        }

                        // backwards compat for now: also set the locale
                        // make sure we set the locale AFTER all child locales have been
                        // created, so we won't end up with the child locale set.
                        getSetGlobalLocale(name);


                        return locales[name];
                    } else {
                        // useful for testing
                        delete locales[name];
                        return null;
                    }
                }

                function updateLocale(name, config) {
                    if (config != null) {
                        var locale, tmpLocale, parentConfig = baseConfig;
                        // MERGE
                        tmpLocale = loadLocale(name);
                        if (tmpLocale != null) {
                            parentConfig = tmpLocale._config;
                        }
                        config = mergeConfigs(parentConfig, config);
                        locale = new Locale(config);
                        locale.parentLocale = locales[name];
                        locales[name] = locale;

                        // backwards compat for now: also set the locale
                        getSetGlobalLocale(name);
                    } else {
                        // pass null for config to unupdate, useful for tests
                        if (locales[name] != null) {
                            if (locales[name].parentLocale != null) {
                                locales[name] = locales[name].parentLocale;
                            } else if (locales[name] != null) {
                                delete locales[name];
                            }
                        }
                    }
                    return locales[name];
                }

                // returns locale data
                function getLocale(key) {
                    var locale;

                    if (key && key._locale && key._locale._abbr) {
                        key = key._locale._abbr;
                    }

                    if (!key) {
                        return globalLocale;
                    }

                    if (!isArray(key)) {
                        //short-circuit everything else
                        locale = loadLocale(key);
                        if (locale) {
                            return locale;
                        }
                        key = [key];
                    }

                    return chooseLocale(key);
                }

                function listLocales() {
                    return keys(locales);
                }

                function checkOverflow(m) {
                    var overflow;
                    var a = m._a;

                    if (a && getParsingFlags(m).overflow === -2) {
                        overflow =
                            a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
                                a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                                    a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                                        a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
                                            a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
                                                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                                                    -1;

                        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                            overflow = DATE;
                        }
                        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                            overflow = WEEK;
                        }
                        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                            overflow = WEEKDAY;
                        }

                        getParsingFlags(m).overflow = overflow;
                    }

                    return m;
                }

                // Pick the first defined of two or three arguments.
                function defaults(a, b, c) {
                    if (a != null) {
                        return a;
                    }
                    if (b != null) {
                        return b;
                    }
                    return c;
                }

                function currentDateArray(config) {
                    // hooks is actually the exported moment object
                    var nowValue = new Date(hooks.now());
                    if (config._useUTC) {
                        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
                    }
                    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
                }

                // convert an array to a date.
                // the array should mirror the parameters below
                // note: all values past the year are optional and will default to the lowest possible value.
                // [year, month, day , hour, minute, second, millisecond]
                function configFromArray(config) {
                    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

                    if (config._d) {
                        return;
                    }

                    currentDate = currentDateArray(config);

                    //compute day of the year from weeks and weekdays
                    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                        dayOfYearFromWeekInfo(config);
                    }

                    //if the day of the year is set, figure out what it is
                    if (config._dayOfYear != null) {
                        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                            getParsingFlags(config)._overflowDayOfYear = true;
                        }

                        date = createUTCDate(yearToUse, 0, config._dayOfYear);
                        config._a[MONTH] = date.getUTCMonth();
                        config._a[DATE] = date.getUTCDate();
                    }

                    // Default to current date.
                    // * if no year, month, day of month are given, default to today
                    // * if day of month is given, default month and year
                    // * if month is given, default only year
                    // * if year is given, don't default anything
                    for (i = 0; i < 3 && config._a[i] == null; ++i) {
                        config._a[i] = input[i] = currentDate[i];
                    }

                    // Zero out whatever was not defaulted, including time
                    for (; i < 7; i++) {
                        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
                    }

                    // Check for 24:00:00.000
                    if (config._a[HOUR] === 24 &&
                        config._a[MINUTE] === 0 &&
                        config._a[SECOND] === 0 &&
                        config._a[MILLISECOND] === 0) {
                        config._nextDay = true;
                        config._a[HOUR] = 0;
                    }

                    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

                    // Apply timezone offset from input. The actual utcOffset can be changed
                    // with parseZone.
                    if (config._tzm != null) {
                        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                    }

                    if (config._nextDay) {
                        config._a[HOUR] = 24;
                    }

                    // check for mismatching day of week
                    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
                        getParsingFlags(config).weekdayMismatch = true;
                    }
                }

                function dayOfYearFromWeekInfo(config) {
                    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

                    w = config._w;
                    if (w.GG != null || w.W != null || w.E != null) {
                        dow = 1;
                        doy = 4;

                        // TODO: We need to take the current isoWeekYear, but that depends on
                        // how we interpret now (local, utc, fixed offset). So create
                        // a now version of current config (take local/utc/offset flags, and
                        // create now).
                        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
                        week = defaults(w.W, 1);
                        weekday = defaults(w.E, 1);
                        if (weekday < 1 || weekday > 7) {
                            weekdayOverflow = true;
                        }
                    } else {
                        dow = config._locale._week.dow;
                        doy = config._locale._week.doy;

                        var curWeek = weekOfYear(createLocal(), dow, doy);

                        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                        // Default to current week.
                        week = defaults(w.w, curWeek.week);

                        if (w.d != null) {
                            // weekday -- low day numbers are considered next week
                            weekday = w.d;
                            if (weekday < 0 || weekday > 6) {
                                weekdayOverflow = true;
                            }
                        } else if (w.e != null) {
                            // local weekday -- counting starts from begining of week
                            weekday = w.e + dow;
                            if (w.e < 0 || w.e > 6) {
                                weekdayOverflow = true;
                            }
                        } else {
                            // default to begining of week
                            weekday = dow;
                        }
                    }
                    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                        getParsingFlags(config)._overflowWeeks = true;
                    } else if (weekdayOverflow != null) {
                        getParsingFlags(config)._overflowWeekday = true;
                    } else {
                        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                        config._a[YEAR] = temp.year;
                        config._dayOfYear = temp.dayOfYear;
                    }
                }

                // iso 8601 regex
                // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
                var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
                var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

                var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

                var isoDates = [
                    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                    ['YYYY-DDD', /\d{4}-\d{3}/],
                    ['YYYY-MM', /\d{4}-\d\d/, false],
                    ['YYYYYYMMDD', /[+-]\d{10}/],
                    ['YYYYMMDD', /\d{8}/],
                    // YYYYMM is NOT allowed by the standard
                    ['GGGG[W]WWE', /\d{4}W\d{3}/],
                    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                    ['YYYYDDD', /\d{7}/]
                ];

                // iso time formats and regexes
                var isoTimes = [
                    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                    ['HH:mm', /\d\d:\d\d/],
                    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                    ['HHmmss', /\d\d\d\d\d\d/],
                    ['HHmm', /\d\d\d\d/],
                    ['HH', /\d\d/]
                ];

                var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

                // date from iso format
                function configFromISO(config) {
                    var i, l,
                        string = config._i,
                        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                        allowTime, dateFormat, timeFormat, tzFormat;

                    if (match) {
                        getParsingFlags(config).iso = true;

                        for (i = 0, l = isoDates.length; i < l; i++) {
                            if (isoDates[i][1].exec(match[1])) {
                                dateFormat = isoDates[i][0];
                                allowTime = isoDates[i][2] !== false;
                                break;
                            }
                        }
                        if (dateFormat == null) {
                            config._isValid = false;
                            return;
                        }
                        if (match[3]) {
                            for (i = 0, l = isoTimes.length; i < l; i++) {
                                if (isoTimes[i][1].exec(match[3])) {
                                    // match[2] should be 'T' or space
                                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                                    break;
                                }
                            }
                            if (timeFormat == null) {
                                config._isValid = false;
                                return;
                            }
                        }
                        if (!allowTime && timeFormat != null) {
                            config._isValid = false;
                            return;
                        }
                        if (match[4]) {
                            if (tzRegex.exec(match[4])) {
                                tzFormat = 'Z';
                            } else {
                                config._isValid = false;
                                return;
                            }
                        }
                        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                        configFromStringAndFormat(config);
                    } else {
                        config._isValid = false;
                    }
                }

                // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
                var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

                function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
                    var result = [
                        untruncateYear(yearStr),
                        defaultLocaleMonthsShort.indexOf(monthStr),
                        parseInt(dayStr, 10),
                        parseInt(hourStr, 10),
                        parseInt(minuteStr, 10)
                    ];

                    if (secondStr) {
                        result.push(parseInt(secondStr, 10));
                    }

                    return result;
                }

                function untruncateYear(yearStr) {
                    var year = parseInt(yearStr, 10);
                    if (year <= 49) {
                        return 2000 + year;
                    } else if (year <= 999) {
                        return 1900 + year;
                    }
                    return year;
                }

                function preprocessRFC2822(s) {
                    // Remove comments and folding whitespace and replace multiple-spaces with a single space
                    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                }

                function checkWeekday(weekdayStr, parsedInput, config) {
                    if (weekdayStr) {
                        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
                        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
                        if (weekdayProvided !== weekdayActual) {
                            getParsingFlags(config).weekdayMismatch = true;
                            config._isValid = false;
                            return false;
                        }
                    }
                    return true;
                }

                var obsOffsets = {
                    UT: 0,
                    GMT: 0,
                    EDT: -4 * 60,
                    EST: -5 * 60,
                    CDT: -5 * 60,
                    CST: -6 * 60,
                    MDT: -6 * 60,
                    MST: -7 * 60,
                    PDT: -7 * 60,
                    PST: -8 * 60
                };

                function calculateOffset(obsOffset, militaryOffset, numOffset) {
                    if (obsOffset) {
                        return obsOffsets[obsOffset];
                    } else if (militaryOffset) {
                        // the only allowed military tz is Z
                        return 0;
                    } else {
                        var hm = parseInt(numOffset, 10);
                        var m = hm % 100, h = (hm - m) / 100;
                        return h * 60 + m;
                    }
                }

                // date and time from ref 2822 format
                function configFromRFC2822(config) {
                    var match = rfc2822.exec(preprocessRFC2822(config._i));
                    if (match) {
                        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
                        if (!checkWeekday(match[1], parsedArray, config)) {
                            return;
                        }

                        config._a = parsedArray;
                        config._tzm = calculateOffset(match[8], match[9], match[10]);

                        config._d = createUTCDate.apply(null, config._a);
                        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

                        getParsingFlags(config).rfc2822 = true;
                    } else {
                        config._isValid = false;
                    }
                }

                // date from iso format or fallback
                function configFromString(config) {
                    var matched = aspNetJsonRegex.exec(config._i);

                    if (matched !== null) {
                        config._d = new Date(+matched[1]);
                        return;
                    }

                    configFromISO(config);
                    if (config._isValid === false) {
                        delete config._isValid;
                    } else {
                        return;
                    }

                    configFromRFC2822(config);
                    if (config._isValid === false) {
                        delete config._isValid;
                    } else {
                        return;
                    }

                    // Final attempt, use Input Fallback
                    hooks.createFromInputFallback(config);
                }

                hooks.createFromInputFallback = deprecate(
                    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
                    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
                    'discouraged and will be removed in an upcoming major release. Please refer to ' +
                    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
                    function (config) {
                        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
                    }
                );

                // constant that refers to the ISO standard
                hooks.ISO_8601 = function () {
                };

                // constant that refers to the RFC 2822 form
                hooks.RFC_2822 = function () {
                };

                // date from string and format string
                function configFromStringAndFormat(config) {
                    // TODO: Move this to another part of the creation flow to prevent circular deps
                    if (config._f === hooks.ISO_8601) {
                        configFromISO(config);
                        return;
                    }
                    if (config._f === hooks.RFC_2822) {
                        configFromRFC2822(config);
                        return;
                    }
                    config._a = [];
                    getParsingFlags(config).empty = true;

                    // This array is used to make a Date, either with `new Date` or `Date.UTC`
                    var string = '' + config._i,
                        i, parsedInput, tokens, token, skipped,
                        stringLength = string.length,
                        totalParsedInputLength = 0;

                    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

                    for (i = 0; i < tokens.length; i++) {
                        token = tokens[i];
                        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                        // console.log('token', token, 'parsedInput', parsedInput,
                        //         'regex', getParseRegexForToken(token, config));
                        if (parsedInput) {
                            skipped = string.substr(0, string.indexOf(parsedInput));
                            if (skipped.length > 0) {
                                getParsingFlags(config).unusedInput.push(skipped);
                            }
                            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                            totalParsedInputLength += parsedInput.length;
                        }
                        // don't parse if it's not a known token
                        if (formatTokenFunctions[token]) {
                            if (parsedInput) {
                                getParsingFlags(config).empty = false;
                            }
                            else {
                                getParsingFlags(config).unusedTokens.push(token);
                            }
                            addTimeToArrayFromToken(token, parsedInput, config);
                        }
                        else if (config._strict && !parsedInput) {
                            getParsingFlags(config).unusedTokens.push(token);
                        }
                    }

                    // add remaining unparsed input length to the string
                    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                    if (string.length > 0) {
                        getParsingFlags(config).unusedInput.push(string);
                    }

                    // clear _12h flag if hour is <= 12
                    if (config._a[HOUR] <= 12 &&
                        getParsingFlags(config).bigHour === true &&
                        config._a[HOUR] > 0) {
                        getParsingFlags(config).bigHour = undefined;
                    }

                    getParsingFlags(config).parsedDateParts = config._a.slice(0);
                    getParsingFlags(config).meridiem = config._meridiem;
                    // handle meridiem
                    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

                    configFromArray(config);
                    checkOverflow(config);
                }


                function meridiemFixWrap(locale, hour, meridiem) {
                    var isPm;

                    if (meridiem == null) {
                        // nothing to do
                        return hour;
                    }
                    if (locale.meridiemHour != null) {
                        return locale.meridiemHour(hour, meridiem);
                    } else if (locale.isPM != null) {
                        // Fallback
                        isPm = locale.isPM(meridiem);
                        if (isPm && hour < 12) {
                            hour += 12;
                        }
                        if (!isPm && hour === 12) {
                            hour = 0;
                        }
                        return hour;
                    } else {
                        // this is not supposed to happen
                        return hour;
                    }
                }

                // date from string and array of format strings
                function configFromStringAndArray(config) {
                    var tempConfig,
                        bestMoment,

                        scoreToBeat,
                        i,
                        currentScore;

                    if (config._f.length === 0) {
                        getParsingFlags(config).invalidFormat = true;
                        config._d = new Date(NaN);
                        return;
                    }

                    for (i = 0; i < config._f.length; i++) {
                        currentScore = 0;
                        tempConfig = copyConfig({}, config);
                        if (config._useUTC != null) {
                            tempConfig._useUTC = config._useUTC;
                        }
                        tempConfig._f = config._f[i];
                        configFromStringAndFormat(tempConfig);

                        if (!isValid(tempConfig)) {
                            continue;
                        }

                        // if there is any input that was not parsed add a penalty for that format
                        currentScore += getParsingFlags(tempConfig).charsLeftOver;

                        //or tokens
                        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                        getParsingFlags(tempConfig).score = currentScore;

                        if (scoreToBeat == null || currentScore < scoreToBeat) {
                            scoreToBeat = currentScore;
                            bestMoment = tempConfig;
                        }
                    }

                    extend(config, bestMoment || tempConfig);
                }

                function configFromObject(config) {
                    if (config._d) {
                        return;
                    }

                    var i = normalizeObjectUnits(config._i);
                    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
                        return obj && parseInt(obj, 10);
                    });

                    configFromArray(config);
                }

                function createFromConfig(config) {
                    var res = new Moment(checkOverflow(prepareConfig(config)));
                    if (res._nextDay) {
                        // Adding is smart enough around DST
                        res.add(1, 'd');
                        res._nextDay = undefined;
                    }

                    return res;
                }

                function prepareConfig(config) {
                    var input = config._i,
                        format = config._f;

                    config._locale = config._locale || getLocale(config._l);

                    if (input === null || (format === undefined && input === '')) {
                        return createInvalid({nullInput: true});
                    }

                    if (typeof input === 'string') {
                        config._i = input = config._locale.preparse(input);
                    }

                    if (isMoment(input)) {
                        return new Moment(checkOverflow(input));
                    } else if (isDate(input)) {
                        config._d = input;
                    } else if (isArray(format)) {
                        configFromStringAndArray(config);
                    } else if (format) {
                        configFromStringAndFormat(config);
                    } else {
                        configFromInput(config);
                    }

                    if (!isValid(config)) {
                        config._d = null;
                    }

                    return config;
                }

                function configFromInput(config) {
                    var input = config._i;
                    if (isUndefined(input)) {
                        config._d = new Date(hooks.now());
                    } else if (isDate(input)) {
                        config._d = new Date(input.valueOf());
                    } else if (typeof input === 'string') {
                        configFromString(config);
                    } else if (isArray(input)) {
                        config._a = map(input.slice(0), function (obj) {
                            return parseInt(obj, 10);
                        });
                        configFromArray(config);
                    } else if (isObject(input)) {
                        configFromObject(config);
                    } else if (isNumber(input)) {
                        // from milliseconds
                        config._d = new Date(input);
                    } else {
                        hooks.createFromInputFallback(config);
                    }
                }

                function createLocalOrUTC(input, format, locale, strict, isUTC) {
                    var c = {};

                    if (locale === true || locale === false) {
                        strict = locale;
                        locale = undefined;
                    }

                    if ((isObject(input) && isObjectEmpty(input)) ||
                        (isArray(input) && input.length === 0)) {
                        input = undefined;
                    }
                    // object construction must be done this way.
                    // https://github.com/moment/moment/issues/1423
                    c._isAMomentObject = true;
                    c._useUTC = c._isUTC = isUTC;
                    c._l = locale;
                    c._i = input;
                    c._f = format;
                    c._strict = strict;

                    return createFromConfig(c);
                }

                function createLocal(input, format, locale, strict) {
                    return createLocalOrUTC(input, format, locale, strict, false);
                }

                var prototypeMin = deprecate(
                    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                    function () {
                        var other = createLocal.apply(null, arguments);
                        if (this.isValid() && other.isValid()) {
                            return other < this ? this : other;
                        } else {
                            return createInvalid();
                        }
                    }
                );

                var prototypeMax = deprecate(
                    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                    function () {
                        var other = createLocal.apply(null, arguments);
                        if (this.isValid() && other.isValid()) {
                            return other > this ? this : other;
                        } else {
                            return createInvalid();
                        }
                    }
                );

                // Pick a moment m from moments so that m[fn](other) is true for all
                // other. This relies on the function fn to be transitive.
                //
                // moments should either be an array of moment objects or an array, whose
                // first element is an array of moment objects.
                function pickBy(fn, moments) {
                    var res, i;
                    if (moments.length === 1 && isArray(moments[0])) {
                        moments = moments[0];
                    }
                    if (!moments.length) {
                        return createLocal();
                    }
                    res = moments[0];
                    for (i = 1; i < moments.length; ++i) {
                        if (!moments[i].isValid() || moments[i][fn](res)) {
                            res = moments[i];
                        }
                    }
                    return res;
                }

                // TODO: Use [].sort instead?
                function min() {
                    var args = [].slice.call(arguments, 0);

                    return pickBy('isBefore', args);
                }

                function max() {
                    var args = [].slice.call(arguments, 0);

                    return pickBy('isAfter', args);
                }

                var now = function () {
                    return Date.now ? Date.now() : +(new Date());
                };

                var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

                function isDurationValid(m) {
                    for (var key in m) {
                        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                            return false;
                        }
                    }

                    var unitHasDecimal = false;
                    for (var i = 0; i < ordering.length; ++i) {
                        if (m[ordering[i]]) {
                            if (unitHasDecimal) {
                                return false; // only allow non-integers for smallest unit
                            }
                            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                                unitHasDecimal = true;
                            }
                        }
                    }

                    return true;
                }

                function isValid$1() {
                    return this._isValid;
                }

                function createInvalid$1() {
                    return createDuration(NaN);
                }

                function Duration(duration) {
                    var normalizedInput = normalizeObjectUnits(duration),
                        years = normalizedInput.year || 0,
                        quarters = normalizedInput.quarter || 0,
                        months = normalizedInput.month || 0,
                        weeks = normalizedInput.week || 0,
                        days = normalizedInput.day || 0,
                        hours = normalizedInput.hour || 0,
                        minutes = normalizedInput.minute || 0,
                        seconds = normalizedInput.second || 0,
                        milliseconds = normalizedInput.millisecond || 0;

                    this._isValid = isDurationValid(normalizedInput);

                    // representation for dateAddRemove
                    this._milliseconds = +milliseconds +
                        seconds * 1e3 + // 1000
                        minutes * 6e4 + // 1000 * 60
                        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
                    // Because of dateAddRemove treats 24 hours as different from a
                    // day when working around DST, we need to store them separately
                    this._days = +days +
                        weeks * 7;
                    // It is impossible to translate months into days without knowing
                    // which months you are are talking about, so we have to store
                    // it separately.
                    this._months = +months +
                        quarters * 3 +
                        years * 12;

                    this._data = {};

                    this._locale = getLocale();

                    this._bubble();
                }

                function isDuration(obj) {
                    return obj instanceof Duration;
                }

                function absRound(number) {
                    if (number < 0) {
                        return Math.round(-1 * number) * -1;
                    } else {
                        return Math.round(number);
                    }
                }

                // FORMATTING

                function offset(token, separator) {
                    addFormatToken(token, 0, 0, function () {
                        var offset = this.utcOffset();
                        var sign = '+';
                        if (offset < 0) {
                            offset = -offset;
                            sign = '-';
                        }
                        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
                    });
                }

                offset('Z', ':');
                offset('ZZ', '');

                // PARSING

                addRegexToken('Z', matchShortOffset);
                addRegexToken('ZZ', matchShortOffset);
                addParseToken(['Z', 'ZZ'], function (input, array, config) {
                    config._useUTC = true;
                    config._tzm = offsetFromString(matchShortOffset, input);
                });

                // HELPERS

                // timezone chunker
                // '+10:00' > ['10',  '00']
                // '-1530'  > ['-15', '30']
                var chunkOffset = /([\+\-]|\d\d)/gi;

                function offsetFromString(matcher, string) {
                    var matches = (string || '').match(matcher);

                    if (matches === null) {
                        return null;
                    }

                    var chunk = matches[matches.length - 1] || [];
                    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
                    var minutes = +(parts[1] * 60) + toInt(parts[2]);

                    return minutes === 0 ?
                        0 :
                        parts[0] === '+' ? minutes : -minutes;
                }

                // Return a moment from input, that is local/utc/zone equivalent to model.
                function cloneWithOffset(input, model) {
                    var res, diff;
                    if (model._isUTC) {
                        res = model.clone();
                        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
                        // Use low-level api, because this fn is low-level api.
                        res._d.setTime(res._d.valueOf() + diff);
                        hooks.updateOffset(res, false);
                        return res;
                    } else {
                        return createLocal(input).local();
                    }
                }

                function getDateOffset(m) {
                    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
                    // https://github.com/moment/moment/pull/1871
                    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
                }

                // HOOKS

                // This function will be called whenever a moment is mutated.
                // It is intended to keep the offset in sync with the timezone.
                hooks.updateOffset = function () {
                };

                // MOMENTS

                // keepLocalTime = true means only change the timezone, without
                // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
                // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
                // +0200, so we adjust the time as needed, to be valid.
                //
                // Keeping the time actually adds/subtracts (one hour)
                // from the actual represented time. That is why we call updateOffset
                // a second time. In case it wants us to change the offset again
                // _changeInProgress == true case, then we have to adjust, because
                // there is no such time in the given timezone.
                function getSetOffset(input, keepLocalTime, keepMinutes) {
                    var offset = this._offset || 0,
                        localAdjust;
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    if (input != null) {
                        if (typeof input === 'string') {
                            input = offsetFromString(matchShortOffset, input);
                            if (input === null) {
                                return this;
                            }
                        } else if (Math.abs(input) < 16 && !keepMinutes) {
                            input = input * 60;
                        }
                        if (!this._isUTC && keepLocalTime) {
                            localAdjust = getDateOffset(this);
                        }
                        this._offset = input;
                        this._isUTC = true;
                        if (localAdjust != null) {
                            this.add(localAdjust, 'm');
                        }
                        if (offset !== input) {
                            if (!keepLocalTime || this._changeInProgress) {
                                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                            } else if (!this._changeInProgress) {
                                this._changeInProgress = true;
                                hooks.updateOffset(this, true);
                                this._changeInProgress = null;
                            }
                        }
                        return this;
                    } else {
                        return this._isUTC ? offset : getDateOffset(this);
                    }
                }

                function getSetZone(input, keepLocalTime) {
                    if (input != null) {
                        if (typeof input !== 'string') {
                            input = -input;
                        }

                        this.utcOffset(input, keepLocalTime);

                        return this;
                    } else {
                        return -this.utcOffset();
                    }
                }

                function setOffsetToUTC(keepLocalTime) {
                    return this.utcOffset(0, keepLocalTime);
                }

                function setOffsetToLocal(keepLocalTime) {
                    if (this._isUTC) {
                        this.utcOffset(0, keepLocalTime);
                        this._isUTC = false;

                        if (keepLocalTime) {
                            this.subtract(getDateOffset(this), 'm');
                        }
                    }
                    return this;
                }

                function setOffsetToParsedOffset() {
                    if (this._tzm != null) {
                        this.utcOffset(this._tzm, false, true);
                    } else if (typeof this._i === 'string') {
                        var tZone = offsetFromString(matchOffset, this._i);
                        if (tZone != null) {
                            this.utcOffset(tZone);
                        }
                        else {
                            this.utcOffset(0, true);
                        }
                    }
                    return this;
                }

                function hasAlignedHourOffset(input) {
                    if (!this.isValid()) {
                        return false;
                    }
                    input = input ? createLocal(input).utcOffset() : 0;

                    return (this.utcOffset() - input) % 60 === 0;
                }

                function isDaylightSavingTime() {
                    return (
                        this.utcOffset() > this.clone().month(0).utcOffset() ||
                        this.utcOffset() > this.clone().month(5).utcOffset()
                    );
                }

                function isDaylightSavingTimeShifted() {
                    if (!isUndefined(this._isDSTShifted)) {
                        return this._isDSTShifted;
                    }

                    var c = {};

                    copyConfig(c, this);
                    c = prepareConfig(c);

                    if (c._a) {
                        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                        this._isDSTShifted = this.isValid() &&
                            compareArrays(c._a, other.toArray()) > 0;
                    } else {
                        this._isDSTShifted = false;
                    }

                    return this._isDSTShifted;
                }

                function isLocal() {
                    return this.isValid() ? !this._isUTC : false;
                }

                function isUtcOffset() {
                    return this.isValid() ? this._isUTC : false;
                }

                function isUtc() {
                    return this.isValid() ? this._isUTC && this._offset === 0 : false;
                }

                // ASP.NET json date format regex
                var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

                // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
                // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
                // and further modified to allow for strings containing both week and day
                var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

                function createDuration(input, key) {
                    var duration = input,
                        // matching against regexp is expensive, do it on demand
                        match = null,
                        sign,
                        ret,
                        diffRes;

                    if (isDuration(input)) {
                        duration = {
                            ms: input._milliseconds,
                            d: input._days,
                            M: input._months
                        };
                    } else if (isNumber(input)) {
                        duration = {};
                        if (key) {
                            duration[key] = input;
                        } else {
                            duration.milliseconds = input;
                        }
                    } else if (!!(match = aspNetRegex.exec(input))) {
                        sign = (match[1] === '-') ? -1 : 1;
                        duration = {
                            y: 0,
                            d: toInt(match[DATE]) * sign,
                            h: toInt(match[HOUR]) * sign,
                            m: toInt(match[MINUTE]) * sign,
                            s: toInt(match[SECOND]) * sign,
                            ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
                        };
                    } else if (!!(match = isoRegex.exec(input))) {
                        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
                        duration = {
                            y: parseIso(match[2], sign),
                            M: parseIso(match[3], sign),
                            w: parseIso(match[4], sign),
                            d: parseIso(match[5], sign),
                            h: parseIso(match[6], sign),
                            m: parseIso(match[7], sign),
                            s: parseIso(match[8], sign)
                        };
                    } else if (duration == null) {// checks for null or undefined
                        duration = {};
                    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
                        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

                        duration = {};
                        duration.ms = diffRes.milliseconds;
                        duration.M = diffRes.months;
                    }

                    ret = new Duration(duration);

                    if (isDuration(input) && hasOwnProp(input, '_locale')) {
                        ret._locale = input._locale;
                    }

                    return ret;
                }

                createDuration.fn = Duration.prototype;
                createDuration.invalid = createInvalid$1;

                function parseIso(inp, sign) {
                    // We'd normally use ~~inp for this, but unfortunately it also
                    // converts floats to ints.
                    // inp may be undefined, so careful calling replace on it.
                    var res = inp && parseFloat(inp.replace(',', '.'));
                    // apply sign while we're at it
                    return (isNaN(res) ? 0 : res) * sign;
                }

                function positiveMomentsDifference(base, other) {
                    var res = {milliseconds: 0, months: 0};

                    res.months = other.month() - base.month() +
                        (other.year() - base.year()) * 12;
                    if (base.clone().add(res.months, 'M').isAfter(other)) {
                        --res.months;
                    }

                    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

                    return res;
                }

                function momentsDifference(base, other) {
                    var res;
                    if (!(base.isValid() && other.isValid())) {
                        return {milliseconds: 0, months: 0};
                    }

                    other = cloneWithOffset(other, base);
                    if (base.isBefore(other)) {
                        res = positiveMomentsDifference(base, other);
                    } else {
                        res = positiveMomentsDifference(other, base);
                        res.milliseconds = -res.milliseconds;
                        res.months = -res.months;
                    }

                    return res;
                }

                // TODO: remove 'name' arg after deprecation is removed
                function createAdder(direction, name) {
                    return function (val, period) {
                        var dur, tmp;
                        //invert the arguments, but complain about it
                        if (period !== null && !isNaN(+period)) {
                            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                            tmp = val;
                            val = period;
                            period = tmp;
                        }

                        val = typeof val === 'string' ? +val : val;
                        dur = createDuration(val, period);
                        addSubtract(this, dur, direction);
                        return this;
                    };
                }

                function addSubtract(mom, duration, isAdding, updateOffset) {
                    var milliseconds = duration._milliseconds,
                        days = absRound(duration._days),
                        months = absRound(duration._months);

                    if (!mom.isValid()) {
                        // No op
                        return;
                    }

                    updateOffset = updateOffset == null ? true : updateOffset;

                    if (months) {
                        setMonth(mom, get(mom, 'Month') + months * isAdding);
                    }
                    if (days) {
                        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
                    }
                    if (milliseconds) {
                        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
                    }
                    if (updateOffset) {
                        hooks.updateOffset(mom, days || months);
                    }
                }

                var add = createAdder(1, 'add');
                var subtract = createAdder(-1, 'subtract');

                function getCalendarFormat(myMoment, now) {
                    var diff = myMoment.diff(now, 'days', true);
                    return diff < -6 ? 'sameElse' :
                        diff < -1 ? 'lastWeek' :
                            diff < 0 ? 'lastDay' :
                                diff < 1 ? 'sameDay' :
                                    diff < 2 ? 'nextDay' :
                                        diff < 7 ? 'nextWeek' : 'sameElse';
                }

                function calendar$1(time, formats) {
                    // We want to compare the start of today, vs this.
                    // Getting start-of-today depends on whether we're local/utc/offset or not.
                    var now = time || createLocal(),
                        sod = cloneWithOffset(now, this).startOf('day'),
                        format = hooks.calendarFormat(this, sod) || 'sameElse';

                    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

                    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
                }

                function clone() {
                    return new Moment(this);
                }

                function isAfter(input, units) {
                    var localInput = isMoment(input) ? input : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                    if (units === 'millisecond') {
                        return this.valueOf() > localInput.valueOf();
                    } else {
                        return localInput.valueOf() < this.clone().startOf(units).valueOf();
                    }
                }

                function isBefore(input, units) {
                    var localInput = isMoment(input) ? input : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                    if (units === 'millisecond') {
                        return this.valueOf() < localInput.valueOf();
                    } else {
                        return this.clone().endOf(units).valueOf() < localInput.valueOf();
                    }
                }

                function isBetween(from, to, units, inclusivity) {
                    inclusivity = inclusivity || '()';
                    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
                        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
                }

                function isSame(input, units) {
                    var localInput = isMoment(input) ? input : createLocal(input),
                        inputMs;
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(units || 'millisecond');
                    if (units === 'millisecond') {
                        return this.valueOf() === localInput.valueOf();
                    } else {
                        inputMs = localInput.valueOf();
                        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                    }
                }

                function isSameOrAfter(input, units) {
                    return this.isSame(input, units) || this.isAfter(input, units);
                }

                function isSameOrBefore(input, units) {
                    return this.isSame(input, units) || this.isBefore(input, units);
                }

                function diff(input, units, asFloat) {
                    var that,
                        zoneDelta,
                        output;

                    if (!this.isValid()) {
                        return NaN;
                    }

                    that = cloneWithOffset(input, this);

                    if (!that.isValid()) {
                        return NaN;
                    }

                    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

                    units = normalizeUnits(units);

                    switch (units) {
                        case 'year':
                            output = monthDiff(this, that) / 12;
                            break;
                        case 'month':
                            output = monthDiff(this, that);
                            break;
                        case 'quarter':
                            output = monthDiff(this, that) / 3;
                            break;
                        case 'second':
                            output = (this - that) / 1e3;
                            break; // 1000
                        case 'minute':
                            output = (this - that) / 6e4;
                            break; // 1000 * 60
                        case 'hour':
                            output = (this - that) / 36e5;
                            break; // 1000 * 60 * 60
                        case 'day':
                            output = (this - that - zoneDelta) / 864e5;
                            break; // 1000 * 60 * 60 * 24, negate dst
                        case 'week':
                            output = (this - that - zoneDelta) / 6048e5;
                            break; // 1000 * 60 * 60 * 24 * 7, negate dst
                        default:
                            output = this - that;
                    }

                    return asFloat ? output : absFloor(output);
                }

                function monthDiff(a, b) {
                    // difference in months
                    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
                        // b is in (anchor - 1 month, anchor + 1 month)
                        anchor = a.clone().add(wholeMonthDiff, 'months'),
                        anchor2, adjust;

                    if (b - anchor < 0) {
                        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                        // linear across the month
                        adjust = (b - anchor) / (anchor - anchor2);
                    } else {
                        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                        // linear across the month
                        adjust = (b - anchor) / (anchor2 - anchor);
                    }

                    //check for negative zero, return zero if negative zero
                    return -(wholeMonthDiff + adjust) || 0;
                }

                hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
                hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

                function toString() {
                    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
                }

                function toISOString(keepOffset) {
                    if (!this.isValid()) {
                        return null;
                    }
                    var utc = keepOffset !== true;
                    var m = utc ? this.clone().utc() : this;
                    if (m.year() < 0 || m.year() > 9999) {
                        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
                    }
                    if (isFunction(Date.prototype.toISOString)) {
                        // native implementation is ~50x faster, use it when we can
                        if (utc) {
                            return this.toDate().toISOString();
                        } else {
                            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
                        }
                    }
                    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
                }

                /**
                 * Return a human readable representation of a moment that can
                 * also be evaluated to get a new moment which is the same
                 *
                 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
                 */
                function inspect() {
                    if (!this.isValid()) {
                        return 'moment.invalid(/* ' + this._i + ' */)';
                    }
                    var func = 'moment';
                    var zone = '';
                    if (!this.isLocal()) {
                        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                        zone = 'Z';
                    }
                    var prefix = '[' + func + '("]';
                    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
                    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
                    var suffix = zone + '[")]';

                    return this.format(prefix + year + datetime + suffix);
                }

                function format(inputString) {
                    if (!inputString) {
                        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
                    }
                    var output = formatMoment(this, inputString);
                    return this.localeData().postformat(output);
                }

                function from(time, withoutSuffix) {
                    if (this.isValid() &&
                        ((isMoment(time) && time.isValid()) ||
                            createLocal(time).isValid())) {
                        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
                    } else {
                        return this.localeData().invalidDate();
                    }
                }

                function fromNow(withoutSuffix) {
                    return this.from(createLocal(), withoutSuffix);
                }

                function to(time, withoutSuffix) {
                    if (this.isValid() &&
                        ((isMoment(time) && time.isValid()) ||
                            createLocal(time).isValid())) {
                        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
                    } else {
                        return this.localeData().invalidDate();
                    }
                }

                function toNow(withoutSuffix) {
                    return this.to(createLocal(), withoutSuffix);
                }

                // If passed a locale key, it will set the locale for this
                // instance.  Otherwise, it will return the locale configuration
                // variables for this instance.
                function locale(key) {
                    var newLocaleData;

                    if (key === undefined) {
                        return this._locale._abbr;
                    } else {
                        newLocaleData = getLocale(key);
                        if (newLocaleData != null) {
                            this._locale = newLocaleData;
                        }
                        return this;
                    }
                }

                var lang = deprecate(
                    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
                    function (key) {
                        if (key === undefined) {
                            return this.localeData();
                        } else {
                            return this.locale(key);
                        }
                    }
                );

                function localeData() {
                    return this._locale;
                }

                function startOf(units) {
                    units = normalizeUnits(units);
                    // the following switch intentionally omits break keywords
                    // to utilize falling through the cases.
                    switch (units) {
                        case 'year':
                            this.month(0);
                        /* falls through */
                        case 'quarter':
                        case 'month':
                            this.date(1);
                        /* falls through */
                        case 'week':
                        case 'isoWeek':
                        case 'day':
                        case 'date':
                            this.hours(0);
                        /* falls through */
                        case 'hour':
                            this.minutes(0);
                        /* falls through */
                        case 'minute':
                            this.seconds(0);
                        /* falls through */
                        case 'second':
                            this.milliseconds(0);
                    }

                    // weeks are a special case
                    if (units === 'week') {
                        this.weekday(0);
                    }
                    if (units === 'isoWeek') {
                        this.isoWeekday(1);
                    }

                    // quarters are also special
                    if (units === 'quarter') {
                        this.month(Math.floor(this.month() / 3) * 3);
                    }

                    return this;
                }

                function endOf(units) {
                    units = normalizeUnits(units);
                    if (units === undefined || units === 'millisecond') {
                        return this;
                    }

                    // 'date' is an alias for 'day', so it should be considered as such.
                    if (units === 'date') {
                        units = 'day';
                    }

                    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
                }

                function valueOf() {
                    return this._d.valueOf() - ((this._offset || 0) * 60000);
                }

                function unix() {
                    return Math.floor(this.valueOf() / 1000);
                }

                function toDate() {
                    return new Date(this.valueOf());
                }

                function toArray() {
                    var m = this;
                    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
                }

                function toObject() {
                    var m = this;
                    return {
                        years: m.year(),
                        months: m.month(),
                        date: m.date(),
                        hours: m.hours(),
                        minutes: m.minutes(),
                        seconds: m.seconds(),
                        milliseconds: m.milliseconds()
                    };
                }

                function toJSON() {
                    // new Date(NaN).toJSON() === null
                    return this.isValid() ? this.toISOString() : null;
                }

                function isValid$2() {
                    return isValid(this);
                }

                function parsingFlags() {
                    return extend({}, getParsingFlags(this));
                }

                function invalidAt() {
                    return getParsingFlags(this).overflow;
                }

                function creationData() {
                    return {
                        input: this._i,
                        format: this._f,
                        locale: this._locale,
                        isUTC: this._isUTC,
                        strict: this._strict
                    };
                }

                // FORMATTING

                addFormatToken(0, ['gg', 2], 0, function () {
                    return this.weekYear() % 100;
                });

                addFormatToken(0, ['GG', 2], 0, function () {
                    return this.isoWeekYear() % 100;
                });

                function addWeekYearFormatToken(token, getter) {
                    addFormatToken(0, [token, token.length], 0, getter);
                }

                addWeekYearFormatToken('gggg', 'weekYear');
                addWeekYearFormatToken('ggggg', 'weekYear');
                addWeekYearFormatToken('GGGG', 'isoWeekYear');
                addWeekYearFormatToken('GGGGG', 'isoWeekYear');

                // ALIASES

                addUnitAlias('weekYear', 'gg');
                addUnitAlias('isoWeekYear', 'GG');

                // PRIORITY

                addUnitPriority('weekYear', 1);
                addUnitPriority('isoWeekYear', 1);


                // PARSING

                addRegexToken('G', matchSigned);
                addRegexToken('g', matchSigned);
                addRegexToken('GG', match1to2, match2);
                addRegexToken('gg', match1to2, match2);
                addRegexToken('GGGG', match1to4, match4);
                addRegexToken('gggg', match1to4, match4);
                addRegexToken('GGGGG', match1to6, match6);
                addRegexToken('ggggg', match1to6, match6);

                addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
                    week[token.substr(0, 2)] = toInt(input);
                });

                addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
                    week[token] = hooks.parseTwoDigitYear(input);
                });

                // MOMENTS

                function getSetWeekYear(input) {
                    return getSetWeekYearHelper.call(this,
                        input,
                        this.week(),
                        this.weekday(),
                        this.localeData()._week.dow,
                        this.localeData()._week.doy);
                }

                function getSetISOWeekYear(input) {
                    return getSetWeekYearHelper.call(this,
                        input, this.isoWeek(), this.isoWeekday(), 1, 4);
                }

                function getISOWeeksInYear() {
                    return weeksInYear(this.year(), 1, 4);
                }

                function getWeeksInYear() {
                    var weekInfo = this.localeData()._week;
                    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                }

                function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                    var weeksTarget;
                    if (input == null) {
                        return weekOfYear(this, dow, doy).year;
                    } else {
                        weeksTarget = weeksInYear(input, dow, doy);
                        if (week > weeksTarget) {
                            week = weeksTarget;
                        }
                        return setWeekAll.call(this, input, week, weekday, dow, doy);
                    }
                }

                function setWeekAll(weekYear, week, weekday, dow, doy) {
                    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

                    this.year(date.getUTCFullYear());
                    this.month(date.getUTCMonth());
                    this.date(date.getUTCDate());
                    return this;
                }

                // FORMATTING

                addFormatToken('Q', 0, 'Qo', 'quarter');

                // ALIASES

                addUnitAlias('quarter', 'Q');

                // PRIORITY

                addUnitPriority('quarter', 7);

                // PARSING

                addRegexToken('Q', match1);
                addParseToken('Q', function (input, array) {
                    array[MONTH] = (toInt(input) - 1) * 3;
                });

                // MOMENTS

                function getSetQuarter(input) {
                    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
                }

                // FORMATTING

                addFormatToken('D', ['DD', 2], 'Do', 'date');

                // ALIASES

                addUnitAlias('date', 'D');

                // PRIORITY
                addUnitPriority('date', 9);

                // PARSING

                addRegexToken('D', match1to2);
                addRegexToken('DD', match1to2, match2);
                addRegexToken('Do', function (isStrict, locale) {
                    // TODO: Remove "ordinalParse" fallback in next major release.
                    return isStrict ?
                        (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
                        locale._dayOfMonthOrdinalParseLenient;
                });

                addParseToken(['D', 'DD'], DATE);
                addParseToken('Do', function (input, array) {
                    array[DATE] = toInt(input.match(match1to2)[0]);
                });

                // MOMENTS

                var getSetDayOfMonth = makeGetSet('Date', true);

                // FORMATTING

                addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

                // ALIASES

                addUnitAlias('dayOfYear', 'DDD');

                // PRIORITY
                addUnitPriority('dayOfYear', 4);

                // PARSING

                addRegexToken('DDD', match1to3);
                addRegexToken('DDDD', match3);
                addParseToken(['DDD', 'DDDD'], function (input, array, config) {
                    config._dayOfYear = toInt(input);
                });

                // HELPERS

                // MOMENTS

                function getSetDayOfYear(input) {
                    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
                    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
                }

                // FORMATTING

                addFormatToken('m', ['mm', 2], 0, 'minute');

                // ALIASES

                addUnitAlias('minute', 'm');

                // PRIORITY

                addUnitPriority('minute', 14);

                // PARSING

                addRegexToken('m', match1to2);
                addRegexToken('mm', match1to2, match2);
                addParseToken(['m', 'mm'], MINUTE);

                // MOMENTS

                var getSetMinute = makeGetSet('Minutes', false);

                // FORMATTING

                addFormatToken('s', ['ss', 2], 0, 'second');

                // ALIASES

                addUnitAlias('second', 's');

                // PRIORITY

                addUnitPriority('second', 15);

                // PARSING

                addRegexToken('s', match1to2);
                addRegexToken('ss', match1to2, match2);
                addParseToken(['s', 'ss'], SECOND);

                // MOMENTS

                var getSetSecond = makeGetSet('Seconds', false);

                // FORMATTING

                addFormatToken('S', 0, 0, function () {
                    return ~~(this.millisecond() / 100);
                });

                addFormatToken(0, ['SS', 2], 0, function () {
                    return ~~(this.millisecond() / 10);
                });

                addFormatToken(0, ['SSS', 3], 0, 'millisecond');
                addFormatToken(0, ['SSSS', 4], 0, function () {
                    return this.millisecond() * 10;
                });
                addFormatToken(0, ['SSSSS', 5], 0, function () {
                    return this.millisecond() * 100;
                });
                addFormatToken(0, ['SSSSSS', 6], 0, function () {
                    return this.millisecond() * 1000;
                });
                addFormatToken(0, ['SSSSSSS', 7], 0, function () {
                    return this.millisecond() * 10000;
                });
                addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
                    return this.millisecond() * 100000;
                });
                addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
                    return this.millisecond() * 1000000;
                });


                // ALIASES

                addUnitAlias('millisecond', 'ms');

                // PRIORITY

                addUnitPriority('millisecond', 16);

                // PARSING

                addRegexToken('S', match1to3, match1);
                addRegexToken('SS', match1to3, match2);
                addRegexToken('SSS', match1to3, match3);

                var token;
                for (token = 'SSSS'; token.length <= 9; token += 'S') {
                    addRegexToken(token, matchUnsigned);
                }

                function parseMs(input, array) {
                    array[MILLISECOND] = toInt(('0.' + input) * 1000);
                }

                for (token = 'S'; token.length <= 9; token += 'S') {
                    addParseToken(token, parseMs);
                }
                // MOMENTS

                var getSetMillisecond = makeGetSet('Milliseconds', false);

                // FORMATTING

                addFormatToken('z', 0, 0, 'zoneAbbr');
                addFormatToken('zz', 0, 0, 'zoneName');

                // MOMENTS

                function getZoneAbbr() {
                    return this._isUTC ? 'UTC' : '';
                }

                function getZoneName() {
                    return this._isUTC ? 'Coordinated Universal Time' : '';
                }

                var proto = Moment.prototype;

                proto.add = add;
                proto.calendar = calendar$1;
                proto.clone = clone;
                proto.diff = diff;
                proto.endOf = endOf;
                proto.format = format;
                proto.from = from;
                proto.fromNow = fromNow;
                proto.to = to;
                proto.toNow = toNow;
                proto.get = stringGet;
                proto.invalidAt = invalidAt;
                proto.isAfter = isAfter;
                proto.isBefore = isBefore;
                proto.isBetween = isBetween;
                proto.isSame = isSame;
                proto.isSameOrAfter = isSameOrAfter;
                proto.isSameOrBefore = isSameOrBefore;
                proto.isValid = isValid$2;
                proto.lang = lang;
                proto.locale = locale;
                proto.localeData = localeData;
                proto.max = prototypeMax;
                proto.min = prototypeMin;
                proto.parsingFlags = parsingFlags;
                proto.set = stringSet;
                proto.startOf = startOf;
                proto.subtract = subtract;
                proto.toArray = toArray;
                proto.toObject = toObject;
                proto.toDate = toDate;
                proto.toISOString = toISOString;
                proto.inspect = inspect;
                proto.toJSON = toJSON;
                proto.toString = toString;
                proto.unix = unix;
                proto.valueOf = valueOf;
                proto.creationData = creationData;
                proto.year = getSetYear;
                proto.isLeapYear = getIsLeapYear;
                proto.weekYear = getSetWeekYear;
                proto.isoWeekYear = getSetISOWeekYear;
                proto.quarter = proto.quarters = getSetQuarter;
                proto.month = getSetMonth;
                proto.daysInMonth = getDaysInMonth;
                proto.week = proto.weeks = getSetWeek;
                proto.isoWeek = proto.isoWeeks = getSetISOWeek;
                proto.weeksInYear = getWeeksInYear;
                proto.isoWeeksInYear = getISOWeeksInYear;
                proto.date = getSetDayOfMonth;
                proto.day = proto.days = getSetDayOfWeek;
                proto.weekday = getSetLocaleDayOfWeek;
                proto.isoWeekday = getSetISODayOfWeek;
                proto.dayOfYear = getSetDayOfYear;
                proto.hour = proto.hours = getSetHour;
                proto.minute = proto.minutes = getSetMinute;
                proto.second = proto.seconds = getSetSecond;
                proto.millisecond = proto.milliseconds = getSetMillisecond;
                proto.utcOffset = getSetOffset;
                proto.utc = setOffsetToUTC;
                proto.local = setOffsetToLocal;
                proto.parseZone = setOffsetToParsedOffset;
                proto.hasAlignedHourOffset = hasAlignedHourOffset;
                proto.isDST = isDaylightSavingTime;
                proto.isLocal = isLocal;
                proto.isUtcOffset = isUtcOffset;
                proto.isUtc = isUtc;
                proto.isUTC = isUtc;
                proto.zoneAbbr = getZoneAbbr;
                proto.zoneName = getZoneName;
                proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
                proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
                proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
                proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
                proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

                function createUnix(input) {
                    return createLocal(input * 1000);
                }

                function createInZone() {
                    return createLocal.apply(null, arguments).parseZone();
                }

                function preParsePostFormat(string) {
                    return string;
                }

                var proto$1 = Locale.prototype;

                proto$1.calendar = calendar;
                proto$1.longDateFormat = longDateFormat;
                proto$1.invalidDate = invalidDate;
                proto$1.ordinal = ordinal;
                proto$1.preparse = preParsePostFormat;
                proto$1.postformat = preParsePostFormat;
                proto$1.relativeTime = relativeTime;
                proto$1.pastFuture = pastFuture;
                proto$1.set = set;

                proto$1.months = localeMonths;
                proto$1.monthsShort = localeMonthsShort;
                proto$1.monthsParse = localeMonthsParse;
                proto$1.monthsRegex = monthsRegex;
                proto$1.monthsShortRegex = monthsShortRegex;
                proto$1.week = localeWeek;
                proto$1.firstDayOfYear = localeFirstDayOfYear;
                proto$1.firstDayOfWeek = localeFirstDayOfWeek;

                proto$1.weekdays = localeWeekdays;
                proto$1.weekdaysMin = localeWeekdaysMin;
                proto$1.weekdaysShort = localeWeekdaysShort;
                proto$1.weekdaysParse = localeWeekdaysParse;

                proto$1.weekdaysRegex = weekdaysRegex;
                proto$1.weekdaysShortRegex = weekdaysShortRegex;
                proto$1.weekdaysMinRegex = weekdaysMinRegex;

                proto$1.isPM = localeIsPM;
                proto$1.meridiem = localeMeridiem;

                function get$1(format, index, field, setter) {
                    var locale = getLocale();
                    var utc = createUTC().set(setter, index);
                    return locale[field](utc, format);
                }

                function listMonthsImpl(format, index, field) {
                    if (isNumber(format)) {
                        index = format;
                        format = undefined;
                    }

                    format = format || '';

                    if (index != null) {
                        return get$1(format, index, field, 'month');
                    }

                    var i;
                    var out = [];
                    for (i = 0; i < 12; i++) {
                        out[i] = get$1(format, i, field, 'month');
                    }
                    return out;
                }

                // ()
                // (5)
                // (fmt, 5)
                // (fmt)
                // (true)
                // (true, 5)
                // (true, fmt, 5)
                // (true, fmt)
                function listWeekdaysImpl(localeSorted, format, index, field) {
                    if (typeof localeSorted === 'boolean') {
                        if (isNumber(format)) {
                            index = format;
                            format = undefined;
                        }

                        format = format || '';
                    } else {
                        format = localeSorted;
                        index = format;
                        localeSorted = false;

                        if (isNumber(format)) {
                            index = format;
                            format = undefined;
                        }

                        format = format || '';
                    }

                    var locale = getLocale(),
                        shift = localeSorted ? locale._week.dow : 0;

                    if (index != null) {
                        return get$1(format, (index + shift) % 7, field, 'day');
                    }

                    var i;
                    var out = [];
                    for (i = 0; i < 7; i++) {
                        out[i] = get$1(format, (i + shift) % 7, field, 'day');
                    }
                    return out;
                }

                function listMonths(format, index) {
                    return listMonthsImpl(format, index, 'months');
                }

                function listMonthsShort(format, index) {
                    return listMonthsImpl(format, index, 'monthsShort');
                }

                function listWeekdays(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
                }

                function listWeekdaysShort(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
                }

                function listWeekdaysMin(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
                }

                getSetGlobalLocale('en', {
                    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: function (number) {
                        var b = number % 10,
                            output = (toInt(number % 100 / 10) === 1) ? 'th' :
                                (b === 1) ? 'st' :
                                    (b === 2) ? 'nd' :
                                        (b === 3) ? 'rd' : 'th';
                        return number + output;
                    }
                });

                // Side effect imports

                hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
                hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

                var mathAbs = Math.abs;

                function abs() {
                    var data = this._data;

                    this._milliseconds = mathAbs(this._milliseconds);
                    this._days = mathAbs(this._days);
                    this._months = mathAbs(this._months);

                    data.milliseconds = mathAbs(data.milliseconds);
                    data.seconds = mathAbs(data.seconds);
                    data.minutes = mathAbs(data.minutes);
                    data.hours = mathAbs(data.hours);
                    data.months = mathAbs(data.months);
                    data.years = mathAbs(data.years);

                    return this;
                }

                function addSubtract$1(duration, input, value, direction) {
                    var other = createDuration(input, value);

                    duration._milliseconds += direction * other._milliseconds;
                    duration._days += direction * other._days;
                    duration._months += direction * other._months;

                    return duration._bubble();
                }

                // supports only 2.0-style add(1, 's') or add(duration)
                function add$1(input, value) {
                    return addSubtract$1(this, input, value, 1);
                }

                // supports only 2.0-style subtract(1, 's') or subtract(duration)
                function subtract$1(input, value) {
                    return addSubtract$1(this, input, value, -1);
                }

                function absCeil(number) {
                    if (number < 0) {
                        return Math.floor(number);
                    } else {
                        return Math.ceil(number);
                    }
                }

                function bubble() {
                    var milliseconds = this._milliseconds;
                    var days = this._days;
                    var months = this._months;
                    var data = this._data;
                    var seconds, minutes, hours, years, monthsFromDays;

                    // if we have a mix of positive and negative values, bubble down first
                    // check: https://github.com/moment/moment/issues/2166
                    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                        (milliseconds <= 0 && days <= 0 && months <= 0))) {
                        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                        days = 0;
                        months = 0;
                    }

                    // The following code bubbles up values, see the tests for
                    // examples of what that means.
                    data.milliseconds = milliseconds % 1000;

                    seconds = absFloor(milliseconds / 1000);
                    data.seconds = seconds % 60;

                    minutes = absFloor(seconds / 60);
                    data.minutes = minutes % 60;

                    hours = absFloor(minutes / 60);
                    data.hours = hours % 24;

                    days += absFloor(hours / 24);

                    // convert days to months
                    monthsFromDays = absFloor(daysToMonths(days));
                    months += monthsFromDays;
                    days -= absCeil(monthsToDays(monthsFromDays));

                    // 12 months -> 1 year
                    years = absFloor(months / 12);
                    months %= 12;

                    data.days = days;
                    data.months = months;
                    data.years = years;

                    return this;
                }

                function daysToMonths(days) {
                    // 400 years have 146097 days (taking into account leap year rules)
                    // 400 years have 12 months === 4800
                    return days * 4800 / 146097;
                }

                function monthsToDays(months) {
                    // the reverse of daysToMonths
                    return months * 146097 / 4800;
                }

                function as(units) {
                    if (!this.isValid()) {
                        return NaN;
                    }
                    var days;
                    var months;
                    var milliseconds = this._milliseconds;

                    units = normalizeUnits(units);

                    if (units === 'month' || units === 'year') {
                        days = this._days + milliseconds / 864e5;
                        months = this._months + daysToMonths(days);
                        return units === 'month' ? months : months / 12;
                    } else {
                        // handle milliseconds separately because of floating point math errors (issue #1867)
                        days = this._days + Math.round(monthsToDays(this._months));
                        switch (units) {
                            case 'week'   :
                                return days / 7 + milliseconds / 6048e5;
                            case 'day'    :
                                return days + milliseconds / 864e5;
                            case 'hour'   :
                                return days * 24 + milliseconds / 36e5;
                            case 'minute' :
                                return days * 1440 + milliseconds / 6e4;
                            case 'second' :
                                return days * 86400 + milliseconds / 1000;
                            // Math.floor prevents floating point math errors here
                            case 'millisecond':
                                return Math.floor(days * 864e5) + milliseconds;
                            default:
                                throw new Error('Unknown unit ' + units);
                        }
                    }
                }

                // TODO: Use this.as('ms')?
                function valueOf$1() {
                    if (!this.isValid()) {
                        return NaN;
                    }
                    return (
                        this._milliseconds +
                        this._days * 864e5 +
                        (this._months % 12) * 2592e6 +
                        toInt(this._months / 12) * 31536e6
                    );
                }

                function makeAs(alias) {
                    return function () {
                        return this.as(alias);
                    };
                }

                var asMilliseconds = makeAs('ms');
                var asSeconds = makeAs('s');
                var asMinutes = makeAs('m');
                var asHours = makeAs('h');
                var asDays = makeAs('d');
                var asWeeks = makeAs('w');
                var asMonths = makeAs('M');
                var asYears = makeAs('y');

                function clone$1() {
                    return createDuration(this);
                }

                function get$2(units) {
                    units = normalizeUnits(units);
                    return this.isValid() ? this[units + 's']() : NaN;
                }

                function makeGetter(name) {
                    return function () {
                        return this.isValid() ? this._data[name] : NaN;
                    };
                }

                var milliseconds = makeGetter('milliseconds');
                var seconds = makeGetter('seconds');
                var minutes = makeGetter('minutes');
                var hours = makeGetter('hours');
                var days = makeGetter('days');
                var months = makeGetter('months');
                var years = makeGetter('years');

                function weeks() {
                    return absFloor(this.days() / 7);
                }

                var round = Math.round;
                var thresholds = {
                    ss: 44,         // a few seconds to seconds
                    s: 45,         // seconds to minute
                    m: 45,         // minutes to hour
                    h: 22,         // hours to day
                    d: 26,         // days to month
                    M: 11          // months to year
                };

                // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
                function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
                }

                function relativeTime$1(posNegDuration, withoutSuffix, locale) {
                    var duration = createDuration(posNegDuration).abs();
                    var seconds = round(duration.as('s'));
                    var minutes = round(duration.as('m'));
                    var hours = round(duration.as('h'));
                    var days = round(duration.as('d'));
                    var months = round(duration.as('M'));
                    var years = round(duration.as('y'));

                    var a = seconds <= thresholds.ss && ['s', seconds] ||
                        seconds < thresholds.s && ['ss', seconds] ||
                        minutes <= 1 && ['m'] ||
                        minutes < thresholds.m && ['mm', minutes] ||
                        hours <= 1 && ['h'] ||
                        hours < thresholds.h && ['hh', hours] ||
                        days <= 1 && ['d'] ||
                        days < thresholds.d && ['dd', days] ||
                        months <= 1 && ['M'] ||
                        months < thresholds.M && ['MM', months] ||
                        years <= 1 && ['y'] || ['yy', years];

                    a[2] = withoutSuffix;
                    a[3] = +posNegDuration > 0;
                    a[4] = locale;
                    return substituteTimeAgo.apply(null, a);
                }

                // This function allows you to set the rounding function for relative time strings
                function getSetRelativeTimeRounding(roundingFunction) {
                    if (roundingFunction === undefined) {
                        return round;
                    }
                    if (typeof(roundingFunction) === 'function') {
                        round = roundingFunction;
                        return true;
                    }
                    return false;
                }

                // This function allows you to set a threshold for relative time strings
                function getSetRelativeTimeThreshold(threshold, limit) {
                    if (thresholds[threshold] === undefined) {
                        return false;
                    }
                    if (limit === undefined) {
                        return thresholds[threshold];
                    }
                    thresholds[threshold] = limit;
                    if (threshold === 's') {
                        thresholds.ss = limit - 1;
                    }
                    return true;
                }

                function humanize(withSuffix) {
                    if (!this.isValid()) {
                        return this.localeData().invalidDate();
                    }

                    var locale = this.localeData();
                    var output = relativeTime$1(this, !withSuffix, locale);

                    if (withSuffix) {
                        output = locale.pastFuture(+this, output);
                    }

                    return locale.postformat(output);
                }

                var abs$1 = Math.abs;

                function sign(x) {
                    return ((x > 0) - (x < 0)) || +x;
                }

                function toISOString$1() {
                    // for ISO strings we do not use the normal bubbling rules:
                    //  * milliseconds bubble up until they become hours
                    //  * days do not bubble at all
                    //  * months bubble up until they become years
                    // This is because there is no context-free conversion between hours and days
                    // (think of clock changes)
                    // and also not between days and months (28-31 days per month)
                    if (!this.isValid()) {
                        return this.localeData().invalidDate();
                    }

                    var seconds = abs$1(this._milliseconds) / 1000;
                    var days = abs$1(this._days);
                    var months = abs$1(this._months);
                    var minutes, hours, years;

                    // 3600 seconds -> 60 minutes -> 1 hour
                    minutes = absFloor(seconds / 60);
                    hours = absFloor(minutes / 60);
                    seconds %= 60;
                    minutes %= 60;

                    // 12 months -> 1 year
                    years = absFloor(months / 12);
                    months %= 12;


                    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
                    var Y = years;
                    var M = months;
                    var D = days;
                    var h = hours;
                    var m = minutes;
                    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
                    var total = this.asSeconds();

                    if (!total) {
                        // this is the same as C#'s (Noda) and python (isodate)...
                        // but not other JS (goog.date)
                        return 'P0D';
                    }

                    var totalSign = total < 0 ? '-' : '';
                    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
                    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
                    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

                    return totalSign + 'P' +
                        (Y ? ymSign + Y + 'Y' : '') +
                        (M ? ymSign + M + 'M' : '') +
                        (D ? daysSign + D + 'D' : '') +
                        ((h || m || s) ? 'T' : '') +
                        (h ? hmsSign + h + 'H' : '') +
                        (m ? hmsSign + m + 'M' : '') +
                        (s ? hmsSign + s + 'S' : '');
                }

                var proto$2 = Duration.prototype;

                proto$2.isValid = isValid$1;
                proto$2.abs = abs;
                proto$2.add = add$1;
                proto$2.subtract = subtract$1;
                proto$2.as = as;
                proto$2.asMilliseconds = asMilliseconds;
                proto$2.asSeconds = asSeconds;
                proto$2.asMinutes = asMinutes;
                proto$2.asHours = asHours;
                proto$2.asDays = asDays;
                proto$2.asWeeks = asWeeks;
                proto$2.asMonths = asMonths;
                proto$2.asYears = asYears;
                proto$2.valueOf = valueOf$1;
                proto$2._bubble = bubble;
                proto$2.clone = clone$1;
                proto$2.get = get$2;
                proto$2.milliseconds = milliseconds;
                proto$2.seconds = seconds;
                proto$2.minutes = minutes;
                proto$2.hours = hours;
                proto$2.days = days;
                proto$2.weeks = weeks;
                proto$2.months = months;
                proto$2.years = years;
                proto$2.humanize = humanize;
                proto$2.toISOString = toISOString$1;
                proto$2.toString = toISOString$1;
                proto$2.toJSON = toISOString$1;
                proto$2.locale = locale;
                proto$2.localeData = localeData;

                proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
                proto$2.lang = lang;

                // Side effect imports

                // FORMATTING

                addFormatToken('X', 0, 0, 'unix');
                addFormatToken('x', 0, 0, 'valueOf');

                // PARSING

                addRegexToken('x', matchSigned);
                addRegexToken('X', matchTimestamp);
                addParseToken('X', function (input, array, config) {
                    config._d = new Date(parseFloat(input, 10) * 1000);
                });
                addParseToken('x', function (input, array, config) {
                    config._d = new Date(toInt(input));
                });

                // Side effect imports


                hooks.version = '2.22.2';

                setHookCallback(createLocal);

                hooks.fn = proto;
                hooks.min = min;
                hooks.max = max;
                hooks.now = now;
                hooks.utc = createUTC;
                hooks.unix = createUnix;
                hooks.months = listMonths;
                hooks.isDate = isDate;
                hooks.locale = getSetGlobalLocale;
                hooks.invalid = createInvalid;
                hooks.duration = createDuration;
                hooks.isMoment = isMoment;
                hooks.weekdays = listWeekdays;
                hooks.parseZone = createInZone;
                hooks.localeData = getLocale;
                hooks.isDuration = isDuration;
                hooks.monthsShort = listMonthsShort;
                hooks.weekdaysMin = listWeekdaysMin;
                hooks.defineLocale = defineLocale;
                hooks.updateLocale = updateLocale;
                hooks.locales = listLocales;
                hooks.weekdaysShort = listWeekdaysShort;
                hooks.normalizeUnits = normalizeUnits;
                hooks.relativeTimeRounding = getSetRelativeTimeRounding;
                hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
                hooks.calendarFormat = getCalendarFormat;
                hooks.prototype = proto;

                // currently HTML5 input type only supports 24-hour formats
                hooks.HTML5_FMT = {
                    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
                    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
                    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
                    DATE: 'YYYY-MM-DD',                             // <input type="date" />
                    TIME: 'HH:mm',                                  // <input type="time" />
                    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
                    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
                    WEEK: 'YYYY-[W]WW',                             // <input type="week" />
                    MONTH: 'YYYY-MM'                                // <input type="month" />
                };

                return hooks;

            })));

        }, {}],
        7: [function (require, module, exports) {
            /**
             * @namespace Chart
             */
            var Chart = require(30)();

            Chart.helpers = require(46);

// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
            require(28)(Chart);

            Chart.Animation = require(22);
            Chart.animationService = require(23);
            Chart.defaults = require(26);
            Chart.Element = require(27);
            Chart.elements = require(41);
            Chart.Interaction = require(29);
            Chart.layouts = require(31);
            Chart.platform = require(49);
            Chart.plugins = require(32);
            Chart.Scale = require(33);
            Chart.scaleService = require(34);
            Chart.Ticks = require(35);
            Chart.Tooltip = require(36);

            require(24)(Chart);
            require(25)(Chart);

            require(56)(Chart);
            require(54)(Chart);
            require(55)(Chart);
            require(57)(Chart);
            require(58)(Chart);
            require(59)(Chart);

// Controllers must be loaded after elements
// See Chart.core.datasetController.dataElementType
            require(15)(Chart);
            require(16)(Chart);
            require(17)(Chart);
            require(18)(Chart);
            require(19)(Chart);
            require(20)(Chart);
            require(21)(Chart);

            require(8)(Chart);
            require(9)(Chart);
            require(10)(Chart);
            require(11)(Chart);
            require(12)(Chart);
            require(13)(Chart);
            require(14)(Chart);

// Loading built-in plugins
            var plugins = require(50);
            for (var k in plugins) {
                if (plugins.hasOwnProperty(k)) {
                    Chart.plugins.register(plugins[k]);
                }
            }

            Chart.platform.initialize();

            module.exports = Chart;
            if (typeof window !== 'undefined') {
                window.Chart = Chart;
            }

// DEPRECATIONS

            /**
             * Provided for backward compatibility, not available anymore
             * @namespace Chart.Legend
             * @deprecated since version 2.1.5
             * @todo remove at version 3
             * @private
             */
            Chart.Legend = plugins.legend._element;

            /**
             * Provided for backward compatibility, not available anymore
             * @namespace Chart.Title
             * @deprecated since version 2.1.5
             * @todo remove at version 3
             * @private
             */
            Chart.Title = plugins.title._element;

            /**
             * Provided for backward compatibility, use Chart.plugins instead
             * @namespace Chart.pluginService
             * @deprecated since version 2.1.5
             * @todo remove at version 3
             * @private
             */
            Chart.pluginService = Chart.plugins;

            /**
             * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
             * effect, instead simply create/register plugins via plain JavaScript objects.
             * @interface Chart.PluginBase
             * @deprecated since version 2.5.0
             * @todo remove at version 3
             * @private
             */
            Chart.PluginBase = Chart.Element.extend({});

            /**
             * Provided for backward compatibility, use Chart.helpers.canvas instead.
             * @namespace Chart.canvasHelpers
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             * @private
             */
            Chart.canvasHelpers = Chart.helpers.canvas;

            /**
             * Provided for backward compatibility, use Chart.layouts instead.
             * @namespace Chart.layoutService
             * @deprecated since version 2.8.0
             * @todo remove at version 3
             * @private
             */
            Chart.layoutService = Chart.layouts;

        }, {
            "10": 10,
            "11": 11,
            "12": 12,
            "13": 13,
            "14": 14,
            "15": 15,
            "16": 16,
            "17": 17,
            "18": 18,
            "19": 19,
            "20": 20,
            "21": 21,
            "22": 22,
            "23": 23,
            "24": 24,
            "25": 25,
            "26": 26,
            "27": 27,
            "28": 28,
            "29": 29,
            "30": 30,
            "31": 31,
            "32": 32,
            "33": 33,
            "34": 34,
            "35": 35,
            "36": 36,
            "41": 41,
            "46": 46,
            "49": 49,
            "50": 50,
            "54": 54,
            "55": 55,
            "56": 56,
            "57": 57,
            "58": 58,
            "59": 59,
            "8": 8,
            "9": 9
        }],
        8: [function (require, module, exports) {
            'use strict';

            module.exports = function (Chart) {

                Chart.Bar = function (context, config) {
                    config.type = 'bar';

                    return new Chart(context, config);
                };

            };

        }, {}],
        9: [function (require, module, exports) {
            'use strict';

            module.exports = function (Chart) {

                Chart.Bubble = function (context, config) {
                    config.type = 'bubble';
                    return new Chart(context, config);
                };

            };

        }, {}],
        10: [function (require, module, exports) {
            'use strict';

            module.exports = function (Chart) {

                Chart.Doughnut = function (context, config) {
                    config.type = 'doughnut';

                    return new Chart(context, config);
                };

            };

        }, {}],
        11: [function (require, module, exports) {
            'use strict';

            module.exports = function (Chart) {

                Chart.Line = function (context, config) {
                    config.type = 'line';

                    return new Chart(context, config);
                };

            };

        }, {}],
        12: [function (require, module, exports) {
            'use strict';

            module.exports = function (Chart) {

                Chart.PolarArea = function (context, config) {
                    config.type = 'polarArea';

                    return new Chart(context, config);
                };

            };

        }, {}],
        13: [function (require, module, exports) {
            'use strict';

            module.exports = function (Chart) {

                Chart.Radar = function (context, config) {
                    config.type = 'radar';

                    return new Chart(context, config);
                };

            };

        }, {}],
        14: [function (require, module, exports) {
            'use strict';

            module.exports = function (Chart) {
                Chart.Scatter = function (context, config) {
                    config.type = 'scatter';
                    return new Chart(context, config);
                };
            };

        }, {}],
        15: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var elements = require(41);
            var helpers = require(46);

            defaults._set('bar', {
                hover: {
                    mode: 'label'
                },

                scales: {
                    xAxes: [{
                        type: 'category',

                        // Specific to Bar Controller
                        categoryPercentage: 0.8,
                        barPercentage: 0.9,

                        // offset settings
                        offset: true,

                        // grid line settings
                        gridLines: {
                            offsetGridLines: true
                        }
                    }],

                    yAxes: [{
                        type: 'linear'
                    }]
                }
            });

            defaults._set('horizontalBar', {
                hover: {
                    mode: 'index',
                    axis: 'y'
                },

                scales: {
                    xAxes: [{
                        type: 'linear',
                        position: 'bottom'
                    }],

                    yAxes: [{
                        position: 'left',
                        type: 'category',

                        // Specific to Horizontal Bar Controller
                        categoryPercentage: 0.8,
                        barPercentage: 0.9,

                        // offset settings
                        offset: true,

                        // grid line settings
                        gridLines: {
                            offsetGridLines: true
                        }
                    }]
                },

                elements: {
                    rectangle: {
                        borderSkipped: 'left'
                    }
                },

                tooltips: {
                    callbacks: {
                        title: function (item, data) {
                            // Pick first xLabel for now
                            var title = '';

                            if (item.length > 0) {
                                if (item[0].yLabel) {
                                    title = item[0].yLabel;
                                } else if (data.labels.length > 0 && item[0].index < data.labels.length) {
                                    title = data.labels[item[0].index];
                                }
                            }

                            return title;
                        },

                        label: function (item, data) {
                            var datasetLabel = data.datasets[item.datasetIndex].label || '';
                            return datasetLabel + ': ' + item.xLabel;
                        }
                    },
                    mode: 'index',
                    axis: 'y'
                }
            });

            /**
             * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
             * @private
             */
            function computeMinSampleSize(scale, pixels) {
                var min = scale.isHorizontal() ? scale.width : scale.height;
                var ticks = scale.getTicks();
                var prev, curr, i, ilen;

                for (i = 1, ilen = pixels.length; i < ilen; ++i) {
                    min = Math.min(min, pixels[i] - pixels[i - 1]);
                }

                for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                    curr = scale.getPixelForTick(i);
                    min = i > 0 ? Math.min(min, curr - prev) : min;
                    prev = curr;
                }

                return min;
            }

            /**
             * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
             * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
             * mode currently always generates bars equally sized (until we introduce scriptable options?).
             * @private
             */
            function computeFitCategoryTraits(index, ruler, options) {
                var thickness = options.barThickness;
                var count = ruler.stackCount;
                var curr = ruler.pixels[index];
                var size, ratio;

                if (helpers.isNullOrUndef(thickness)) {
                    size = ruler.min * options.categoryPercentage;
                    ratio = options.barPercentage;
                } else {
                    // When bar thickness is enforced, category and bar percentages are ignored.
                    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
                    // and deprecate barPercentage since this value is ignored when thickness is absolute.
                    size = thickness * count;
                    ratio = 1;
                }

                return {
                    chunk: size / count,
                    ratio: ratio,
                    start: curr - (size / 2)
                };
            }

            /**
             * Computes an "optimal" category that globally arranges bars side by side (no gap when
             * percentage options are 1), based on the previous and following categories. This mode
             * generates bars with different widths when data are not evenly spaced.
             * @private
             */
            function computeFlexCategoryTraits(index, ruler, options) {
                var pixels = ruler.pixels;
                var curr = pixels[index];
                var prev = index > 0 ? pixels[index - 1] : null;
                var next = index < pixels.length - 1 ? pixels[index + 1] : null;
                var percent = options.categoryPercentage;
                var start, size;

                if (prev === null) {
                    // first data: its size is double based on the next point or,
                    // if it's also the last data, we use the scale end extremity.
                    prev = curr - (next === null ? ruler.end - curr : next - curr);
                }

                if (next === null) {
                    // last data: its size is also double based on the previous point.
                    next = curr + curr - prev;
                }

                start = curr - ((curr - prev) / 2) * percent;
                size = ((next - prev) / 2) * percent;

                return {
                    chunk: size / ruler.stackCount,
                    ratio: options.barPercentage,
                    start: start
                };
            }

            module.exports = function (Chart) {

                Chart.controllers.bar = Chart.DatasetController.extend({

                    dataElementType: elements.Rectangle,

                    initialize: function () {
                        var me = this;
                        var meta;

                        Chart.DatasetController.prototype.initialize.apply(me, arguments);

                        meta = me.getMeta();
                        meta.stack = me.getDataset().stack;
                        meta.bar = true;
                    },

                    update: function (reset) {
                        var me = this;
                        var rects = me.getMeta().data;
                        var i, ilen;

                        me._ruler = me.getRuler();

                        for (i = 0, ilen = rects.length; i < ilen; ++i) {
                            me.updateElement(rects[i], i, reset);
                        }
                    },

                    updateElement: function (rectangle, index, reset) {
                        var me = this;
                        var chart = me.chart;
                        var meta = me.getMeta();
                        var dataset = me.getDataset();
                        var custom = rectangle.custom || {};
                        var rectangleOptions = chart.options.elements.rectangle;

                        rectangle._xScale = me.getScaleForId(meta.xAxisID);
                        rectangle._yScale = me.getScaleForId(meta.yAxisID);
                        rectangle._datasetIndex = me.index;
                        rectangle._index = index;

                        rectangle._model = {
                            datasetLabel: dataset.label,
                            label: chart.data.labels[index],
                            borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
                            backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
                            borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
                            borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
                        };

                        me.updateElementGeometry(rectangle, index, reset);

                        rectangle.pivot();
                    },

                    /**
                     * @private
                     */
                    updateElementGeometry: function (rectangle, index, reset) {
                        var me = this;
                        var model = rectangle._model;
                        var vscale = me.getValueScale();
                        var base = vscale.getBasePixel();
                        var horizontal = vscale.isHorizontal();
                        var ruler = me._ruler || me.getRuler();
                        var vpixels = me.calculateBarValuePixels(me.index, index);
                        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

                        model.horizontal = horizontal;
                        model.base = reset ? base : vpixels.base;
                        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
                        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
                        model.height = horizontal ? ipixels.size : undefined;
                        model.width = horizontal ? undefined : ipixels.size;
                    },

                    /**
                     * @private
                     */
                    getValueScaleId: function () {
                        return this.getMeta().yAxisID;
                    },

                    /**
                     * @private
                     */
                    getIndexScaleId: function () {
                        return this.getMeta().xAxisID;
                    },

                    /**
                     * @private
                     */
                    getValueScale: function () {
                        return this.getScaleForId(this.getValueScaleId());
                    },

                    /**
                     * @private
                     */
                    getIndexScale: function () {
                        return this.getScaleForId(this.getIndexScaleId());
                    },

                    /**
                     * Returns the stacks based on groups and bar visibility.
                     * @param {Number} [last] - The dataset index
                     * @returns {Array} The stack list
                     * @private
                     */
                    _getStacks: function (last) {
                        var me = this;
                        var chart = me.chart;
                        var scale = me.getIndexScale();
                        var stacked = scale.options.stacked;
                        var ilen = last === undefined ? chart.data.datasets.length : last + 1;
                        var stacks = [];
                        var i, meta;

                        for (i = 0; i < ilen; ++i) {
                            meta = chart.getDatasetMeta(i);
                            if (meta.bar && chart.isDatasetVisible(i) &&
                                (stacked === false ||
                                    (stacked === true && stacks.indexOf(meta.stack) === -1) ||
                                    (stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
                                stacks.push(meta.stack);
                            }
                        }

                        return stacks;
                    },

                    /**
                     * Returns the effective number of stacks based on groups and bar visibility.
                     * @private
                     */
                    getStackCount: function () {
                        return this._getStacks().length;
                    },

                    /**
                     * Returns the stack index for the given dataset based on groups and bar visibility.
                     * @param {Number} [datasetIndex] - The dataset index
                     * @param {String} [name] - The stack name to find
                     * @returns {Number} The stack index
                     * @private
                     */
                    getStackIndex: function (datasetIndex, name) {
                        var stacks = this._getStacks(datasetIndex);
                        var index = (name !== undefined)
                            ? stacks.indexOf(name)
                            : -1; // indexOf returns -1 if element is not present

                        return (index === -1)
                            ? stacks.length - 1
                            : index;
                    },

                    /**
                     * @private
                     */
                    getRuler: function () {
                        var me = this;
                        var scale = me.getIndexScale();
                        var stackCount = me.getStackCount();
                        var datasetIndex = me.index;
                        var isHorizontal = scale.isHorizontal();
                        var start = isHorizontal ? scale.left : scale.top;
                        var end = start + (isHorizontal ? scale.width : scale.height);
                        var pixels = [];
                        var i, ilen, min;

                        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
                            pixels.push(scale.getPixelForValue(null, i, datasetIndex));
                        }

                        min = helpers.isNullOrUndef(scale.options.barThickness)
                            ? computeMinSampleSize(scale, pixels)
                            : -1;

                        return {
                            min: min,
                            pixels: pixels,
                            start: start,
                            end: end,
                            stackCount: stackCount,
                            scale: scale
                        };
                    },

                    /**
                     * Note: pixel values are not clamped to the scale area.
                     * @private
                     */
                    calculateBarValuePixels: function (datasetIndex, index) {
                        var me = this;
                        var chart = me.chart;
                        var meta = me.getMeta();
                        var scale = me.getValueScale();
                        var datasets = chart.data.datasets;
                        var value = scale.getRightValue(datasets[datasetIndex].data[index]);
                        var stacked = scale.options.stacked;
                        var stack = meta.stack;
                        var start = 0;
                        var i, imeta, ivalue, base, head, size;

                        if (stacked || (stacked === undefined && stack !== undefined)) {
                            for (i = 0; i < datasetIndex; ++i) {
                                imeta = chart.getDatasetMeta(i);

                                if (imeta.bar &&
                                    imeta.stack === stack &&
                                    imeta.controller.getValueScaleId() === scale.id &&
                                    chart.isDatasetVisible(i)) {

                                    ivalue = scale.getRightValue(datasets[i].data[index]);
                                    if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
                                        start += ivalue;
                                    }
                                }
                            }
                        }

                        base = scale.getPixelForValue(start);
                        head = scale.getPixelForValue(start + value);
                        size = (head - base) / 2;

                        return {
                            size: size,
                            base: base,
                            head: head,
                            center: head + size / 2
                        };
                    },

                    /**
                     * @private
                     */
                    calculateBarIndexPixels: function (datasetIndex, index, ruler) {
                        var me = this;
                        var options = ruler.scale.options;
                        var range = options.barThickness === 'flex'
                            ? computeFlexCategoryTraits(index, ruler, options)
                            : computeFitCategoryTraits(index, ruler, options);

                        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
                        var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
                        var size = Math.min(
                            helpers.valueOrDefault(options.maxBarThickness, Infinity),
                            range.chunk * range.ratio);

                        return {
                            base: center - size / 2,
                            head: center + size / 2,
                            center: center,
                            size: size
                        };
                    },

                    draw: function () {
                        var me = this;
                        var chart = me.chart;
                        var scale = me.getValueScale();
                        var rects = me.getMeta().data;
                        var dataset = me.getDataset();
                        var ilen = rects.length;
                        var i = 0;

                        helpers.canvas.clipArea(chart.ctx, chart.chartArea);

                        for (; i < ilen; ++i) {
                            if (!isNaN(scale.getRightValue(dataset.data[i]))) {
                                rects[i].draw();
                            }
                        }

                        helpers.canvas.unclipArea(chart.ctx);
                    },
                });

                Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
                    /**
                     * @private
                     */
                    getValueScaleId: function () {
                        return this.getMeta().xAxisID;
                    },

                    /**
                     * @private
                     */
                    getIndexScaleId: function () {
                        return this.getMeta().yAxisID;
                    }
                });
            };

        }, {"26": 26, "41": 41, "46": 46}],
        16: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var elements = require(41);
            var helpers = require(46);

            defaults._set('bubble', {
                hover: {
                    mode: 'single'
                },

                scales: {
                    xAxes: [{
                        type: 'linear', // bubble should probably use a linear scale by default
                        position: 'bottom',
                        id: 'x-axis-0' // need an ID so datasets can reference the scale
                    }],
                    yAxes: [{
                        type: 'linear',
                        position: 'left',
                        id: 'y-axis-0'
                    }]
                },

                tooltips: {
                    callbacks: {
                        title: function () {
                            // Title doesn't make sense for scatter since we format the data as a point
                            return '';
                        },
                        label: function (item, data) {
                            var datasetLabel = data.datasets[item.datasetIndex].label || '';
                            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
                            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
                        }
                    }
                }
            });


            module.exports = function (Chart) {

                Chart.controllers.bubble = Chart.DatasetController.extend({
                    /**
                     * @protected
                     */
                    dataElementType: elements.Point,

                    /**
                     * @protected
                     */
                    update: function (reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var points = meta.data;

                        // Update Points
                        helpers.each(points, function (point, index) {
                            me.updateElement(point, index, reset);
                        });
                    },

                    /**
                     * @protected
                     */
                    updateElement: function (point, index, reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var custom = point.custom || {};
                        var xScale = me.getScaleForId(meta.xAxisID);
                        var yScale = me.getScaleForId(meta.yAxisID);
                        var options = me._resolveElementOptions(point, index);
                        var data = me.getDataset().data[index];
                        var dsIndex = me.index;

                        var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
                        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

                        point._xScale = xScale;
                        point._yScale = yScale;
                        point._options = options;
                        point._datasetIndex = dsIndex;
                        point._index = index;
                        point._model = {
                            backgroundColor: options.backgroundColor,
                            borderColor: options.borderColor,
                            borderWidth: options.borderWidth,
                            hitRadius: options.hitRadius,
                            pointStyle: options.pointStyle,
                            rotation: options.rotation,
                            radius: reset ? 0 : options.radius,
                            skip: custom.skip || isNaN(x) || isNaN(y),
                            x: x,
                            y: y,
                        };

                        point.pivot();
                    },

                    /**
                     * @protected
                     */
                    setHoverStyle: function (point) {
                        var model = point._model;
                        var options = point._options;
                        point.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth,
                            radius: model.radius
                        };
                        model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
                        model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
                        model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
                        model.radius = options.radius + options.hoverRadius;
                    },

                    /**
                     * @private
                     */
                    _resolveElementOptions: function (point, index) {
                        var me = this;
                        var chart = me.chart;
                        var datasets = chart.data.datasets;
                        var dataset = datasets[me.index];
                        var custom = point.custom || {};
                        var options = chart.options.elements.point;
                        var resolve = helpers.options.resolve;
                        var data = dataset.data[index];
                        var values = {};
                        var i, ilen, key;

                        // Scriptable options
                        var context = {
                            chart: chart,
                            dataIndex: index,
                            dataset: dataset,
                            datasetIndex: me.index
                        };

                        var keys = [
                            'backgroundColor',
                            'borderColor',
                            'borderWidth',
                            'hoverBackgroundColor',
                            'hoverBorderColor',
                            'hoverBorderWidth',
                            'hoverRadius',
                            'hitRadius',
                            'pointStyle',
                            'rotation'
                        ];

                        for (i = 0, ilen = keys.length; i < ilen; ++i) {
                            key = keys[i];
                            values[key] = resolve([
                                custom[key],
                                dataset[key],
                                options[key]
                            ], context, index);
                        }

                        // Custom radius resolution
                        values.radius = resolve([
                            custom.radius,
                            data ? data.r : undefined,
                            dataset.radius,
                            options.radius
                        ], context, index);
                        return values;
                    }
                });
            };

        }, {"26": 26, "41": 41, "46": 46}],
        17: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var elements = require(41);
            var helpers = require(46);

            defaults._set('doughnut', {
                animation: {
                    // Boolean - Whether we animate the rotation of the Doughnut
                    animateRotate: true,
                    // Boolean - Whether we animate scaling the Doughnut from the centre
                    animateScale: false
                },
                hover: {
                    mode: 'single'
                },
                legendCallback: function (chart) {
                    var text = [];
                    text.push('<ul class="' + chart.id + '-legend">');

                    var data = chart.data;
                    var datasets = data.datasets;
                    var labels = data.labels;

                    if (datasets.length) {
                        for (var i = 0; i < datasets[0].data.length; ++i) {
                            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
                            if (labels[i]) {
                                text.push(labels[i]);
                            }
                            text.push('</li>');
                        }
                    }

                    text.push('</ul>');
                    return text.join('');
                },
                legend: {
                    labels: {
                        generateLabels: function (chart) {
                            var data = chart.data;
                            if (data.labels.length && data.datasets.length) {
                                return data.labels.map(function (label, i) {
                                    var meta = chart.getDatasetMeta(0);
                                    var ds = data.datasets[0];
                                    var arc = meta.data[i];
                                    var custom = arc && arc.custom || {};
                                    var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
                                    var arcOpts = chart.options.elements.arc;
                                    var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
                                    var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
                                    var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

                                    return {
                                        text: label,
                                        fillStyle: fill,
                                        strokeStyle: stroke,
                                        lineWidth: bw,
                                        hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

                                        // Extra data used for toggling the correct item
                                        index: i
                                    };
                                });
                            }
                            return [];
                        }
                    },

                    onClick: function (e, legendItem) {
                        var index = legendItem.index;
                        var chart = this.chart;
                        var i, ilen, meta;

                        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                            meta = chart.getDatasetMeta(i);
                            // toggle visibility of index if exists
                            if (meta.data[index]) {
                                meta.data[index].hidden = !meta.data[index].hidden;
                            }
                        }

                        chart.update();
                    }
                },

                // The percentage of the chart that we cut out of the middle.
                cutoutPercentage: 50,

                // The rotation of the chart, where the first data arc begins.
                rotation: Math.PI * -0.5,

                // The total circumference of the chart.
                circumference: Math.PI * 2.0,

                // Need to override these to give a nice default
                tooltips: {
                    callbacks: {
                        title: function () {
                            return '';
                        },
                        label: function (tooltipItem, data) {
                            var dataLabel = data.labels[tooltipItem.index];
                            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

                            if (helpers.isArray(dataLabel)) {
                                // show value on first line of multiline label
                                // need to clone because we are changing the value
                                dataLabel = dataLabel.slice();
                                dataLabel[0] += value;
                            } else {
                                dataLabel += value;
                            }

                            return dataLabel;
                        }
                    }
                }
            });

            defaults._set('pie', helpers.clone(defaults.doughnut));
            defaults._set('pie', {
                cutoutPercentage: 0
            });

            module.exports = function (Chart) {

                Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

                    dataElementType: elements.Arc,

                    linkScales: helpers.noop,

                    // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
                    getRingIndex: function (datasetIndex) {
                        var ringIndex = 0;

                        for (var j = 0; j < datasetIndex; ++j) {
                            if (this.chart.isDatasetVisible(j)) {
                                ++ringIndex;
                            }
                        }

                        return ringIndex;
                    },

                    update: function (reset) {
                        var me = this;
                        var chart = me.chart;
                        var chartArea = chart.chartArea;
                        var opts = chart.options;
                        var arcOpts = opts.elements.arc;
                        var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
                        var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
                        var minSize = Math.min(availableWidth, availableHeight);
                        var offset = {x: 0, y: 0};
                        var meta = me.getMeta();
                        var cutoutPercentage = opts.cutoutPercentage;
                        var circumference = opts.circumference;

                        // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
                        if (circumference < Math.PI * 2.0) {
                            var startAngle = opts.rotation % (Math.PI * 2.0);
                            startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
                            var endAngle = startAngle + circumference;
                            var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
                            var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
                            var contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
                            var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
                            var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
                            var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
                            var cutout = cutoutPercentage / 100.0;
                            var min = {
                                x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
                                y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
                            };
                            var max = {
                                x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
                                y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
                            };
                            var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
                            minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
                            offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
                        }

                        chart.borderWidth = me.getMaxBorderWidth(meta.data);
                        chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
                        chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
                        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
                        chart.offsetX = offset.x * chart.outerRadius;
                        chart.offsetY = offset.y * chart.outerRadius;

                        meta.total = me.calculateTotal();

                        me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
                        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

                        helpers.each(meta.data, function (arc, index) {
                            me.updateElement(arc, index, reset);
                        });
                    },

                    updateElement: function (arc, index, reset) {
                        var me = this;
                        var chart = me.chart;
                        var chartArea = chart.chartArea;
                        var opts = chart.options;
                        var animationOpts = opts.animation;
                        var centerX = (chartArea.left + chartArea.right) / 2;
                        var centerY = (chartArea.top + chartArea.bottom) / 2;
                        var startAngle = opts.rotation; // non reset case handled later
                        var endAngle = opts.rotation; // non reset case handled later
                        var dataset = me.getDataset();
                        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
                        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
                        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
                        var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

                        helpers.extend(arc, {
                            // Utility
                            _datasetIndex: me.index,
                            _index: index,

                            // Desired view properties
                            _model: {
                                x: centerX + chart.offsetX,
                                y: centerY + chart.offsetY,
                                startAngle: startAngle,
                                endAngle: endAngle,
                                circumference: circumference,
                                outerRadius: outerRadius,
                                innerRadius: innerRadius,
                                label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
                            }
                        });

                        var model = arc._model;

                        // Resets the visual styles
                        var custom = arc.custom || {};
                        var valueOrDefault = helpers.valueAtIndexOrDefault;
                        var elementOpts = this.chart.options.elements.arc;
                        model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
                        model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
                        model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);

                        // Set correct angles if not resetting
                        if (!reset || !animationOpts.animateRotate) {
                            if (index === 0) {
                                model.startAngle = opts.rotation;
                            } else {
                                model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
                            }

                            model.endAngle = model.startAngle + model.circumference;
                        }

                        arc.pivot();
                    },

                    calculateTotal: function () {
                        var dataset = this.getDataset();
                        var meta = this.getMeta();
                        var total = 0;
                        var value;

                        helpers.each(meta.data, function (element, index) {
                            value = dataset.data[index];
                            if (!isNaN(value) && !element.hidden) {
                                total += Math.abs(value);
                            }
                        });

                        /* if (total === 0) {
				total = NaN;
			}*/

                        return total;
                    },

                    calculateCircumference: function (value) {
                        var total = this.getMeta().total;
                        if (total > 0 && !isNaN(value)) {
                            return (Math.PI * 2.0) * (Math.abs(value) / total);
                        }
                        return 0;
                    },

                    // gets the max border or hover width to properly scale pie charts
                    getMaxBorderWidth: function (arcs) {
                        var max = 0;
                        var index = this.index;
                        var length = arcs.length;
                        var borderWidth;
                        var hoverWidth;

                        for (var i = 0; i < length; i++) {
                            borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
                            hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

                            max = borderWidth > max ? borderWidth : max;
                            max = hoverWidth > max ? hoverWidth : max;
                        }
                        return max;
                    }
                });
            };

        }, {"26": 26, "41": 41, "46": 46}],
        18: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var elements = require(41);
            var helpers = require(46);

            defaults._set('line', {
                showLines: true,
                spanGaps: false,

                hover: {
                    mode: 'label'
                },

                scales: {
                    xAxes: [{
                        type: 'category',
                        id: 'x-axis-0'
                    }],
                    yAxes: [{
                        type: 'linear',
                        id: 'y-axis-0'
                    }]
                }
            });

            module.exports = function (Chart) {

                function lineEnabled(dataset, options) {
                    return helpers.valueOrDefault(dataset.showLine, options.showLines);
                }

                Chart.controllers.line = Chart.DatasetController.extend({

                    datasetElementType: elements.Line,

                    dataElementType: elements.Point,

                    update: function (reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var line = meta.dataset;
                        var points = meta.data || [];
                        var options = me.chart.options;
                        var lineElementOptions = options.elements.line;
                        var scale = me.getScaleForId(meta.yAxisID);
                        var i, ilen, custom;
                        var dataset = me.getDataset();
                        var showLine = lineEnabled(dataset, options);

                        // Update Line
                        if (showLine) {
                            custom = line.custom || {};

                            // Compatibility: If the properties are defined with only the old name, use those values
                            if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
                                dataset.lineTension = dataset.tension;
                            }

                            // Utility
                            line._scale = scale;
                            line._datasetIndex = me.index;
                            // Data
                            line._children = points;
                            // Model
                            line._model = {
                                // Appearance
                                // The default behavior of lines is to break at null values, according
                                // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
                                // This option gives lines the ability to span gaps
                                spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
                                tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
                                backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
                                borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
                                borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
                                borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
                                borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
                                borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
                                borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
                                fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
                                steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
                                cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
                            };

                            line.pivot();
                        }

                        // Update Points
                        for (i = 0, ilen = points.length; i < ilen; ++i) {
                            me.updateElement(points[i], i, reset);
                        }

                        if (showLine && line._model.tension !== 0) {
                            me.updateBezierControlPoints();
                        }

                        // Now pivot the point for animation
                        for (i = 0, ilen = points.length; i < ilen; ++i) {
                            points[i].pivot();
                        }
                    },

                    getPointBackgroundColor: function (point, index) {
                        var backgroundColor = this.chart.options.elements.point.backgroundColor;
                        var dataset = this.getDataset();
                        var custom = point.custom || {};

                        if (custom.backgroundColor) {
                            backgroundColor = custom.backgroundColor;
                        } else if (dataset.pointBackgroundColor) {
                            backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
                        } else if (dataset.backgroundColor) {
                            backgroundColor = dataset.backgroundColor;
                        }

                        return backgroundColor;
                    },

                    getPointBorderColor: function (point, index) {
                        var borderColor = this.chart.options.elements.point.borderColor;
                        var dataset = this.getDataset();
                        var custom = point.custom || {};

                        if (custom.borderColor) {
                            borderColor = custom.borderColor;
                        } else if (dataset.pointBorderColor) {
                            borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
                        } else if (dataset.borderColor) {
                            borderColor = dataset.borderColor;
                        }

                        return borderColor;
                    },

                    getPointBorderWidth: function (point, index) {
                        var borderWidth = this.chart.options.elements.point.borderWidth;
                        var dataset = this.getDataset();
                        var custom = point.custom || {};

                        if (!isNaN(custom.borderWidth)) {
                            borderWidth = custom.borderWidth;
                        } else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
                            borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
                        } else if (!isNaN(dataset.borderWidth)) {
                            borderWidth = dataset.borderWidth;
                        }

                        return borderWidth;
                    },

                    getPointRotation: function (point, index) {
                        var pointRotation = this.chart.options.elements.point.rotation;
                        var dataset = this.getDataset();
                        var custom = point.custom || {};

                        if (!isNaN(custom.rotation)) {
                            pointRotation = custom.rotation;
                        } else if (!isNaN(dataset.pointRotation) || helpers.isArray(dataset.pointRotation)) {
                            pointRotation = helpers.valueAtIndexOrDefault(dataset.pointRotation, index, pointRotation);
                        }
                        return pointRotation;
                    },

                    updateElement: function (point, index, reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var custom = point.custom || {};
                        var dataset = me.getDataset();
                        var datasetIndex = me.index;
                        var value = dataset.data[index];
                        var yScale = me.getScaleForId(meta.yAxisID);
                        var xScale = me.getScaleForId(meta.xAxisID);
                        var pointOptions = me.chart.options.elements.point;
                        var x, y;

                        // Compatibility: If the properties are defined with only the old name, use those values
                        if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
                            dataset.pointRadius = dataset.radius;
                        }
                        if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
                            dataset.pointHitRadius = dataset.hitRadius;
                        }

                        x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
                        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

                        // Utility
                        point._xScale = xScale;
                        point._yScale = yScale;
                        point._datasetIndex = datasetIndex;
                        point._index = index;

                        // Desired view properties
                        point._model = {
                            x: x,
                            y: y,
                            skip: custom.skip || isNaN(x) || isNaN(y),
                            // Appearance
                            radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
                            pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
                            rotation: me.getPointRotation(point, index),
                            backgroundColor: me.getPointBackgroundColor(point, index),
                            borderColor: me.getPointBorderColor(point, index),
                            borderWidth: me.getPointBorderWidth(point, index),
                            tension: meta.dataset._model ? meta.dataset._model.tension : 0,
                            steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
                            // Tooltip
                            hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
                        };
                    },

                    calculatePointY: function (value, index, datasetIndex) {
                        var me = this;
                        var chart = me.chart;
                        var meta = me.getMeta();
                        var yScale = me.getScaleForId(meta.yAxisID);
                        var sumPos = 0;
                        var sumNeg = 0;
                        var i, ds, dsMeta;

                        if (yScale.options.stacked) {
                            for (i = 0; i < datasetIndex; i++) {
                                ds = chart.data.datasets[i];
                                dsMeta = chart.getDatasetMeta(i);
                                if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
                                    var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
                                    if (stackedRightValue < 0) {
                                        sumNeg += stackedRightValue || 0;
                                    } else {
                                        sumPos += stackedRightValue || 0;
                                    }
                                }
                            }

                            var rightValue = Number(yScale.getRightValue(value));
                            if (rightValue < 0) {
                                return yScale.getPixelForValue(sumNeg + rightValue);
                            }
                            return yScale.getPixelForValue(sumPos + rightValue);
                        }

                        return yScale.getPixelForValue(value);
                    },

                    updateBezierControlPoints: function () {
                        var me = this;
                        var meta = me.getMeta();
                        var area = me.chart.chartArea;
                        var points = (meta.data || []);
                        var i, ilen, point, model, controlPoints;

                        // Only consider points that are drawn in case the spanGaps option is used
                        if (meta.dataset._model.spanGaps) {
                            points = points.filter(function (pt) {
                                return !pt._model.skip;
                            });
                        }

                        function capControlPoint(pt, min, max) {
                            return Math.max(Math.min(pt, max), min);
                        }

                        if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
                            helpers.splineCurveMonotone(points);
                        } else {
                            for (i = 0, ilen = points.length; i < ilen; ++i) {
                                point = points[i];
                                model = point._model;
                                controlPoints = helpers.splineCurve(
                                    helpers.previousItem(points, i)._model,
                                    model,
                                    helpers.nextItem(points, i)._model,
                                    meta.dataset._model.tension
                                );
                                model.controlPointPreviousX = controlPoints.previous.x;
                                model.controlPointPreviousY = controlPoints.previous.y;
                                model.controlPointNextX = controlPoints.next.x;
                                model.controlPointNextY = controlPoints.next.y;
                            }
                        }

                        if (me.chart.options.elements.line.capBezierPoints) {
                            for (i = 0, ilen = points.length; i < ilen; ++i) {
                                model = points[i]._model;
                                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
                            }
                        }
                    },

                    draw: function () {
                        var me = this;
                        var chart = me.chart;
                        var meta = me.getMeta();
                        var points = meta.data || [];
                        var area = chart.chartArea;
                        var ilen = points.length;
                        var halfBorderWidth;
                        var i = 0;

                        if (lineEnabled(me.getDataset(), chart.options)) {
                            halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;

                            helpers.canvas.clipArea(chart.ctx, {
                                left: area.left,
                                right: area.right,
                                top: area.top - halfBorderWidth,
                                bottom: area.bottom + halfBorderWidth
                            });

                            meta.dataset.draw();

                            helpers.canvas.unclipArea(chart.ctx);
                        }

                        // Draw the points
                        for (; i < ilen; ++i) {
                            points[i].draw(area);
                        }
                    },

                    setHoverStyle: function (element) {
                        // Point
                        var dataset = this.chart.data.datasets[element._datasetIndex];
                        var index = element._index;
                        var custom = element.custom || {};
                        var model = element._model;

                        element.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth,
                            radius: model.radius
                        };

                        model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
                        model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
                        model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
                        model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
                    },
                });
            };

        }, {"26": 26, "41": 41, "46": 46}],
        19: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var elements = require(41);
            var helpers = require(46);

            defaults._set('polarArea', {
                scale: {
                    type: 'radialLinear',
                    angleLines: {
                        display: false
                    },
                    gridLines: {
                        circular: true
                    },
                    pointLabels: {
                        display: false
                    },
                    ticks: {
                        beginAtZero: true
                    }
                },

                // Boolean - Whether to animate the rotation of the chart
                animation: {
                    animateRotate: true,
                    animateScale: true
                },

                startAngle: -0.5 * Math.PI,
                legendCallback: function (chart) {
                    var text = [];
                    text.push('<ul class="' + chart.id + '-legend">');

                    var data = chart.data;
                    var datasets = data.datasets;
                    var labels = data.labels;

                    if (datasets.length) {
                        for (var i = 0; i < datasets[0].data.length; ++i) {
                            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
                            if (labels[i]) {
                                text.push(labels[i]);
                            }
                            text.push('</li>');
                        }
                    }

                    text.push('</ul>');
                    return text.join('');
                },
                legend: {
                    labels: {
                        generateLabels: function (chart) {
                            var data = chart.data;
                            if (data.labels.length && data.datasets.length) {
                                return data.labels.map(function (label, i) {
                                    var meta = chart.getDatasetMeta(0);
                                    var ds = data.datasets[0];
                                    var arc = meta.data[i];
                                    var custom = arc.custom || {};
                                    var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
                                    var arcOpts = chart.options.elements.arc;
                                    var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
                                    var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
                                    var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

                                    return {
                                        text: label,
                                        fillStyle: fill,
                                        strokeStyle: stroke,
                                        lineWidth: bw,
                                        hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

                                        // Extra data used for toggling the correct item
                                        index: i
                                    };
                                });
                            }
                            return [];
                        }
                    },

                    onClick: function (e, legendItem) {
                        var index = legendItem.index;
                        var chart = this.chart;
                        var i, ilen, meta;

                        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                            meta = chart.getDatasetMeta(i);
                            meta.data[index].hidden = !meta.data[index].hidden;
                        }

                        chart.update();
                    }
                },

                // Need to override these to give a nice default
                tooltips: {
                    callbacks: {
                        title: function () {
                            return '';
                        },
                        label: function (item, data) {
                            return data.labels[item.index] + ': ' + item.yLabel;
                        }
                    }
                }
            });

            module.exports = function (Chart) {

                Chart.controllers.polarArea = Chart.DatasetController.extend({

                    dataElementType: elements.Arc,

                    linkScales: helpers.noop,

                    update: function (reset) {
                        var me = this;
                        var dataset = me.getDataset();
                        var meta = me.getMeta();
                        var start = me.chart.options.startAngle || 0;
                        var starts = me._starts = [];
                        var angles = me._angles = [];
                        var i, ilen, angle;

                        me._updateRadius();

                        meta.count = me.countVisibleElements();

                        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
                            starts[i] = start;
                            angle = me._computeAngle(i);
                            angles[i] = angle;
                            start += angle;
                        }

                        helpers.each(meta.data, function (arc, index) {
                            me.updateElement(arc, index, reset);
                        });
                    },

                    /**
                     * @private
                     */
                    _updateRadius: function () {
                        var me = this;
                        var chart = me.chart;
                        var chartArea = chart.chartArea;
                        var opts = chart.options;
                        var arcOpts = opts.elements.arc;
                        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);

                        chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
                        chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
                        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

                        me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
                        me.innerRadius = me.outerRadius - chart.radiusLength;
                    },

                    updateElement: function (arc, index, reset) {
                        var me = this;
                        var chart = me.chart;
                        var dataset = me.getDataset();
                        var opts = chart.options;
                        var animationOpts = opts.animation;
                        var scale = chart.scale;
                        var labels = chart.data.labels;

                        var centerX = scale.xCenter;
                        var centerY = scale.yCenter;

                        // var negHalfPI = -0.5 * Math.PI;
                        var datasetStartAngle = opts.startAngle;
                        var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
                        var startAngle = me._starts[index];
                        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);

                        var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

                        helpers.extend(arc, {
                            // Utility
                            _datasetIndex: me.index,
                            _index: index,
                            _scale: scale,

                            // Desired view properties
                            _model: {
                                x: centerX,
                                y: centerY,
                                innerRadius: 0,
                                outerRadius: reset ? resetRadius : distance,
                                startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                                endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                                label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
                            }
                        });

                        // Apply border and fill style
                        var elementOpts = this.chart.options.elements.arc;
                        var custom = arc.custom || {};
                        var valueOrDefault = helpers.valueAtIndexOrDefault;
                        var model = arc._model;

                        model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
                        model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
                        model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);

                        arc.pivot();
                    },

                    countVisibleElements: function () {
                        var dataset = this.getDataset();
                        var meta = this.getMeta();
                        var count = 0;

                        helpers.each(meta.data, function (element, index) {
                            if (!isNaN(dataset.data[index]) && !element.hidden) {
                                count++;
                            }
                        });

                        return count;
                    },

                    /**
                     * @private
                     */
                    _computeAngle: function (index) {
                        var me = this;
                        var count = this.getMeta().count;
                        var dataset = me.getDataset();
                        var meta = me.getMeta();

                        if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
                            return 0;
                        }

                        // Scriptable options
                        var context = {
                            chart: me.chart,
                            dataIndex: index,
                            dataset: dataset,
                            datasetIndex: me.index
                        };

                        return helpers.options.resolve([
                            me.chart.options.elements.arc.angle,
                            (2 * Math.PI) / count
                        ], context, index);
                    }
                });
            };

        }, {"26": 26, "41": 41, "46": 46}],
        20: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var elements = require(41);
            var helpers = require(46);

            defaults._set('radar', {
                scale: {
                    type: 'radialLinear'
                },
                elements: {
                    line: {
                        tension: 0 // no bezier in radar
                    }
                }
            });

            module.exports = function (Chart) {

                Chart.controllers.radar = Chart.DatasetController.extend({

                    datasetElementType: elements.Line,

                    dataElementType: elements.Point,

                    linkScales: helpers.noop,

                    update: function (reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var line = meta.dataset;
                        var points = meta.data;
                        var custom = line.custom || {};
                        var dataset = me.getDataset();
                        var lineElementOptions = me.chart.options.elements.line;
                        var scale = me.chart.scale;

                        // Compatibility: If the properties are defined with only the old name, use those values
                        if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
                            dataset.lineTension = dataset.tension;
                        }

                        helpers.extend(meta.dataset, {
                            // Utility
                            _datasetIndex: me.index,
                            _scale: scale,
                            // Data
                            _children: points,
                            _loop: true,
                            // Model
                            _model: {
                                // Appearance
                                tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
                                backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
                                borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
                                borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
                                fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
                                borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
                                borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
                                borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
                                borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
                            }
                        });

                        meta.dataset.pivot();

                        // Update Points
                        helpers.each(points, function (point, index) {
                            me.updateElement(point, index, reset);
                        }, me);

                        // Update bezier control points
                        me.updateBezierControlPoints();
                    },
                    updateElement: function (point, index, reset) {
                        var me = this;
                        var custom = point.custom || {};
                        var dataset = me.getDataset();
                        var scale = me.chart.scale;
                        var pointElementOptions = me.chart.options.elements.point;
                        var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

                        // Compatibility: If the properties are defined with only the old name, use those values
                        if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
                            dataset.pointRadius = dataset.radius;
                        }
                        if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
                            dataset.pointHitRadius = dataset.hitRadius;
                        }

                        helpers.extend(point, {
                            // Utility
                            _datasetIndex: me.index,
                            _index: index,
                            _scale: scale,

                            // Desired view properties
                            _model: {
                                x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
                                y: reset ? scale.yCenter : pointPosition.y,

                                // Appearance
                                tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
                                radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
                                backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
                                borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
                                borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
                                pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
                                rotation: custom.rotation ? custom.rotation : helpers.valueAtIndexOrDefault(dataset.pointRotation, index, pointElementOptions.rotation),

                                // Tooltip
                                hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
                            }
                        });

                        point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
                    },
                    updateBezierControlPoints: function () {
                        var chartArea = this.chart.chartArea;
                        var meta = this.getMeta();

                        helpers.each(meta.data, function (point, index) {
                            var model = point._model;
                            var controlPoints = helpers.splineCurve(
                                helpers.previousItem(meta.data, index, true)._model,
                                model,
                                helpers.nextItem(meta.data, index, true)._model,
                                model.tension
                            );

                            // Prevent the bezier going outside of the bounds of the graph
                            model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
                            model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

                            model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
                            model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

                            // Now pivot the point for animation
                            point.pivot();
                        });
                    },

                    setHoverStyle: function (point) {
                        // Point
                        var dataset = this.chart.data.datasets[point._datasetIndex];
                        var custom = point.custom || {};
                        var index = point._index;
                        var model = point._model;

                        point.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth,
                            radius: model.radius
                        };

                        model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
                        model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
                        model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
                        model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
                    },
                });
            };

        }, {"26": 26, "41": 41, "46": 46}],
        21: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);

            defaults._set('scatter', {
                hover: {
                    mode: 'single'
                },

                scales: {
                    xAxes: [{
                        id: 'x-axis-1',    // need an ID so datasets can reference the scale
                        type: 'linear',    // scatter should not use a category axis
                        position: 'bottom'
                    }],
                    yAxes: [{
                        id: 'y-axis-1',
                        type: 'linear',
                        position: 'left'
                    }]
                },

                showLines: false,

                tooltips: {
                    callbacks: {
                        title: function () {
                            return '';     // doesn't make sense for scatter since data are formatted as a point
                        },
                        label: function (item) {
                            return '(' + item.xLabel + ', ' + item.yLabel + ')';
                        }
                    }
                }
            });

            module.exports = function (Chart) {

                // Scatter charts use line controllers
                Chart.controllers.scatter = Chart.controllers.line;

            };

        }, {"26": 26}],
        22: [function (require, module, exports) {
            'use strict';

            var Element = require(27);

            var exports = module.exports = Element.extend({
                chart: null, // the animation associated chart instance
                currentStep: 0, // the current animation step
                numSteps: 60, // default number of steps
                easing: '', // the easing to use for this animation
                render: null, // render function used by the animation service

                onAnimationProgress: null, // user specified callback to fire on each step of the animation
                onAnimationComplete: null, // user specified callback to fire when the animation finishes
            });

// DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.Animation instead
             * @prop Chart.Animation#animationObject
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             */
            Object.defineProperty(exports.prototype, 'animationObject', {
                get: function () {
                    return this;
                }
            });

            /**
             * Provided for backward compatibility, use Chart.Animation#chart instead
             * @prop Chart.Animation#chartInstance
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             */
            Object.defineProperty(exports.prototype, 'chartInstance', {
                get: function () {
                    return this.chart;
                },
                set: function (value) {
                    this.chart = value;
                }
            });

        }, {"27": 27}],
        23: [function (require, module, exports) {
            /* global window: false */
            'use strict';

            var defaults = require(26);
            var helpers = require(46);

            defaults._set('global', {
                animation: {
                    duration: 1000,
                    easing: 'easeOutQuart',
                    onProgress: helpers.noop,
                    onComplete: helpers.noop
                }
            });

            module.exports = {
                frameDuration: 17,
                animations: [],
                dropFrames: 0,
                request: null,

                /**
                 * @param {Chart} chart - The chart to animate.
                 * @param {Chart.Animation} animation - The animation that we will animate.
                 * @param {Number} duration - The animation duration in ms.
                 * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
                 */
                addAnimation: function (chart, animation, duration, lazy) {
                    var animations = this.animations;
                    var i, ilen;

                    animation.chart = chart;

                    if (!lazy) {
                        chart.animating = true;
                    }

                    for (i = 0, ilen = animations.length; i < ilen; ++i) {
                        if (animations[i].chart === chart) {
                            animations[i] = animation;
                            return;
                        }
                    }

                    animations.push(animation);

                    // If there are no animations queued, manually kickstart a digest, for lack of a better word
                    if (animations.length === 1) {
                        this.requestAnimationFrame();
                    }
                },

                cancelAnimation: function (chart) {
                    var index = helpers.findIndex(this.animations, function (animation) {
                        return animation.chart === chart;
                    });

                    if (index !== -1) {
                        this.animations.splice(index, 1);
                        chart.animating = false;
                    }
                },

                requestAnimationFrame: function () {
                    var me = this;
                    if (me.request === null) {
                        // Skip animation frame requests until the active one is executed.
                        // This can happen when processing mouse events, e.g. 'mousemove'
                        // and 'mouseout' events will trigger multiple renders.
                        me.request = helpers.requestAnimFrame.call(window, function () {
                            me.request = null;
                            me.startDigest();
                        });
                    }
                },

                /**
                 * @private
                 */
                startDigest: function () {
                    var me = this;
                    var startTime = Date.now();
                    var framesToDrop = 0;

                    if (me.dropFrames > 1) {
                        framesToDrop = Math.floor(me.dropFrames);
                        me.dropFrames = me.dropFrames % 1;
                    }

                    me.advance(1 + framesToDrop);

                    var endTime = Date.now();

                    me.dropFrames += (endTime - startTime) / me.frameDuration;

                    // Do we have more stuff to animate?
                    if (me.animations.length > 0) {
                        me.requestAnimationFrame();
                    }
                },

                /**
                 * @private
                 */
                advance: function (count) {
                    var animations = this.animations;
                    var animation, chart;
                    var i = 0;

                    while (i < animations.length) {
                        animation = animations[i];
                        chart = animation.chart;

                        animation.currentStep = (animation.currentStep || 0) + count;
                        animation.currentStep = Math.min(animation.currentStep, animation.numSteps);

                        helpers.callback(animation.render, [chart, animation], chart);
                        helpers.callback(animation.onAnimationProgress, [animation], chart);

                        if (animation.currentStep >= animation.numSteps) {
                            helpers.callback(animation.onAnimationComplete, [animation], chart);
                            chart.animating = false;
                            animations.splice(i, 1);
                        } else {
                            ++i;
                        }
                    }
                }
            };

        }, {"26": 26, "46": 46}],
        24: [function (require, module, exports) {
            'use strict';

            var Animation = require(22);
            var animations = require(23);
            var defaults = require(26);
            var helpers = require(46);
            var Interaction = require(29);
            var layouts = require(31);
            var platform = require(49);
            var plugins = require(32);
            var scaleService = require(34);
            var Tooltip = require(36);

            module.exports = function (Chart) {

                // Create a dictionary of chart types, to allow for extension of existing types
                Chart.types = {};

                // Store a reference to each instance - allowing us to globally resize chart instances on window resize.
                // Destroy method on the chart will remove the instance of the chart from this reference.
                Chart.instances = {};

                // Controllers available for dataset visualization eg. bar, line, slice, etc.
                Chart.controllers = {};

                /**
                 * Initializes the given config with global and chart default values.
                 */
                function initConfig(config) {
                    config = config || {};

                    // Do NOT use configMerge() for the data object because this method merges arrays
                    // and so would change references to labels and datasets, preventing data updates.
                    var data = config.data = config.data || {};
                    data.datasets = data.datasets || [];
                    data.labels = data.labels || [];

                    config.options = helpers.configMerge(
                        defaults.global,
                        defaults[config.type],
                        config.options || {});

                    return config;
                }

                /**
                 * Updates the config of the chart
                 * @param chart {Chart} chart to update the options for
                 */
                function updateConfig(chart) {
                    var newOptions = chart.options;

                    helpers.each(chart.scales, function (scale) {
                        layouts.removeBox(chart, scale);
                    });

                    newOptions = helpers.configMerge(
                        Chart.defaults.global,
                        Chart.defaults[chart.config.type],
                        newOptions);

                    chart.options = chart.config.options = newOptions;
                    chart.ensureScalesHaveIDs();
                    chart.buildOrUpdateScales();
                    // Tooltip
                    chart.tooltip._options = newOptions.tooltips;
                    chart.tooltip.initialize();
                }

                function positionIsHorizontal(position) {
                    return position === 'top' || position === 'bottom';
                }

                helpers.extend(Chart.prototype, /** @lends Chart */ {
                    /**
                     * @private
                     */
                    construct: function (item, config) {
                        var me = this;

                        config = initConfig(config);

                        var context = platform.acquireContext(item, config);
                        var canvas = context && context.canvas;
                        var height = canvas && canvas.height;
                        var width = canvas && canvas.width;

                        me.id = helpers.uid();
                        me.ctx = context;
                        me.canvas = canvas;
                        me.config = config;
                        me.width = width;
                        me.height = height;
                        me.aspectRatio = height ? width / height : null;
                        me.options = config.options;
                        me._bufferedRender = false;

                        /**
                         * Provided for backward compatibility, Chart and Chart.Controller have been merged,
                         * the "instance" still need to be defined since it might be called from plugins.
                         * @prop Chart#chart
                         * @deprecated since version 2.6.0
                         * @todo remove at version 3
                         * @private
                         */
                        me.chart = me;
                        me.controller = me; // chart.chart.controller #inception

                        // Add the chart instance to the global namespace
                        Chart.instances[me.id] = me;

                        // Define alias to the config data: `chart.data === chart.config.data`
                        Object.defineProperty(me, 'data', {
                            get: function () {
                                return me.config.data;
                            },
                            set: function (value) {
                                me.config.data = value;
                            }
                        });

                        if (!context || !canvas) {
                            // The given item is not a compatible context2d element, let's return before finalizing
                            // the chart initialization but after setting basic chart / controller properties that
                            // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
                            // https://github.com/chartjs/Chart.js/issues/2807
                            console.error("Failed to create chart: can't acquire context from the given item");
                            return;
                        }

                        me.initialize();
                        me.update();
                    },

                    /**
                     * @private
                     */
                    initialize: function () {
                        var me = this;

                        // Before init plugin notification
                        plugins.notify(me, 'beforeInit');

                        helpers.retinaScale(me, me.options.devicePixelRatio);

                        me.bindEvents();

                        if (me.options.responsive) {
                            // Initial resize before chart draws (must be silent to preserve initial animations).
                            me.resize(true);
                        }

                        // Make sure scales have IDs and are built before we build any controllers.
                        me.ensureScalesHaveIDs();
                        me.buildOrUpdateScales();
                        me.initToolTip();

                        // After init plugin notification
                        plugins.notify(me, 'afterInit');

                        return me;
                    },

                    clear: function () {
                        helpers.canvas.clear(this);
                        return this;
                    },

                    stop: function () {
                        // Stops any current animation loop occurring
                        animations.cancelAnimation(this);
                        return this;
                    },

                    resize: function (silent) {
                        var me = this;
                        var options = me.options;
                        var canvas = me.canvas;
                        var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;

                        // the canvas render width and height will be casted to integers so make sure that
                        // the canvas display style uses the same integer values to avoid blurring effect.

                        // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed
                        var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
                        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

                        if (me.width === newWidth && me.height === newHeight) {
                            return;
                        }

                        canvas.width = me.width = newWidth;
                        canvas.height = me.height = newHeight;
                        canvas.style.width = newWidth + 'px';
                        canvas.style.height = newHeight + 'px';

                        helpers.retinaScale(me, options.devicePixelRatio);

                        if (!silent) {
                            // Notify any plugins about the resize
                            var newSize = {width: newWidth, height: newHeight};
                            plugins.notify(me, 'resize', [newSize]);

                            // Notify of resize
                            if (me.options.onResize) {
                                me.options.onResize(me, newSize);
                            }

                            me.stop();
                            me.update({
                                duration: me.options.responsiveAnimationDuration
                            });
                        }
                    },

                    ensureScalesHaveIDs: function () {
                        var options = this.options;
                        var scalesOptions = options.scales || {};
                        var scaleOptions = options.scale;

                        helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {
                            xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
                        });

                        helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {
                            yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
                        });

                        if (scaleOptions) {
                            scaleOptions.id = scaleOptions.id || 'scale';
                        }
                    },

                    /**
                     * Builds a map of scale ID to scale object for future lookup.
                     */
                    buildOrUpdateScales: function () {
                        var me = this;
                        var options = me.options;
                        var scales = me.scales || {};
                        var items = [];
                        var updated = Object.keys(scales).reduce(function (obj, id) {
                            obj[id] = false;
                            return obj;
                        }, {});

                        if (options.scales) {
                            items = items.concat(
                                (options.scales.xAxes || []).map(function (xAxisOptions) {
                                    return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
                                }),
                                (options.scales.yAxes || []).map(function (yAxisOptions) {
                                    return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
                                })
                            );
                        }

                        if (options.scale) {
                            items.push({
                                options: options.scale,
                                dtype: 'radialLinear',
                                isDefault: true,
                                dposition: 'chartArea'
                            });
                        }

                        helpers.each(items, function (item) {
                            var scaleOptions = item.options;
                            var id = scaleOptions.id;
                            var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);

                            if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
                                scaleOptions.position = item.dposition;
                            }

                            updated[id] = true;
                            var scale = null;
                            if (id in scales && scales[id].type === scaleType) {
                                scale = scales[id];
                                scale.options = scaleOptions;
                                scale.ctx = me.ctx;
                                scale.chart = me;
                            } else {
                                var scaleClass = scaleService.getScaleConstructor(scaleType);
                                if (!scaleClass) {
                                    return;
                                }
                                scale = new scaleClass({
                                    id: id,
                                    type: scaleType,
                                    options: scaleOptions,
                                    ctx: me.ctx,
                                    chart: me
                                });
                                scales[scale.id] = scale;
                            }

                            scale.mergeTicksOptions();

                            // TODO(SB): I think we should be able to remove this custom case (options.scale)
                            // and consider it as a regular scale part of the "scales"" map only! This would
                            // make the logic easier and remove some useless? custom code.
                            if (item.isDefault) {
                                me.scale = scale;
                            }
                        });
                        // clear up discarded scales
                        helpers.each(updated, function (hasUpdated, id) {
                            if (!hasUpdated) {
                                delete scales[id];
                            }
                        });

                        me.scales = scales;

                        scaleService.addScalesToLayout(this);
                    },

                    buildOrUpdateControllers: function () {
                        var me = this;
                        var types = [];
                        var newControllers = [];

                        helpers.each(me.data.datasets, function (dataset, datasetIndex) {
                            var meta = me.getDatasetMeta(datasetIndex);
                            var type = dataset.type || me.config.type;

                            if (meta.type && meta.type !== type) {
                                me.destroyDatasetMeta(datasetIndex);
                                meta = me.getDatasetMeta(datasetIndex);
                            }
                            meta.type = type;

                            types.push(meta.type);

                            if (meta.controller) {
                                meta.controller.updateIndex(datasetIndex);
                                meta.controller.linkScales();
                            } else {
                                var ControllerClass = Chart.controllers[meta.type];
                                if (ControllerClass === undefined) {
                                    throw new Error('"' + meta.type + '" is not a chart type.');
                                }

                                meta.controller = new ControllerClass(me, datasetIndex);
                                newControllers.push(meta.controller);
                            }
                        }, me);

                        return newControllers;
                    },

                    /**
                     * Reset the elements of all datasets
                     * @private
                     */
                    resetElements: function () {
                        var me = this;
                        helpers.each(me.data.datasets, function (dataset, datasetIndex) {
                            me.getDatasetMeta(datasetIndex).controller.reset();
                        }, me);
                    },

                    /**
                     * Resets the chart back to it's state before the initial animation
                     */
                    reset: function () {
                        this.resetElements();
                        this.tooltip.initialize();
                    },

                    update: function (config) {
                        var me = this;

                        if (!config || typeof config !== 'object') {
                            // backwards compatibility
                            config = {
                                duration: config,
                                lazy: arguments[1]
                            };
                        }

                        updateConfig(me);

                        // plugins options references might have change, let's invalidate the cache
                        // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
                        plugins._invalidate(me);

                        if (plugins.notify(me, 'beforeUpdate') === false) {
                            return;
                        }

                        // In case the entire data object changed
                        me.tooltip._data = me.data;

                        // Make sure dataset controllers are updated and new controllers are reset
                        var newControllers = me.buildOrUpdateControllers();

                        // Make sure all dataset controllers have correct meta data counts
                        helpers.each(me.data.datasets, function (dataset, datasetIndex) {
                            me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
                        }, me);

                        me.updateLayout();

                        // Can only reset the new controllers after the scales have been updated
                        if (me.options.animation && me.options.animation.duration) {
                            helpers.each(newControllers, function (controller) {
                                controller.reset();
                            });
                        }

                        me.updateDatasets();

                        // Need to reset tooltip in case it is displayed with elements that are removed
                        // after update.
                        me.tooltip.initialize();

                        // Last active contains items that were previously in the tooltip.
                        // When we reset the tooltip, we need to clear it
                        me.lastActive = [];

                        // Do this before render so that any plugins that need final scale updates can use it
                        plugins.notify(me, 'afterUpdate');

                        if (me._bufferedRender) {
                            me._bufferedRequest = {
                                duration: config.duration,
                                easing: config.easing,
                                lazy: config.lazy
                            };
                        } else {
                            me.render(config);
                        }
                    },

                    /**
                     * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
                     * hook, in which case, plugins will not be called on `afterLayout`.
                     * @private
                     */
                    updateLayout: function () {
                        var me = this;

                        if (plugins.notify(me, 'beforeLayout') === false) {
                            return;
                        }

                        layouts.update(this, this.width, this.height);

                        /**
                         * Provided for backward compatibility, use `afterLayout` instead.
                         * @method IPlugin#afterScaleUpdate
                         * @deprecated since version 2.5.0
                         * @todo remove at version 3
                         * @private
                         */
                        plugins.notify(me, 'afterScaleUpdate');
                        plugins.notify(me, 'afterLayout');
                    },

                    /**
                     * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
                     * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
                     * @private
                     */
                    updateDatasets: function () {
                        var me = this;

                        if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
                            return;
                        }

                        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
                            me.updateDataset(i);
                        }

                        plugins.notify(me, 'afterDatasetsUpdate');
                    },

                    /**
                     * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
                     * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
                     * @private
                     */
                    updateDataset: function (index) {
                        var me = this;
                        var meta = me.getDatasetMeta(index);
                        var args = {
                            meta: meta,
                            index: index
                        };

                        if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
                            return;
                        }

                        meta.controller.update();

                        plugins.notify(me, 'afterDatasetUpdate', [args]);
                    },

                    render: function (config) {
                        var me = this;

                        if (!config || typeof config !== 'object') {
                            // backwards compatibility
                            config = {
                                duration: config,
                                lazy: arguments[1]
                            };
                        }

                        var duration = config.duration;
                        var lazy = config.lazy;

                        if (plugins.notify(me, 'beforeRender') === false) {
                            return;
                        }

                        var animationOptions = me.options.animation;
                        var onComplete = function (animation) {
                            plugins.notify(me, 'afterRender');
                            helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
                        };

                        if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
                            var animation = new Animation({
                                numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
                                easing: config.easing || animationOptions.easing,

                                render: function (chart, animationObject) {
                                    var easingFunction = helpers.easing.effects[animationObject.easing];
                                    var currentStep = animationObject.currentStep;
                                    var stepDecimal = currentStep / animationObject.numSteps;

                                    chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                                },

                                onAnimationProgress: animationOptions.onProgress,
                                onAnimationComplete: onComplete
                            });

                            animations.addAnimation(me, animation, duration, lazy);
                        } else {
                            me.draw();

                            // See https://github.com/chartjs/Chart.js/issues/3781
                            onComplete(new Animation({numSteps: 0, chart: me}));
                        }

                        return me;
                    },

                    draw: function (easingValue) {
                        var me = this;

                        me.clear();

                        if (helpers.isNullOrUndef(easingValue)) {
                            easingValue = 1;
                        }

                        me.transition(easingValue);

                        if (me.width <= 0 || me.height <= 0) {
                            return;
                        }

                        if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
                            return;
                        }

                        // Draw all the scales
                        helpers.each(me.boxes, function (box) {
                            box.draw(me.chartArea);
                        }, me);

                        if (me.scale) {
                            me.scale.draw();
                        }

                        me.drawDatasets(easingValue);
                        me._drawTooltip(easingValue);

                        plugins.notify(me, 'afterDraw', [easingValue]);
                    },

                    /**
                     * @private
                     */
                    transition: function (easingValue) {
                        var me = this;

                        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
                            if (me.isDatasetVisible(i)) {
                                me.getDatasetMeta(i).controller.transition(easingValue);
                            }
                        }

                        me.tooltip.transition(easingValue);
                    },

                    /**
                     * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
                     * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
                     * @private
                     */
                    drawDatasets: function (easingValue) {
                        var me = this;

                        if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
                            return;
                        }

                        // Draw datasets reversed to support proper line stacking
                        for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
                            if (me.isDatasetVisible(i)) {
                                me.drawDataset(i, easingValue);
                            }
                        }

                        plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
                    },

                    /**
                     * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
                     * hook, in which case, plugins will not be called on `afterDatasetDraw`.
                     * @private
                     */
                    drawDataset: function (index, easingValue) {
                        var me = this;
                        var meta = me.getDatasetMeta(index);
                        var args = {
                            meta: meta,
                            index: index,
                            easingValue: easingValue
                        };

                        if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
                            return;
                        }

                        meta.controller.draw(easingValue);

                        plugins.notify(me, 'afterDatasetDraw', [args]);
                    },

                    /**
                     * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
                     * hook, in which case, plugins will not be called on `afterTooltipDraw`.
                     * @private
                     */
                    _drawTooltip: function (easingValue) {
                        var me = this;
                        var tooltip = me.tooltip;
                        var args = {
                            tooltip: tooltip,
                            easingValue: easingValue
                        };

                        if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
                            return;
                        }

                        tooltip.draw();

                        plugins.notify(me, 'afterTooltipDraw', [args]);
                    },

                    // Get the single element that was clicked on
                    // @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
                    getElementAtEvent: function (e) {
                        return Interaction.modes.single(this, e);
                    },

                    getElementsAtEvent: function (e) {
                        return Interaction.modes.label(this, e, {intersect: true});
                    },

                    getElementsAtXAxis: function (e) {
                        return Interaction.modes['x-axis'](this, e, {intersect: true});
                    },

                    getElementsAtEventForMode: function (e, mode, options) {
                        var method = Interaction.modes[mode];
                        if (typeof method === 'function') {
                            return method(this, e, options);
                        }

                        return [];
                    },

                    getDatasetAtEvent: function (e) {
                        return Interaction.modes.dataset(this, e, {intersect: true});
                    },

                    getDatasetMeta: function (datasetIndex) {
                        var me = this;
                        var dataset = me.data.datasets[datasetIndex];
                        if (!dataset._meta) {
                            dataset._meta = {};
                        }

                        var meta = dataset._meta[me.id];
                        if (!meta) {
                            meta = dataset._meta[me.id] = {
                                type: null,
                                data: [],
                                dataset: null,
                                controller: null,
                                hidden: null,			// See isDatasetVisible() comment
                                xAxisID: null,
                                yAxisID: null
                            };
                        }

                        return meta;
                    },

                    getVisibleDatasetCount: function () {
                        var count = 0;
                        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
                            if (this.isDatasetVisible(i)) {
                                count++;
                            }
                        }
                        return count;
                    },

                    isDatasetVisible: function (datasetIndex) {
                        var meta = this.getDatasetMeta(datasetIndex);

                        // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
                        // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
                        return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
                    },

                    generateLegend: function () {
                        return this.options.legendCallback(this);
                    },

                    /**
                     * @private
                     */
                    destroyDatasetMeta: function (datasetIndex) {
                        var id = this.id;
                        var dataset = this.data.datasets[datasetIndex];
                        var meta = dataset._meta && dataset._meta[id];

                        if (meta) {
                            meta.controller.destroy();
                            delete dataset._meta[id];
                        }
                    },

                    destroy: function () {
                        var me = this;
                        var canvas = me.canvas;
                        var i, ilen;

                        me.stop();

                        // dataset controllers need to cleanup associated data
                        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
                            me.destroyDatasetMeta(i);
                        }

                        if (canvas) {
                            me.unbindEvents();
                            helpers.canvas.clear(me);
                            platform.releaseContext(me.ctx);
                            me.canvas = null;
                            me.ctx = null;
                        }

                        plugins.notify(me, 'destroy');

                        delete Chart.instances[me.id];
                    },

                    toBase64Image: function () {
                        return this.canvas.toDataURL.apply(this.canvas, arguments);
                    },

                    initToolTip: function () {
                        var me = this;
                        me.tooltip = new Tooltip({
                            _chart: me,
                            _chartInstance: me, // deprecated, backward compatibility
                            _data: me.data,
                            _options: me.options.tooltips
                        }, me);
                    },

                    /**
                     * @private
                     */
                    bindEvents: function () {
                        var me = this;
                        var listeners = me._listeners = {};
                        var listener = function () {
                            me.eventHandler.apply(me, arguments);
                        };

                        helpers.each(me.options.events, function (type) {
                            platform.addEventListener(me, type, listener);
                            listeners[type] = listener;
                        });

                        // Elements used to detect size change should not be injected for non responsive charts.
                        // See https://github.com/chartjs/Chart.js/issues/2210
                        if (me.options.responsive) {
                            listener = function () {
                                me.resize();
                            };

                            platform.addEventListener(me, 'resize', listener);
                            listeners.resize = listener;
                        }
                    },

                    /**
                     * @private
                     */
                    unbindEvents: function () {
                        var me = this;
                        var listeners = me._listeners;
                        if (!listeners) {
                            return;
                        }

                        delete me._listeners;
                        helpers.each(listeners, function (listener, type) {
                            platform.removeEventListener(me, type, listener);
                        });
                    },

                    updateHoverStyle: function (elements, mode, enabled) {
                        var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
                        var element, i, ilen;

                        for (i = 0, ilen = elements.length; i < ilen; ++i) {
                            element = elements[i];
                            if (element) {
                                this.getDatasetMeta(element._datasetIndex).controller[method](element);
                            }
                        }
                    },

                    /**
                     * @private
                     */
                    eventHandler: function (e) {
                        var me = this;
                        var tooltip = me.tooltip;

                        if (plugins.notify(me, 'beforeEvent', [e]) === false) {
                            return;
                        }

                        // Buffer any update calls so that renders do not occur
                        me._bufferedRender = true;
                        me._bufferedRequest = null;

                        var changed = me.handleEvent(e);
                        // for smooth tooltip animations issue #4989
                        // the tooltip should be the source of change
                        // Animation check workaround:
                        // tooltip._start will be null when tooltip isn't animating
                        if (tooltip) {
                            changed = tooltip._start
                                ? tooltip.handleEvent(e)
                                : changed | tooltip.handleEvent(e);
                        }

                        plugins.notify(me, 'afterEvent', [e]);

                        var bufferedRequest = me._bufferedRequest;
                        if (bufferedRequest) {
                            // If we have an update that was triggered, we need to do a normal render
                            me.render(bufferedRequest);
                        } else if (changed && !me.animating) {
                            // If entering, leaving, or changing elements, animate the change via pivot
                            me.stop();

                            // We only need to render at this point. Updating will cause scales to be
                            // recomputed generating flicker & using more memory than necessary.
                            me.render({
                                duration: me.options.hover.animationDuration,
                                lazy: true
                            });
                        }

                        me._bufferedRender = false;
                        me._bufferedRequest = null;

                        return me;
                    },

                    /**
                     * Handle an event
                     * @private
                     * @param {IEvent} event the event to handle
                     * @return {Boolean} true if the chart needs to re-render
                     */
                    handleEvent: function (e) {
                        var me = this;
                        var options = me.options || {};
                        var hoverOptions = options.hover;
                        var changed = false;

                        me.lastActive = me.lastActive || [];

                        // Find Active Elements for hover and tooltips
                        if (e.type === 'mouseout') {
                            me.active = [];
                        } else {
                            me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
                        }

                        // Invoke onHover hook
                        // Need to call with native event here to not break backwards compatibility
                        helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

                        if (e.type === 'mouseup' || e.type === 'click') {
                            if (options.onClick) {
                                // Use e.native here for backwards compatibility
                                options.onClick.call(me, e.native, me.active);
                            }
                        }

                        // Remove styling for last active (even if it may still be active)
                        if (me.lastActive.length) {
                            me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
                        }

                        // Built in hover styling
                        if (me.active.length && hoverOptions.mode) {
                            me.updateHoverStyle(me.active, hoverOptions.mode, true);
                        }

                        changed = !helpers.arrayEquals(me.active, me.lastActive);

                        // Remember Last Actives
                        me.lastActive = me.active;

                        return changed;
                    }
                });

                /**
                 * Provided for backward compatibility, use Chart instead.
                 * @class Chart.Controller
                 * @deprecated since version 2.6.0
                 * @todo remove at version 3
                 * @private
                 */
                Chart.Controller = Chart;
            };

        }, {"22": 22, "23": 23, "26": 26, "29": 29, "31": 31, "32": 32, "34": 34, "36": 36, "46": 46, "49": 49}],
        25: [function (require, module, exports) {
            'use strict';

            var helpers = require(46);

            module.exports = function (Chart) {

                var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

                /**
                 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
                 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
                 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
                 */
                function listenArrayEvents(array, listener) {
                    if (array._chartjs) {
                        array._chartjs.listeners.push(listener);
                        return;
                    }

                    Object.defineProperty(array, '_chartjs', {
                        configurable: true,
                        enumerable: false,
                        value: {
                            listeners: [listener]
                        }
                    });

                    arrayEvents.forEach(function (key) {
                        var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
                        var base = array[key];

                        Object.defineProperty(array, key, {
                            configurable: true,
                            enumerable: false,
                            value: function () {
                                var args = Array.prototype.slice.call(arguments);
                                var res = base.apply(this, args);

                                helpers.each(array._chartjs.listeners, function (object) {
                                    if (typeof object[method] === 'function') {
                                        object[method].apply(object, args);
                                    }
                                });

                                return res;
                            }
                        });
                    });
                }

                /**
                 * Removes the given array event listener and cleanup extra attached properties (such as
                 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
                 */
                function unlistenArrayEvents(array, listener) {
                    var stub = array._chartjs;
                    if (!stub) {
                        return;
                    }

                    var listeners = stub.listeners;
                    var index = listeners.indexOf(listener);
                    if (index !== -1) {
                        listeners.splice(index, 1);
                    }

                    if (listeners.length > 0) {
                        return;
                    }

                    arrayEvents.forEach(function (key) {
                        delete array[key];
                    });

                    delete array._chartjs;
                }

                // Base class for all dataset controllers (line, bar, etc)
                Chart.DatasetController = function (chart, datasetIndex) {
                    this.initialize(chart, datasetIndex);
                };

                helpers.extend(Chart.DatasetController.prototype, {

                    /**
                     * Element type used to generate a meta dataset (e.g. Chart.element.Line).
                     * @type {Chart.core.element}
                     */
                    datasetElementType: null,

                    /**
                     * Element type used to generate a meta data (e.g. Chart.element.Point).
                     * @type {Chart.core.element}
                     */
                    dataElementType: null,

                    initialize: function (chart, datasetIndex) {
                        var me = this;
                        me.chart = chart;
                        me.index = datasetIndex;
                        me.linkScales();
                        me.addElements();
                    },

                    updateIndex: function (datasetIndex) {
                        this.index = datasetIndex;
                    },

                    linkScales: function () {
                        var me = this;
                        var meta = me.getMeta();
                        var dataset = me.getDataset();

                        if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
                            meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
                        }
                        if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
                            meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
                        }
                    },

                    getDataset: function () {
                        return this.chart.data.datasets[this.index];
                    },

                    getMeta: function () {
                        return this.chart.getDatasetMeta(this.index);
                    },

                    getScaleForId: function (scaleID) {
                        return this.chart.scales[scaleID];
                    },

                    reset: function () {
                        this.update(true);
                    },

                    /**
                     * @private
                     */
                    destroy: function () {
                        if (this._data) {
                            unlistenArrayEvents(this._data, this);
                        }
                    },

                    createMetaDataset: function () {
                        var me = this;
                        var type = me.datasetElementType;
                        return type && new type({
                            _chart: me.chart,
                            _datasetIndex: me.index
                        });
                    },

                    createMetaData: function (index) {
                        var me = this;
                        var type = me.dataElementType;
                        return type && new type({
                            _chart: me.chart,
                            _datasetIndex: me.index,
                            _index: index
                        });
                    },

                    addElements: function () {
                        var me = this;
                        var meta = me.getMeta();
                        var data = me.getDataset().data || [];
                        var metaData = meta.data;
                        var i, ilen;

                        for (i = 0, ilen = data.length; i < ilen; ++i) {
                            metaData[i] = metaData[i] || me.createMetaData(i);
                        }

                        meta.dataset = meta.dataset || me.createMetaDataset();
                    },

                    addElementAndReset: function (index) {
                        var element = this.createMetaData(index);
                        this.getMeta().data.splice(index, 0, element);
                        this.updateElement(element, index, true);
                    },

                    buildOrUpdateElements: function () {
                        var me = this;
                        var dataset = me.getDataset();
                        var data = dataset.data || (dataset.data = []);

                        // In order to correctly handle data addition/deletion animation (an thus simulate
                        // real-time charts), we need to monitor these data modifications and synchronize
                        // the internal meta data accordingly.
                        if (me._data !== data) {
                            if (me._data) {
                                // This case happens when the user replaced the data array instance.
                                unlistenArrayEvents(me._data, me);
                            }

                            listenArrayEvents(data, me);
                            me._data = data;
                        }

                        // Re-sync meta data in case the user replaced the data array or if we missed
                        // any updates and so make sure that we handle number of datapoints changing.
                        me.resyncElements();
                    },

                    update: helpers.noop,

                    transition: function (easingValue) {
                        var meta = this.getMeta();
                        var elements = meta.data || [];
                        var ilen = elements.length;
                        var i = 0;

                        for (; i < ilen; ++i) {
                            elements[i].transition(easingValue);
                        }

                        if (meta.dataset) {
                            meta.dataset.transition(easingValue);
                        }
                    },

                    draw: function () {
                        var meta = this.getMeta();
                        var elements = meta.data || [];
                        var ilen = elements.length;
                        var i = 0;

                        if (meta.dataset) {
                            meta.dataset.draw();
                        }

                        for (; i < ilen; ++i) {
                            elements[i].draw();
                        }
                    },

                    removeHoverStyle: function (element) {
                        helpers.merge(element._model, element.$previousStyle || {});
                        delete element.$previousStyle;
                    },

                    setHoverStyle: function (element) {
                        var dataset = this.chart.data.datasets[element._datasetIndex];
                        var index = element._index;
                        var custom = element.custom || {};
                        var valueOrDefault = helpers.valueAtIndexOrDefault;
                        var getHoverColor = helpers.getHoverColor;
                        var model = element._model;

                        element.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth
                        };

                        model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
                        model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
                        model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
                    },

                    /**
                     * @private
                     */
                    resyncElements: function () {
                        var me = this;
                        var meta = me.getMeta();
                        var data = me.getDataset().data;
                        var numMeta = meta.data.length;
                        var numData = data.length;

                        if (numData < numMeta) {
                            meta.data.splice(numData, numMeta - numData);
                        } else if (numData > numMeta) {
                            me.insertElements(numMeta, numData - numMeta);
                        }
                    },

                    /**
                     * @private
                     */
                    insertElements: function (start, count) {
                        for (var i = 0; i < count; ++i) {
                            this.addElementAndReset(start + i);
                        }
                    },

                    /**
                     * @private
                     */
                    onDataPush: function () {
                        this.insertElements(this.getDataset().data.length - 1, arguments.length);
                    },

                    /**
                     * @private
                     */
                    onDataPop: function () {
                        this.getMeta().data.pop();
                    },

                    /**
                     * @private
                     */
                    onDataShift: function () {
                        this.getMeta().data.shift();
                    },

                    /**
                     * @private
                     */
                    onDataSplice: function (start, count) {
                        this.getMeta().data.splice(start, count);
                        this.insertElements(start, arguments.length - 2);
                    },

                    /**
                     * @private
                     */
                    onDataUnshift: function () {
                        this.insertElements(0, arguments.length);
                    }
                });

                Chart.DatasetController.extend = helpers.inherits;
            };

        }, {"46": 46}],
        26: [function (require, module, exports) {
            'use strict';

            var helpers = require(46);

            module.exports = {
                /**
                 * @private
                 */
                _set: function (scope, values) {
                    return helpers.merge(this[scope] || (this[scope] = {}), values);
                }
            };

        }, {"46": 46}],
        27: [function (require, module, exports) {
            'use strict';

            var color = require(2);
            var helpers = require(46);

            function interpolate(start, view, model, ease) {
                var keys = Object.keys(model);
                var i, ilen, key, actual, origin, target, type, c0, c1;

                for (i = 0, ilen = keys.length; i < ilen; ++i) {
                    key = keys[i];

                    target = model[key];

                    // if a value is added to the model after pivot() has been called, the view
                    // doesn't contain it, so let's initialize the view to the target value.
                    if (!view.hasOwnProperty(key)) {
                        view[key] = target;
                    }

                    actual = view[key];

                    if (actual === target || key[0] === '_') {
                        continue;
                    }

                    if (!start.hasOwnProperty(key)) {
                        start[key] = actual;
                    }

                    origin = start[key];

                    type = typeof target;

                    if (type === typeof origin) {
                        if (type === 'string') {
                            c0 = color(origin);
                            if (c0.valid) {
                                c1 = color(target);
                                if (c1.valid) {
                                    view[key] = c1.mix(c0, ease).rgbString();
                                    continue;
                                }
                            }
                        } else if (type === 'number' && isFinite(origin) && isFinite(target)) {
                            view[key] = origin + (target - origin) * ease;
                            continue;
                        }
                    }

                    view[key] = target;
                }
            }

            var Element = function (configuration) {
                helpers.extend(this, configuration);
                this.initialize.apply(this, arguments);
            };

            helpers.extend(Element.prototype, {

                initialize: function () {
                    this.hidden = false;
                },

                pivot: function () {
                    var me = this;
                    if (!me._view) {
                        me._view = helpers.clone(me._model);
                    }
                    me._start = {};
                    return me;
                },

                transition: function (ease) {
                    var me = this;
                    var model = me._model;
                    var start = me._start;
                    var view = me._view;

                    // No animation -> No Transition
                    if (!model || ease === 1) {
                        me._view = model;
                        me._start = null;
                        return me;
                    }

                    if (!view) {
                        view = me._view = {};
                    }

                    if (!start) {
                        start = me._start = {};
                    }

                    interpolate(start, view, model, ease);

                    return me;
                },

                tooltipPosition: function () {
                    return {
                        x: this._model.x,
                        y: this._model.y
                    };
                },

                hasValue: function () {
                    return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
                }
            });

            Element.extend = helpers.inherits;

            module.exports = Element;

        }, {"2": 2, "46": 46}],
        28: [function (require, module, exports) {
            /* global window: false */
            /* global document: false */
            'use strict';

            var color = require(2);
            var defaults = require(26);
            var helpers = require(46);
            var scaleService = require(34);

            module.exports = function () {

                // -- Basic js utility methods

                helpers.configMerge = function (/* objects ... */) {
                    return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
                        merger: function (key, target, source, options) {
                            var tval = target[key] || {};
                            var sval = source[key];

                            if (key === 'scales') {
                                // scale config merging is complex. Add our own function here for that
                                target[key] = helpers.scaleMerge(tval, sval);
                            } else if (key === 'scale') {
                                // used in polar area & radar charts since there is only one scale
                                target[key] = helpers.merge(tval, [scaleService.getScaleDefaults(sval.type), sval]);
                            } else {
                                helpers._merger(key, target, source, options);
                            }
                        }
                    });
                };

                helpers.scaleMerge = function (/* objects ... */) {
                    return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
                        merger: function (key, target, source, options) {
                            if (key === 'xAxes' || key === 'yAxes') {
                                var slen = source[key].length;
                                var i, type, scale;

                                if (!target[key]) {
                                    target[key] = [];
                                }

                                for (i = 0; i < slen; ++i) {
                                    scale = source[key][i];
                                    type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

                                    if (i >= target[key].length) {
                                        target[key].push({});
                                    }

                                    if (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
                                        // new/untyped scale or type changed: let's apply the new defaults
                                        // then merge source scale to correctly overwrite the defaults.
                                        helpers.merge(target[key][i], [scaleService.getScaleDefaults(type), scale]);
                                    } else {
                                        // scales type are the same
                                        helpers.merge(target[key][i], scale);
                                    }
                                }
                            } else {
                                helpers._merger(key, target, source, options);
                            }
                        }
                    });
                };

                helpers.where = function (collection, filterCallback) {
                    if (helpers.isArray(collection) && Array.prototype.filter) {
                        return collection.filter(filterCallback);
                    }
                    var filtered = [];

                    helpers.each(collection, function (item) {
                        if (filterCallback(item)) {
                            filtered.push(item);
                        }
                    });

                    return filtered;
                };
                helpers.findIndex = Array.prototype.findIndex ?
                    function (array, callback, scope) {
                        return array.findIndex(callback, scope);
                    } :
                    function (array, callback, scope) {
                        scope = scope === undefined ? array : scope;
                        for (var i = 0, ilen = array.length; i < ilen; ++i) {
                            if (callback.call(scope, array[i], i, array)) {
                                return i;
                            }
                        }
                        return -1;
                    };
                helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
                    // Default to start of the array
                    if (helpers.isNullOrUndef(startIndex)) {
                        startIndex = -1;
                    }
                    for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
                        var currentItem = arrayToSearch[i];
                        if (filterCallback(currentItem)) {
                            return currentItem;
                        }
                    }
                };
                helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
                    // Default to end of the array
                    if (helpers.isNullOrUndef(startIndex)) {
                        startIndex = arrayToSearch.length;
                    }
                    for (var i = startIndex - 1; i >= 0; i--) {
                        var currentItem = arrayToSearch[i];
                        if (filterCallback(currentItem)) {
                            return currentItem;
                        }
                    }
                };

                // -- Math methods
                helpers.isNumber = function (n) {
                    return !isNaN(parseFloat(n)) && isFinite(n);
                };
                helpers.almostEquals = function (x, y, epsilon) {
                    return Math.abs(x - y) < epsilon;
                };
                helpers.almostWhole = function (x, epsilon) {
                    var rounded = Math.round(x);
                    return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
                };
                helpers.max = function (array) {
                    return array.reduce(function (max, value) {
                        if (!isNaN(value)) {
                            return Math.max(max, value);
                        }
                        return max;
                    }, Number.NEGATIVE_INFINITY);
                };
                helpers.min = function (array) {
                    return array.reduce(function (min, value) {
                        if (!isNaN(value)) {
                            return Math.min(min, value);
                        }
                        return min;
                    }, Number.POSITIVE_INFINITY);
                };
                helpers.sign = Math.sign ?
                    function (x) {
                        return Math.sign(x);
                    } :
                    function (x) {
                        x = +x; // convert to a number
                        if (x === 0 || isNaN(x)) {
                            return x;
                        }
                        return x > 0 ? 1 : -1;
                    };
                helpers.log10 = Math.log10 ?
                    function (x) {
                        return Math.log10(x);
                    } :
                    function (x) {
                        var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
                        // Check for whole powers of 10,
                        // which due to floating point rounding error should be corrected.
                        var powerOf10 = Math.round(exponent);
                        var isPowerOf10 = x === Math.pow(10, powerOf10);

                        return isPowerOf10 ? powerOf10 : exponent;
                    };
                helpers.toRadians = function (degrees) {
                    return degrees * (Math.PI / 180);
                };
                helpers.toDegrees = function (radians) {
                    return radians * (180 / Math.PI);
                };
                // Gets the angle from vertical upright to the point about a centre.
                helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
                    var distanceFromXCenter = anglePoint.x - centrePoint.x;
                    var distanceFromYCenter = anglePoint.y - centrePoint.y;
                    var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

                    var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

                    if (angle < (-0.5 * Math.PI)) {
                        angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
                    }

                    return {
                        angle: angle,
                        distance: radialDistanceFromCenter
                    };
                };
                helpers.distanceBetweenPoints = function (pt1, pt2) {
                    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
                };
                helpers.aliasPixel = function (pixelWidth) {
                    return (pixelWidth % 2 === 0) ? 0 : 0.5;
                };
                helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
                    // Props to Rob Spencer at scaled innovation for his post on splining between points
                    // http://scaledinnovation.com/analytics/splines/aboutSplines.html

                    // This function must also respect "skipped" points

                    var previous = firstPoint.skip ? middlePoint : firstPoint;
                    var current = middlePoint;
                    var next = afterPoint.skip ? middlePoint : afterPoint;

                    var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
                    var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

                    var s01 = d01 / (d01 + d12);
                    var s12 = d12 / (d01 + d12);

                    // If all points are the same, s01 & s02 will be inf
                    s01 = isNaN(s01) ? 0 : s01;
                    s12 = isNaN(s12) ? 0 : s12;

                    var fa = t * s01; // scaling factor for triangle Ta
                    var fb = t * s12;

                    return {
                        previous: {
                            x: current.x - fa * (next.x - previous.x),
                            y: current.y - fa * (next.y - previous.y)
                        },
                        next: {
                            x: current.x + fb * (next.x - previous.x),
                            y: current.y + fb * (next.y - previous.y)
                        }
                    };
                };
                helpers.EPSILON = Number.EPSILON || 1e-14;
                helpers.splineCurveMonotone = function (points) {
                    // This function calculates Bézier control points in a similar way than |splineCurve|,
                    // but preserves monotonicity of the provided data and ensures no local extremums are added
                    // between the dataset discrete points due to the interpolation.
                    // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

                    var pointsWithTangents = (points || []).map(function (point) {
                        return {
                            model: point._model,
                            deltaK: 0,
                            mK: 0
                        };
                    });

                    // Calculate slopes (deltaK) and initialize tangents (mK)
                    var pointsLen = pointsWithTangents.length;
                    var i, pointBefore, pointCurrent, pointAfter;
                    for (i = 0; i < pointsLen; ++i) {
                        pointCurrent = pointsWithTangents[i];
                        if (pointCurrent.model.skip) {
                            continue;
                        }

                        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
                        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
                        if (pointAfter && !pointAfter.model.skip) {
                            var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);

                            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
                            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
                        }

                        if (!pointBefore || pointBefore.model.skip) {
                            pointCurrent.mK = pointCurrent.deltaK;
                        } else if (!pointAfter || pointAfter.model.skip) {
                            pointCurrent.mK = pointBefore.deltaK;
                        } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
                            pointCurrent.mK = 0;
                        } else {
                            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
                        }
                    }

                    // Adjust tangents to ensure monotonic properties
                    var alphaK, betaK, tauK, squaredMagnitude;
                    for (i = 0; i < pointsLen - 1; ++i) {
                        pointCurrent = pointsWithTangents[i];
                        pointAfter = pointsWithTangents[i + 1];
                        if (pointCurrent.model.skip || pointAfter.model.skip) {
                            continue;
                        }

                        if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                            pointCurrent.mK = pointAfter.mK = 0;
                            continue;
                        }

                        alphaK = pointCurrent.mK / pointCurrent.deltaK;
                        betaK = pointAfter.mK / pointCurrent.deltaK;
                        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
                        if (squaredMagnitude <= 9) {
                            continue;
                        }

                        tauK = 3 / Math.sqrt(squaredMagnitude);
                        pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
                        pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
                    }

                    // Compute control points
                    var deltaX;
                    for (i = 0; i < pointsLen; ++i) {
                        pointCurrent = pointsWithTangents[i];
                        if (pointCurrent.model.skip) {
                            continue;
                        }

                        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
                        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
                        if (pointBefore && !pointBefore.model.skip) {
                            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
                        }
                        if (pointAfter && !pointAfter.model.skip) {
                            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
                        }
                    }
                };
                helpers.nextItem = function (collection, index, loop) {
                    if (loop) {
                        return index >= collection.length - 1 ? collection[0] : collection[index + 1];
                    }
                    return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
                };
                helpers.previousItem = function (collection, index, loop) {
                    if (loop) {
                        return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
                    }
                    return index <= 0 ? collection[0] : collection[index - 1];
                };
                // Implementation of the nice number algorithm used in determining where axis labels will go
                helpers.niceNum = function (range, round) {
                    var exponent = Math.floor(helpers.log10(range));
                    var fraction = range / Math.pow(10, exponent);
                    var niceFraction;

                    if (round) {
                        if (fraction < 1.5) {
                            niceFraction = 1;
                        } else if (fraction < 3) {
                            niceFraction = 2;
                        } else if (fraction < 7) {
                            niceFraction = 5;
                        } else {
                            niceFraction = 10;
                        }
                    } else if (fraction <= 1.0) {
                        niceFraction = 1;
                    } else if (fraction <= 2) {
                        niceFraction = 2;
                    } else if (fraction <= 5) {
                        niceFraction = 5;
                    } else {
                        niceFraction = 10;
                    }

                    return niceFraction * Math.pow(10, exponent);
                };
                // Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
                helpers.requestAnimFrame = (function () {
                    if (typeof window === 'undefined') {
                        return function (callback) {
                            callback();
                        };
                    }
                    return window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function (callback) {
                            return window.setTimeout(callback, 1000 / 60);
                        };
                }());
                // -- DOM methods
                helpers.getRelativePosition = function (evt, chart) {
                    var mouseX, mouseY;
                    var e = evt.originalEvent || evt;
                    var canvas = evt.target || evt.srcElement;
                    var boundingRect = canvas.getBoundingClientRect();

                    var touches = e.touches;
                    if (touches && touches.length > 0) {
                        mouseX = touches[0].clientX;
                        mouseY = touches[0].clientY;

                    } else {
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }

                    // Scale mouse coordinates into canvas coordinates
                    // by following the pattern laid out by 'jerryj' in the comments of
                    // http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
                    var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
                    var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
                    var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
                    var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
                    var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
                    var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

                    // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
                    // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
                    mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
                    mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

                    return {
                        x: mouseX,
                        y: mouseY
                    };

                };

                // Private helper function to convert max-width/max-height values that may be percentages into a number
                function parseMaxStyle(styleValue, node, parentProperty) {
                    var valueInPixels;
                    if (typeof styleValue === 'string') {
                        valueInPixels = parseInt(styleValue, 10);

                        if (styleValue.indexOf('%') !== -1) {
                            // percentage * size in dimension
                            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
                        }
                    } else {
                        valueInPixels = styleValue;
                    }

                    return valueInPixels;
                }

                /**
                 * Returns if the given value contains an effective constraint.
                 * @private
                 */
                function isConstrainedValue(value) {
                    return value !== undefined && value !== null && value !== 'none';
                }

                // Private helper to get a constraint dimension
                // @param domNode : the node to check the constraint on
                // @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
                // @param percentageProperty : property of parent to use when calculating width as a percentage
                // @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
                function getConstraintDimension(domNode, maxStyle, percentageProperty) {
                    var view = document.defaultView;
                    var parentNode = helpers._getParentNode(domNode);
                    var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
                    var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
                    var hasCNode = isConstrainedValue(constrainedNode);
                    var hasCContainer = isConstrainedValue(constrainedContainer);
                    var infinity = Number.POSITIVE_INFINITY;

                    if (hasCNode || hasCContainer) {
                        return Math.min(
                            hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
                            hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
                    }

                    return 'none';
                }

                // returns Number or undefined if no constraint
                helpers.getConstraintWidth = function (domNode) {
                    return getConstraintDimension(domNode, 'max-width', 'clientWidth');
                };
                // returns Number or undefined if no constraint
                helpers.getConstraintHeight = function (domNode) {
                    return getConstraintDimension(domNode, 'max-height', 'clientHeight');
                };
                /**
                 * @private
                 */
                helpers._calculatePadding = function (container, padding, parentDimension) {
                    padding = helpers.getStyle(container, padding);

                    return padding.indexOf('%') > -1 ? parentDimension / parseInt(padding, 10) : parseInt(padding, 10);
                };
                /**
                 * @private
                 */
                helpers._getParentNode = function (domNode) {
                    var parent = domNode.parentNode;
                    if (parent && parent.host) {
                        parent = parent.host;
                    }
                    return parent;
                };
                helpers.getMaximumWidth = function (domNode) {
                    var container = helpers._getParentNode(domNode);
                    if (!container) {
                        return domNode.clientWidth;
                    }

                    var clientWidth = container.clientWidth;
                    var paddingLeft = helpers._calculatePadding(container, 'padding-left', clientWidth);
                    var paddingRight = helpers._calculatePadding(container, 'padding-right', clientWidth);

                    var w = clientWidth - paddingLeft - paddingRight;
                    var cw = helpers.getConstraintWidth(domNode);
                    return isNaN(cw) ? w : Math.min(w, cw);
                };
                helpers.getMaximumHeight = function (domNode) {
                    var container = helpers._getParentNode(domNode);
                    if (!container) {
                        return domNode.clientHeight;
                    }

                    var clientHeight = container.clientHeight;
                    var paddingTop = helpers._calculatePadding(container, 'padding-top', clientHeight);
                    var paddingBottom = helpers._calculatePadding(container, 'padding-bottom', clientHeight);

                    var h = clientHeight - paddingTop - paddingBottom;
                    var ch = helpers.getConstraintHeight(domNode);
                    return isNaN(ch) ? h : Math.min(h, ch);
                };
                helpers.getStyle = function (el, property) {
                    return el.currentStyle ?
                        el.currentStyle[property] :
                        document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
                };
                helpers.retinaScale = function (chart, forceRatio) {
                    var pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;
                    if (pixelRatio === 1) {
                        return;
                    }

                    var canvas = chart.canvas;
                    var height = chart.height;
                    var width = chart.width;

                    canvas.height = height * pixelRatio;
                    canvas.width = width * pixelRatio;
                    chart.ctx.scale(pixelRatio, pixelRatio);

                    // If no style has been set on the canvas, the render size is used as display size,
                    // making the chart visually bigger, so let's enforce it to the "correct" values.
                    // See https://github.com/chartjs/Chart.js/issues/3575
                    if (!canvas.style.height && !canvas.style.width) {
                        canvas.style.height = height + 'px';
                        canvas.style.width = width + 'px';
                    }
                };
                // -- Canvas methods
                helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
                    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
                };
                helpers.longestText = function (ctx, font, arrayOfThings, cache) {
                    cache = cache || {};
                    var data = cache.data = cache.data || {};
                    var gc = cache.garbageCollect = cache.garbageCollect || [];

                    if (cache.font !== font) {
                        data = cache.data = {};
                        gc = cache.garbageCollect = [];
                        cache.font = font;
                    }

                    ctx.font = font;
                    var longest = 0;
                    helpers.each(arrayOfThings, function (thing) {
                        // Undefined strings and arrays should not be measured
                        if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
                            longest = helpers.measureText(ctx, data, gc, longest, thing);
                        } else if (helpers.isArray(thing)) {
                            // if it is an array lets measure each element
                            // to do maybe simplify this function a bit so we can do this more recursively?
                            helpers.each(thing, function (nestedThing) {
                                // Undefined strings and arrays should not be measured
                                if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
                                    longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
                                }
                            });
                        }
                    });

                    var gcLen = gc.length / 2;
                    if (gcLen > arrayOfThings.length) {
                        for (var i = 0; i < gcLen; i++) {
                            delete data[gc[i]];
                        }
                        gc.splice(0, gcLen);
                    }
                    return longest;
                };
                helpers.measureText = function (ctx, data, gc, longest, string) {
                    var textWidth = data[string];
                    if (!textWidth) {
                        textWidth = data[string] = ctx.measureText(string).width;
                        gc.push(string);
                    }
                    if (textWidth > longest) {
                        longest = textWidth;
                    }
                    return longest;
                };
                helpers.numberOfLabelLines = function (arrayOfThings) {
                    var numberOfLines = 1;
                    helpers.each(arrayOfThings, function (thing) {
                        if (helpers.isArray(thing)) {
                            if (thing.length > numberOfLines) {
                                numberOfLines = thing.length;
                            }
                        }
                    });
                    return numberOfLines;
                };

                helpers.color = !color ?
                    function (value) {
                        console.error('Color.js not found!');
                        return value;
                    } :
                    function (value) {
                        /* global CanvasGradient */
                        if (value instanceof CanvasGradient) {
                            value = defaults.global.defaultColor;
                        }

                        return color(value);
                    };

                helpers.getHoverColor = function (colorValue) {
                    /* global CanvasPattern */
                    return (colorValue instanceof CanvasPattern) ?
                        colorValue :
                        helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
                };
            };

        }, {"2": 2, "26": 26, "34": 34, "46": 46}],
        29: [function (require, module, exports) {
            'use strict';

            var helpers = require(46);

            /**
             * Helper function to get relative position for an event
             * @param {Event|IEvent} event - The event to get the position for
             * @param {Chart} chart - The chart
             * @returns {Point} the event position
             */
            function getRelativePosition(e, chart) {
                if (e.native) {
                    return {
                        x: e.x,
                        y: e.y
                    };
                }

                return helpers.getRelativePosition(e, chart);
            }

            /**
             * Helper function to traverse all of the visible elements in the chart
             * @param chart {chart} the chart
             * @param handler {Function} the callback to execute for each visible item
             */
            function parseVisibleItems(chart, handler) {
                var datasets = chart.data.datasets;
                var meta, i, j, ilen, jlen;

                for (i = 0, ilen = datasets.length; i < ilen; ++i) {
                    if (!chart.isDatasetVisible(i)) {
                        continue;
                    }

                    meta = chart.getDatasetMeta(i);
                    for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
                        var element = meta.data[j];
                        if (!element._view.skip) {
                            handler(element);
                        }
                    }
                }
            }

            /**
             * Helper function to get the items that intersect the event position
             * @param items {ChartElement[]} elements to filter
             * @param position {Point} the point to be nearest to
             * @return {ChartElement[]} the nearest items
             */
            function getIntersectItems(chart, position) {
                var elements = [];

                parseVisibleItems(chart, function (element) {
                    if (element.inRange(position.x, position.y)) {
                        elements.push(element);
                    }
                });

                return elements;
            }

            /**
             * Helper function to get the items nearest to the event position considering all visible items in teh chart
             * @param chart {Chart} the chart to look at elements from
             * @param position {Point} the point to be nearest to
             * @param intersect {Boolean} if true, only consider items that intersect the position
             * @param distanceMetric {Function} function to provide the distance between points
             * @return {ChartElement[]} the nearest items
             */
            function getNearestItems(chart, position, intersect, distanceMetric) {
                var minDistance = Number.POSITIVE_INFINITY;
                var nearestItems = [];

                parseVisibleItems(chart, function (element) {
                    if (intersect && !element.inRange(position.x, position.y)) {
                        return;
                    }

                    var center = element.getCenterPoint();
                    var distance = distanceMetric(position, center);

                    if (distance < minDistance) {
                        nearestItems = [element];
                        minDistance = distance;
                    } else if (distance === minDistance) {
                        // Can have multiple items at the same distance in which case we sort by size
                        nearestItems.push(element);
                    }
                });

                return nearestItems;
            }

            /**
             * Get a distance metric function for two points based on the
             * axis mode setting
             * @param {String} axis the axis mode. x|y|xy
             */
            function getDistanceMetricForAxis(axis) {
                var useX = axis.indexOf('x') !== -1;
                var useY = axis.indexOf('y') !== -1;

                return function (pt1, pt2) {
                    var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
                    var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
                    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                };
            }

            function indexMode(chart, e, options) {
                var position = getRelativePosition(e, chart);
                // Default axis for index mode is 'x' to match old behaviour
                options.axis = options.axis || 'x';
                var distanceMetric = getDistanceMetricForAxis(options.axis);
                var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
                var elements = [];

                if (!items.length) {
                    return [];
                }

                chart.data.datasets.forEach(function (dataset, datasetIndex) {
                    if (chart.isDatasetVisible(datasetIndex)) {
                        var meta = chart.getDatasetMeta(datasetIndex);
                        var element = meta.data[items[0]._index];

                        // don't count items that are skipped (null data)
                        if (element && !element._view.skip) {
                            elements.push(element);
                        }
                    }
                });

                return elements;
            }

            /**
             * @interface IInteractionOptions
             */
            /**
             * If true, only consider items that intersect the point
             * @name IInterfaceOptions#boolean
             * @type Boolean
             */

            /**
             * Contains interaction related functions
             * @namespace Chart.Interaction
             */
            module.exports = {
                // Helper function for different modes
                modes: {
                    single: function (chart, e) {
                        var position = getRelativePosition(e, chart);
                        var elements = [];

                        parseVisibleItems(chart, function (element) {
                            if (element.inRange(position.x, position.y)) {
                                elements.push(element);
                                return elements;
                            }
                        });

                        return elements.slice(0, 1);
                    },

                    /**
                     * @function Chart.Interaction.modes.label
                     * @deprecated since version 2.4.0
                     * @todo remove at version 3
                     * @private
                     */
                    label: indexMode,

                    /**
                     * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
                     * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
                     * @function Chart.Interaction.modes.index
                     * @since v2.4.0
                     * @param chart {chart} the chart we are returning items from
                     * @param e {Event} the event we are find things at
                     * @param options {IInteractionOptions} options to use during interaction
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    index: indexMode,

                    /**
                     * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
                     * If the options.intersect is false, we find the nearest item and return the items in that dataset
                     * @function Chart.Interaction.modes.dataset
                     * @param chart {chart} the chart we are returning items from
                     * @param e {Event} the event we are find things at
                     * @param options {IInteractionOptions} options to use during interaction
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    dataset: function (chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        options.axis = options.axis || 'xy';
                        var distanceMetric = getDistanceMetricForAxis(options.axis);
                        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

                        if (items.length > 0) {
                            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
                        }

                        return items;
                    },

                    /**
                     * @function Chart.Interaction.modes.x-axis
                     * @deprecated since version 2.4.0. Use index mode and intersect == true
                     * @todo remove at version 3
                     * @private
                     */
                    'x-axis': function (chart, e) {
                        return indexMode(chart, e, {intersect: false});
                    },

                    /**
                     * Point mode returns all elements that hit test based on the event position
                     * of the event
                     * @function Chart.Interaction.modes.intersect
                     * @param chart {chart} the chart we are returning items from
                     * @param e {Event} the event we are find things at
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    point: function (chart, e) {
                        var position = getRelativePosition(e, chart);
                        return getIntersectItems(chart, position);
                    },

                    /**
                     * nearest mode returns the element closest to the point
                     * @function Chart.Interaction.modes.intersect
                     * @param chart {chart} the chart we are returning items from
                     * @param e {Event} the event we are find things at
                     * @param options {IInteractionOptions} options to use
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    nearest: function (chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        options.axis = options.axis || 'xy';
                        var distanceMetric = getDistanceMetricForAxis(options.axis);
                        var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);

                        // We have multiple items at the same distance from the event. Now sort by smallest
                        if (nearestItems.length > 1) {
                            nearestItems.sort(function (a, b) {
                                var sizeA = a.getArea();
                                var sizeB = b.getArea();
                                var ret = sizeA - sizeB;

                                if (ret === 0) {
                                    // if equal sort by dataset index
                                    ret = a._datasetIndex - b._datasetIndex;
                                }

                                return ret;
                            });
                        }

                        // Return only 1 item
                        return nearestItems.slice(0, 1);
                    },

                    /**
                     * x mode returns the elements that hit-test at the current x coordinate
                     * @function Chart.Interaction.modes.x
                     * @param chart {chart} the chart we are returning items from
                     * @param e {Event} the event we are find things at
                     * @param options {IInteractionOptions} options to use
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    x: function (chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        var items = [];
                        var intersectsItem = false;

                        parseVisibleItems(chart, function (element) {
                            if (element.inXRange(position.x)) {
                                items.push(element);
                            }

                            if (element.inRange(position.x, position.y)) {
                                intersectsItem = true;
                            }
                        });

                        // If we want to trigger on an intersect and we don't have any items
                        // that intersect the position, return nothing
                        if (options.intersect && !intersectsItem) {
                            items = [];
                        }
                        return items;
                    },

                    /**
                     * y mode returns the elements that hit-test at the current y coordinate
                     * @function Chart.Interaction.modes.y
                     * @param chart {chart} the chart we are returning items from
                     * @param e {Event} the event we are find things at
                     * @param options {IInteractionOptions} options to use
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    y: function (chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        var items = [];
                        var intersectsItem = false;

                        parseVisibleItems(chart, function (element) {
                            if (element.inYRange(position.y)) {
                                items.push(element);
                            }

                            if (element.inRange(position.x, position.y)) {
                                intersectsItem = true;
                            }
                        });

                        // If we want to trigger on an intersect and we don't have any items
                        // that intersect the position, return nothing
                        if (options.intersect && !intersectsItem) {
                            items = [];
                        }
                        return items;
                    }
                }
            };

        }, {"46": 46}],
        30: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);

            defaults._set('global', {
                responsive: true,
                responsiveAnimationDuration: 0,
                maintainAspectRatio: true,
                events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
                hover: {
                    onHover: null,
                    mode: 'nearest',
                    intersect: true,
                    animationDuration: 400
                },
                onClick: null,
                defaultColor: 'rgba(0,0,0,0.1)',
                defaultFontColor: '#666',
                defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                defaultFontSize: 12,
                defaultFontStyle: 'normal',
                showLines: true,

                // Element defaults defined in element extensions
                elements: {},

                // Layout options such as padding
                layout: {
                    padding: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                }
            });

            module.exports = function () {

                // Occupy the global variable of Chart, and create a simple base class
                var Chart = function (item, config) {
                    this.construct(item, config);
                    return this;
                };

                Chart.Chart = Chart;

                return Chart;
            };

        }, {"26": 26}],
        31: [function (require, module, exports) {
            'use strict';

            var helpers = require(46);

            function filterByPosition(array, position) {
                return helpers.where(array, function (v) {
                    return v.position === position;
                });
            }

            function sortByWeight(array, reverse) {
                array.forEach(function (v, i) {
                    v._tmpIndex_ = i;
                    return v;
                });
                array.sort(function (a, b) {
                    var v0 = reverse ? b : a;
                    var v1 = reverse ? a : b;
                    return v0.weight === v1.weight ?
                        v0._tmpIndex_ - v1._tmpIndex_ :
                        v0.weight - v1.weight;
                });
                array.forEach(function (v) {
                    delete v._tmpIndex_;
                });
            }

            /**
             * @interface ILayoutItem
             * @prop {String} position - The position of the item in the chart layout. Possible values are
             * 'left', 'top', 'right', 'bottom', and 'chartArea'
             * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
             * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
             * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
             * @prop {Function} update - Takes two parameters: width and height. Returns size of item
             * @prop {Function} getPadding -  Returns an object with padding on the edges
             * @prop {Number} width - Width of item. Must be valid after update()
             * @prop {Number} height - Height of item. Must be valid after update()
             * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
             * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
             * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
             * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
             */

// The layout service is very self explanatory.  It's responsible for the layout within a chart.
// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
// It is this service's responsibility of carrying out that layout.
            module.exports = {
                defaults: {},

                /**
                 * Register a box to a chart.
                 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
                 * @param {Chart} chart - the chart to use
                 * @param {ILayoutItem} item - the item to add to be layed out
                 */
                addBox: function (chart, item) {
                    if (!chart.boxes) {
                        chart.boxes = [];
                    }

                    // initialize item with default values
                    item.fullWidth = item.fullWidth || false;
                    item.position = item.position || 'top';
                    item.weight = item.weight || 0;

                    chart.boxes.push(item);
                },

                /**
                 * Remove a layoutItem from a chart
                 * @param {Chart} chart - the chart to remove the box from
                 * @param {Object} layoutItem - the item to remove from the layout
                 */
                removeBox: function (chart, layoutItem) {
                    var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
                    if (index !== -1) {
                        chart.boxes.splice(index, 1);
                    }
                },

                /**
                 * Sets (or updates) options on the given `item`.
                 * @param {Chart} chart - the chart in which the item lives (or will be added to)
                 * @param {Object} item - the item to configure with the given options
                 * @param {Object} options - the new item options.
                 */
                configure: function (chart, item, options) {
                    var props = ['fullWidth', 'position', 'weight'];
                    var ilen = props.length;
                    var i = 0;
                    var prop;

                    for (; i < ilen; ++i) {
                        prop = props[i];
                        if (options.hasOwnProperty(prop)) {
                            item[prop] = options[prop];
                        }
                    }
                },

                /**
                 * Fits boxes of the given chart into the given size by having each box measure itself
                 * then running a fitting algorithm
                 * @param {Chart} chart - the chart
                 * @param {Number} width - the width to fit into
                 * @param {Number} height - the height to fit into
                 */
                update: function (chart, width, height) {
                    if (!chart) {
                        return;
                    }

                    var layoutOptions = chart.options.layout || {};
                    var padding = helpers.options.toPadding(layoutOptions.padding);
                    var leftPadding = padding.left;
                    var rightPadding = padding.right;
                    var topPadding = padding.top;
                    var bottomPadding = padding.bottom;

                    var leftBoxes = filterByPosition(chart.boxes, 'left');
                    var rightBoxes = filterByPosition(chart.boxes, 'right');
                    var topBoxes = filterByPosition(chart.boxes, 'top');
                    var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
                    var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

                    // Sort boxes by weight. A higher weight is further away from the chart area
                    sortByWeight(leftBoxes, true);
                    sortByWeight(rightBoxes, false);
                    sortByWeight(topBoxes, true);
                    sortByWeight(bottomBoxes, false);

                    // Essentially we now have any number of boxes on each of the 4 sides.
                    // Our canvas looks like the following.
                    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
                    // B1 is the bottom axis
                    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
                    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
                    // an error will be thrown.
                    //
                    // |----------------------------------------------------|
                    // |                  T1 (Full Width)                   |
                    // |----------------------------------------------------|
                    // |    |    |                 T2                  |    |
                    // |    |----|-------------------------------------|----|
                    // |    |    | C1 |                           | C2 |    |
                    // |    |    |----|                           |----|    |
                    // |    |    |                                     |    |
                    // | L1 | L2 |           ChartArea (C0)            | R1 |
                    // |    |    |                                     |    |
                    // |    |    |----|                           |----|    |
                    // |    |    | C3 |                           | C4 |    |
                    // |    |----|-------------------------------------|----|
                    // |    |    |                 B1                  |    |
                    // |----------------------------------------------------|
                    // |                  B2 (Full Width)                   |
                    // |----------------------------------------------------|
                    //
                    // What we do to find the best sizing, we do the following
                    // 1. Determine the minimum size of the chart area.
                    // 2. Split the remaining width equally between each vertical axis
                    // 3. Split the remaining height equally between each horizontal axis
                    // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
                    // 5. Adjust the sizes of each axis based on it's minimum reported size.
                    // 6. Refit each axis
                    // 7. Position each axis in the final location
                    // 8. Tell the chart the final location of the chart area
                    // 9. Tell any axes that overlay the chart area the positions of the chart area

                    // Step 1
                    var chartWidth = width - leftPadding - rightPadding;
                    var chartHeight = height - topPadding - bottomPadding;
                    var chartAreaWidth = chartWidth / 2; // min 50%
                    var chartAreaHeight = chartHeight / 2; // min 50%

                    // Step 2
                    var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

                    // Step 3
                    var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

                    // Step 4
                    var maxChartAreaWidth = chartWidth;
                    var maxChartAreaHeight = chartHeight;
                    var minBoxSizes = [];

                    function getMinimumBoxSize(box) {
                        var minSize;
                        var isHorizontal = box.isHorizontal();

                        if (isHorizontal) {
                            minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
                            maxChartAreaHeight -= minSize.height;
                        } else {
                            minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
                            maxChartAreaWidth -= minSize.width;
                        }

                        minBoxSizes.push({
                            horizontal: isHorizontal,
                            minSize: minSize,
                            box: box,
                        });
                    }

                    helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

                    // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
                    var maxHorizontalLeftPadding = 0;
                    var maxHorizontalRightPadding = 0;
                    var maxVerticalTopPadding = 0;
                    var maxVerticalBottomPadding = 0;

                    helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {
                        if (horizontalBox.getPadding) {
                            var boxPadding = horizontalBox.getPadding();
                            maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
                            maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
                        }
                    });

                    helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {
                        if (verticalBox.getPadding) {
                            var boxPadding = verticalBox.getPadding();
                            maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
                            maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
                        }
                    });

                    // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
                    // be if the axes are drawn at their minimum sizes.
                    // Steps 5 & 6
                    var totalLeftBoxesWidth = leftPadding;
                    var totalRightBoxesWidth = rightPadding;
                    var totalTopBoxesHeight = topPadding;
                    var totalBottomBoxesHeight = bottomPadding;

                    // Function to fit a box
                    function fitBox(box) {
                        var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {
                            return minBox.box === box;
                        });

                        if (minBoxSize) {
                            if (box.isHorizontal()) {
                                var scaleMargin = {
                                    left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
                                    right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
                                    top: 0,
                                    bottom: 0
                                };

                                // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
                                // on the margin. Sometimes they need to increase in size slightly
                                box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
                            } else {
                                box.update(minBoxSize.minSize.width, maxChartAreaHeight);
                            }
                        }
                    }

                    // Update, and calculate the left and right margins for the horizontal boxes
                    helpers.each(leftBoxes.concat(rightBoxes), fitBox);

                    helpers.each(leftBoxes, function (box) {
                        totalLeftBoxesWidth += box.width;
                    });

                    helpers.each(rightBoxes, function (box) {
                        totalRightBoxesWidth += box.width;
                    });

                    // Set the Left and Right margins for the horizontal boxes
                    helpers.each(topBoxes.concat(bottomBoxes), fitBox);

                    // Figure out how much margin is on the top and bottom of the vertical boxes
                    helpers.each(topBoxes, function (box) {
                        totalTopBoxesHeight += box.height;
                    });

                    helpers.each(bottomBoxes, function (box) {
                        totalBottomBoxesHeight += box.height;
                    });

                    function finalFitVerticalBox(box) {
                        var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {
                            return minSize.box === box;
                        });

                        var scaleMargin = {
                            left: 0,
                            right: 0,
                            top: totalTopBoxesHeight,
                            bottom: totalBottomBoxesHeight
                        };

                        if (minBoxSize) {
                            box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
                        }
                    }

                    // Let the left layout know the final margin
                    helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

                    // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
                    totalLeftBoxesWidth = leftPadding;
                    totalRightBoxesWidth = rightPadding;
                    totalTopBoxesHeight = topPadding;
                    totalBottomBoxesHeight = bottomPadding;

                    helpers.each(leftBoxes, function (box) {
                        totalLeftBoxesWidth += box.width;
                    });

                    helpers.each(rightBoxes, function (box) {
                        totalRightBoxesWidth += box.width;
                    });

                    helpers.each(topBoxes, function (box) {
                        totalTopBoxesHeight += box.height;
                    });
                    helpers.each(bottomBoxes, function (box) {
                        totalBottomBoxesHeight += box.height;
                    });

                    // We may be adding some padding to account for rotated x axis labels
                    var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
                    totalLeftBoxesWidth += leftPaddingAddition;
                    totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

                    var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
                    totalTopBoxesHeight += topPaddingAddition;
                    totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

                    // Figure out if our chart area changed. This would occur if the dataset layout label rotation
                    // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
                    // without calling `fit` again
                    var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
                    var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

                    if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
                        helpers.each(leftBoxes, function (box) {
                            box.height = newMaxChartAreaHeight;
                        });

                        helpers.each(rightBoxes, function (box) {
                            box.height = newMaxChartAreaHeight;
                        });

                        helpers.each(topBoxes, function (box) {
                            if (!box.fullWidth) {
                                box.width = newMaxChartAreaWidth;
                            }
                        });

                        helpers.each(bottomBoxes, function (box) {
                            if (!box.fullWidth) {
                                box.width = newMaxChartAreaWidth;
                            }
                        });

                        maxChartAreaHeight = newMaxChartAreaHeight;
                        maxChartAreaWidth = newMaxChartAreaWidth;
                    }

                    // Step 7 - Position the boxes
                    var left = leftPadding + leftPaddingAddition;
                    var top = topPadding + topPaddingAddition;

                    function placeBox(box) {
                        if (box.isHorizontal()) {
                            box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
                            box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
                            box.top = top;
                            box.bottom = top + box.height;

                            // Move to next point
                            top = box.bottom;

                        } else {

                            box.left = left;
                            box.right = left + box.width;
                            box.top = totalTopBoxesHeight;
                            box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

                            // Move to next point
                            left = box.right;
                        }
                    }

                    helpers.each(leftBoxes.concat(topBoxes), placeBox);

                    // Account for chart width and height
                    left += maxChartAreaWidth;
                    top += maxChartAreaHeight;

                    helpers.each(rightBoxes, placeBox);
                    helpers.each(bottomBoxes, placeBox);

                    // Step 8
                    chart.chartArea = {
                        left: totalLeftBoxesWidth,
                        top: totalTopBoxesHeight,
                        right: totalLeftBoxesWidth + maxChartAreaWidth,
                        bottom: totalTopBoxesHeight + maxChartAreaHeight
                    };

                    // Step 9
                    helpers.each(chartAreaBoxes, function (box) {
                        box.left = chart.chartArea.left;
                        box.top = chart.chartArea.top;
                        box.right = chart.chartArea.right;
                        box.bottom = chart.chartArea.bottom;

                        box.update(maxChartAreaWidth, maxChartAreaHeight);
                    });
                }
            };

        }, {"46": 46}],
        32: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var helpers = require(46);

            defaults._set('global', {
                plugins: {}
            });

            /**
             * The plugin service singleton
             * @namespace Chart.plugins
             * @since 2.1.0
             */
            module.exports = {
                /**
                 * Globally registered plugins.
                 * @private
                 */
                _plugins: [],

                /**
                 * This identifier is used to invalidate the descriptors cache attached to each chart
                 * when a global plugin is registered or unregistered. In this case, the cache ID is
                 * incremented and descriptors are regenerated during following API calls.
                 * @private
                 */
                _cacheId: 0,

                /**
                 * Registers the given plugin(s) if not already registered.
                 * @param {Array|Object} plugins plugin instance(s).
                 */
                register: function (plugins) {
                    var p = this._plugins;
                    ([]).concat(plugins).forEach(function (plugin) {
                        if (p.indexOf(plugin) === -1) {
                            p.push(plugin);
                        }
                    });

                    this._cacheId++;
                },

                /**
                 * Unregisters the given plugin(s) only if registered.
                 * @param {Array|Object} plugins plugin instance(s).
                 */
                unregister: function (plugins) {
                    var p = this._plugins;
                    ([]).concat(plugins).forEach(function (plugin) {
                        var idx = p.indexOf(plugin);
                        if (idx !== -1) {
                            p.splice(idx, 1);
                        }
                    });

                    this._cacheId++;
                },

                /**
                 * Remove all registered plugins.
                 * @since 2.1.5
                 */
                clear: function () {
                    this._plugins = [];
                    this._cacheId++;
                },

                /**
                 * Returns the number of registered plugins?
                 * @returns {Number}
                 * @since 2.1.5
                 */
                count: function () {
                    return this._plugins.length;
                },

                /**
                 * Returns all registered plugin instances.
                 * @returns {Array} array of plugin objects.
                 * @since 2.1.5
                 */
                getAll: function () {
                    return this._plugins;
                },

                /**
                 * Calls enabled plugins for `chart` on the specified hook and with the given args.
                 * This method immediately returns as soon as a plugin explicitly returns false. The
                 * returned value can be used, for instance, to interrupt the current action.
                 * @param {Object} chart - The chart instance for which plugins should be called.
                 * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
                 * @param {Array} [args] - Extra arguments to apply to the hook call.
                 * @returns {Boolean} false if any of the plugins return false, else returns true.
                 */
                notify: function (chart, hook, args) {
                    var descriptors = this.descriptors(chart);
                    var ilen = descriptors.length;
                    var i, descriptor, plugin, params, method;

                    for (i = 0; i < ilen; ++i) {
                        descriptor = descriptors[i];
                        plugin = descriptor.plugin;
                        method = plugin[hook];
                        if (typeof method === 'function') {
                            params = [chart].concat(args || []);
                            params.push(descriptor.options);
                            if (method.apply(plugin, params) === false) {
                                return false;
                            }
                        }
                    }

                    return true;
                },

                /**
                 * Returns descriptors of enabled plugins for the given chart.
                 * @returns {Array} [{ plugin, options }]
                 * @private
                 */
                descriptors: function (chart) {
                    var cache = chart.$plugins || (chart.$plugins = {});
                    if (cache.id === this._cacheId) {
                        return cache.descriptors;
                    }

                    var plugins = [];
                    var descriptors = [];
                    var config = (chart && chart.config) || {};
                    var options = (config.options && config.options.plugins) || {};

                    this._plugins.concat(config.plugins || []).forEach(function (plugin) {
                        var idx = plugins.indexOf(plugin);
                        if (idx !== -1) {
                            return;
                        }

                        var id = plugin.id;
                        var opts = options[id];
                        if (opts === false) {
                            return;
                        }

                        if (opts === true) {
                            opts = helpers.clone(defaults.global.plugins[id]);
                        }

                        plugins.push(plugin);
                        descriptors.push({
                            plugin: plugin,
                            options: opts || {}
                        });
                    });

                    cache.descriptors = descriptors;
                    cache.id = this._cacheId;
                    return descriptors;
                },

                /**
                 * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
                 * but in some cases, this reference can be changed by the user when updating options.
                 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
                 * @private
                 */
                _invalidate: function (chart) {
                    delete chart.$plugins;
                }
            };

            /**
             * Plugin extension hooks.
             * @interface IPlugin
             * @since 2.1.0
             */
            /**
             * @method IPlugin#beforeInit
             * @desc Called before initializing `chart`.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#afterInit
             * @desc Called after `chart` has been initialized and before the first update.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeUpdate
             * @desc Called before updating `chart`. If any plugin returns `false`, the update
             * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} `false` to cancel the chart update.
             */
            /**
             * @method IPlugin#afterUpdate
             * @desc Called after `chart` has been updated and before rendering. Note that this
             * hook will not be called if the chart update has been previously cancelled.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeDatasetsUpdate
             * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
             * the datasets update is cancelled until another `update` is triggered.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} false to cancel the datasets update.
             * @since version 2.1.5
             */
            /**
             * @method IPlugin#afterDatasetsUpdate
             * @desc Called after the `chart` datasets have been updated. Note that this hook
             * will not be called if the datasets update has been previously cancelled.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             * @since version 2.1.5
             */
            /**
             * @method IPlugin#beforeDatasetUpdate
             * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
             * returns `false`, the datasets update is cancelled until another `update` is triggered.
             * @param {Chart} chart - The chart instance.
             * @param {Object} args - The call arguments.
             * @param {Number} args.index - The dataset index.
             * @param {Object} args.meta - The dataset metadata.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} `false` to cancel the chart datasets drawing.
             */
            /**
             * @method IPlugin#afterDatasetUpdate
             * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
             * that this hook will not be called if the datasets update has been previously cancelled.
             * @param {Chart} chart - The chart instance.
             * @param {Object} args - The call arguments.
             * @param {Number} args.index - The dataset index.
             * @param {Object} args.meta - The dataset metadata.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeLayout
             * @desc Called before laying out `chart`. If any plugin returns `false`,
             * the layout update is cancelled until another `update` is triggered.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} `false` to cancel the chart layout.
             */
            /**
             * @method IPlugin#afterLayout
             * @desc Called after the `chart` has been layed out. Note that this hook will not
             * be called if the layout update has been previously cancelled.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeRender
             * @desc Called before rendering `chart`. If any plugin returns `false`,
             * the rendering is cancelled until another `render` is triggered.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} `false` to cancel the chart rendering.
             */
            /**
             * @method IPlugin#afterRender
             * @desc Called after the `chart` has been fully rendered (and animation completed). Note
             * that this hook will not be called if the rendering has been previously cancelled.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeDraw
             * @desc Called before drawing `chart` at every animation frame specified by the given
             * easing value. If any plugin returns `false`, the frame drawing is cancelled until
             * another `render` is triggered.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} `false` to cancel the chart drawing.
             */
            /**
             * @method IPlugin#afterDraw
             * @desc Called after the `chart` has been drawn for the specific easing value. Note
             * that this hook will not be called if the drawing has been previously cancelled.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeDatasetsDraw
             * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
             * the datasets drawing is cancelled until another `render` is triggered.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} `false` to cancel the chart datasets drawing.
             */
            /**
             * @method IPlugin#afterDatasetsDraw
             * @desc Called after the `chart` datasets have been drawn. Note that this hook
             * will not be called if the datasets drawing has been previously cancelled.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeDatasetDraw
             * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
             * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
             * is cancelled until another `render` is triggered.
             * @param {Chart} chart - The chart instance.
             * @param {Object} args - The call arguments.
             * @param {Number} args.index - The dataset index.
             * @param {Object} args.meta - The dataset metadata.
             * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} `false` to cancel the chart datasets drawing.
             */
            /**
             * @method IPlugin#afterDatasetDraw
             * @desc Called after the `chart` datasets at the given `args.index` have been drawn
             * (datasets are drawn in the reverse order). Note that this hook will not be called
             * if the datasets drawing has been previously cancelled.
             * @param {Chart} chart - The chart instance.
             * @param {Object} args - The call arguments.
             * @param {Number} args.index - The dataset index.
             * @param {Object} args.meta - The dataset metadata.
             * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeTooltipDraw
             * @desc Called before drawing the `tooltip`. If any plugin returns `false`,
             * the tooltip drawing is cancelled until another `render` is triggered.
             * @param {Chart} chart - The chart instance.
             * @param {Object} args - The call arguments.
             * @param {Object} args.tooltip - The tooltip.
             * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
             * @param {Object} options - The plugin options.
             * @returns {Boolean} `false` to cancel the chart tooltip drawing.
             */
            /**
             * @method IPlugin#afterTooltipDraw
             * @desc Called after drawing the `tooltip`. Note that this hook will not
             * be called if the tooltip drawing has been previously cancelled.
             * @param {Chart} chart - The chart instance.
             * @param {Object} args - The call arguments.
             * @param {Object} args.tooltip - The tooltip.
             * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#beforeEvent
             * @desc Called before processing the specified `event`. If any plugin returns `false`,
             * the event will be discarded.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {IEvent} event - The event object.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#afterEvent
             * @desc Called after the `event` has been consumed. Note that this hook
             * will not be called if the `event` has been previously discarded.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {IEvent} event - The event object.
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#resize
             * @desc Called after the chart as been resized.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
             * @param {Object} options - The plugin options.
             */
            /**
             * @method IPlugin#destroy
             * @desc Called after the chart as been destroyed.
             * @param {Chart.Controller} chart - The chart instance.
             * @param {Object} options - The plugin options.
             */

        }, {"26": 26, "46": 46}],
        33: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var Element = require(27);
            var helpers = require(46);
            var Ticks = require(35);

            defaults._set('scale', {
                display: true,
                position: 'left',
                offset: false,

                // grid line settings
                gridLines: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.1)',
                    lineWidth: 1,
                    drawBorder: true,
                    drawOnChartArea: true,
                    drawTicks: true,
                    tickMarkLength: 10,
                    zeroLineWidth: 1,
                    zeroLineColor: 'rgba(0,0,0,0.25)',
                    zeroLineBorderDash: [],
                    zeroLineBorderDashOffset: 0.0,
                    offsetGridLines: false,
                    borderDash: [],
                    borderDashOffset: 0.0
                },

                // scale label
                scaleLabel: {
                    // display property
                    display: false,

                    // actual label
                    labelString: '',

                    // line height
                    lineHeight: 1.2,

                    // top/bottom padding
                    padding: {
                        top: 4,
                        bottom: 4
                    }
                },

                // label settings
                ticks: {
                    beginAtZero: false,
                    minRotation: 0,
                    maxRotation: 50,
                    mirror: false,
                    padding: 0,
                    reverse: false,
                    display: true,
                    autoSkip: true,
                    autoSkipPadding: 0,
                    labelOffset: 0,
                    // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
                    callback: Ticks.formatters.values,
                    minor: {},
                    major: {}
                }
            });

            function labelsFromTicks(ticks) {
                var labels = [];
                var i, ilen;

                for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                    labels.push(ticks[i].label);
                }

                return labels;
            }

            function getLineValue(scale, index, offsetGridLines) {
                var lineValue = scale.getPixelForTick(index);

                if (offsetGridLines) {
                    if (index === 0) {
                        lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
                    } else {
                        lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
                    }
                }
                return lineValue;
            }

            function computeTextSize(context, tick, font) {
                return helpers.isArray(tick) ?
                    helpers.longestText(context, font, tick) :
                    context.measureText(tick).width;
            }

            function parseFontOptions(options) {
                var valueOrDefault = helpers.valueOrDefault;
                var globalDefaults = defaults.global;
                var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
                var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
                var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

                return {
                    size: size,
                    style: style,
                    family: family,
                    font: helpers.fontString(size, style, family)
                };
            }

            function parseLineHeight(options) {
                return helpers.options.toLineHeight(
                    helpers.valueOrDefault(options.lineHeight, 1.2),
                    helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
            }

            module.exports = Element.extend({
                /**
                 * Get the padding needed for the scale
                 * @method getPadding
                 * @private
                 * @returns {Padding} the necessary padding
                 */
                getPadding: function () {
                    var me = this;
                    return {
                        left: me.paddingLeft || 0,
                        top: me.paddingTop || 0,
                        right: me.paddingRight || 0,
                        bottom: me.paddingBottom || 0
                    };
                },

                /**
                 * Returns the scale tick objects ({label, major})
                 * @since 2.7
                 */
                getTicks: function () {
                    return this._ticks;
                },

                // These methods are ordered by lifecyle. Utilities then follow.
                // Any function defined here is inherited by all scale types.
                // Any function can be extended by the scale type

                mergeTicksOptions: function () {
                    var ticks = this.options.ticks;
                    if (ticks.minor === false) {
                        ticks.minor = {
                            display: false
                        };
                    }
                    if (ticks.major === false) {
                        ticks.major = {
                            display: false
                        };
                    }
                    for (var key in ticks) {
                        if (key !== 'major' && key !== 'minor') {
                            if (typeof ticks.minor[key] === 'undefined') {
                                ticks.minor[key] = ticks[key];
                            }
                            if (typeof ticks.major[key] === 'undefined') {
                                ticks.major[key] = ticks[key];
                            }
                        }
                    }
                },
                beforeUpdate: function () {
                    helpers.callback(this.options.beforeUpdate, [this]);
                },

                update: function (maxWidth, maxHeight, margins) {
                    var me = this;
                    var i, ilen, labels, label, ticks, tick;

                    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
                    me.beforeUpdate();

                    // Absorb the master measurements
                    me.maxWidth = maxWidth;
                    me.maxHeight = maxHeight;
                    me.margins = helpers.extend({
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, margins);
                    me.longestTextCache = me.longestTextCache || {};

                    // Dimensions
                    me.beforeSetDimensions();
                    me.setDimensions();
                    me.afterSetDimensions();

                    // Data min/max
                    me.beforeDataLimits();
                    me.determineDataLimits();
                    me.afterDataLimits();

                    // Ticks - `this.ticks` is now DEPRECATED!
                    // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
                    // and must not be accessed directly from outside this class. `this.ticks` being
                    // around for long time and not marked as private, we can't change its structure
                    // without unexpected breaking changes. If you need to access the scale ticks,
                    // use scale.getTicks() instead.

                    me.beforeBuildTicks();

                    // New implementations should return an array of objects but for BACKWARD COMPAT,
                    // we still support no return (`this.ticks` internally set by calling this method).
                    ticks = me.buildTicks() || [];

                    me.afterBuildTicks();

                    me.beforeTickToLabelConversion();

                    // New implementations should return the formatted tick labels but for BACKWARD
                    // COMPAT, we still support no return (`this.ticks` internally changed by calling
                    // this method and supposed to contain only string values).
                    labels = me.convertTicksToLabels(ticks) || me.ticks;

                    me.afterTickToLabelConversion();

                    me.ticks = labels;   // BACKWARD COMPATIBILITY

                    // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!

                    // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
                    for (i = 0, ilen = labels.length; i < ilen; ++i) {
                        label = labels[i];
                        tick = ticks[i];
                        if (!tick) {
                            ticks.push(tick = {
                                label: label,
                                major: false
                            });
                        } else {
                            tick.label = label;
                        }
                    }

                    me._ticks = ticks;

                    // Tick Rotation
                    me.beforeCalculateTickRotation();
                    me.calculateTickRotation();
                    me.afterCalculateTickRotation();
                    // Fit
                    me.beforeFit();
                    me.fit();
                    me.afterFit();
                    //
                    me.afterUpdate();

                    return me.minSize;

                },
                afterUpdate: function () {
                    helpers.callback(this.options.afterUpdate, [this]);
                },

                //

                beforeSetDimensions: function () {
                    helpers.callback(this.options.beforeSetDimensions, [this]);
                },
                setDimensions: function () {
                    var me = this;
                    // Set the unconstrained dimension before label rotation
                    if (me.isHorizontal()) {
                        // Reset position before calculating rotation
                        me.width = me.maxWidth;
                        me.left = 0;
                        me.right = me.width;
                    } else {
                        me.height = me.maxHeight;

                        // Reset position before calculating rotation
                        me.top = 0;
                        me.bottom = me.height;
                    }

                    // Reset padding
                    me.paddingLeft = 0;
                    me.paddingTop = 0;
                    me.paddingRight = 0;
                    me.paddingBottom = 0;
                },
                afterSetDimensions: function () {
                    helpers.callback(this.options.afterSetDimensions, [this]);
                },

                // Data limits
                beforeDataLimits: function () {
                    helpers.callback(this.options.beforeDataLimits, [this]);
                },
                determineDataLimits: helpers.noop,
                afterDataLimits: function () {
                    helpers.callback(this.options.afterDataLimits, [this]);
                },

                //
                beforeBuildTicks: function () {
                    helpers.callback(this.options.beforeBuildTicks, [this]);
                },
                buildTicks: helpers.noop,
                afterBuildTicks: function () {
                    helpers.callback(this.options.afterBuildTicks, [this]);
                },

                beforeTickToLabelConversion: function () {
                    helpers.callback(this.options.beforeTickToLabelConversion, [this]);
                },
                convertTicksToLabels: function () {
                    var me = this;
                    // Convert ticks to strings
                    var tickOpts = me.options.ticks;
                    me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
                },
                afterTickToLabelConversion: function () {
                    helpers.callback(this.options.afterTickToLabelConversion, [this]);
                },

                //

                beforeCalculateTickRotation: function () {
                    helpers.callback(this.options.beforeCalculateTickRotation, [this]);
                },
                calculateTickRotation: function () {
                    var me = this;
                    var context = me.ctx;
                    var tickOpts = me.options.ticks;
                    var labels = labelsFromTicks(me._ticks);

                    // Get the width of each grid by calculating the difference
                    // between x offsets between 0 and 1.
                    var tickFont = parseFontOptions(tickOpts);
                    context.font = tickFont.font;

                    var labelRotation = tickOpts.minRotation || 0;

                    if (labels.length && me.options.display && me.isHorizontal()) {
                        var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
                        var labelWidth = originalLabelWidth;
                        var cosRotation, sinRotation;

                        // Allow 3 pixels x2 padding either side for label readability
                        var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

                        // Max label rotation can be set or default to 90 - also act as a loop counter
                        while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
                            var angleRadians = helpers.toRadians(labelRotation);
                            cosRotation = Math.cos(angleRadians);
                            sinRotation = Math.sin(angleRadians);

                            if (sinRotation * originalLabelWidth > me.maxHeight) {
                                // go back one step
                                labelRotation--;
                                break;
                            }

                            labelRotation++;
                            labelWidth = cosRotation * originalLabelWidth;
                        }
                    }

                    me.labelRotation = labelRotation;
                },
                afterCalculateTickRotation: function () {
                    helpers.callback(this.options.afterCalculateTickRotation, [this]);
                },

                //

                beforeFit: function () {
                    helpers.callback(this.options.beforeFit, [this]);
                },
                fit: function () {
                    var me = this;
                    // Reset
                    var minSize = me.minSize = {
                        width: 0,
                        height: 0
                    };

                    var labels = labelsFromTicks(me._ticks);

                    var opts = me.options;
                    var tickOpts = opts.ticks;
                    var scaleLabelOpts = opts.scaleLabel;
                    var gridLineOpts = opts.gridLines;
                    var display = opts.display;
                    var isHorizontal = me.isHorizontal();

                    var tickFont = parseFontOptions(tickOpts);
                    var tickMarkLength = opts.gridLines.tickMarkLength;

                    // Width
                    if (isHorizontal) {
                        // subtract the margins to line up with the chartArea if we are a full width scale
                        minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
                    } else {
                        minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
                    }

                    // height
                    if (isHorizontal) {
                        minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
                    } else {
                        minSize.height = me.maxHeight; // fill all the height
                    }

                    // Are we showing a title for the scale?
                    if (scaleLabelOpts.display && display) {
                        var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
                        var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
                        var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

                        if (isHorizontal) {
                            minSize.height += deltaHeight;
                        } else {
                            minSize.width += deltaHeight;
                        }
                    }

                    // Don't bother fitting the ticks if we are not showing them
                    if (tickOpts.display && display) {
                        var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
                        var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
                        var lineSpace = tickFont.size * 0.5;
                        var tickPadding = me.options.ticks.padding;

                        if (isHorizontal) {
                            // A horizontal axis is more constrained by the height.
                            me.longestLabelWidth = largestTextWidth;

                            var angleRadians = helpers.toRadians(me.labelRotation);
                            var cosRotation = Math.cos(angleRadians);
                            var sinRotation = Math.sin(angleRadians);

                            // TODO - improve this calculation
                            var labelHeight = (sinRotation * largestTextWidth)
                                + (tickFont.size * tallestLabelHeightInLines)
                                + (lineSpace * (tallestLabelHeightInLines - 1))
                                + lineSpace; // padding

                            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

                            me.ctx.font = tickFont.font;
                            var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
                            var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

                            // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
                            // which means that the right padding is dominated by the font height
                            if (me.labelRotation !== 0) {
                                me.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
                                me.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
                            } else {
                                me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
                                me.paddingRight = lastLabelWidth / 2 + 3;
                            }
                        } else {
                            // A vertical axis is more constrained by the width. Labels are the
                            // dominant factor here, so get that length first and account for padding
                            if (tickOpts.mirror) {
                                largestTextWidth = 0;
                            } else {
                                // use lineSpace for consistency with horizontal axis
                                // tickPadding is not implemented for horizontal
                                largestTextWidth += tickPadding + lineSpace;
                            }

                            minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

                            me.paddingTop = tickFont.size / 2;
                            me.paddingBottom = tickFont.size / 2;
                        }
                    }

                    me.handleMargins();

                    me.width = minSize.width;
                    me.height = minSize.height;
                },

                /**
                 * Handle margins and padding interactions
                 * @private
                 */
                handleMargins: function () {
                    var me = this;
                    if (me.margins) {
                        me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
                        me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
                        me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
                        me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
                    }
                },

                afterFit: function () {
                    helpers.callback(this.options.afterFit, [this]);
                },

                // Shared Methods
                isHorizontal: function () {
                    return this.options.position === 'top' || this.options.position === 'bottom';
                },
                isFullWidth: function () {
                    return (this.options.fullWidth);
                },

                // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
                getRightValue: function (rawValue) {
                    // Null and undefined values first
                    if (helpers.isNullOrUndef(rawValue)) {
                        return NaN;
                    }
                    // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
                    if (typeof rawValue === 'number' && !isFinite(rawValue)) {
                        return NaN;
                    }
                    // If it is in fact an object, dive in one more level
                    if (rawValue) {
                        if (this.isHorizontal()) {
                            if (rawValue.x !== undefined) {
                                return this.getRightValue(rawValue.x);
                            }
                        } else if (rawValue.y !== undefined) {
                            return this.getRightValue(rawValue.y);
                        }
                    }

                    // Value is good, return it
                    return rawValue;
                },

                /**
                 * Used to get the value to display in the tooltip for the data at the given index
                 * @param index
                 * @param datasetIndex
                 */
                getLabelForIndex: helpers.noop,

                /**
                 * Returns the location of the given data point. Value can either be an index or a numerical value
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 * @param value
                 * @param index
                 * @param datasetIndex
                 */
                getPixelForValue: helpers.noop,

                /**
                 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 * @param pixel
                 */
                getValueForPixel: helpers.noop,

                /**
                 * Returns the location of the tick at the given index
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 */
                getPixelForTick: function (index) {
                    var me = this;
                    var offset = me.options.offset;
                    if (me.isHorizontal()) {
                        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
                        var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
                        var pixel = (tickWidth * index) + me.paddingLeft;

                        if (offset) {
                            pixel += tickWidth / 2;
                        }

                        var finalVal = me.left + Math.round(pixel);
                        finalVal += me.isFullWidth() ? me.margins.left : 0;
                        return finalVal;
                    }
                    var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
                    return me.top + (index * (innerHeight / (me._ticks.length - 1)));
                },

                /**
                 * Utility for getting the pixel location of a percentage of scale
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 */
                getPixelForDecimal: function (decimal) {
                    var me = this;
                    if (me.isHorizontal()) {
                        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
                        var valueOffset = (innerWidth * decimal) + me.paddingLeft;

                        var finalVal = me.left + Math.round(valueOffset);
                        finalVal += me.isFullWidth() ? me.margins.left : 0;
                        return finalVal;
                    }
                    return me.top + (decimal * me.height);
                },

                /**
                 * Returns the pixel for the minimum chart value
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 */
                getBasePixel: function () {
                    return this.getPixelForValue(this.getBaseValue());
                },

                getBaseValue: function () {
                    var me = this;
                    var min = me.min;
                    var max = me.max;

                    return me.beginAtZero ? 0 :
                        min < 0 && max < 0 ? max :
                            min > 0 && max > 0 ? min :
                                0;
                },

                /**
                 * Returns a subset of ticks to be plotted to avoid overlapping labels.
                 * @private
                 */
                _autoSkip: function (ticks) {
                    var skipRatio;
                    var me = this;
                    var isHorizontal = me.isHorizontal();
                    var optionTicks = me.options.ticks.minor;
                    var tickCount = ticks.length;
                    var labelRotationRadians = helpers.toRadians(me.labelRotation);
                    var cosRotation = Math.cos(labelRotationRadians);
                    var longestRotatedLabel = me.longestLabelWidth * cosRotation;
                    var result = [];
                    var i, tick, shouldSkip;

                    // figure out the maximum number of gridlines to show
                    var maxTicks;
                    if (optionTicks.maxTicksLimit) {
                        maxTicks = optionTicks.maxTicksLimit;
                    }

                    if (isHorizontal) {
                        skipRatio = false;

                        if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {
                            skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
                        }

                        // if they defined a max number of optionTicks,
                        // increase skipRatio until that number is met
                        if (maxTicks && tickCount > maxTicks) {
                            skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
                        }
                    }

                    for (i = 0; i < tickCount; i++) {
                        tick = ticks[i];

                        // Since we always show the last tick,we need may need to hide the last shown one before
                        shouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);
                        if (shouldSkip && i !== tickCount - 1) {
                            // leave tick in place but make sure it's not displayed (#4635)
                            delete tick.label;
                        }
                        result.push(tick);
                    }
                    return result;
                },

                // Actually draw the scale on the canvas
                // @param {rectangle} chartArea : the area of the chart to draw full grid lines on
                draw: function (chartArea) {
                    var me = this;
                    var options = me.options;
                    if (!options.display) {
                        return;
                    }

                    var context = me.ctx;
                    var globalDefaults = defaults.global;
                    var optionTicks = options.ticks.minor;
                    var optionMajorTicks = options.ticks.major || optionTicks;
                    var gridLines = options.gridLines;
                    var scaleLabel = options.scaleLabel;

                    var isRotated = me.labelRotation !== 0;
                    var isHorizontal = me.isHorizontal();

                    var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
                    var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
                    var tickFont = parseFontOptions(optionTicks);
                    var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
                    var majorTickFont = parseFontOptions(optionMajorTicks);

                    var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

                    var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
                    var scaleLabelFont = parseFontOptions(scaleLabel);
                    var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
                    var labelRotationRadians = helpers.toRadians(me.labelRotation);

                    var itemsToDraw = [];

                    var axisWidth = me.options.gridLines.lineWidth;
                    var xTickStart = options.position === 'right' ? me.left : me.right - axisWidth - tl;
                    var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
                    var yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;
                    var yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;

                    helpers.each(ticks, function (tick, index) {
                        // autoskipper skipped this tick (#4635)
                        if (helpers.isNullOrUndef(tick.label)) {
                            return;
                        }

                        var label = tick.label;
                        var lineWidth, lineColor, borderDash, borderDashOffset;
                        if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
                            // Draw the first index specially
                            lineWidth = gridLines.zeroLineWidth;
                            lineColor = gridLines.zeroLineColor;
                            borderDash = gridLines.zeroLineBorderDash;
                            borderDashOffset = gridLines.zeroLineBorderDashOffset;
                        } else {
                            lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
                            lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
                            borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
                            borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
                        }

                        // Common properties
                        var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
                        var textAlign = 'middle';
                        var textBaseline = 'middle';
                        var tickPadding = optionTicks.padding;

                        if (isHorizontal) {
                            var labelYOffset = tl + tickPadding;

                            if (options.position === 'bottom') {
                                // bottom
                                textBaseline = !isRotated ? 'top' : 'middle';
                                textAlign = !isRotated ? 'center' : 'right';
                                labelY = me.top + labelYOffset;
                            } else {
                                // top
                                textBaseline = !isRotated ? 'bottom' : 'middle';
                                textAlign = !isRotated ? 'center' : 'left';
                                labelY = me.bottom - labelYOffset;
                            }

                            var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
                            if (xLineValue < me.left) {
                                lineColor = 'rgba(0,0,0,0)';
                            }
                            xLineValue += helpers.aliasPixel(lineWidth);

                            labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

                            tx1 = tx2 = x1 = x2 = xLineValue;
                            ty1 = yTickStart;
                            ty2 = yTickEnd;
                            y1 = chartArea.top;
                            y2 = chartArea.bottom + axisWidth;
                        } else {
                            var isLeft = options.position === 'left';
                            var labelXOffset;

                            if (optionTicks.mirror) {
                                textAlign = isLeft ? 'left' : 'right';
                                labelXOffset = tickPadding;
                            } else {
                                textAlign = isLeft ? 'right' : 'left';
                                labelXOffset = tl + tickPadding;
                            }

                            labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

                            var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
                            if (yLineValue < me.top) {
                                lineColor = 'rgba(0,0,0,0)';
                            }
                            yLineValue += helpers.aliasPixel(lineWidth);

                            labelY = me.getPixelForTick(index) + optionTicks.labelOffset;

                            tx1 = xTickStart;
                            tx2 = xTickEnd;
                            x1 = chartArea.left;
                            x2 = chartArea.right + axisWidth;
                            ty1 = ty2 = y1 = y2 = yLineValue;
                        }

                        itemsToDraw.push({
                            tx1: tx1,
                            ty1: ty1,
                            tx2: tx2,
                            ty2: ty2,
                            x1: x1,
                            y1: y1,
                            x2: x2,
                            y2: y2,
                            labelX: labelX,
                            labelY: labelY,
                            glWidth: lineWidth,
                            glColor: lineColor,
                            glBorderDash: borderDash,
                            glBorderDashOffset: borderDashOffset,
                            rotation: -1 * labelRotationRadians,
                            label: label,
                            major: tick.major,
                            textBaseline: textBaseline,
                            textAlign: textAlign
                        });
                    });

                    // Draw all of the tick labels, tick marks, and grid lines at the correct places
                    helpers.each(itemsToDraw, function (itemToDraw) {
                        if (gridLines.display) {
                            context.save();
                            context.lineWidth = itemToDraw.glWidth;
                            context.strokeStyle = itemToDraw.glColor;
                            if (context.setLineDash) {
                                context.setLineDash(itemToDraw.glBorderDash);
                                context.lineDashOffset = itemToDraw.glBorderDashOffset;
                            }

                            context.beginPath();

                            if (gridLines.drawTicks) {
                                context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
                                context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
                            }

                            if (gridLines.drawOnChartArea) {
                                context.moveTo(itemToDraw.x1, itemToDraw.y1);
                                context.lineTo(itemToDraw.x2, itemToDraw.y2);
                            }

                            context.stroke();
                            context.restore();
                        }

                        if (optionTicks.display) {
                            // Make sure we draw text in the correct color and font
                            context.save();
                            context.translate(itemToDraw.labelX, itemToDraw.labelY);
                            context.rotate(itemToDraw.rotation);
                            context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
                            context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
                            context.textBaseline = itemToDraw.textBaseline;
                            context.textAlign = itemToDraw.textAlign;

                            var label = itemToDraw.label;
                            if (helpers.isArray(label)) {
                                var lineCount = label.length;
                                var lineHeight = tickFont.size * 1.5;
                                var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;

                                for (var i = 0; i < lineCount; ++i) {
                                    // We just make sure the multiline element is a string here..
                                    context.fillText('' + label[i], 0, y);
                                    // apply same lineSpacing as calculated @ L#320
                                    y += lineHeight;
                                }
                            } else {
                                context.fillText(label, 0, 0);
                            }
                            context.restore();
                        }
                    });

                    if (scaleLabel.display) {
                        // Draw the scale label
                        var scaleLabelX;
                        var scaleLabelY;
                        var rotation = 0;
                        var halfLineHeight = parseLineHeight(scaleLabel) / 2;

                        if (isHorizontal) {
                            scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
                            scaleLabelY = options.position === 'bottom'
                                ? me.bottom - halfLineHeight - scaleLabelPadding.bottom
                                : me.top + halfLineHeight + scaleLabelPadding.top;
                        } else {
                            var isLeft = options.position === 'left';
                            scaleLabelX = isLeft
                                ? me.left + halfLineHeight + scaleLabelPadding.top
                                : me.right - halfLineHeight - scaleLabelPadding.top;
                            scaleLabelY = me.top + ((me.bottom - me.top) / 2);
                            rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
                        }

                        context.save();
                        context.translate(scaleLabelX, scaleLabelY);
                        context.rotate(rotation);
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillStyle = scaleLabelFontColor; // render in correct colour
                        context.font = scaleLabelFont.font;
                        context.fillText(scaleLabel.labelString, 0, 0);
                        context.restore();
                    }

                    if (gridLines.drawBorder) {
                        // Draw the line at the edge of the axis
                        context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
                        context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
                        var x1 = me.left;
                        var x2 = me.right + axisWidth;
                        var y1 = me.top;
                        var y2 = me.bottom + axisWidth;

                        var aliasPixel = helpers.aliasPixel(context.lineWidth);
                        if (isHorizontal) {
                            y1 = y2 = options.position === 'top' ? me.bottom : me.top;
                            y1 += aliasPixel;
                            y2 += aliasPixel;
                        } else {
                            x1 = x2 = options.position === 'left' ? me.right : me.left;
                            x1 += aliasPixel;
                            x2 += aliasPixel;
                        }

                        context.beginPath();
                        context.moveTo(x1, y1);
                        context.lineTo(x2, y2);
                        context.stroke();
                    }
                }
            });

        }, {"26": 26, "27": 27, "35": 35, "46": 46}],
        34: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var helpers = require(46);
            var layouts = require(31);

            module.exports = {
                // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
                // use the new chart options to grab the correct scale
                constructors: {},
                // Use a registration function so that we can move to an ES6 map when we no longer need to support
                // old browsers

                // Scale config defaults
                defaults: {},
                registerScaleType: function (type, scaleConstructor, scaleDefaults) {
                    this.constructors[type] = scaleConstructor;
                    this.defaults[type] = helpers.clone(scaleDefaults);
                },
                getScaleConstructor: function (type) {
                    return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
                },
                getScaleDefaults: function (type) {
                    // Return the scale defaults merged with the global settings so that we always use the latest ones
                    return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
                },
                updateScaleDefaults: function (type, additions) {
                    var me = this;
                    if (me.defaults.hasOwnProperty(type)) {
                        me.defaults[type] = helpers.extend(me.defaults[type], additions);
                    }
                },
                addScalesToLayout: function (chart) {
                    // Adds each scale to the chart.boxes array to be sized accordingly
                    helpers.each(chart.scales, function (scale) {
                        // Set ILayoutItem parameters for backwards compatibility
                        scale.fullWidth = scale.options.fullWidth;
                        scale.position = scale.options.position;
                        scale.weight = scale.options.weight;
                        layouts.addBox(chart, scale);
                    });
                }
            };

        }, {"26": 26, "31": 31, "46": 46}],
        35: [function (require, module, exports) {
            'use strict';

            var helpers = require(46);

            /**
             * Namespace to hold static tick generation functions
             * @namespace Chart.Ticks
             */
            module.exports = {
                /**
                 * Namespace to hold formatters for different types of ticks
                 * @namespace Chart.Ticks.formatters
                 */
                formatters: {
                    /**
                     * Formatter for value labels
                     * @method Chart.Ticks.formatters.values
                     * @param value the value to display
                     * @return {String|Array} the label to display
                     */
                    values: function (value) {
                        return helpers.isArray(value) ? value : '' + value;
                    },

                    /**
                     * Formatter for linear numeric ticks
                     * @method Chart.Ticks.formatters.linear
                     * @param tickValue {Number} the value to be formatted
                     * @param index {Number} the position of the tickValue parameter in the ticks array
                     * @param ticks {Array<Number>} the list of ticks being converted
                     * @return {String} string representation of the tickValue parameter
                     */
                    linear: function (tickValue, index, ticks) {
                        // If we have lots of ticks, don't use the ones
                        var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

                        // If we have a number like 2.5 as the delta, figure out how many decimal places we need
                        if (Math.abs(delta) > 1) {
                            if (tickValue !== Math.floor(tickValue)) {
                                // not an integer
                                delta = tickValue - Math.floor(tickValue);
                            }
                        }

                        var logDelta = helpers.log10(Math.abs(delta));
                        var tickString = '';

                        if (tickValue !== 0) {
                            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                            if (maxTick < 1e-4) { // all ticks are small numbers; use scientific notation
                                var logTick = helpers.log10(Math.abs(tickValue));
                                tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
                            } else {
                                var numDecimal = -1 * Math.floor(logDelta);
                                numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
                                tickString = tickValue.toFixed(numDecimal);
                            }
                        } else {
                            tickString = '0'; // never show decimal places for 0
                        }

                        return tickString;
                    },

                    logarithmic: function (tickValue, index, ticks) {
                        var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));

                        if (tickValue === 0) {
                            return '0';
                        } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
                            return tickValue.toExponential();
                        }
                        return '';
                    }
                }
            };

        }, {"46": 46}],
        36: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var Element = require(27);
            var helpers = require(46);

            defaults._set('global', {
                tooltips: {
                    enabled: true,
                    custom: null,
                    mode: 'nearest',
                    position: 'average',
                    intersect: true,
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleFontStyle: 'bold',
                    titleSpacing: 2,
                    titleMarginBottom: 6,
                    titleFontColor: '#fff',
                    titleAlign: 'left',
                    bodySpacing: 2,
                    bodyFontColor: '#fff',
                    bodyAlign: 'left',
                    footerFontStyle: 'bold',
                    footerSpacing: 2,
                    footerMarginTop: 6,
                    footerFontColor: '#fff',
                    footerAlign: 'left',
                    yPadding: 6,
                    xPadding: 6,
                    caretPadding: 2,
                    caretSize: 5,
                    cornerRadius: 6,
                    multiKeyBackground: '#fff',
                    displayColors: true,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 0,
                    callbacks: {
                        // Args are: (tooltipItems, data)
                        beforeTitle: helpers.noop,
                        title: function (tooltipItems, data) {
                            // Pick first xLabel for now
                            var title = '';
                            var labels = data.labels;
                            var labelCount = labels ? labels.length : 0;

                            if (tooltipItems.length > 0) {
                                var item = tooltipItems[0];

                                if (item.xLabel) {
                                    title = item.xLabel;
                                } else if (labelCount > 0 && item.index < labelCount) {
                                    title = labels[item.index];
                                }
                            }

                            return title;
                        },
                        afterTitle: helpers.noop,

                        // Args are: (tooltipItems, data)
                        beforeBody: helpers.noop,

                        // Args are: (tooltipItem, data)
                        beforeLabel: helpers.noop,
                        label: function (tooltipItem, data) {
                            var label = data.datasets[tooltipItem.datasetIndex].label || '';

                            if (label) {
                                label += ': ';
                            }
                            label += tooltipItem.yLabel;
                            return label;
                        },
                        labelColor: function (tooltipItem, chart) {
                            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                            var activeElement = meta.data[tooltipItem.index];
                            var view = activeElement._view;
                            return {
                                borderColor: view.borderColor,
                                backgroundColor: view.backgroundColor
                            };
                        },
                        labelTextColor: function () {
                            return this._options.bodyFontColor;
                        },
                        afterLabel: helpers.noop,

                        // Args are: (tooltipItems, data)
                        afterBody: helpers.noop,

                        // Args are: (tooltipItems, data)
                        beforeFooter: helpers.noop,
                        footer: helpers.noop,
                        afterFooter: helpers.noop
                    }
                }
            });

            var positioners = {
                /**
                 * Average mode places the tooltip at the average position of the elements shown
                 * @function Chart.Tooltip.positioners.average
                 * @param elements {ChartElement[]} the elements being displayed in the tooltip
                 * @returns {Point} tooltip position
                 */
                average: function (elements) {
                    if (!elements.length) {
                        return false;
                    }

                    var i, len;
                    var x = 0;
                    var y = 0;
                    var count = 0;

                    for (i = 0, len = elements.length; i < len; ++i) {
                        var el = elements[i];
                        if (el && el.hasValue()) {
                            var pos = el.tooltipPosition();
                            x += pos.x;
                            y += pos.y;
                            ++count;
                        }
                    }

                    return {
                        x: Math.round(x / count),
                        y: Math.round(y / count)
                    };
                },

                /**
                 * Gets the tooltip position nearest of the item nearest to the event position
                 * @function Chart.Tooltip.positioners.nearest
                 * @param elements {Chart.Element[]} the tooltip elements
                 * @param eventPosition {Point} the position of the event in canvas coordinates
                 * @returns {Point} the tooltip position
                 */
                nearest: function (elements, eventPosition) {
                    var x = eventPosition.x;
                    var y = eventPosition.y;
                    var minDistance = Number.POSITIVE_INFINITY;
                    var i, len, nearestElement;

                    for (i = 0, len = elements.length; i < len; ++i) {
                        var el = elements[i];
                        if (el && el.hasValue()) {
                            var center = el.getCenterPoint();
                            var d = helpers.distanceBetweenPoints(eventPosition, center);

                            if (d < minDistance) {
                                minDistance = d;
                                nearestElement = el;
                            }
                        }
                    }

                    if (nearestElement) {
                        var tp = nearestElement.tooltipPosition();
                        x = tp.x;
                        y = tp.y;
                    }

                    return {
                        x: x,
                        y: y
                    };
                }
            };

            /**
             * Helper method to merge the opacity into a color
             */
            function mergeOpacity(colorString, opacity) {
                var color = helpers.color(colorString);
                return color.alpha(opacity * color.alpha()).rgbaString();
            }

// Helper to push or concat based on if the 2nd parameter is an array or not
            function pushOrConcat(base, toPush) {
                if (toPush) {
                    if (helpers.isArray(toPush)) {
                        // base = base.concat(toPush);
                        Array.prototype.push.apply(base, toPush);
                    } else {
                        base.push(toPush);
                    }
                }

                return base;
            }

            /**
             * Returns array of strings split by newline
             * @param {String} value - The value to split by newline.
             * @returns {Array} value if newline present - Returned from String split() method
             * @function
             */
            function splitNewlines(str) {
                if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
                    return str.split('\n');
                }
                return str;
            }


// Private helper to create a tooltip item model
// @param element : the chart element (point, arc, bar) to create the tooltip item for
// @return : new tooltip item
            function createTooltipItem(element) {
                var xScale = element._xScale;
                var yScale = element._yScale || element._scale; // handle radar || polarArea charts
                var index = element._index;
                var datasetIndex = element._datasetIndex;

                return {
                    xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
                    yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
                    index: index,
                    datasetIndex: datasetIndex,
                    x: element._model.x,
                    y: element._model.y
                };
            }

            /**
             * Helper to get the reset model for the tooltip
             * @param tooltipOpts {Object} the tooltip options
             */
            function getBaseModel(tooltipOpts) {
                var globalDefaults = defaults.global;
                var valueOrDefault = helpers.valueOrDefault;

                return {
                    // Positioning
                    xPadding: tooltipOpts.xPadding,
                    yPadding: tooltipOpts.yPadding,
                    xAlign: tooltipOpts.xAlign,
                    yAlign: tooltipOpts.yAlign,

                    // Body
                    bodyFontColor: tooltipOpts.bodyFontColor,
                    _bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
                    _bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
                    _bodyAlign: tooltipOpts.bodyAlign,
                    bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
                    bodySpacing: tooltipOpts.bodySpacing,

                    // Title
                    titleFontColor: tooltipOpts.titleFontColor,
                    _titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
                    _titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
                    titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
                    _titleAlign: tooltipOpts.titleAlign,
                    titleSpacing: tooltipOpts.titleSpacing,
                    titleMarginBottom: tooltipOpts.titleMarginBottom,

                    // Footer
                    footerFontColor: tooltipOpts.footerFontColor,
                    _footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
                    _footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
                    footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
                    _footerAlign: tooltipOpts.footerAlign,
                    footerSpacing: tooltipOpts.footerSpacing,
                    footerMarginTop: tooltipOpts.footerMarginTop,

                    // Appearance
                    caretSize: tooltipOpts.caretSize,
                    cornerRadius: tooltipOpts.cornerRadius,
                    backgroundColor: tooltipOpts.backgroundColor,
                    opacity: 0,
                    legendColorBackground: tooltipOpts.multiKeyBackground,
                    displayColors: tooltipOpts.displayColors,
                    borderColor: tooltipOpts.borderColor,
                    borderWidth: tooltipOpts.borderWidth
                };
            }

            /**
             * Get the size of the tooltip
             */
            function getTooltipSize(tooltip, model) {
                var ctx = tooltip._chart.ctx;

                var height = model.yPadding * 2; // Tooltip Padding
                var width = 0;

                // Count of all lines in the body
                var body = model.body;
                var combinedBodyLength = body.reduce(function (count, bodyItem) {
                    return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
                }, 0);
                combinedBodyLength += model.beforeBody.length + model.afterBody.length;

                var titleLineCount = model.title.length;
                var footerLineCount = model.footer.length;
                var titleFontSize = model.titleFontSize;
                var bodyFontSize = model.bodyFontSize;
                var footerFontSize = model.footerFontSize;

                height += titleLineCount * titleFontSize; // Title Lines
                height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
                height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
                height += combinedBodyLength * bodyFontSize; // Body Lines
                height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
                height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
                height += footerLineCount * (footerFontSize); // Footer Lines
                height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

                // Title width
                var widthPadding = 0;
                var maxLineWidth = function (line) {
                    width = Math.max(width, ctx.measureText(line).width + widthPadding);
                };

                ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
                helpers.each(model.title, maxLineWidth);

                // Body width
                ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
                helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

                // Body lines may include some extra width due to the color box
                widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
                helpers.each(body, function (bodyItem) {
                    helpers.each(bodyItem.before, maxLineWidth);
                    helpers.each(bodyItem.lines, maxLineWidth);
                    helpers.each(bodyItem.after, maxLineWidth);
                });

                // Reset back to 0
                widthPadding = 0;

                // Footer width
                ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
                helpers.each(model.footer, maxLineWidth);

                // Add padding
                width += 2 * model.xPadding;

                return {
                    width: width,
                    height: height
                };
            }

            /**
             * Helper to get the alignment of a tooltip given the size
             */
            function determineAlignment(tooltip, size) {
                var model = tooltip._model;
                var chart = tooltip._chart;
                var chartArea = tooltip._chart.chartArea;
                var xAlign = 'center';
                var yAlign = 'center';

                if (model.y < size.height) {
                    yAlign = 'top';
                } else if (model.y > (chart.height - size.height)) {
                    yAlign = 'bottom';
                }

                var lf, rf; // functions to determine left, right alignment
                var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
                var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
                var midX = (chartArea.left + chartArea.right) / 2;
                var midY = (chartArea.top + chartArea.bottom) / 2;

                if (yAlign === 'center') {
                    lf = function (x) {
                        return x <= midX;
                    };
                    rf = function (x) {
                        return x > midX;
                    };
                } else {
                    lf = function (x) {
                        return x <= (size.width / 2);
                    };
                    rf = function (x) {
                        return x >= (chart.width - (size.width / 2));
                    };
                }

                olf = function (x) {
                    return x + size.width + model.caretSize + model.caretPadding > chart.width;
                };
                orf = function (x) {
                    return x - size.width - model.caretSize - model.caretPadding < 0;
                };
                yf = function (y) {
                    return y <= midY ? 'top' : 'bottom';
                };

                if (lf(model.x)) {
                    xAlign = 'left';

                    // Is tooltip too wide and goes over the right side of the chart.?
                    if (olf(model.x)) {
                        xAlign = 'center';
                        yAlign = yf(model.y);
                    }
                } else if (rf(model.x)) {
                    xAlign = 'right';

                    // Is tooltip too wide and goes outside left edge of canvas?
                    if (orf(model.x)) {
                        xAlign = 'center';
                        yAlign = yf(model.y);
                    }
                }

                var opts = tooltip._options;
                return {
                    xAlign: opts.xAlign ? opts.xAlign : xAlign,
                    yAlign: opts.yAlign ? opts.yAlign : yAlign
                };
            }

            /**
             * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
             */
            function getBackgroundPoint(vm, size, alignment, chart) {
                // Background Position
                var x = vm.x;
                var y = vm.y;

                var caretSize = vm.caretSize;
                var caretPadding = vm.caretPadding;
                var cornerRadius = vm.cornerRadius;
                var xAlign = alignment.xAlign;
                var yAlign = alignment.yAlign;
                var paddingAndSize = caretSize + caretPadding;
                var radiusAndPadding = cornerRadius + caretPadding;

                if (xAlign === 'right') {
                    x -= size.width;
                } else if (xAlign === 'center') {
                    x -= (size.width / 2);
                    if (x + size.width > chart.width) {
                        x = chart.width - size.width;
                    }
                    if (x < 0) {
                        x = 0;
                    }
                }

                if (yAlign === 'top') {
                    y += paddingAndSize;
                } else if (yAlign === 'bottom') {
                    y -= size.height + paddingAndSize;
                } else {
                    y -= (size.height / 2);
                }

                if (yAlign === 'center') {
                    if (xAlign === 'left') {
                        x += paddingAndSize;
                    } else if (xAlign === 'right') {
                        x -= paddingAndSize;
                    }
                } else if (xAlign === 'left') {
                    x -= radiusAndPadding;
                } else if (xAlign === 'right') {
                    x += radiusAndPadding;
                }

                return {
                    x: x,
                    y: y
                };
            }

            /**
             * Helper to build before and after body lines
             */
            function getBeforeAfterBodyLines(callback) {
                return pushOrConcat([], splitNewlines(callback));
            }

            var exports = module.exports = Element.extend({
                initialize: function () {
                    this._model = getBaseModel(this._options);
                    this._lastActive = [];
                },

                // Get the title
                // Args are: (tooltipItem, data)
                getTitle: function () {
                    var me = this;
                    var opts = me._options;
                    var callbacks = opts.callbacks;

                    var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
                    var title = callbacks.title.apply(me, arguments);
                    var afterTitle = callbacks.afterTitle.apply(me, arguments);

                    var lines = [];
                    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
                    lines = pushOrConcat(lines, splitNewlines(title));
                    lines = pushOrConcat(lines, splitNewlines(afterTitle));

                    return lines;
                },

                // Args are: (tooltipItem, data)
                getBeforeBody: function () {
                    return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
                },

                // Args are: (tooltipItem, data)
                getBody: function (tooltipItems, data) {
                    var me = this;
                    var callbacks = me._options.callbacks;
                    var bodyItems = [];

                    helpers.each(tooltipItems, function (tooltipItem) {
                        var bodyItem = {
                            before: [],
                            lines: [],
                            after: []
                        };
                        pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
                        pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
                        pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));

                        bodyItems.push(bodyItem);
                    });

                    return bodyItems;
                },

                // Args are: (tooltipItem, data)
                getAfterBody: function () {
                    return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
                },

                // Get the footer and beforeFooter and afterFooter lines
                // Args are: (tooltipItem, data)
                getFooter: function () {
                    var me = this;
                    var callbacks = me._options.callbacks;

                    var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
                    var footer = callbacks.footer.apply(me, arguments);
                    var afterFooter = callbacks.afterFooter.apply(me, arguments);

                    var lines = [];
                    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
                    lines = pushOrConcat(lines, splitNewlines(footer));
                    lines = pushOrConcat(lines, splitNewlines(afterFooter));

                    return lines;
                },

                update: function (changed) {
                    var me = this;
                    var opts = me._options;

                    // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
                    // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
                    // which breaks any animations.
                    var existingModel = me._model;
                    var model = me._model = getBaseModel(opts);
                    var active = me._active;

                    var data = me._data;

                    // In the case where active.length === 0 we need to keep these at existing values for good animations
                    var alignment = {
                        xAlign: existingModel.xAlign,
                        yAlign: existingModel.yAlign
                    };
                    var backgroundPoint = {
                        x: existingModel.x,
                        y: existingModel.y
                    };
                    var tooltipSize = {
                        width: existingModel.width,
                        height: existingModel.height
                    };
                    var tooltipPosition = {
                        x: existingModel.caretX,
                        y: existingModel.caretY
                    };

                    var i, len;

                    if (active.length) {
                        model.opacity = 1;

                        var labelColors = [];
                        var labelTextColors = [];
                        tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);

                        var tooltipItems = [];
                        for (i = 0, len = active.length; i < len; ++i) {
                            tooltipItems.push(createTooltipItem(active[i]));
                        }

                        // If the user provided a filter function, use it to modify the tooltip items
                        if (opts.filter) {
                            tooltipItems = tooltipItems.filter(function (a) {
                                return opts.filter(a, data);
                            });
                        }

                        // If the user provided a sorting function, use it to modify the tooltip items
                        if (opts.itemSort) {
                            tooltipItems = tooltipItems.sort(function (a, b) {
                                return opts.itemSort(a, b, data);
                            });
                        }

                        // Determine colors for boxes
                        helpers.each(tooltipItems, function (tooltipItem) {
                            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
                            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
                        });


                        // Build the Text Lines
                        model.title = me.getTitle(tooltipItems, data);
                        model.beforeBody = me.getBeforeBody(tooltipItems, data);
                        model.body = me.getBody(tooltipItems, data);
                        model.afterBody = me.getAfterBody(tooltipItems, data);
                        model.footer = me.getFooter(tooltipItems, data);

                        // Initial positioning and colors
                        model.x = Math.round(tooltipPosition.x);
                        model.y = Math.round(tooltipPosition.y);
                        model.caretPadding = opts.caretPadding;
                        model.labelColors = labelColors;
                        model.labelTextColors = labelTextColors;

                        // data points
                        model.dataPoints = tooltipItems;

                        // We need to determine alignment of the tooltip
                        tooltipSize = getTooltipSize(this, model);
                        alignment = determineAlignment(this, tooltipSize);
                        // Final Size and Position
                        backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
                    } else {
                        model.opacity = 0;
                    }

                    model.xAlign = alignment.xAlign;
                    model.yAlign = alignment.yAlign;
                    model.x = backgroundPoint.x;
                    model.y = backgroundPoint.y;
                    model.width = tooltipSize.width;
                    model.height = tooltipSize.height;

                    // Point where the caret on the tooltip points to
                    model.caretX = tooltipPosition.x;
                    model.caretY = tooltipPosition.y;

                    me._model = model;

                    if (changed && opts.custom) {
                        opts.custom.call(me, model);
                    }

                    return me;
                },

                drawCaret: function (tooltipPoint, size) {
                    var ctx = this._chart.ctx;
                    var vm = this._view;
                    var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

                    ctx.lineTo(caretPosition.x1, caretPosition.y1);
                    ctx.lineTo(caretPosition.x2, caretPosition.y2);
                    ctx.lineTo(caretPosition.x3, caretPosition.y3);
                },
                getCaretPosition: function (tooltipPoint, size, vm) {
                    var x1, x2, x3, y1, y2, y3;
                    var caretSize = vm.caretSize;
                    var cornerRadius = vm.cornerRadius;
                    var xAlign = vm.xAlign;
                    var yAlign = vm.yAlign;
                    var ptX = tooltipPoint.x;
                    var ptY = tooltipPoint.y;
                    var width = size.width;
                    var height = size.height;

                    if (yAlign === 'center') {
                        y2 = ptY + (height / 2);

                        if (xAlign === 'left') {
                            x1 = ptX;
                            x2 = x1 - caretSize;
                            x3 = x1;

                            y1 = y2 + caretSize;
                            y3 = y2 - caretSize;
                        } else {
                            x1 = ptX + width;
                            x2 = x1 + caretSize;
                            x3 = x1;

                            y1 = y2 - caretSize;
                            y3 = y2 + caretSize;
                        }
                    } else {
                        if (xAlign === 'left') {
                            x2 = ptX + cornerRadius + (caretSize);
                            x1 = x2 - caretSize;
                            x3 = x2 + caretSize;
                        } else if (xAlign === 'right') {
                            x2 = ptX + width - cornerRadius - caretSize;
                            x1 = x2 - caretSize;
                            x3 = x2 + caretSize;
                        } else {
                            x2 = vm.caretX;
                            x1 = x2 - caretSize;
                            x3 = x2 + caretSize;
                        }
                        if (yAlign === 'top') {
                            y1 = ptY;
                            y2 = y1 - caretSize;
                            y3 = y1;
                        } else {
                            y1 = ptY + height;
                            y2 = y1 + caretSize;
                            y3 = y1;
                            // invert drawing order
                            var tmp = x3;
                            x3 = x1;
                            x1 = tmp;
                        }
                    }
                    return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
                },

                drawTitle: function (pt, vm, ctx, opacity) {
                    var title = vm.title;

                    if (title.length) {
                        ctx.textAlign = vm._titleAlign;
                        ctx.textBaseline = 'top';

                        var titleFontSize = vm.titleFontSize;
                        var titleSpacing = vm.titleSpacing;

                        ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
                        ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

                        var i, len;
                        for (i = 0, len = title.length; i < len; ++i) {
                            ctx.fillText(title[i], pt.x, pt.y);
                            pt.y += titleFontSize + titleSpacing; // Line Height and spacing

                            if (i + 1 === title.length) {
                                pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
                            }
                        }
                    }
                },

                drawBody: function (pt, vm, ctx, opacity) {
                    var bodyFontSize = vm.bodyFontSize;
                    var bodySpacing = vm.bodySpacing;
                    var body = vm.body;

                    ctx.textAlign = vm._bodyAlign;
                    ctx.textBaseline = 'top';
                    ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

                    // Before Body
                    var xLinePadding = 0;
                    var fillLineOfText = function (line) {
                        ctx.fillText(line, pt.x + xLinePadding, pt.y);
                        pt.y += bodyFontSize + bodySpacing;
                    };

                    // Before body lines
                    ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
                    helpers.each(vm.beforeBody, fillLineOfText);

                    var drawColorBoxes = vm.displayColors;
                    xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;

                    // Draw body lines now
                    helpers.each(body, function (bodyItem, i) {
                        var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
                        ctx.fillStyle = textColor;
                        helpers.each(bodyItem.before, fillLineOfText);

                        helpers.each(bodyItem.lines, function (line) {
                            // Draw Legend-like boxes if needed
                            if (drawColorBoxes) {
                                // Fill a white rect so that colours merge nicely if the opacity is < 1
                                ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
                                ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

                                // Border
                                ctx.lineWidth = 1;
                                ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
                                ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

                                // Inner square
                                ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
                                ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                                ctx.fillStyle = textColor;
                            }

                            fillLineOfText(line);
                        });

                        helpers.each(bodyItem.after, fillLineOfText);
                    });

                    // Reset back to 0 for after body
                    xLinePadding = 0;

                    // After body lines
                    helpers.each(vm.afterBody, fillLineOfText);
                    pt.y -= bodySpacing; // Remove last body spacing
                },

                drawFooter: function (pt, vm, ctx, opacity) {
                    var footer = vm.footer;

                    if (footer.length) {
                        pt.y += vm.footerMarginTop;

                        ctx.textAlign = vm._footerAlign;
                        ctx.textBaseline = 'top';

                        ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
                        ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

                        helpers.each(footer, function (line) {
                            ctx.fillText(line, pt.x, pt.y);
                            pt.y += vm.footerFontSize + vm.footerSpacing;
                        });
                    }
                },

                drawBackground: function (pt, vm, ctx, tooltipSize, opacity) {
                    ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
                    ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
                    ctx.lineWidth = vm.borderWidth;
                    var xAlign = vm.xAlign;
                    var yAlign = vm.yAlign;
                    var x = pt.x;
                    var y = pt.y;
                    var width = tooltipSize.width;
                    var height = tooltipSize.height;
                    var radius = vm.cornerRadius;

                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    if (yAlign === 'top') {
                        this.drawCaret(pt, tooltipSize);
                    }
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    if (yAlign === 'center' && xAlign === 'right') {
                        this.drawCaret(pt, tooltipSize);
                    }
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    if (yAlign === 'bottom') {
                        this.drawCaret(pt, tooltipSize);
                    }
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    if (yAlign === 'center' && xAlign === 'left') {
                        this.drawCaret(pt, tooltipSize);
                    }
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();

                    ctx.fill();

                    if (vm.borderWidth > 0) {
                        ctx.stroke();
                    }
                },

                draw: function () {
                    var ctx = this._chart.ctx;
                    var vm = this._view;

                    if (vm.opacity === 0) {
                        return;
                    }

                    var tooltipSize = {
                        width: vm.width,
                        height: vm.height
                    };
                    var pt = {
                        x: vm.x,
                        y: vm.y
                    };

                    // IE11/Edge does not like very small opacities, so snap to 0
                    var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

                    // Truthy/falsey value for empty tooltip
                    var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

                    if (this._options.enabled && hasTooltipContent) {
                        // Draw Background
                        this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

                        // Draw Title, Body, and Footer
                        pt.x += vm.xPadding;
                        pt.y += vm.yPadding;

                        // Titles
                        this.drawTitle(pt, vm, ctx, opacity);

                        // Body
                        this.drawBody(pt, vm, ctx, opacity);

                        // Footer
                        this.drawFooter(pt, vm, ctx, opacity);
                    }
                },

                /**
                 * Handle an event
                 * @private
                 * @param {IEvent} event - The event to handle
                 * @returns {Boolean} true if the tooltip changed
                 */
                handleEvent: function (e) {
                    var me = this;
                    var options = me._options;
                    var changed = false;

                    me._lastActive = me._lastActive || [];

                    // Find Active Elements for tooltips
                    if (e.type === 'mouseout') {
                        me._active = [];
                    } else {
                        me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
                    }

                    // Remember Last Actives
                    changed = !helpers.arrayEquals(me._active, me._lastActive);

                    // Only handle target event on tooltip change
                    if (changed) {
                        me._lastActive = me._active;

                        if (options.enabled || options.custom) {
                            me._eventPosition = {
                                x: e.x,
                                y: e.y
                            };

                            me.update(true);
                            me.pivot();
                        }
                    }

                    return changed;
                }
            });

            /**
             * @namespace Chart.Tooltip.positioners
             */
            exports.positioners = positioners;


        }, {"26": 26, "27": 27, "46": 46}],
        37: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var Element = require(27);
            var helpers = require(46);

            defaults._set('global', {
                elements: {
                    arc: {
                        backgroundColor: defaults.global.defaultColor,
                        borderColor: '#fff',
                        borderWidth: 2
                    }
                }
            });

            module.exports = Element.extend({
                inLabelRange: function (mouseX) {
                    var vm = this._view;

                    if (vm) {
                        return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
                    }
                    return false;
                },

                inRange: function (chartX, chartY) {
                    var vm = this._view;

                    if (vm) {
                        var pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
                        var angle = pointRelativePosition.angle;
                        var distance = pointRelativePosition.distance;

                        // Sanitise angle range
                        var startAngle = vm.startAngle;
                        var endAngle = vm.endAngle;
                        while (endAngle < startAngle) {
                            endAngle += 2.0 * Math.PI;
                        }
                        while (angle > endAngle) {
                            angle -= 2.0 * Math.PI;
                        }
                        while (angle < startAngle) {
                            angle += 2.0 * Math.PI;
                        }

                        // Check if within the range of the open/close angle
                        var betweenAngles = (angle >= startAngle && angle <= endAngle);
                        var withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);

                        return (betweenAngles && withinRadius);
                    }
                    return false;
                },

                getCenterPoint: function () {
                    var vm = this._view;
                    var halfAngle = (vm.startAngle + vm.endAngle) / 2;
                    var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
                    return {
                        x: vm.x + Math.cos(halfAngle) * halfRadius,
                        y: vm.y + Math.sin(halfAngle) * halfRadius
                    };
                },

                getArea: function () {
                    var vm = this._view;
                    return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
                },

                tooltipPosition: function () {
                    var vm = this._view;
                    var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
                    var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

                    return {
                        x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
                        y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
                    };
                },

                draw: function () {
                    var ctx = this._chart.ctx;
                    var vm = this._view;
                    var sA = vm.startAngle;
                    var eA = vm.endAngle;

                    ctx.beginPath();

                    ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
                    ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

                    ctx.closePath();
                    ctx.strokeStyle = vm.borderColor;
                    ctx.lineWidth = vm.borderWidth;

                    ctx.fillStyle = vm.backgroundColor;

                    ctx.fill();
                    ctx.lineJoin = 'bevel';

                    if (vm.borderWidth) {
                        ctx.stroke();
                    }
                }
            });

        }, {"26": 26, "27": 27, "46": 46}],
        38: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var Element = require(27);
            var helpers = require(46);

            var globalDefaults = defaults.global;

            defaults._set('global', {
                elements: {
                    line: {
                        tension: 0.4,
                        backgroundColor: globalDefaults.defaultColor,
                        borderWidth: 3,
                        borderColor: globalDefaults.defaultColor,
                        borderCapStyle: 'butt',
                        borderDash: [],
                        borderDashOffset: 0.0,
                        borderJoinStyle: 'miter',
                        capBezierPoints: true,
                        fill: true, // do we fill in the area between the line and its base axis
                    }
                }
            });

            module.exports = Element.extend({
                draw: function () {
                    var me = this;
                    var vm = me._view;
                    var ctx = me._chart.ctx;
                    var spanGaps = vm.spanGaps;
                    var points = me._children.slice(); // clone array
                    var globalOptionLineElements = globalDefaults.elements.line;
                    var lastDrawnIndex = -1;
                    var index, current, previous, currentVM;

                    // If we are looping, adding the first point again
                    if (me._loop && points.length) {
                        points.push(points[0]);
                    }

                    ctx.save();

                    // Stroke Line Options
                    ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

                    // IE 9 and 10 do not support line dash
                    if (ctx.setLineDash) {
                        ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
                    }

                    ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
                    ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
                    ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
                    ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

                    // Stroke Line
                    ctx.beginPath();
                    lastDrawnIndex = -1;

                    for (index = 0; index < points.length; ++index) {
                        current = points[index];
                        previous = helpers.previousItem(points, index);
                        currentVM = current._view;

                        // First point moves to it's starting position no matter what
                        if (index === 0) {
                            if (!currentVM.skip) {
                                ctx.moveTo(currentVM.x, currentVM.y);
                                lastDrawnIndex = index;
                            }
                        } else {
                            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

                            if (!currentVM.skip) {
                                if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
                                    // There was a gap and this is the first point after the gap
                                    ctx.moveTo(currentVM.x, currentVM.y);
                                } else {
                                    // Line to next point
                                    helpers.canvas.lineTo(ctx, previous._view, current._view);
                                }
                                lastDrawnIndex = index;
                            }
                        }
                    }

                    ctx.stroke();
                    ctx.restore();
                }
            });

        }, {"26": 26, "27": 27, "46": 46}],
        39: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var Element = require(27);
            var helpers = require(46);

            var defaultColor = defaults.global.defaultColor;

            defaults._set('global', {
                elements: {
                    point: {
                        radius: 3,
                        pointStyle: 'circle',
                        backgroundColor: defaultColor,
                        borderColor: defaultColor,
                        borderWidth: 1,
                        // Hover
                        hitRadius: 1,
                        hoverRadius: 4,
                        hoverBorderWidth: 1
                    }
                }
            });

            function xRange(mouseX) {
                var vm = this._view;
                return vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;
            }

            function yRange(mouseY) {
                var vm = this._view;
                return vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;
            }

            module.exports = Element.extend({
                inRange: function (mouseX, mouseY) {
                    var vm = this._view;
                    return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
                },

                inLabelRange: xRange,
                inXRange: xRange,
                inYRange: yRange,

                getCenterPoint: function () {
                    var vm = this._view;
                    return {
                        x: vm.x,
                        y: vm.y
                    };
                },

                getArea: function () {
                    return Math.PI * Math.pow(this._view.radius, 2);
                },

                tooltipPosition: function () {
                    var vm = this._view;
                    return {
                        x: vm.x,
                        y: vm.y,
                        padding: vm.radius + vm.borderWidth
                    };
                },

                draw: function (chartArea) {
                    var vm = this._view;
                    var model = this._model;
                    var ctx = this._chart.ctx;
                    var pointStyle = vm.pointStyle;
                    var rotation = vm.rotation;
                    var radius = vm.radius;
                    var x = vm.x;
                    var y = vm.y;
                    var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)

                    if (vm.skip) {
                        return;
                    }

                    // Clipping for Points.
                    if (chartArea === undefined || (model.x >= chartArea.left && chartArea.right * errMargin >= model.x && model.y >= chartArea.top && chartArea.bottom * errMargin >= model.y)) {
                        ctx.strokeStyle = vm.borderColor || defaultColor;
                        ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
                        ctx.fillStyle = vm.backgroundColor || defaultColor;
                        helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
                    }
                }
            });

        }, {"26": 26, "27": 27, "46": 46}],
        40: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var Element = require(27);

            defaults._set('global', {
                elements: {
                    rectangle: {
                        backgroundColor: defaults.global.defaultColor,
                        borderColor: defaults.global.defaultColor,
                        borderSkipped: 'bottom',
                        borderWidth: 0
                    }
                }
            });

            function isVertical(bar) {
                return bar._view.width !== undefined;
            }

            /**
             * Helper function to get the bounds of the bar regardless of the orientation
             * @param bar {Chart.Element.Rectangle} the bar
             * @return {Bounds} bounds of the bar
             * @private
             */
            function getBarBounds(bar) {
                var vm = bar._view;
                var x1, x2, y1, y2;

                if (isVertical(bar)) {
                    // vertical
                    var halfWidth = vm.width / 2;
                    x1 = vm.x - halfWidth;
                    x2 = vm.x + halfWidth;
                    y1 = Math.min(vm.y, vm.base);
                    y2 = Math.max(vm.y, vm.base);
                } else {
                    // horizontal bar
                    var halfHeight = vm.height / 2;
                    x1 = Math.min(vm.x, vm.base);
                    x2 = Math.max(vm.x, vm.base);
                    y1 = vm.y - halfHeight;
                    y2 = vm.y + halfHeight;
                }

                return {
                    left: x1,
                    top: y1,
                    right: x2,
                    bottom: y2
                };
            }

            module.exports = Element.extend({
                draw: function () {
                    var ctx = this._chart.ctx;
                    var vm = this._view;
                    var left, right, top, bottom, signX, signY, borderSkipped;
                    var borderWidth = vm.borderWidth;

                    if (!vm.horizontal) {
                        // bar
                        left = vm.x - vm.width / 2;
                        right = vm.x + vm.width / 2;
                        top = vm.y;
                        bottom = vm.base;
                        signX = 1;
                        signY = bottom > top ? 1 : -1;
                        borderSkipped = vm.borderSkipped || 'bottom';
                    } else {
                        // horizontal bar
                        left = vm.base;
                        right = vm.x;
                        top = vm.y - vm.height / 2;
                        bottom = vm.y + vm.height / 2;
                        signX = right > left ? 1 : -1;
                        signY = 1;
                        borderSkipped = vm.borderSkipped || 'left';
                    }

                    // Canvas doesn't allow us to stroke inside the width so we can
                    // adjust the sizes to fit if we're setting a stroke on the line
                    if (borderWidth) {
                        // borderWidth shold be less than bar width and bar height.
                        var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
                        borderWidth = borderWidth > barSize ? barSize : borderWidth;
                        var halfStroke = borderWidth / 2;
                        // Adjust borderWidth when bar top position is near vm.base(zero).
                        var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
                        var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
                        var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
                        var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
                        // not become a vertical line?
                        if (borderLeft !== borderRight) {
                            top = borderTop;
                            bottom = borderBottom;
                        }
                        // not become a horizontal line?
                        if (borderTop !== borderBottom) {
                            left = borderLeft;
                            right = borderRight;
                        }
                    }

                    ctx.beginPath();
                    ctx.fillStyle = vm.backgroundColor;
                    ctx.strokeStyle = vm.borderColor;
                    ctx.lineWidth = borderWidth;

                    // Corner points, from bottom-left to bottom-right clockwise
                    // | 1 2 |
                    // | 0 3 |
                    var corners = [
                        [left, bottom],
                        [left, top],
                        [right, top],
                        [right, bottom]
                    ];

                    // Find first (starting) corner with fallback to 'bottom'
                    var borders = ['bottom', 'left', 'top', 'right'];
                    var startCorner = borders.indexOf(borderSkipped, 0);
                    if (startCorner === -1) {
                        startCorner = 0;
                    }

                    function cornerAt(index) {
                        return corners[(startCorner + index) % 4];
                    }

                    // Draw rectangle from 'startCorner'
                    var corner = cornerAt(0);
                    ctx.moveTo(corner[0], corner[1]);

                    for (var i = 1; i < 4; i++) {
                        corner = cornerAt(i);
                        ctx.lineTo(corner[0], corner[1]);
                    }

                    ctx.fill();
                    if (borderWidth) {
                        ctx.stroke();
                    }
                },

                height: function () {
                    var vm = this._view;
                    return vm.base - vm.y;
                },

                inRange: function (mouseX, mouseY) {
                    var inRange = false;

                    if (this._view) {
                        var bounds = getBarBounds(this);
                        inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
                    }

                    return inRange;
                },

                inLabelRange: function (mouseX, mouseY) {
                    var me = this;
                    if (!me._view) {
                        return false;
                    }

                    var inRange = false;
                    var bounds = getBarBounds(me);

                    if (isVertical(me)) {
                        inRange = mouseX >= bounds.left && mouseX <= bounds.right;
                    } else {
                        inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
                    }

                    return inRange;
                },

                inXRange: function (mouseX) {
                    var bounds = getBarBounds(this);
                    return mouseX >= bounds.left && mouseX <= bounds.right;
                },

                inYRange: function (mouseY) {
                    var bounds = getBarBounds(this);
                    return mouseY >= bounds.top && mouseY <= bounds.bottom;
                },

                getCenterPoint: function () {
                    var vm = this._view;
                    var x, y;
                    if (isVertical(this)) {
                        x = vm.x;
                        y = (vm.y + vm.base) / 2;
                    } else {
                        x = (vm.x + vm.base) / 2;
                        y = vm.y;
                    }

                    return {x: x, y: y};
                },

                getArea: function () {
                    var vm = this._view;
                    return vm.width * Math.abs(vm.y - vm.base);
                },

                tooltipPosition: function () {
                    var vm = this._view;
                    return {
                        x: vm.x,
                        y: vm.y
                    };
                }
            });

        }, {"26": 26, "27": 27}],
        41: [function (require, module, exports) {
            'use strict';

            module.exports = {};
            module.exports.Arc = require(37);
            module.exports.Line = require(38);
            module.exports.Point = require(39);
            module.exports.Rectangle = require(40);

        }, {"37": 37, "38": 38, "39": 39, "40": 40}],
        42: [function (require, module, exports) {
            'use strict';

            var helpers = require(43);

            /**
             * @namespace Chart.helpers.canvas
             */
            var exports = module.exports = {
                /**
                 * Clears the entire canvas associated to the given `chart`.
                 * @param {Chart} chart - The chart for which to clear the canvas.
                 */
                clear: function (chart) {
                    chart.ctx.clearRect(0, 0, chart.width, chart.height);
                },

                /**
                 * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
                 * given size (width, height) and the same `radius` for all corners.
                 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
                 * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
                 * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
                 * @param {Number} width - The rectangle's width.
                 * @param {Number} height - The rectangle's height.
                 * @param {Number} radius - The rounded amount (in pixels) for the four corners.
                 * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
                 */
                roundedRect: function (ctx, x, y, width, height, radius) {
                    if (radius) {
                        // NOTE(SB) `epsilon` helps to prevent minor artifacts appearing
                        // on Chrome when `r` is exactly half the height or the width.
                        var epsilon = 0.0000001;
                        var r = Math.min(radius, (height / 2) - epsilon, (width / 2) - epsilon);

                        ctx.moveTo(x + r, y);
                        ctx.lineTo(x + width - r, y);
                        ctx.arcTo(x + width, y, x + width, y + r, r);
                        ctx.lineTo(x + width, y + height - r);
                        ctx.arcTo(x + width, y + height, x + width - r, y + height, r);
                        ctx.lineTo(x + r, y + height);
                        ctx.arcTo(x, y + height, x, y + height - r, r);
                        ctx.lineTo(x, y + r);
                        ctx.arcTo(x, y, x + r, y, r);
                        ctx.closePath();
                        ctx.moveTo(x, y);
                    } else {
                        ctx.rect(x, y, width, height);
                    }
                },

                drawPoint: function (ctx, style, radius, x, y, rotation) {
                    var type, edgeLength, xOffset, yOffset, height, size;
                    rotation = rotation || 0;

                    if (style && typeof style === 'object') {
                        type = style.toString();
                        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
                            ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
                            return;
                        }
                    }

                    if (isNaN(radius) || radius <= 0) {
                        return;
                    }

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation * Math.PI / 180);
                    ctx.beginPath();

                    switch (style) {
                        // Default includes circle
                        default:
                            ctx.arc(0, 0, radius, 0, Math.PI * 2);
                            ctx.closePath();
                            break;
                        case 'triangle':
                            edgeLength = 3 * radius / Math.sqrt(3);
                            height = edgeLength * Math.sqrt(3) / 2;
                            ctx.moveTo(-edgeLength / 2, height / 3);
                            ctx.lineTo(edgeLength / 2, height / 3);
                            ctx.lineTo(0, -2 * height / 3);
                            ctx.closePath();
                            break;
                        case 'rect':
                            size = 1 / Math.SQRT2 * radius;
                            ctx.rect(-size, -size, 2 * size, 2 * size);
                            break;
                        case 'rectRounded':
                            var offset = radius / Math.SQRT2;
                            var leftX = -offset;
                            var topY = -offset;
                            var sideSize = Math.SQRT2 * radius;

                            // NOTE(SB) the rounded rect implementation changed to use `arcTo`
                            // instead of `quadraticCurveTo` since it generates better results
                            // when rect is almost a circle. 0.425 (instead of 0.5) produces
                            // results visually closer to the previous impl.
                            this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius * 0.425);
                            break;
                        case 'rectRot':
                            size = 1 / Math.SQRT2 * radius;
                            ctx.moveTo(-size, 0);
                            ctx.lineTo(0, size);
                            ctx.lineTo(size, 0);
                            ctx.lineTo(0, -size);
                            ctx.closePath();
                            break;
                        case 'cross':
                            ctx.moveTo(0, radius);
                            ctx.lineTo(0, -radius);
                            ctx.moveTo(-radius, 0);
                            ctx.lineTo(radius, 0);
                            break;
                        case 'crossRot':
                            xOffset = Math.cos(Math.PI / 4) * radius;
                            yOffset = Math.sin(Math.PI / 4) * radius;
                            ctx.moveTo(-xOffset, -yOffset);
                            ctx.lineTo(xOffset, yOffset);
                            ctx.moveTo(-xOffset, yOffset);
                            ctx.lineTo(xOffset, -yOffset);
                            break;
                        case 'star':
                            ctx.moveTo(0, radius);
                            ctx.lineTo(0, -radius);
                            ctx.moveTo(-radius, 0);
                            ctx.lineTo(radius, 0);
                            xOffset = Math.cos(Math.PI / 4) * radius;
                            yOffset = Math.sin(Math.PI / 4) * radius;
                            ctx.moveTo(-xOffset, -yOffset);
                            ctx.lineTo(xOffset, yOffset);
                            ctx.moveTo(-xOffset, yOffset);
                            ctx.lineTo(xOffset, -yOffset);
                            break;
                        case 'line':
                            ctx.moveTo(-radius, 0);
                            ctx.lineTo(radius, 0);
                            break;
                        case 'dash':
                            ctx.moveTo(0, 0);
                            ctx.lineTo(radius, 0);
                            break;
                    }

                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                },

                clipArea: function (ctx, area) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
                    ctx.clip();
                },

                unclipArea: function (ctx) {
                    ctx.restore();
                },

                lineTo: function (ctx, previous, target, flip) {
                    if (target.steppedLine) {
                        if ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {
                            ctx.lineTo(previous.x, target.y);
                        } else {
                            ctx.lineTo(target.x, previous.y);
                        }
                        ctx.lineTo(target.x, target.y);
                        return;
                    }

                    if (!target.tension) {
                        ctx.lineTo(target.x, target.y);
                        return;
                    }

                    ctx.bezierCurveTo(
                        flip ? previous.controlPointPreviousX : previous.controlPointNextX,
                        flip ? previous.controlPointPreviousY : previous.controlPointNextY,
                        flip ? target.controlPointNextX : target.controlPointPreviousX,
                        flip ? target.controlPointNextY : target.controlPointPreviousY,
                        target.x,
                        target.y);
                }
            };

// DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
             * @namespace Chart.helpers.clear
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.clear = exports.clear;

            /**
             * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
             * @namespace Chart.helpers.drawRoundedRectangle
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.drawRoundedRectangle = function (ctx) {
                ctx.beginPath();
                exports.roundedRect.apply(exports, arguments);
            };

        }, {"43": 43}],
        43: [function (require, module, exports) {
            'use strict';

            /**
             * @namespace Chart.helpers
             */
            var helpers = {
                /**
                 * An empty function that can be used, for example, for optional callback.
                 */
                noop: function () {
                },

                /**
                 * Returns a unique id, sequentially generated from a global variable.
                 * @returns {Number}
                 * @function
                 */
                uid: (function () {
                    var id = 0;
                    return function () {
                        return id++;
                    };
                }()),

                /**
                 * Returns true if `value` is neither null nor undefined, else returns false.
                 * @param {*} value - The value to test.
                 * @returns {Boolean}
                 * @since 2.7.0
                 */
                isNullOrUndef: function (value) {
                    return value === null || typeof value === 'undefined';
                },

                /**
                 * Returns true if `value` is an array, else returns false.
                 * @param {*} value - The value to test.
                 * @returns {Boolean}
                 * @function
                 */
                isArray: Array.isArray ? Array.isArray : function (value) {
                    return Object.prototype.toString.call(value) === '[object Array]';
                },

                /**
                 * Returns true if `value` is an object (excluding null), else returns false.
                 * @param {*} value - The value to test.
                 * @returns {Boolean}
                 * @since 2.7.0
                 */
                isObject: function (value) {
                    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
                },

                /**
                 * Returns `value` if defined, else returns `defaultValue`.
                 * @param {*} value - The value to return if defined.
                 * @param {*} defaultValue - The value to return if `value` is undefined.
                 * @returns {*}
                 */
                valueOrDefault: function (value, defaultValue) {
                    return typeof value === 'undefined' ? defaultValue : value;
                },

                /**
                 * Returns value at the given `index` in array if defined, else returns `defaultValue`.
                 * @param {Array} value - The array to lookup for value at `index`.
                 * @param {Number} index - The index in `value` to lookup for value.
                 * @param {*} defaultValue - The value to return if `value[index]` is undefined.
                 * @returns {*}
                 */
                valueAtIndexOrDefault: function (value, index, defaultValue) {
                    return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
                },

                /**
                 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
                 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
                 * @param {Function} fn - The function to call.
                 * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
                 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
                 * @returns {*}
                 */
                callback: function (fn, args, thisArg) {
                    if (fn && typeof fn.call === 'function') {
                        return fn.apply(thisArg, args);
                    }
                },

                /**
                 * Note(SB) for performance sake, this method should only be used when loopable type
                 * is unknown or in none intensive code (not called often and small loopable). Else
                 * it's preferable to use a regular for() loop and save extra function calls.
                 * @param {Object|Array} loopable - The object or array to be iterated.
                 * @param {Function} fn - The function to call for each item.
                 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
                 * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
                 */
                each: function (loopable, fn, thisArg, reverse) {
                    var i, len, keys;
                    if (helpers.isArray(loopable)) {
                        len = loopable.length;
                        if (reverse) {
                            for (i = len - 1; i >= 0; i--) {
                                fn.call(thisArg, loopable[i], i);
                            }
                        } else {
                            for (i = 0; i < len; i++) {
                                fn.call(thisArg, loopable[i], i);
                            }
                        }
                    } else if (helpers.isObject(loopable)) {
                        keys = Object.keys(loopable);
                        len = keys.length;
                        for (i = 0; i < len; i++) {
                            fn.call(thisArg, loopable[keys[i]], keys[i]);
                        }
                    }
                },

                /**
                 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
                 * @see http://stackoverflow.com/a/14853974
                 * @param {Array} a0 - The array to compare
                 * @param {Array} a1 - The array to compare
                 * @returns {Boolean}
                 */
                arrayEquals: function (a0, a1) {
                    var i, ilen, v0, v1;

                    if (!a0 || !a1 || a0.length !== a1.length) {
                        return false;
                    }

                    for (i = 0, ilen = a0.length; i < ilen; ++i) {
                        v0 = a0[i];
                        v1 = a1[i];

                        if (v0 instanceof Array && v1 instanceof Array) {
                            if (!helpers.arrayEquals(v0, v1)) {
                                return false;
                            }
                        } else if (v0 !== v1) {
                            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
                            return false;
                        }
                    }

                    return true;
                },

                /**
                 * Returns a deep copy of `source` without keeping references on objects and arrays.
                 * @param {*} source - The value to clone.
                 * @returns {*}
                 */
                clone: function (source) {
                    if (helpers.isArray(source)) {
                        return source.map(helpers.clone);
                    }

                    if (helpers.isObject(source)) {
                        var target = {};
                        var keys = Object.keys(source);
                        var klen = keys.length;
                        var k = 0;

                        for (; k < klen; ++k) {
                            target[keys[k]] = helpers.clone(source[keys[k]]);
                        }

                        return target;
                    }

                    return source;
                },

                /**
                 * The default merger when Chart.helpers.merge is called without merger option.
                 * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
                 * @private
                 */
                _merger: function (key, target, source, options) {
                    var tval = target[key];
                    var sval = source[key];

                    if (helpers.isObject(tval) && helpers.isObject(sval)) {
                        helpers.merge(tval, sval, options);
                    } else {
                        target[key] = helpers.clone(sval);
                    }
                },

                /**
                 * Merges source[key] in target[key] only if target[key] is undefined.
                 * @private
                 */
                _mergerIf: function (key, target, source) {
                    var tval = target[key];
                    var sval = source[key];

                    if (helpers.isObject(tval) && helpers.isObject(sval)) {
                        helpers.mergeIf(tval, sval);
                    } else if (!target.hasOwnProperty(key)) {
                        target[key] = helpers.clone(sval);
                    }
                },

                /**
                 * Recursively deep copies `source` properties into `target` with the given `options`.
                 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
                 * @param {Object} target - The target object in which all sources are merged into.
                 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
                 * @param {Object} [options] - Merging options:
                 * @param {Function} [options.merger] - The merge method (key, target, source, options)
                 * @returns {Object} The `target` object.
                 */
                merge: function (target, source, options) {
                    var sources = helpers.isArray(source) ? source : [source];
                    var ilen = sources.length;
                    var merge, i, keys, klen, k;

                    if (!helpers.isObject(target)) {
                        return target;
                    }

                    options = options || {};
                    merge = options.merger || helpers._merger;

                    for (i = 0; i < ilen; ++i) {
                        source = sources[i];
                        if (!helpers.isObject(source)) {
                            continue;
                        }

                        keys = Object.keys(source);
                        for (k = 0, klen = keys.length; k < klen; ++k) {
                            merge(keys[k], target, source, options);
                        }
                    }

                    return target;
                },

                /**
                 * Recursively deep copies `source` properties into `target` *only* if not defined in target.
                 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
                 * @param {Object} target - The target object in which all sources are merged into.
                 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
                 * @returns {Object} The `target` object.
                 */
                mergeIf: function (target, source) {
                    return helpers.merge(target, source, {merger: helpers._mergerIf});
                },

                /**
                 * Applies the contents of two or more objects together into the first object.
                 * @param {Object} target - The target object in which all objects are merged into.
                 * @param {Object} arg1 - Object containing additional properties to merge in target.
                 * @param {Object} argN - Additional objects containing properties to merge in target.
                 * @returns {Object} The `target` object.
                 */
                extend: function (target) {
                    var setFn = function (value, key) {
                        target[key] = value;
                    };
                    for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
                        helpers.each(arguments[i], setFn);
                    }
                    return target;
                },

                /**
                 * Basic javascript inheritance based on the model created in Backbone.js
                 */
                inherits: function (extensions) {
                    var me = this;
                    var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function () {
                        return me.apply(this, arguments);
                    };

                    var Surrogate = function () {
                        this.constructor = ChartElement;
                    };

                    Surrogate.prototype = me.prototype;
                    ChartElement.prototype = new Surrogate();
                    ChartElement.extend = helpers.inherits;

                    if (extensions) {
                        helpers.extend(ChartElement.prototype, extensions);
                    }

                    ChartElement.__super__ = me.prototype;
                    return ChartElement;
                }
            };

            module.exports = helpers;

// DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.helpers.callback instead.
             * @function Chart.helpers.callCallback
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             * @private
             */
            helpers.callCallback = helpers.callback;

            /**
             * Provided for backward compatibility, use Array.prototype.indexOf instead.
             * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
             * @function Chart.helpers.indexOf
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.indexOf = function (array, item, fromIndex) {
                return Array.prototype.indexOf.call(array, item, fromIndex);
            };

            /**
             * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
             * @function Chart.helpers.getValueOrDefault
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.getValueOrDefault = helpers.valueOrDefault;

            /**
             * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
             * @function Chart.helpers.getValueAtIndexOrDefault
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

        }, {}],
        44: [function (require, module, exports) {
            'use strict';

            var helpers = require(43);

            /**
             * Easing functions adapted from Robert Penner's easing equations.
             * @namespace Chart.helpers.easingEffects
             * @see http://www.robertpenner.com/easing/
             */
            var effects = {
                linear: function (t) {
                    return t;
                },

                easeInQuad: function (t) {
                    return t * t;
                },

                easeOutQuad: function (t) {
                    return -t * (t - 2);
                },

                easeInOutQuad: function (t) {
                    if ((t /= 0.5) < 1) {
                        return 0.5 * t * t;
                    }
                    return -0.5 * ((--t) * (t - 2) - 1);
                },

                easeInCubic: function (t) {
                    return t * t * t;
                },

                easeOutCubic: function (t) {
                    return (t = t - 1) * t * t + 1;
                },

                easeInOutCubic: function (t) {
                    if ((t /= 0.5) < 1) {
                        return 0.5 * t * t * t;
                    }
                    return 0.5 * ((t -= 2) * t * t + 2);
                },

                easeInQuart: function (t) {
                    return t * t * t * t;
                },

                easeOutQuart: function (t) {
                    return -((t = t - 1) * t * t * t - 1);
                },

                easeInOutQuart: function (t) {
                    if ((t /= 0.5) < 1) {
                        return 0.5 * t * t * t * t;
                    }
                    return -0.5 * ((t -= 2) * t * t * t - 2);
                },

                easeInQuint: function (t) {
                    return t * t * t * t * t;
                },

                easeOutQuint: function (t) {
                    return (t = t - 1) * t * t * t * t + 1;
                },

                easeInOutQuint: function (t) {
                    if ((t /= 0.5) < 1) {
                        return 0.5 * t * t * t * t * t;
                    }
                    return 0.5 * ((t -= 2) * t * t * t * t + 2);
                },

                easeInSine: function (t) {
                    return -Math.cos(t * (Math.PI / 2)) + 1;
                },

                easeOutSine: function (t) {
                    return Math.sin(t * (Math.PI / 2));
                },

                easeInOutSine: function (t) {
                    return -0.5 * (Math.cos(Math.PI * t) - 1);
                },

                easeInExpo: function (t) {
                    return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
                },

                easeOutExpo: function (t) {
                    return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
                },

                easeInOutExpo: function (t) {
                    if (t === 0) {
                        return 0;
                    }
                    if (t === 1) {
                        return 1;
                    }
                    if ((t /= 0.5) < 1) {
                        return 0.5 * Math.pow(2, 10 * (t - 1));
                    }
                    return 0.5 * (-Math.pow(2, -10 * --t) + 2);
                },

                easeInCirc: function (t) {
                    if (t >= 1) {
                        return t;
                    }
                    return -(Math.sqrt(1 - t * t) - 1);
                },

                easeOutCirc: function (t) {
                    return Math.sqrt(1 - (t = t - 1) * t);
                },

                easeInOutCirc: function (t) {
                    if ((t /= 0.5) < 1) {
                        return -0.5 * (Math.sqrt(1 - t * t) - 1);
                    }
                    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
                },

                easeInElastic: function (t) {
                    var s = 1.70158;
                    var p = 0;
                    var a = 1;
                    if (t === 0) {
                        return 0;
                    }
                    if (t === 1) {
                        return 1;
                    }
                    if (!p) {
                        p = 0.3;
                    }
                    if (a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p / (2 * Math.PI) * Math.asin(1 / a);
                    }
                    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
                },

                easeOutElastic: function (t) {
                    var s = 1.70158;
                    var p = 0;
                    var a = 1;
                    if (t === 0) {
                        return 0;
                    }
                    if (t === 1) {
                        return 1;
                    }
                    if (!p) {
                        p = 0.3;
                    }
                    if (a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p / (2 * Math.PI) * Math.asin(1 / a);
                    }
                    return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
                },

                easeInOutElastic: function (t) {
                    var s = 1.70158;
                    var p = 0;
                    var a = 1;
                    if (t === 0) {
                        return 0;
                    }
                    if ((t /= 0.5) === 2) {
                        return 1;
                    }
                    if (!p) {
                        p = 0.45;
                    }
                    if (a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p / (2 * Math.PI) * Math.asin(1 / a);
                    }
                    if (t < 1) {
                        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
                    }
                    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
                },
                easeInBack: function (t) {
                    var s = 1.70158;
                    return t * t * ((s + 1) * t - s);
                },

                easeOutBack: function (t) {
                    var s = 1.70158;
                    return (t = t - 1) * t * ((s + 1) * t + s) + 1;
                },

                easeInOutBack: function (t) {
                    var s = 1.70158;
                    if ((t /= 0.5) < 1) {
                        return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
                    }
                    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
                },

                easeInBounce: function (t) {
                    return 1 - effects.easeOutBounce(1 - t);
                },

                easeOutBounce: function (t) {
                    if (t < (1 / 2.75)) {
                        return 7.5625 * t * t;
                    }
                    if (t < (2 / 2.75)) {
                        return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
                    }
                    if (t < (2.5 / 2.75)) {
                        return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
                    }
                    return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
                },

                easeInOutBounce: function (t) {
                    if (t < 0.5) {
                        return effects.easeInBounce(t * 2) * 0.5;
                    }
                    return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
                }
            };

            module.exports = {
                effects: effects
            };

// DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
             * @function Chart.helpers.easingEffects
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.easingEffects = effects;

        }, {"43": 43}],
        45: [function (require, module, exports) {
            'use strict';

            var helpers = require(43);

            /**
             * @alias Chart.helpers.options
             * @namespace
             */
            module.exports = {
                /**
                 * Converts the given line height `value` in pixels for a specific font `size`.
                 * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
                 * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
                 * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
                 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
                 * @since 2.7.0
                 */
                toLineHeight: function (value, size) {
                    var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
                    if (!matches || matches[1] === 'normal') {
                        return size * 1.2;
                    }

                    value = +matches[2];

                    switch (matches[3]) {
                        case 'px':
                            return value;
                        case '%':
                            value /= 100;
                            break;
                        default:
                            break;
                    }

                    return size * value;
                },

                /**
                 * Converts the given value into a padding object with pre-computed width/height.
                 * @param {Number|Object} value - If a number, set the value to all TRBL component,
                 *  else, if and object, use defined properties and sets undefined ones to 0.
                 * @returns {Object} The padding values (top, right, bottom, left, width, height)
                 * @since 2.7.0
                 */
                toPadding: function (value) {
                    var t, r, b, l;

                    if (helpers.isObject(value)) {
                        t = +value.top || 0;
                        r = +value.right || 0;
                        b = +value.bottom || 0;
                        l = +value.left || 0;
                    } else {
                        t = r = b = l = +value || 0;
                    }

                    return {
                        top: t,
                        right: r,
                        bottom: b,
                        left: l,
                        height: t + b,
                        width: l + r
                    };
                },

                /**
                 * Evaluates the given `inputs` sequentially and returns the first defined value.
                 * @param {Array[]} inputs - An array of values, falling back to the last value.
                 * @param {Object} [context] - If defined and the current value is a function, the value
                 * is called with `context` as first argument and the result becomes the new input.
                 * @param {Number} [index] - If defined and the current value is an array, the value
                 * at `index` become the new input.
                 * @since 2.7.0
                 */
                resolve: function (inputs, context, index) {
                    var i, ilen, value;

                    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
                        value = inputs[i];
                        if (value === undefined) {
                            continue;
                        }
                        if (context !== undefined && typeof value === 'function') {
                            value = value(context);
                        }
                        if (index !== undefined && helpers.isArray(value)) {
                            value = value[index];
                        }
                        if (value !== undefined) {
                            return value;
                        }
                    }
                }
            };

        }, {"43": 43}],
        46: [function (require, module, exports) {
            'use strict';

            module.exports = require(43);
            module.exports.easing = require(44);
            module.exports.canvas = require(42);
            module.exports.options = require(45);

        }, {"42": 42, "43": 43, "44": 44, "45": 45}],
        47: [function (require, module, exports) {
            /**
             * Platform fallback implementation (minimal).
             * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
             */

            module.exports = {
                acquireContext: function (item) {
                    if (item && item.canvas) {
                        // Support for any object associated to a canvas (including a context2d)
                        item = item.canvas;
                    }

                    return item && item.getContext('2d') || null;
                }
            };

        }, {}],
        48: [function (require, module, exports) {
            /**
             * Chart.Platform implementation for targeting a web browser
             */

            'use strict';

            var helpers = require(46);

            var EXPANDO_KEY = '$chartjs';
            var CSS_PREFIX = 'chartjs-';
            var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
            var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
            var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

            /**
             * DOM event types -> Chart.js event types.
             * Note: only events with different types are mapped.
             * @see https://developer.mozilla.org/en-US/docs/Web/Events
             */
            var EVENT_TYPES = {
                touchstart: 'mousedown',
                touchmove: 'mousemove',
                touchend: 'mouseup',
                pointerenter: 'mouseenter',
                pointerdown: 'mousedown',
                pointermove: 'mousemove',
                pointerup: 'mouseup',
                pointerleave: 'mouseout',
                pointerout: 'mouseout'
            };

            /**
             * The "used" size is the final value of a dimension property after all calculations have
             * been performed. This method uses the computed style of `element` but returns undefined
             * if the computed style is not expressed in pixels. That can happen in some cases where
             * `element` has a size relative to its parent and this last one is not yet displayed,
             * for example because of `display: none` on a parent node.
             * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
             * @returns {Number} Size in pixels or undefined if unknown.
             */
            function readUsedSize(element, property) {
                var value = helpers.getStyle(element, property);
                var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
                return matches ? Number(matches[1]) : undefined;
            }

            /**
             * Initializes the canvas style and render size without modifying the canvas display size,
             * since responsiveness is handled by the controller.resize() method. The config is used
             * to determine the aspect ratio to apply in case no explicit height has been specified.
             */
            function initCanvas(canvas, config) {
                var style = canvas.style;

                // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
                // returns null or '' if no explicit value has been set to the canvas attribute.
                var renderHeight = canvas.getAttribute('height');
                var renderWidth = canvas.getAttribute('width');

                // Chart.js modifies some canvas values that we want to restore on destroy
                canvas[EXPANDO_KEY] = {
                    initial: {
                        height: renderHeight,
                        width: renderWidth,
                        style: {
                            display: style.display,
                            height: style.height,
                            width: style.width
                        }
                    }
                };

                // Force canvas to display as block to avoid extra space caused by inline
                // elements, which would interfere with the responsive resize process.
                // https://github.com/chartjs/Chart.js/issues/2538
                style.display = style.display || 'block';

                if (renderWidth === null || renderWidth === '') {
                    var displayWidth = readUsedSize(canvas, 'width');
                    if (displayWidth !== undefined) {
                        canvas.width = displayWidth;
                    }
                }

                if (renderHeight === null || renderHeight === '') {
                    if (canvas.style.height === '') {
                        // If no explicit render height and style height, let's apply the aspect ratio,
                        // which one can be specified by the user but also by charts as default option
                        // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
                        canvas.height = canvas.width / (config.options.aspectRatio || 2);
                    } else {
                        var displayHeight = readUsedSize(canvas, 'height');
                        if (displayWidth !== undefined) {
                            canvas.height = displayHeight;
                        }
                    }
                }

                return canvas;
            }

            /**
             * Detects support for options object argument in addEventListener.
             * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
             * @private
             */
            var supportsEventListenerOptions = (function () {
                var supports = false;
                try {
                    var options = Object.defineProperty({}, 'passive', {
                        get: function () {
                            supports = true;
                        }
                    });
                    window.addEventListener('e', null, options);
                } catch (e) {
                    // continue regardless of error
                }
                return supports;
            }());

// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
// https://github.com/chartjs/Chart.js/issues/4287
            var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;

            function addEventListener(node, type, listener) {
                node.addEventListener(type, listener, eventListenerOptions);
            }

            function removeEventListener(node, type, listener) {
                node.removeEventListener(type, listener, eventListenerOptions);
            }

            function createEvent(type, chart, x, y, nativeEvent) {
                return {
                    type: type,
                    chart: chart,
                    native: nativeEvent || null,
                    x: x !== undefined ? x : null,
                    y: y !== undefined ? y : null,
                };
            }

            function fromNativeEvent(event, chart) {
                var type = EVENT_TYPES[event.type] || event.type;
                var pos = helpers.getRelativePosition(event, chart);
                return createEvent(type, chart, pos.x, pos.y, event);
            }

            function throttled(fn, thisArg) {
                var ticking = false;
                var args = [];

                return function () {
                    args = Array.prototype.slice.call(arguments);
                    thisArg = thisArg || this;

                    if (!ticking) {
                        ticking = true;
                        helpers.requestAnimFrame.call(window, function () {
                            ticking = false;
                            fn.apply(thisArg, args);
                        });
                    }
                };
            }

// Implementation based on https://github.com/marcj/css-element-queries
            function createResizer(handler) {
                var resizer = document.createElement('div');
                var cls = CSS_PREFIX + 'size-monitor';
                var maxSize = 1000000;
                var style =
                    'position:absolute;' +
                    'left:0;' +
                    'top:0;' +
                    'right:0;' +
                    'bottom:0;' +
                    'overflow:hidden;' +
                    'pointer-events:none;' +
                    'visibility:hidden;' +
                    'z-index:-1;';

                resizer.style.cssText = style;
                resizer.className = cls;
                resizer.innerHTML =
                    '<div class="' + cls + '-expand" style="' + style + '">' +
                    '<div style="' +
                    'position:absolute;' +
                    'width:' + maxSize + 'px;' +
                    'height:' + maxSize + 'px;' +
                    'left:0;' +
                    'top:0">' +
                    '</div>' +
                    '</div>' +
                    '<div class="' + cls + '-shrink" style="' + style + '">' +
                    '<div style="' +
                    'position:absolute;' +
                    'width:200%;' +
                    'height:200%;' +
                    'left:0; ' +
                    'top:0">' +
                    '</div>' +
                    '</div>';

                var expand = resizer.childNodes[0];
                var shrink = resizer.childNodes[1];

                resizer._reset = function () {
                    expand.scrollLeft = maxSize;
                    expand.scrollTop = maxSize;
                    shrink.scrollLeft = maxSize;
                    shrink.scrollTop = maxSize;
                };
                var onScroll = function () {
                    resizer._reset();
                    handler();
                };

                addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
                addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

                return resizer;
            }

// https://davidwalsh.name/detect-node-insertion
            function watchForRender(node, handler) {
                var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
                var proxy = expando.renderProxy = function (e) {
                    if (e.animationName === CSS_RENDER_ANIMATION) {
                        handler();
                    }
                };

                helpers.each(ANIMATION_START_EVENTS, function (type) {
                    addEventListener(node, type, proxy);
                });

                // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
                // is removed then added back immediately (same animation frame?). Accessing the
                // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
                // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
                // https://github.com/chartjs/Chart.js/issues/4737
                expando.reflow = !!node.offsetParent;

                node.classList.add(CSS_RENDER_MONITOR);
            }

            function unwatchForRender(node) {
                var expando = node[EXPANDO_KEY] || {};
                var proxy = expando.renderProxy;

                if (proxy) {
                    helpers.each(ANIMATION_START_EVENTS, function (type) {
                        removeEventListener(node, type, proxy);
                    });

                    delete expando.renderProxy;
                }

                node.classList.remove(CSS_RENDER_MONITOR);
            }

            function addResizeListener(node, listener, chart) {
                var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

                // Let's keep track of this added resizer and thus avoid DOM query when removing it.
                var resizer = expando.resizer = createResizer(throttled(function () {
                    if (expando.resizer) {
                        return listener(createEvent('resize', chart));
                    }
                }));

                // The resizer needs to be attached to the node parent, so we first need to be
                // sure that `node` is attached to the DOM before injecting the resizer element.
                watchForRender(node, function () {
                    if (expando.resizer) {
                        var container = node.parentNode;
                        if (container && container !== resizer.parentNode) {
                            container.insertBefore(resizer, container.firstChild);
                        }

                        // The container size might have changed, let's reset the resizer state.
                        resizer._reset();
                    }
                });
            }

            function removeResizeListener(node) {
                var expando = node[EXPANDO_KEY] || {};
                var resizer = expando.resizer;

                delete expando.resizer;
                unwatchForRender(node);

                if (resizer && resizer.parentNode) {
                    resizer.parentNode.removeChild(resizer);
                }
            }

            function injectCSS(platform, css) {
                // http://stackoverflow.com/q/3922139
                var style = platform._style || document.createElement('style');
                if (!platform._style) {
                    platform._style = style;
                    css = '/* Chart.js */\n' + css;
                    style.setAttribute('type', 'text/css');
                    document.getElementsByTagName('head')[0].appendChild(style);
                }

                style.appendChild(document.createTextNode(css));
            }

            module.exports = {
                /**
                 * This property holds whether this platform is enabled for the current environment.
                 * Currently used by platform.js to select the proper implementation.
                 * @private
                 */
                _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

                initialize: function () {
                    var keyframes = 'from{opacity:0.99}to{opacity:1}';

                    injectCSS(this,
                        // DOM rendering detection
                        // https://davidwalsh.name/detect-node-insertion
                        '@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
                        '@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
                        '.' + CSS_RENDER_MONITOR + '{' +
                        '-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
                        'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
                        '}'
                    );
                },

                acquireContext: function (item, config) {
                    if (typeof item === 'string') {
                        item = document.getElementById(item);
                    } else if (item.length) {
                        // Support for array based queries (such as jQuery)
                        item = item[0];
                    }

                    if (item && item.canvas) {
                        // Support for any object associated to a canvas (including a context2d)
                        item = item.canvas;
                    }

                    // To prevent canvas fingerprinting, some add-ons undefine the getContext
                    // method, for example: https://github.com/kkapsner/CanvasBlocker
                    // https://github.com/chartjs/Chart.js/issues/2807
                    var context = item && item.getContext && item.getContext('2d');

                    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
                    // inside an iframe or when running in a protected environment. We could guess the
                    // types from their toString() value but let's keep things flexible and assume it's
                    // a sufficient condition if the item has a context2D which has item as `canvas`.
                    // https://github.com/chartjs/Chart.js/issues/3887
                    // https://github.com/chartjs/Chart.js/issues/4102
                    // https://github.com/chartjs/Chart.js/issues/4152
                    if (context && context.canvas === item) {
                        initCanvas(item, config);
                        return context;
                    }

                    return null;
                },

                releaseContext: function (context) {
                    var canvas = context.canvas;
                    if (!canvas[EXPANDO_KEY]) {
                        return;
                    }

                    var initial = canvas[EXPANDO_KEY].initial;
                    ['height', 'width'].forEach(function (prop) {
                        var value = initial[prop];
                        if (helpers.isNullOrUndef(value)) {
                            canvas.removeAttribute(prop);
                        } else {
                            canvas.setAttribute(prop, value);
                        }
                    });

                    helpers.each(initial.style || {}, function (value, key) {
                        canvas.style[key] = value;
                    });

                    // The canvas render size might have been changed (and thus the state stack discarded),
                    // we can't use save() and restore() to restore the initial state. So make sure that at
                    // least the canvas context is reset to the default state by setting the canvas width.
                    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
                    canvas.width = canvas.width;

                    delete canvas[EXPANDO_KEY];
                },

                addEventListener: function (chart, type, listener) {
                    var canvas = chart.canvas;
                    if (type === 'resize') {
                        // Note: the resize event is not supported on all browsers.
                        addResizeListener(canvas, listener, chart);
                        return;
                    }

                    var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
                    var proxies = expando.proxies || (expando.proxies = {});
                    var proxy = proxies[chart.id + '_' + type] = function (event) {
                        listener(fromNativeEvent(event, chart));
                    };

                    addEventListener(canvas, type, proxy);
                },

                removeEventListener: function (chart, type, listener) {
                    var canvas = chart.canvas;
                    if (type === 'resize') {
                        // Note: the resize event is not supported on all browsers.
                        removeResizeListener(canvas, listener);
                        return;
                    }

                    var expando = listener[EXPANDO_KEY] || {};
                    var proxies = expando.proxies || {};
                    var proxy = proxies[chart.id + '_' + type];
                    if (!proxy) {
                        return;
                    }

                    removeEventListener(canvas, type, proxy);
                }
            };

// DEPRECATIONS

            /**
             * Provided for backward compatibility, use EventTarget.addEventListener instead.
             * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
             * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
             * @function Chart.helpers.addEvent
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.addEvent = addEventListener;

            /**
             * Provided for backward compatibility, use EventTarget.removeEventListener instead.
             * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
             * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
             * @function Chart.helpers.removeEvent
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.removeEvent = removeEventListener;

        }, {"46": 46}],
        49: [function (require, module, exports) {
            'use strict';

            var helpers = require(46);
            var basic = require(47);
            var dom = require(48);

// @TODO Make possible to select another platform at build time.
            var implementation = dom._enabled ? dom : basic;

            /**
             * @namespace Chart.platform
             * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
             * @since 2.4.0
             */
            module.exports = helpers.extend({
                /**
                 * @since 2.7.0
                 */
                initialize: function () {
                },

                /**
                 * Called at chart construction time, returns a context2d instance implementing
                 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
                 * @param {*} item - The native item from which to acquire context (platform specific)
                 * @param {Object} options - The chart options
                 * @returns {CanvasRenderingContext2D} context2d instance
                 */
                acquireContext: function () {
                },

                /**
                 * Called at chart destruction time, releases any resources associated to the context
                 * previously returned by the acquireContext() method.
                 * @param {CanvasRenderingContext2D} context - The context2d instance
                 * @returns {Boolean} true if the method succeeded, else false
                 */
                releaseContext: function () {
                },

                /**
                 * Registers the specified listener on the given chart.
                 * @param {Chart} chart - Chart from which to listen for event
                 * @param {String} type - The ({@link IEvent}) type to listen for
                 * @param {Function} listener - Receives a notification (an object that implements
                 * the {@link IEvent} interface) when an event of the specified type occurs.
                 */
                addEventListener: function () {
                },

                /**
                 * Removes the specified listener previously registered with addEventListener.
                 * @param {Chart} chart -Chart from which to remove the listener
                 * @param {String} type - The ({@link IEvent}) type to remove
                 * @param {Function} listener - The listener function to remove from the event target.
                 */
                removeEventListener: function () {
                }

            }, implementation);

            /**
             * @interface IPlatform
             * Allows abstracting platform dependencies away from the chart
             * @borrows Chart.platform.acquireContext as acquireContext
             * @borrows Chart.platform.releaseContext as releaseContext
             * @borrows Chart.platform.addEventListener as addEventListener
             * @borrows Chart.platform.removeEventListener as removeEventListener
             */

            /**
             * @interface IEvent
             * @prop {String} type - The event type name, possible values are:
             * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
             * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
             * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
             * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
             * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
             */

        }, {"46": 46, "47": 47, "48": 48}],
        50: [function (require, module, exports) {
            'use strict';

            module.exports = {};
            module.exports.filler = require(51);
            module.exports.legend = require(52);
            module.exports.title = require(53);

        }, {"51": 51, "52": 52, "53": 53}],
        51: [function (require, module, exports) {
            /**
             * Plugin based on discussion from the following Chart.js issues:
             * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
             * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
             */

            'use strict';

            var defaults = require(26);
            var elements = require(41);
            var helpers = require(46);

            defaults._set('global', {
                plugins: {
                    filler: {
                        propagate: true
                    }
                }
            });

            var mappers = {
                dataset: function (source) {
                    var index = source.fill;
                    var chart = source.chart;
                    var meta = chart.getDatasetMeta(index);
                    var visible = meta && chart.isDatasetVisible(index);
                    var points = (visible && meta.dataset._children) || [];
                    var length = points.length || 0;

                    return !length ? null : function (point, i) {
                        return (i < length && points[i]._view) || null;
                    };
                },

                boundary: function (source) {
                    var boundary = source.boundary;
                    var x = boundary ? boundary.x : null;
                    var y = boundary ? boundary.y : null;

                    return function (point) {
                        return {
                            x: x === null ? point.x : x,
                            y: y === null ? point.y : y,
                        };
                    };
                }
            };

// @todo if (fill[0] === '#')
            function decodeFill(el, index, count) {
                var model = el._model || {};
                var fill = model.fill;
                var target;

                if (fill === undefined) {
                    fill = !!model.backgroundColor;
                }

                if (fill === false || fill === null) {
                    return false;
                }

                if (fill === true) {
                    return 'origin';
                }

                target = parseFloat(fill, 10);
                if (isFinite(target) && Math.floor(target) === target) {
                    if (fill[0] === '-' || fill[0] === '+') {
                        target = index + target;
                    }

                    if (target === index || target < 0 || target >= count) {
                        return false;
                    }

                    return target;
                }

                switch (fill) {
                    // compatibility
                    case 'bottom':
                        return 'start';
                    case 'top':
                        return 'end';
                    case 'zero':
                        return 'origin';
                    // supported boundaries
                    case 'origin':
                    case 'start':
                    case 'end':
                        return fill;
                    // invalid fill values
                    default:
                        return false;
                }
            }

            function computeBoundary(source) {
                var model = source.el._model || {};
                var scale = source.el._scale || {};
                var fill = source.fill;
                var target = null;
                var horizontal;

                if (isFinite(fill)) {
                    return null;
                }

                // Backward compatibility: until v3, we still need to support boundary values set on
                // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
                // controllers might still use it (e.g. the Smith chart).

                if (fill === 'start') {
                    target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
                } else if (fill === 'end') {
                    target = model.scaleTop === undefined ? scale.top : model.scaleTop;
                } else if (model.scaleZero !== undefined) {
                    target = model.scaleZero;
                } else if (scale.getBasePosition) {
                    target = scale.getBasePosition();
                } else if (scale.getBasePixel) {
                    target = scale.getBasePixel();
                }

                if (target !== undefined && target !== null) {
                    if (target.x !== undefined && target.y !== undefined) {
                        return target;
                    }

                    if (typeof target === 'number' && isFinite(target)) {
                        horizontal = scale.isHorizontal();
                        return {
                            x: horizontal ? target : null,
                            y: horizontal ? null : target
                        };
                    }
                }

                return null;
            }

            function resolveTarget(sources, index, propagate) {
                var source = sources[index];
                var fill = source.fill;
                var visited = [index];
                var target;

                if (!propagate) {
                    return fill;
                }

                while (fill !== false && visited.indexOf(fill) === -1) {
                    if (!isFinite(fill)) {
                        return fill;
                    }

                    target = sources[fill];
                    if (!target) {
                        return false;
                    }

                    if (target.visible) {
                        return fill;
                    }

                    visited.push(fill);
                    fill = target.fill;
                }

                return false;
            }

            function createMapper(source) {
                var fill = source.fill;
                var type = 'dataset';

                if (fill === false) {
                    return null;
                }

                if (!isFinite(fill)) {
                    type = 'boundary';
                }

                return mappers[type](source);
            }

            function isDrawable(point) {
                return point && !point.skip;
            }

            function drawArea(ctx, curve0, curve1, len0, len1) {
                var i;

                if (!len0 || !len1) {
                    return;
                }

                // building first area curve (normal)
                ctx.moveTo(curve0[0].x, curve0[0].y);
                for (i = 1; i < len0; ++i) {
                    helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
                }

                // joining the two area curves
                ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

                // building opposite area curve (reverse)
                for (i = len1 - 1; i > 0; --i) {
                    helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
                }
            }

            function doFill(ctx, points, mapper, view, color, loop) {
                var count = points.length;
                var span = view.spanGaps;
                var curve0 = [];
                var curve1 = [];
                var len0 = 0;
                var len1 = 0;
                var i, ilen, index, p0, p1, d0, d1;

                ctx.beginPath();

                for (i = 0, ilen = (count + !!loop); i < ilen; ++i) {
                    index = i % count;
                    p0 = points[index]._view;
                    p1 = mapper(p0, index, view);
                    d0 = isDrawable(p0);
                    d1 = isDrawable(p1);

                    if (d0 && d1) {
                        len0 = curve0.push(p0);
                        len1 = curve1.push(p1);
                    } else if (len0 && len1) {
                        if (!span) {
                            drawArea(ctx, curve0, curve1, len0, len1);
                            len0 = len1 = 0;
                            curve0 = [];
                            curve1 = [];
                        } else {
                            if (d0) {
                                curve0.push(p0);
                            }
                            if (d1) {
                                curve1.push(p1);
                            }
                        }
                    }
                }

                drawArea(ctx, curve0, curve1, len0, len1);

                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
            }

            module.exports = {
                id: 'filler',

                afterDatasetsUpdate: function (chart, options) {
                    var count = (chart.data.datasets || []).length;
                    var propagate = options.propagate;
                    var sources = [];
                    var meta, i, el, source;

                    for (i = 0; i < count; ++i) {
                        meta = chart.getDatasetMeta(i);
                        el = meta.dataset;
                        source = null;

                        if (el && el._model && el instanceof elements.Line) {
                            source = {
                                visible: chart.isDatasetVisible(i),
                                fill: decodeFill(el, i, count),
                                chart: chart,
                                el: el
                            };
                        }

                        meta.$filler = source;
                        sources.push(source);
                    }

                    for (i = 0; i < count; ++i) {
                        source = sources[i];
                        if (!source) {
                            continue;
                        }

                        source.fill = resolveTarget(sources, i, propagate);
                        source.boundary = computeBoundary(source);
                        source.mapper = createMapper(source);
                    }
                },

                beforeDatasetDraw: function (chart, args) {
                    var meta = args.meta.$filler;
                    if (!meta) {
                        return;
                    }

                    var ctx = chart.ctx;
                    var el = meta.el;
                    var view = el._view;
                    var points = el._children || [];
                    var mapper = meta.mapper;
                    var color = view.backgroundColor || defaults.global.defaultColor;

                    if (mapper && color && points.length) {
                        helpers.canvas.clipArea(ctx, chart.chartArea);
                        doFill(ctx, points, mapper, view, color, el._loop);
                        helpers.canvas.unclipArea(ctx);
                    }
                }
            };

        }, {"26": 26, "41": 41, "46": 46}],
        52: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var Element = require(27);
            var helpers = require(46);
            var layouts = require(31);

            var noop = helpers.noop;

            defaults._set('global', {
                legend: {
                    display: true,
                    position: 'top',
                    fullWidth: true,
                    reverse: false,
                    weight: 1000,

                    // a callback that will handle
                    onClick: function (e, legendItem) {
                        var index = legendItem.datasetIndex;
                        var ci = this.chart;
                        var meta = ci.getDatasetMeta(index);

                        // See controller.isDatasetVisible comment
                        meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

                        // We hid a dataset ... rerender the chart
                        ci.update();
                    },

                    onHover: null,

                    labels: {
                        boxWidth: 40,
                        padding: 10,
                        // Generates labels shown in the legend
                        // Valid properties to return:
                        // text : text to display
                        // fillStyle : fill of coloured box
                        // strokeStyle: stroke of coloured box
                        // hidden : if this legend item refers to a hidden item
                        // lineCap : cap style for line
                        // lineDash
                        // lineDashOffset :
                        // lineJoin :
                        // lineWidth :
                        generateLabels: function (chart) {
                            var data = chart.data;
                            return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
                                return {
                                    text: dataset.label,
                                    fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
                                    hidden: !chart.isDatasetVisible(i),
                                    lineCap: dataset.borderCapStyle,
                                    lineDash: dataset.borderDash,
                                    lineDashOffset: dataset.borderDashOffset,
                                    lineJoin: dataset.borderJoinStyle,
                                    lineWidth: dataset.borderWidth,
                                    strokeStyle: dataset.borderColor,
                                    pointStyle: dataset.pointStyle,

                                    // Below is extra data used for toggling the datasets
                                    datasetIndex: i
                                };
                            }, this) : [];
                        }
                    }
                },

                legendCallback: function (chart) {
                    var text = [];
                    text.push('<ul class="' + chart.id + '-legend">');
                    for (var i = 0; i < chart.data.datasets.length; i++) {
                        text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
                        if (chart.data.datasets[i].label) {
                            text.push(chart.data.datasets[i].label);
                        }
                        text.push('</li>');
                    }
                    text.push('</ul>');
                    return text.join('');
                }
            });

            /**
             * Helper function to get the box width based on the usePointStyle option
             * @param labelopts {Object} the label options on the legend
             * @param fontSize {Number} the label font size
             * @return {Number} width of the color box area
             */
            function getBoxWidth(labelOpts, fontSize) {
                return labelOpts.usePointStyle ?
                    fontSize * Math.SQRT2 :
                    labelOpts.boxWidth;
            }

            /**
             * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
             */
            var Legend = Element.extend({

                initialize: function (config) {
                    helpers.extend(this, config);

                    // Contains hit boxes for each dataset (in dataset order)
                    this.legendHitBoxes = [];

                    // Are we in doughnut mode which has a different data type
                    this.doughnutMode = false;
                },

                // These methods are ordered by lifecycle. Utilities then follow.
                // Any function defined here is inherited by all legend types.
                // Any function can be extended by the legend type

                beforeUpdate: noop,
                update: function (maxWidth, maxHeight, margins) {
                    var me = this;

                    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
                    me.beforeUpdate();

                    // Absorb the master measurements
                    me.maxWidth = maxWidth;
                    me.maxHeight = maxHeight;
                    me.margins = margins;

                    // Dimensions
                    me.beforeSetDimensions();
                    me.setDimensions();
                    me.afterSetDimensions();
                    // Labels
                    me.beforeBuildLabels();
                    me.buildLabels();
                    me.afterBuildLabels();

                    // Fit
                    me.beforeFit();
                    me.fit();
                    me.afterFit();
                    //
                    me.afterUpdate();

                    return me.minSize;
                },
                afterUpdate: noop,

                //

                beforeSetDimensions: noop,
                setDimensions: function () {
                    var me = this;
                    // Set the unconstrained dimension before label rotation
                    if (me.isHorizontal()) {
                        // Reset position before calculating rotation
                        me.width = me.maxWidth;
                        me.left = 0;
                        me.right = me.width;
                    } else {
                        me.height = me.maxHeight;

                        // Reset position before calculating rotation
                        me.top = 0;
                        me.bottom = me.height;
                    }

                    // Reset padding
                    me.paddingLeft = 0;
                    me.paddingTop = 0;
                    me.paddingRight = 0;
                    me.paddingBottom = 0;

                    // Reset minSize
                    me.minSize = {
                        width: 0,
                        height: 0
                    };
                },
                afterSetDimensions: noop,

                //

                beforeBuildLabels: noop,
                buildLabels: function () {
                    var me = this;
                    var labelOpts = me.options.labels || {};
                    var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

                    if (labelOpts.filter) {
                        legendItems = legendItems.filter(function (item) {
                            return labelOpts.filter(item, me.chart.data);
                        });
                    }

                    if (me.options.reverse) {
                        legendItems.reverse();
                    }

                    me.legendItems = legendItems;
                },
                afterBuildLabels: noop,

                //

                beforeFit: noop,
                fit: function () {
                    var me = this;
                    var opts = me.options;
                    var labelOpts = opts.labels;
                    var display = opts.display;

                    var ctx = me.ctx;

                    var globalDefault = defaults.global;
                    var valueOrDefault = helpers.valueOrDefault;
                    var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
                    var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
                    var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
                    var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

                    // Reset hit boxes
                    var hitboxes = me.legendHitBoxes = [];

                    var minSize = me.minSize;
                    var isHorizontal = me.isHorizontal();

                    if (isHorizontal) {
                        minSize.width = me.maxWidth; // fill all the width
                        minSize.height = display ? 10 : 0;
                    } else {
                        minSize.width = display ? 10 : 0;
                        minSize.height = me.maxHeight; // fill all the height
                    }

                    // Increase sizes here
                    if (display) {
                        ctx.font = labelFont;

                        if (isHorizontal) {
                            // Labels

                            // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
                            var lineWidths = me.lineWidths = [0];
                            var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;

                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'top';

                            helpers.each(me.legendItems, function (legendItem, i) {
                                var boxWidth = getBoxWidth(labelOpts, fontSize);
                                var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

                                if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
                                    totalHeight += fontSize + (labelOpts.padding);
                                    lineWidths[lineWidths.length] = me.left;
                                }

                                // Store the hitbox width and height here. Final position will be updated in `draw`
                                hitboxes[i] = {
                                    left: 0,
                                    top: 0,
                                    width: width,
                                    height: fontSize
                                };

                                lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
                            });

                            minSize.height += totalHeight;

                        } else {
                            var vPadding = labelOpts.padding;
                            var columnWidths = me.columnWidths = [];
                            var totalWidth = labelOpts.padding;
                            var currentColWidth = 0;
                            var currentColHeight = 0;
                            var itemHeight = fontSize + vPadding;

                            helpers.each(me.legendItems, function (legendItem, i) {
                                var boxWidth = getBoxWidth(labelOpts, fontSize);
                                var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

                                // If too tall, go to new column
                                if (currentColHeight + itemHeight > minSize.height) {
                                    totalWidth += currentColWidth + labelOpts.padding;
                                    columnWidths.push(currentColWidth); // previous column width

                                    currentColWidth = 0;
                                    currentColHeight = 0;
                                }

                                // Get max width
                                currentColWidth = Math.max(currentColWidth, itemWidth);
                                currentColHeight += itemHeight;

                                // Store the hitbox width and height here. Final position will be updated in `draw`
                                hitboxes[i] = {
                                    left: 0,
                                    top: 0,
                                    width: itemWidth,
                                    height: fontSize
                                };
                            });

                            totalWidth += currentColWidth;
                            columnWidths.push(currentColWidth);
                            minSize.width += totalWidth;
                        }
                    }

                    me.width = minSize.width;
                    me.height = minSize.height;
                },
                afterFit: noop,

                // Shared Methods
                isHorizontal: function () {
                    return this.options.position === 'top' || this.options.position === 'bottom';
                },

                // Actually draw the legend on the canvas
                draw: function () {
                    var me = this;
                    var opts = me.options;
                    var labelOpts = opts.labels;
                    var globalDefault = defaults.global;
                    var lineDefault = globalDefault.elements.line;
                    var legendWidth = me.width;
                    var lineWidths = me.lineWidths;

                    if (opts.display) {
                        var ctx = me.ctx;
                        var valueOrDefault = helpers.valueOrDefault;
                        var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
                        var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
                        var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
                        var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
                        var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
                        var cursor;

                        // Canvas setup
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.lineWidth = 0.5;
                        ctx.strokeStyle = fontColor; // for strikethrough effect
                        ctx.fillStyle = fontColor; // render in correct colour
                        ctx.font = labelFont;

                        var boxWidth = getBoxWidth(labelOpts, fontSize);
                        var hitboxes = me.legendHitBoxes;

                        // current position
                        var drawLegendBox = function (x, y, legendItem) {
                            if (isNaN(boxWidth) || boxWidth <= 0) {
                                return;
                            }

                            // Set the ctx for the box
                            ctx.save();

                            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
                            ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
                            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
                            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
                            ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
                            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
                            var isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);

                            if (ctx.setLineDash) {
                                // IE 9 and 10 do not support line dash
                                ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
                            }

                            if (opts.labels && opts.labels.usePointStyle) {
                                // Recalculate x and y for drawPoint() because its expecting
                                // x and y to be center of figure (instead of top left)
                                var radius = fontSize * Math.SQRT2 / 2;
                                var offSet = radius / Math.SQRT2;
                                var centerX = x + offSet;
                                var centerY = y + offSet;

                                // Draw pointStyle as legend symbol
                                helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
                            } else {
                                // Draw box as legend symbol
                                if (!isLineWidthZero) {
                                    ctx.strokeRect(x, y, boxWidth, fontSize);
                                }
                                ctx.fillRect(x, y, boxWidth, fontSize);
                            }

                            ctx.restore();
                        };
                        var fillText = function (x, y, legendItem, textWidth) {
                            var halfFontSize = fontSize / 2;
                            var xLeft = boxWidth + halfFontSize + x;
                            var yMiddle = y + halfFontSize;

                            ctx.fillText(legendItem.text, xLeft, yMiddle);

                            if (legendItem.hidden) {
                                // Strikethrough the text if hidden
                                ctx.beginPath();
                                ctx.lineWidth = 2;
                                ctx.moveTo(xLeft, yMiddle);
                                ctx.lineTo(xLeft + textWidth, yMiddle);
                                ctx.stroke();
                            }
                        };

                        // Horizontal
                        var isHorizontal = me.isHorizontal();
                        if (isHorizontal) {
                            cursor = {
                                x: me.left + ((legendWidth - lineWidths[0]) / 2),
                                y: me.top + labelOpts.padding,
                                line: 0
                            };
                        } else {
                            cursor = {
                                x: me.left + labelOpts.padding,
                                y: me.top + labelOpts.padding,
                                line: 0
                            };
                        }

                        var itemHeight = fontSize + labelOpts.padding;
                        helpers.each(me.legendItems, function (legendItem, i) {
                            var textWidth = ctx.measureText(legendItem.text).width;
                            var width = boxWidth + (fontSize / 2) + textWidth;
                            var x = cursor.x;
                            var y = cursor.y;

                            if (isHorizontal) {
                                if (x + width >= legendWidth) {
                                    y = cursor.y += itemHeight;
                                    cursor.line++;
                                    x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
                                }
                            } else if (y + itemHeight > me.bottom) {
                                x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                                y = cursor.y = me.top + labelOpts.padding;
                                cursor.line++;
                            }

                            drawLegendBox(x, y, legendItem);

                            hitboxes[i].left = x;
                            hitboxes[i].top = y;

                            // Fill the actual label
                            fillText(x, y, legendItem, textWidth);

                            if (isHorizontal) {
                                cursor.x += width + (labelOpts.padding);
                            } else {
                                cursor.y += itemHeight;
                            }

                        });
                    }
                },

                /**
                 * Handle an event
                 * @private
                 * @param {IEvent} event - The event to handle
                 * @return {Boolean} true if a change occured
                 */
                handleEvent: function (e) {
                    var me = this;
                    var opts = me.options;
                    var type = e.type === 'mouseup' ? 'click' : e.type;
                    var changed = false;

                    if (type === 'mousemove') {
                        if (!opts.onHover) {
                            return;
                        }
                    } else if (type === 'click') {
                        if (!opts.onClick) {
                            return;
                        }
                    } else {
                        return;
                    }

                    // Chart event already has relative position in it
                    var x = e.x;
                    var y = e.y;

                    if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
                        // See if we are touching one of the dataset boxes
                        var lh = me.legendHitBoxes;
                        for (var i = 0; i < lh.length; ++i) {
                            var hitBox = lh[i];

                            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                                // Touching an element
                                if (type === 'click') {
                                    // use e.native for backwards compatibility
                                    opts.onClick.call(me, e.native, me.legendItems[i]);
                                    changed = true;
                                    break;
                                } else if (type === 'mousemove') {
                                    // use e.native for backwards compatibility
                                    opts.onHover.call(me, e.native, me.legendItems[i]);
                                    changed = true;
                                    break;
                                }
                            }
                        }
                    }

                    return changed;
                }
            });

            function createNewLegendAndAttach(chart, legendOpts) {
                var legend = new Legend({
                    ctx: chart.ctx,
                    options: legendOpts,
                    chart: chart
                });

                layouts.configure(chart, legend, legendOpts);
                layouts.addBox(chart, legend);
                chart.legend = legend;
            }

            module.exports = {
                id: 'legend',

                /**
                 * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
                 * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
                 * the plugin, which one will be re-exposed in the chart.js file.
                 * https://github.com/chartjs/Chart.js/pull/2640
                 * @private
                 */
                _element: Legend,

                beforeInit: function (chart) {
                    var legendOpts = chart.options.legend;

                    if (legendOpts) {
                        createNewLegendAndAttach(chart, legendOpts);
                    }
                },

                beforeUpdate: function (chart) {
                    var legendOpts = chart.options.legend;
                    var legend = chart.legend;

                    if (legendOpts) {
                        helpers.mergeIf(legendOpts, defaults.global.legend);

                        if (legend) {
                            layouts.configure(chart, legend, legendOpts);
                            legend.options = legendOpts;
                        } else {
                            createNewLegendAndAttach(chart, legendOpts);
                        }
                    } else if (legend) {
                        layouts.removeBox(chart, legend);
                        delete chart.legend;
                    }
                },

                afterEvent: function (chart, e) {
                    var legend = chart.legend;
                    if (legend) {
                        legend.handleEvent(e);
                    }
                }
            };

        }, {"26": 26, "27": 27, "31": 31, "46": 46}],
        53: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var Element = require(27);
            var helpers = require(46);
            var layouts = require(31);

            var noop = helpers.noop;

            defaults._set('global', {
                title: {
                    display: false,
                    fontStyle: 'bold',
                    fullWidth: true,
                    lineHeight: 1.2,
                    padding: 10,
                    position: 'top',
                    text: '',
                    weight: 2000         // by default greater than legend (1000) to be above
                }
            });

            /**
             * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
             */
            var Title = Element.extend({
                initialize: function (config) {
                    var me = this;
                    helpers.extend(me, config);

                    // Contains hit boxes for each dataset (in dataset order)
                    me.legendHitBoxes = [];
                },

                // These methods are ordered by lifecycle. Utilities then follow.

                beforeUpdate: noop,
                update: function (maxWidth, maxHeight, margins) {
                    var me = this;

                    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
                    me.beforeUpdate();

                    // Absorb the master measurements
                    me.maxWidth = maxWidth;
                    me.maxHeight = maxHeight;
                    me.margins = margins;

                    // Dimensions
                    me.beforeSetDimensions();
                    me.setDimensions();
                    me.afterSetDimensions();
                    // Labels
                    me.beforeBuildLabels();
                    me.buildLabels();
                    me.afterBuildLabels();

                    // Fit
                    me.beforeFit();
                    me.fit();
                    me.afterFit();
                    //
                    me.afterUpdate();

                    return me.minSize;

                },
                afterUpdate: noop,

                //

                beforeSetDimensions: noop,
                setDimensions: function () {
                    var me = this;
                    // Set the unconstrained dimension before label rotation
                    if (me.isHorizontal()) {
                        // Reset position before calculating rotation
                        me.width = me.maxWidth;
                        me.left = 0;
                        me.right = me.width;
                    } else {
                        me.height = me.maxHeight;

                        // Reset position before calculating rotation
                        me.top = 0;
                        me.bottom = me.height;
                    }

                    // Reset padding
                    me.paddingLeft = 0;
                    me.paddingTop = 0;
                    me.paddingRight = 0;
                    me.paddingBottom = 0;

                    // Reset minSize
                    me.minSize = {
                        width: 0,
                        height: 0
                    };
                },
                afterSetDimensions: noop,

                //

                beforeBuildLabels: noop,
                buildLabels: noop,
                afterBuildLabels: noop,

                //

                beforeFit: noop,
                fit: function () {
                    var me = this;
                    var valueOrDefault = helpers.valueOrDefault;
                    var opts = me.options;
                    var display = opts.display;
                    var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
                    var minSize = me.minSize;
                    var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
                    var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
                    var textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;

                    if (me.isHorizontal()) {
                        minSize.width = me.maxWidth; // fill all the width
                        minSize.height = textSize;
                    } else {
                        minSize.width = textSize;
                        minSize.height = me.maxHeight; // fill all the height
                    }

                    me.width = minSize.width;
                    me.height = minSize.height;

                },
                afterFit: noop,

                // Shared Methods
                isHorizontal: function () {
                    var pos = this.options.position;
                    return pos === 'top' || pos === 'bottom';
                },

                // Actually draw the title block on the canvas
                draw: function () {
                    var me = this;
                    var ctx = me.ctx;
                    var valueOrDefault = helpers.valueOrDefault;
                    var opts = me.options;
                    var globalDefaults = defaults.global;

                    if (opts.display) {
                        var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
                        var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
                        var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
                        var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
                        var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
                        var offset = lineHeight / 2 + opts.padding;
                        var rotation = 0;
                        var top = me.top;
                        var left = me.left;
                        var bottom = me.bottom;
                        var right = me.right;
                        var maxWidth, titleX, titleY;

                        ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
                        ctx.font = titleFont;

                        // Horizontal
                        if (me.isHorizontal()) {
                            titleX = left + ((right - left) / 2); // midpoint of the width
                            titleY = top + offset;
                            maxWidth = right - left;
                        } else {
                            titleX = opts.position === 'left' ? left + offset : right - offset;
                            titleY = top + ((bottom - top) / 2);
                            maxWidth = bottom - top;
                            rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
                        }

                        ctx.save();
                        ctx.translate(titleX, titleY);
                        ctx.rotate(rotation);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        var text = opts.text;
                        if (helpers.isArray(text)) {
                            var y = 0;
                            for (var i = 0; i < text.length; ++i) {
                                ctx.fillText(text[i], 0, y, maxWidth);
                                y += lineHeight;
                            }
                        } else {
                            ctx.fillText(text, 0, 0, maxWidth);
                        }

                        ctx.restore();
                    }
                }
            });

            function createNewTitleBlockAndAttach(chart, titleOpts) {
                var title = new Title({
                    ctx: chart.ctx,
                    options: titleOpts,
                    chart: chart
                });

                layouts.configure(chart, title, titleOpts);
                layouts.addBox(chart, title);
                chart.titleBlock = title;
            }

            module.exports = {
                id: 'title',

                /**
                 * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
                 * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
                 * the plugin, which one will be re-exposed in the chart.js file.
                 * https://github.com/chartjs/Chart.js/pull/2640
                 * @private
                 */
                _element: Title,

                beforeInit: function (chart) {
                    var titleOpts = chart.options.title;

                    if (titleOpts) {
                        createNewTitleBlockAndAttach(chart, titleOpts);
                    }
                },

                beforeUpdate: function (chart) {
                    var titleOpts = chart.options.title;
                    var titleBlock = chart.titleBlock;

                    if (titleOpts) {
                        helpers.mergeIf(titleOpts, defaults.global.title);

                        if (titleBlock) {
                            layouts.configure(chart, titleBlock, titleOpts);
                            titleBlock.options = titleOpts;
                        } else {
                            createNewTitleBlockAndAttach(chart, titleOpts);
                        }
                    } else if (titleBlock) {
                        layouts.removeBox(chart, titleBlock);
                        delete chart.titleBlock;
                    }
                }
            };

        }, {"26": 26, "27": 27, "31": 31, "46": 46}],
        54: [function (require, module, exports) {
            'use strict';

            var Scale = require(33);
            var scaleService = require(34);

            module.exports = function () {

                // Default config for a category scale
                var defaultConfig = {
                    position: 'bottom'
                };

                var DatasetScale = Scale.extend({
                    /**
                     * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
                     * else fall back to data.labels
                     * @private
                     */
                    getLabels: function () {
                        var data = this.chart.data;
                        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
                    },

                    determineDataLimits: function () {
                        var me = this;
                        var labels = me.getLabels();
                        me.minIndex = 0;
                        me.maxIndex = labels.length - 1;
                        var findIndex;

                        if (me.options.ticks.min !== undefined) {
                            // user specified min value
                            findIndex = labels.indexOf(me.options.ticks.min);
                            me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
                        }

                        if (me.options.ticks.max !== undefined) {
                            // user specified max value
                            findIndex = labels.indexOf(me.options.ticks.max);
                            me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
                        }

                        me.min = labels[me.minIndex];
                        me.max = labels[me.maxIndex];
                    },

                    buildTicks: function () {
                        var me = this;
                        var labels = me.getLabels();
                        // If we are viewing some subset of labels, slice the original array
                        me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
                    },

                    getLabelForIndex: function (index, datasetIndex) {
                        var me = this;
                        var data = me.chart.data;
                        var isHorizontal = me.isHorizontal();

                        if (data.yLabels && !isHorizontal) {
                            return me.getRightValue(data.datasets[datasetIndex].data[index]);
                        }
                        return me.ticks[index - me.minIndex];
                    },

                    // Used to get data value locations.  Value can either be an index or a numerical value
                    getPixelForValue: function (value, index) {
                        var me = this;
                        var offset = me.options.offset;
                        // 1 is added because we need the length but we have the indexes
                        var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);

                        // If value is a data object, then index is the index in the data array,
                        // not the index of the scale. We need to change that.
                        var valueCategory;
                        if (value !== undefined && value !== null) {
                            valueCategory = me.isHorizontal() ? value.x : value.y;
                        }
                        if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
                            var labels = me.getLabels();
                            value = valueCategory || value;
                            var idx = labels.indexOf(value);
                            index = idx !== -1 ? idx : index;
                        }

                        if (me.isHorizontal()) {
                            var valueWidth = me.width / offsetAmt;
                            var widthOffset = (valueWidth * (index - me.minIndex));

                            if (offset) {
                                widthOffset += (valueWidth / 2);
                            }

                            return me.left + Math.round(widthOffset);
                        }
                        var valueHeight = me.height / offsetAmt;
                        var heightOffset = (valueHeight * (index - me.minIndex));

                        if (offset) {
                            heightOffset += (valueHeight / 2);
                        }

                        return me.top + Math.round(heightOffset);
                    },
                    getPixelForTick: function (index) {
                        return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
                    },
                    getValueForPixel: function (pixel) {
                        var me = this;
                        var offset = me.options.offset;
                        var value;
                        var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
                        var horz = me.isHorizontal();
                        var valueDimension = (horz ? me.width : me.height) / offsetAmt;

                        pixel -= horz ? me.left : me.top;

                        if (offset) {
                            pixel -= (valueDimension / 2);
                        }

                        if (pixel <= 0) {
                            value = 0;
                        } else {
                            value = Math.round(pixel / valueDimension);
                        }

                        return value + me.minIndex;
                    },
                    getBasePixel: function () {
                        return this.bottom;
                    }
                });

                scaleService.registerScaleType('category', DatasetScale, defaultConfig);
            };

        }, {"33": 33, "34": 34}],
        55: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var helpers = require(46);
            var scaleService = require(34);
            var Ticks = require(35);

            module.exports = function (Chart) {

                var defaultConfig = {
                    position: 'left',
                    ticks: {
                        callback: Ticks.formatters.linear
                    }
                };

                var LinearScale = Chart.LinearScaleBase.extend({

                    determineDataLimits: function () {
                        var me = this;
                        var opts = me.options;
                        var chart = me.chart;
                        var data = chart.data;
                        var datasets = data.datasets;
                        var isHorizontal = me.isHorizontal();
                        var DEFAULT_MIN = 0;
                        var DEFAULT_MAX = 1;

                        function IDMatches(meta) {
                            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
                        }

                        // First Calculate the range
                        me.min = null;
                        me.max = null;

                        var hasStacks = opts.stacked;
                        if (hasStacks === undefined) {
                            helpers.each(datasets, function (dataset, datasetIndex) {
                                if (hasStacks) {
                                    return;
                                }

                                var meta = chart.getDatasetMeta(datasetIndex);
                                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
                                    meta.stack !== undefined) {
                                    hasStacks = true;
                                }
                            });
                        }

                        if (opts.stacked || hasStacks) {
                            var valuesPerStack = {};

                            helpers.each(datasets, function (dataset, datasetIndex) {
                                var meta = chart.getDatasetMeta(datasetIndex);
                                var key = [
                                    meta.type,
                                    // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
                                    ((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
                                    meta.stack
                                ].join('.');

                                if (valuesPerStack[key] === undefined) {
                                    valuesPerStack[key] = {
                                        positiveValues: [],
                                        negativeValues: []
                                    };
                                }

                                // Store these per type
                                var positiveValues = valuesPerStack[key].positiveValues;
                                var negativeValues = valuesPerStack[key].negativeValues;

                                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                    helpers.each(dataset.data, function (rawValue, index) {
                                        var value = +me.getRightValue(rawValue);
                                        if (isNaN(value) || meta.data[index].hidden) {
                                            return;
                                        }

                                        positiveValues[index] = positiveValues[index] || 0;
                                        negativeValues[index] = negativeValues[index] || 0;

                                        if (opts.relativePoints) {
                                            positiveValues[index] = 100;
                                        } else if (value < 0) {
                                            negativeValues[index] += value;
                                        } else {
                                            positiveValues[index] += value;
                                        }
                                    });
                                }
                            });

                            helpers.each(valuesPerStack, function (valuesForType) {
                                var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
                                var minVal = helpers.min(values);
                                var maxVal = helpers.max(values);
                                me.min = me.min === null ? minVal : Math.min(me.min, minVal);
                                me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
                            });

                        } else {
                            helpers.each(datasets, function (dataset, datasetIndex) {
                                var meta = chart.getDatasetMeta(datasetIndex);
                                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                    helpers.each(dataset.data, function (rawValue, index) {
                                        var value = +me.getRightValue(rawValue);
                                        if (isNaN(value) || meta.data[index].hidden) {
                                            return;
                                        }

                                        if (me.min === null) {
                                            me.min = value;
                                        } else if (value < me.min) {
                                            me.min = value;
                                        }

                                        if (me.max === null) {
                                            me.max = value;
                                        } else if (value > me.max) {
                                            me.max = value;
                                        }
                                    });
                                }
                            });
                        }

                        me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
                        me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

                        // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
                        this.handleTickRangeOptions();
                    },
                    getTickLimit: function () {
                        var maxTicks;
                        var me = this;
                        var tickOpts = me.options.ticks;

                        if (me.isHorizontal()) {
                            maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
                        } else {
                            // The factor of 2 used to scale the font size has been experimentally determined.
                            var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
                            maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
                        }

                        return maxTicks;
                    },
                    // Called after the ticks are built. We need
                    handleDirectionalChanges: function () {
                        if (!this.isHorizontal()) {
                            // We are in a vertical orientation. The top value is the highest. So reverse the array
                            this.ticks.reverse();
                        }
                    },
                    getLabelForIndex: function (index, datasetIndex) {
                        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
                    },
                    // Utils
                    getPixelForValue: function (value) {
                        // This must be called after fit has been run so that
                        // this.left, this.top, this.right, and this.bottom have been defined
                        var me = this;
                        var start = me.start;

                        var rightValue = +me.getRightValue(value);
                        var pixel;
                        var range = me.end - start;

                        if (me.isHorizontal()) {
                            pixel = me.left + (me.width / range * (rightValue - start));
                        } else {
                            pixel = me.bottom - (me.height / range * (rightValue - start));
                        }
                        return pixel;
                    },
                    getValueForPixel: function (pixel) {
                        var me = this;
                        var isHorizontal = me.isHorizontal();
                        var innerDimension = isHorizontal ? me.width : me.height;
                        var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
                        return me.start + ((me.end - me.start) * offset);
                    },
                    getPixelForTick: function (index) {
                        return this.getPixelForValue(this.ticksAsNumbers[index]);
                    }
                });

                scaleService.registerScaleType('linear', LinearScale, defaultConfig);
            };

        }, {"26": 26, "34": 34, "35": 35, "46": 46}],
        56: [function (require, module, exports) {
            'use strict';

            var helpers = require(46);
            var Scale = require(33);

            /**
             * Generate a set of linear ticks
             * @param generationOptions the options used to generate the ticks
             * @param dataRange the range of the data
             * @returns {Array<Number>} array of tick values
             */
            function generateTicks(generationOptions, dataRange) {
                var ticks = [];
                // To get a "nice" value for the tick spacing, we will use the appropriately named
                // "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
                // for details.

                var factor;
                var precision;
                var spacing;

                if (generationOptions.stepSize && generationOptions.stepSize > 0) {
                    spacing = generationOptions.stepSize;
                } else {
                    var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
                    spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);

                    precision = generationOptions.precision;
                    if (precision !== undefined) {
                        // If the user specified a precision, round to that number of decimal places
                        factor = Math.pow(10, precision);
                        spacing = Math.ceil(spacing * factor) / factor;
                    }
                }
                var niceMin = Math.floor(dataRange.min / spacing) * spacing;
                var niceMax = Math.ceil(dataRange.max / spacing) * spacing;

                // If min, max and stepSize is set and they make an evenly spaced scale use it.
                if (!helpers.isNullOrUndef(generationOptions.min) && !helpers.isNullOrUndef(generationOptions.max) && generationOptions.stepSize) {
                    // If very close to our whole number, use it.
                    if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
                        niceMin = generationOptions.min;
                        niceMax = generationOptions.max;
                    }
                }

                var numSpaces = (niceMax - niceMin) / spacing;
                // If very close to our rounded value, use it.
                if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
                    numSpaces = Math.round(numSpaces);
                } else {
                    numSpaces = Math.ceil(numSpaces);
                }

                precision = 1;
                if (spacing < 1) {
                    precision = Math.pow(10, 1 - Math.floor(helpers.log10(spacing)));
                    niceMin = Math.round(niceMin * precision) / precision;
                    niceMax = Math.round(niceMax * precision) / precision;
                }
                ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
                for (var j = 1; j < numSpaces; ++j) {
                    ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);
                }
                ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

                return ticks;
            }

            module.exports = function (Chart) {

                var noop = helpers.noop;

                Chart.LinearScaleBase = Scale.extend({
                    getRightValue: function (value) {
                        if (typeof value === 'string') {
                            return +value;
                        }
                        return Scale.prototype.getRightValue.call(this, value);
                    },

                    handleTickRangeOptions: function () {
                        var me = this;
                        var opts = me.options;
                        var tickOpts = opts.ticks;

                        // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
                        // do nothing since that would make the chart weird. If the user really wants a weird chart
                        // axis, they can manually override it
                        if (tickOpts.beginAtZero) {
                            var minSign = helpers.sign(me.min);
                            var maxSign = helpers.sign(me.max);

                            if (minSign < 0 && maxSign < 0) {
                                // move the top up to 0
                                me.max = 0;
                            } else if (minSign > 0 && maxSign > 0) {
                                // move the bottom down to 0
                                me.min = 0;
                            }
                        }

                        var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
                        var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

                        if (tickOpts.min !== undefined) {
                            me.min = tickOpts.min;
                        } else if (tickOpts.suggestedMin !== undefined) {
                            if (me.min === null) {
                                me.min = tickOpts.suggestedMin;
                            } else {
                                me.min = Math.min(me.min, tickOpts.suggestedMin);
                            }
                        }

                        if (tickOpts.max !== undefined) {
                            me.max = tickOpts.max;
                        } else if (tickOpts.suggestedMax !== undefined) {
                            if (me.max === null) {
                                me.max = tickOpts.suggestedMax;
                            } else {
                                me.max = Math.max(me.max, tickOpts.suggestedMax);
                            }
                        }

                        if (setMin !== setMax) {
                            // We set the min or the max but not both.
                            // So ensure that our range is good
                            // Inverted or 0 length range can happen when
                            // ticks.min is set, and no datasets are visible
                            if (me.min >= me.max) {
                                if (setMin) {
                                    me.max = me.min + 1;
                                } else {
                                    me.min = me.max - 1;
                                }
                            }
                        }

                        if (me.min === me.max) {
                            me.max++;

                            if (!tickOpts.beginAtZero) {
                                me.min--;
                            }
                        }
                    },
                    getTickLimit: noop,
                    handleDirectionalChanges: noop,

                    buildTicks: function () {
                        var me = this;
                        var opts = me.options;
                        var tickOpts = opts.ticks;

                        // Figure out what the max number of ticks we can support it is based on the size of
                        // the axis area. For now, we say that the minimum tick spacing in pixels must be 50
                        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
                        // the graph. Make sure we always have at least 2 ticks
                        var maxTicks = me.getTickLimit();
                        maxTicks = Math.max(2, maxTicks);

                        var numericGeneratorOptions = {
                            maxTicks: maxTicks,
                            min: tickOpts.min,
                            max: tickOpts.max,
                            precision: tickOpts.precision,
                            stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
                        };
                        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);

                        me.handleDirectionalChanges();

                        // At this point, we need to update our max and min given the tick values since we have expanded the
                        // range of the scale
                        me.max = helpers.max(ticks);
                        me.min = helpers.min(ticks);

                        if (tickOpts.reverse) {
                            ticks.reverse();

                            me.start = me.max;
                            me.end = me.min;
                        } else {
                            me.start = me.min;
                            me.end = me.max;
                        }
                    },
                    convertTicksToLabels: function () {
                        var me = this;
                        me.ticksAsNumbers = me.ticks.slice();
                        me.zeroLineIndex = me.ticks.indexOf(0);

                        Scale.prototype.convertTicksToLabels.call(me);
                    }
                });
            };

        }, {"33": 33, "46": 46}],
        57: [function (require, module, exports) {
            'use strict';

            var helpers = require(46);
            var Scale = require(33);
            var scaleService = require(34);
            var Ticks = require(35);

            /**
             * Generate a set of logarithmic ticks
             * @param generationOptions the options used to generate the ticks
             * @param dataRange the range of the data
             * @returns {Array<Number>} array of tick values
             */
            function generateTicks(generationOptions, dataRange) {
                var ticks = [];
                var valueOrDefault = helpers.valueOrDefault;

                // Figure out what the max number of ticks we can support it is based on the size of
                // the axis area. For now, we say that the minimum tick spacing in pixels must be 50
                // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
                // the graph
                var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

                var endExp = Math.floor(helpers.log10(dataRange.max));
                var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
                var exp, significand;

                if (tickVal === 0) {
                    exp = Math.floor(helpers.log10(dataRange.minNotZero));
                    significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

                    ticks.push(tickVal);
                    tickVal = significand * Math.pow(10, exp);
                } else {
                    exp = Math.floor(helpers.log10(tickVal));
                    significand = Math.floor(tickVal / Math.pow(10, exp));
                }
                var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

                do {
                    ticks.push(tickVal);

                    ++significand;
                    if (significand === 10) {
                        significand = 1;
                        ++exp;
                        precision = exp >= 0 ? 1 : precision;
                    }

                    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
                } while (exp < endExp || (exp === endExp && significand < endSignificand));

                var lastTick = valueOrDefault(generationOptions.max, tickVal);
                ticks.push(lastTick);

                return ticks;
            }


            module.exports = function (Chart) {

                var defaultConfig = {
                    position: 'left',

                    // label settings
                    ticks: {
                        callback: Ticks.formatters.logarithmic
                    }
                };

                var LogarithmicScale = Scale.extend({
                    determineDataLimits: function () {
                        var me = this;
                        var opts = me.options;
                        var chart = me.chart;
                        var data = chart.data;
                        var datasets = data.datasets;
                        var isHorizontal = me.isHorizontal();

                        function IDMatches(meta) {
                            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
                        }

                        // Calculate Range
                        me.min = null;
                        me.max = null;
                        me.minNotZero = null;

                        var hasStacks = opts.stacked;
                        if (hasStacks === undefined) {
                            helpers.each(datasets, function (dataset, datasetIndex) {
                                if (hasStacks) {
                                    return;
                                }

                                var meta = chart.getDatasetMeta(datasetIndex);
                                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
                                    meta.stack !== undefined) {
                                    hasStacks = true;
                                }
                            });
                        }

                        if (opts.stacked || hasStacks) {
                            var valuesPerStack = {};

                            helpers.each(datasets, function (dataset, datasetIndex) {
                                var meta = chart.getDatasetMeta(datasetIndex);
                                var key = [
                                    meta.type,
                                    // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
                                    ((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
                                    meta.stack
                                ].join('.');

                                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                    if (valuesPerStack[key] === undefined) {
                                        valuesPerStack[key] = [];
                                    }

                                    helpers.each(dataset.data, function (rawValue, index) {
                                        var values = valuesPerStack[key];
                                        var value = +me.getRightValue(rawValue);
                                        // invalid, hidden and negative values are ignored
                                        if (isNaN(value) || meta.data[index].hidden || value < 0) {
                                            return;
                                        }
                                        values[index] = values[index] || 0;
                                        values[index] += value;
                                    });
                                }
                            });

                            helpers.each(valuesPerStack, function (valuesForType) {
                                if (valuesForType.length > 0) {
                                    var minVal = helpers.min(valuesForType);
                                    var maxVal = helpers.max(valuesForType);
                                    me.min = me.min === null ? minVal : Math.min(me.min, minVal);
                                    me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
                                }
                            });

                        } else {
                            helpers.each(datasets, function (dataset, datasetIndex) {
                                var meta = chart.getDatasetMeta(datasetIndex);
                                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                    helpers.each(dataset.data, function (rawValue, index) {
                                        var value = +me.getRightValue(rawValue);
                                        // invalid, hidden and negative values are ignored
                                        if (isNaN(value) || meta.data[index].hidden || value < 0) {
                                            return;
                                        }

                                        if (me.min === null) {
                                            me.min = value;
                                        } else if (value < me.min) {
                                            me.min = value;
                                        }

                                        if (me.max === null) {
                                            me.max = value;
                                        } else if (value > me.max) {
                                            me.max = value;
                                        }

                                        if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                                            me.minNotZero = value;
                                        }
                                    });
                                }
                            });
                        }

                        // Common base implementation to handle ticks.min, ticks.max
                        this.handleTickRangeOptions();
                    },
                    handleTickRangeOptions: function () {
                        var me = this;
                        var opts = me.options;
                        var tickOpts = opts.ticks;
                        var valueOrDefault = helpers.valueOrDefault;
                        var DEFAULT_MIN = 1;
                        var DEFAULT_MAX = 10;

                        me.min = valueOrDefault(tickOpts.min, me.min);
                        me.max = valueOrDefault(tickOpts.max, me.max);

                        if (me.min === me.max) {
                            if (me.min !== 0 && me.min !== null) {
                                me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
                                me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
                            } else {
                                me.min = DEFAULT_MIN;
                                me.max = DEFAULT_MAX;
                            }
                        }
                        if (me.min === null) {
                            me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);
                        }
                        if (me.max === null) {
                            me.max = me.min !== 0
                                ? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)
                                : DEFAULT_MAX;
                        }
                        if (me.minNotZero === null) {
                            if (me.min > 0) {
                                me.minNotZero = me.min;
                            } else if (me.max < 1) {
                                me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));
                            } else {
                                me.minNotZero = DEFAULT_MIN;
                            }
                        }
                    },
                    buildTicks: function () {
                        var me = this;
                        var opts = me.options;
                        var tickOpts = opts.ticks;
                        var reverse = !me.isHorizontal();

                        var generationOptions = {
                            min: tickOpts.min,
                            max: tickOpts.max
                        };
                        var ticks = me.ticks = generateTicks(generationOptions, me);

                        // At this point, we need to update our max and min given the tick values since we have expanded the
                        // range of the scale
                        me.max = helpers.max(ticks);
                        me.min = helpers.min(ticks);

                        if (tickOpts.reverse) {
                            reverse = !reverse;
                            me.start = me.max;
                            me.end = me.min;
                        } else {
                            me.start = me.min;
                            me.end = me.max;
                        }
                        if (reverse) {
                            ticks.reverse();
                        }
                    },
                    convertTicksToLabels: function () {
                        this.tickValues = this.ticks.slice();

                        Scale.prototype.convertTicksToLabels.call(this);
                    },
                    // Get the correct tooltip label
                    getLabelForIndex: function (index, datasetIndex) {
                        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
                    },
                    getPixelForTick: function (index) {
                        return this.getPixelForValue(this.tickValues[index]);
                    },
                    /**
                     * Returns the value of the first tick.
                     * @param {Number} value - The minimum not zero value.
                     * @return {Number} The first tick value.
                     * @private
                     */
                    _getFirstTickValue: function (value) {
                        var exp = Math.floor(helpers.log10(value));
                        var significand = Math.floor(value / Math.pow(10, exp));

                        return significand * Math.pow(10, exp);
                    },
                    getPixelForValue: function (value) {
                        var me = this;
                        var reverse = me.options.ticks.reverse;
                        var log10 = helpers.log10;
                        var firstTickValue = me._getFirstTickValue(me.minNotZero);
                        var offset = 0;
                        var innerDimension, pixel, start, end, sign;

                        value = +me.getRightValue(value);
                        if (reverse) {
                            start = me.end;
                            end = me.start;
                            sign = -1;
                        } else {
                            start = me.start;
                            end = me.end;
                            sign = 1;
                        }
                        if (me.isHorizontal()) {
                            innerDimension = me.width;
                            pixel = reverse ? me.right : me.left;
                        } else {
                            innerDimension = me.height;
                            sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)
                            pixel = reverse ? me.top : me.bottom;
                        }
                        if (value !== start) {
                            if (start === 0) { // include zero tick
                                offset = helpers.getValueOrDefault(
                                    me.options.ticks.fontSize,
                                    Chart.defaults.global.defaultFontSize
                                );
                                innerDimension -= offset;
                                start = firstTickValue;
                            }
                            if (value !== 0) {
                                offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
                            }
                            pixel += sign * offset;
                        }
                        return pixel;
                    },
                    getValueForPixel: function (pixel) {
                        var me = this;
                        var reverse = me.options.ticks.reverse;
                        var log10 = helpers.log10;
                        var firstTickValue = me._getFirstTickValue(me.minNotZero);
                        var innerDimension, start, end, value;

                        if (reverse) {
                            start = me.end;
                            end = me.start;
                        } else {
                            start = me.start;
                            end = me.end;
                        }
                        if (me.isHorizontal()) {
                            innerDimension = me.width;
                            value = reverse ? me.right - pixel : pixel - me.left;
                        } else {
                            innerDimension = me.height;
                            value = reverse ? pixel - me.top : me.bottom - pixel;
                        }
                        if (value !== start) {
                            if (start === 0) { // include zero tick
                                var offset = helpers.getValueOrDefault(
                                    me.options.ticks.fontSize,
                                    Chart.defaults.global.defaultFontSize
                                );
                                value -= offset;
                                innerDimension -= offset;
                                start = firstTickValue;
                            }
                            value *= log10(end) - log10(start);
                            value /= innerDimension;
                            value = Math.pow(10, log10(start) + value);
                        }
                        return value;
                    }
                });

                scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
            };

        }, {"33": 33, "34": 34, "35": 35, "46": 46}],
        58: [function (require, module, exports) {
            'use strict';

            var defaults = require(26);
            var helpers = require(46);
            var scaleService = require(34);
            var Ticks = require(35);

            module.exports = function (Chart) {

                var globalDefaults = defaults.global;

                var defaultConfig = {
                    display: true,

                    // Boolean - Whether to animate scaling the chart from the centre
                    animate: true,
                    position: 'chartArea',

                    angleLines: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.1)',
                        lineWidth: 1
                    },

                    gridLines: {
                        circular: false
                    },

                    // label settings
                    ticks: {
                        // Boolean - Show a backdrop to the scale label
                        showLabelBackdrop: true,

                        // String - The colour of the label backdrop
                        backdropColor: 'rgba(255,255,255,0.75)',

                        // Number - The backdrop padding above & below the label in pixels
                        backdropPaddingY: 2,

                        // Number - The backdrop padding to the side of the label in pixels
                        backdropPaddingX: 2,

                        callback: Ticks.formatters.linear
                    },

                    pointLabels: {
                        // Boolean - if true, show point labels
                        display: true,

                        // Number - Point label font size in pixels
                        fontSize: 10,

                        // Function - Used to convert point labels
                        callback: function (label) {
                            return label;
                        }
                    }
                };

                function getValueCount(scale) {
                    var opts = scale.options;
                    return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
                }

                function getPointLabelFontOptions(scale) {
                    var pointLabelOptions = scale.options.pointLabels;
                    var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
                    var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
                    var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
                    var font = helpers.fontString(fontSize, fontStyle, fontFamily);

                    return {
                        size: fontSize,
                        style: fontStyle,
                        family: fontFamily,
                        font: font
                    };
                }

                function measureLabelSize(ctx, fontSize, label) {
                    if (helpers.isArray(label)) {
                        return {
                            w: helpers.longestText(ctx, ctx.font, label),
                            h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
                        };
                    }

                    return {
                        w: ctx.measureText(label).width,
                        h: fontSize
                    };
                }

                function determineLimits(angle, pos, size, min, max) {
                    if (angle === min || angle === max) {
                        return {
                            start: pos - (size / 2),
                            end: pos + (size / 2)
                        };
                    } else if (angle < min || angle > max) {
                        return {
                            start: pos - size - 5,
                            end: pos
                        };
                    }

                    return {
                        start: pos,
                        end: pos + size + 5
                    };
                }

                /**
                 * Helper function to fit a radial linear scale with point labels
                 */
                function fitWithPointLabels(scale) {
                    /*
		 * Right, this is really confusing and there is a lot of maths going on here
		 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
		 *
		 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
		 *
		 * Solution:
		 *
		 * We assume the radius of the polygon is half the size of the canvas at first
		 * at each index we check if the text overlaps.
		 *
		 * Where it does, we store that angle and that index.
		 *
		 * After finding the largest index and angle we calculate how much we need to remove
		 * from the shape radius to move the point inwards by that x.
		 *
		 * We average the left and right distances to get the maximum shape radius that can fit in the box
		 * along with labels.
		 *
		 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
		 * on each side, removing that from the size, halving it and adding the left x protrusion width.
		 *
		 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
		 * and position it in the most space efficient manner
		 *
		 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
		 */

                    var plFont = getPointLabelFontOptions(scale);

                    // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
                    // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
                    var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
                    var furthestLimits = {
                        r: scale.width,
                        l: 0,
                        t: scale.height,
                        b: 0
                    };
                    var furthestAngles = {};
                    var i, textSize, pointPosition;

                    scale.ctx.font = plFont.font;
                    scale._pointLabelSizes = [];

                    var valueCount = getValueCount(scale);
                    for (i = 0; i < valueCount; i++) {
                        pointPosition = scale.getPointPosition(i, largestPossibleRadius);
                        textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
                        scale._pointLabelSizes[i] = textSize;

                        // Add quarter circle to make degree 0 mean top of circle
                        var angleRadians = scale.getIndexAngle(i);
                        var angle = helpers.toDegrees(angleRadians) % 360;
                        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
                        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

                        if (hLimits.start < furthestLimits.l) {
                            furthestLimits.l = hLimits.start;
                            furthestAngles.l = angleRadians;
                        }

                        if (hLimits.end > furthestLimits.r) {
                            furthestLimits.r = hLimits.end;
                            furthestAngles.r = angleRadians;
                        }

                        if (vLimits.start < furthestLimits.t) {
                            furthestLimits.t = vLimits.start;
                            furthestAngles.t = angleRadians;
                        }

                        if (vLimits.end > furthestLimits.b) {
                            furthestLimits.b = vLimits.end;
                            furthestAngles.b = angleRadians;
                        }
                    }

                    scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
                }

                /**
                 * Helper function to fit a radial linear scale with no point labels
                 */
                function fit(scale) {
                    var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
                    scale.drawingArea = Math.round(largestPossibleRadius);
                    scale.setCenterPoint(0, 0, 0, 0);
                }

                function getTextAlignForAngle(angle) {
                    if (angle === 0 || angle === 180) {
                        return 'center';
                    } else if (angle < 180) {
                        return 'left';
                    }

                    return 'right';
                }

                function fillText(ctx, text, position, fontSize) {
                    if (helpers.isArray(text)) {
                        var y = position.y;
                        var spacing = 1.5 * fontSize;

                        for (var i = 0; i < text.length; ++i) {
                            ctx.fillText(text[i], position.x, y);
                            y += spacing;
                        }
                    } else {
                        ctx.fillText(text, position.x, position.y);
                    }
                }

                function adjustPointPositionForLabelHeight(angle, textSize, position) {
                    if (angle === 90 || angle === 270) {
                        position.y -= (textSize.h / 2);
                    } else if (angle > 270 || angle < 90) {
                        position.y -= textSize.h;
                    }
                }

                function drawPointLabels(scale) {
                    var ctx = scale.ctx;
                    var opts = scale.options;
                    var angleLineOpts = opts.angleLines;
                    var pointLabelOpts = opts.pointLabels;

                    ctx.lineWidth = angleLineOpts.lineWidth;
                    ctx.strokeStyle = angleLineOpts.color;

                    var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

                    // Point Label Font
                    var plFont = getPointLabelFontOptions(scale);

                    ctx.textBaseline = 'top';

                    for (var i = getValueCount(scale) - 1; i >= 0; i--) {
                        if (angleLineOpts.display) {
                            var outerPosition = scale.getPointPosition(i, outerDistance);
                            ctx.beginPath();
                            ctx.moveTo(scale.xCenter, scale.yCenter);
                            ctx.lineTo(outerPosition.x, outerPosition.y);
                            ctx.stroke();
                            ctx.closePath();
                        }

                        if (pointLabelOpts.display) {
                            // Extra 3px out for some label spacing
                            var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);

                            // Keep this in loop since we may support array properties here
                            var pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);
                            ctx.font = plFont.font;
                            ctx.fillStyle = pointLabelFontColor;

                            var angleRadians = scale.getIndexAngle(i);
                            var angle = helpers.toDegrees(angleRadians);
                            ctx.textAlign = getTextAlignForAngle(angle);
                            adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
                            fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
                        }
                    }
                }

                function drawRadiusLine(scale, gridLineOpts, radius, index) {
                    var ctx = scale.ctx;
                    ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
                    ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

                    if (scale.options.gridLines.circular) {
                        // Draw circular arcs between the points
                        ctx.beginPath();
                        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
                        ctx.closePath();
                        ctx.stroke();
                    } else {
                        // Draw straight lines connecting each index
                        var valueCount = getValueCount(scale);

                        if (valueCount === 0) {
                            return;
                        }

                        ctx.beginPath();
                        var pointPosition = scale.getPointPosition(0, radius);
                        ctx.moveTo(pointPosition.x, pointPosition.y);

                        for (var i = 1; i < valueCount; i++) {
                            pointPosition = scale.getPointPosition(i, radius);
                            ctx.lineTo(pointPosition.x, pointPosition.y);
                        }

                        ctx.closePath();
                        ctx.stroke();
                    }
                }

                function numberOrZero(param) {
                    return helpers.isNumber(param) ? param : 0;
                }

                var LinearRadialScale = Chart.LinearScaleBase.extend({
                    setDimensions: function () {
                        var me = this;
                        var opts = me.options;
                        var tickOpts = opts.ticks;
                        // Set the unconstrained dimension before label rotation
                        me.width = me.maxWidth;
                        me.height = me.maxHeight;
                        me.xCenter = Math.round(me.width / 2);
                        me.yCenter = Math.round(me.height / 2);

                        var minSize = helpers.min([me.height, me.width]);
                        var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
                        me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
                    },
                    determineDataLimits: function () {
                        var me = this;
                        var chart = me.chart;
                        var min = Number.POSITIVE_INFINITY;
                        var max = Number.NEGATIVE_INFINITY;

                        helpers.each(chart.data.datasets, function (dataset, datasetIndex) {
                            if (chart.isDatasetVisible(datasetIndex)) {
                                var meta = chart.getDatasetMeta(datasetIndex);

                                helpers.each(dataset.data, function (rawValue, index) {
                                    var value = +me.getRightValue(rawValue);
                                    if (isNaN(value) || meta.data[index].hidden) {
                                        return;
                                    }

                                    min = Math.min(value, min);
                                    max = Math.max(value, max);
                                });
                            }
                        });

                        me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
                        me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);

                        // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
                        me.handleTickRangeOptions();
                    },
                    getTickLimit: function () {
                        var tickOpts = this.options.ticks;
                        var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
                        return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
                    },
                    convertTicksToLabels: function () {
                        var me = this;

                        Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

                        // Point labels
                        me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
                    },
                    getLabelForIndex: function (index, datasetIndex) {
                        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
                    },
                    fit: function () {
                        if (this.options.pointLabels.display) {
                            fitWithPointLabels(this);
                        } else {
                            fit(this);
                        }
                    },
                    /**
                     * Set radius reductions and determine new radius and center point
                     * @private
                     */
                    setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
                        var me = this;
                        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
                        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
                        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
                        var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

                        radiusReductionLeft = numberOrZero(radiusReductionLeft);
                        radiusReductionRight = numberOrZero(radiusReductionRight);
                        radiusReductionTop = numberOrZero(radiusReductionTop);
                        radiusReductionBottom = numberOrZero(radiusReductionBottom);

                        me.drawingArea = Math.min(
                            Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
                            Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
                        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
                    },
                    setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
                        var me = this;
                        var maxRight = me.width - rightMovement - me.drawingArea;
                        var maxLeft = leftMovement + me.drawingArea;
                        var maxTop = topMovement + me.drawingArea;
                        var maxBottom = me.height - bottomMovement - me.drawingArea;

                        me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
                        me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
                    },

                    getIndexAngle: function (index) {
                        var angleMultiplier = (Math.PI * 2) / getValueCount(this);
                        var startAngle = this.chart.options && this.chart.options.startAngle ?
                            this.chart.options.startAngle :
                            0;

                        var startAngleRadians = startAngle * Math.PI * 2 / 360;

                        // Start from the top instead of right, so remove a quarter of the circle
                        return index * angleMultiplier + startAngleRadians;
                    },
                    getDistanceFromCenterForValue: function (value) {
                        var me = this;

                        if (value === null) {
                            return 0; // null always in center
                        }

                        // Take into account half font size + the yPadding of the top value
                        var scalingFactor = me.drawingArea / (me.max - me.min);
                        if (me.options.ticks.reverse) {
                            return (me.max - value) * scalingFactor;
                        }
                        return (value - me.min) * scalingFactor;
                    },
                    getPointPosition: function (index, distanceFromCenter) {
                        var me = this;
                        var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
                        return {
                            x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
                            y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
                        };
                    },
                    getPointPositionForValue: function (index, value) {
                        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
                    },

                    getBasePosition: function () {
                        var me = this;
                        var min = me.min;
                        var max = me.max;

                        return me.getPointPositionForValue(0,
                            me.beginAtZero ? 0 :
                                min < 0 && max < 0 ? max :
                                    min > 0 && max > 0 ? min :
                                        0);
                    },

                    draw: function () {
                        var me = this;
                        var opts = me.options;
                        var gridLineOpts = opts.gridLines;
                        var tickOpts = opts.ticks;
                        var valueOrDefault = helpers.valueOrDefault;

                        if (opts.display) {
                            var ctx = me.ctx;
                            var startAngle = this.getIndexAngle(0);

                            // Tick Font
                            var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
                            var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
                            var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
                            var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

                            helpers.each(me.ticks, function (label, index) {
                                // Don't draw a centre value (if it is minimum)
                                if (index > 0 || tickOpts.reverse) {
                                    var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

                                    // Draw circular lines around the scale
                                    if (gridLineOpts.display && index !== 0) {
                                        drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
                                    }

                                    if (tickOpts.display) {
                                        var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
                                        ctx.font = tickLabelFont;

                                        ctx.save();
                                        ctx.translate(me.xCenter, me.yCenter);
                                        ctx.rotate(startAngle);

                                        if (tickOpts.showLabelBackdrop) {
                                            var labelWidth = ctx.measureText(label).width;
                                            ctx.fillStyle = tickOpts.backdropColor;
                                            ctx.fillRect(
                                                -labelWidth / 2 - tickOpts.backdropPaddingX,
                                                -yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
                                                labelWidth + tickOpts.backdropPaddingX * 2,
                                                tickFontSize + tickOpts.backdropPaddingY * 2
                                            );
                                        }

                                        ctx.textAlign = 'center';
                                        ctx.textBaseline = 'middle';
                                        ctx.fillStyle = tickFontColor;
                                        ctx.fillText(label, 0, -yCenterOffset);
                                        ctx.restore();
                                    }
                                }
                            });

                            if (opts.angleLines.display || opts.pointLabels.display) {
                                drawPointLabels(me);
                            }
                        }
                    }
                });

                scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
            };

        }, {"26": 26, "34": 34, "35": 35, "46": 46}],
        59: [function (require, module, exports) {
            /* global window: false */
            'use strict';

            var moment = require(6);
            moment = typeof moment === 'function' ? moment : window.moment;

            var defaults = require(26);
            var helpers = require(46);
            var Scale = require(33);
            var scaleService = require(34);

// Integer constants are from the ES6 spec.
            var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
            var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

            var INTERVALS = {
                millisecond: {
                    common: true,
                    size: 1,
                    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
                },
                second: {
                    common: true,
                    size: 1000,
                    steps: [1, 2, 5, 10, 15, 30]
                },
                minute: {
                    common: true,
                    size: 60000,
                    steps: [1, 2, 5, 10, 15, 30]
                },
                hour: {
                    common: true,
                    size: 3600000,
                    steps: [1, 2, 3, 6, 12]
                },
                day: {
                    common: true,
                    size: 86400000,
                    steps: [1, 2, 5]
                },
                week: {
                    common: false,
                    size: 604800000,
                    steps: [1, 2, 3, 4]
                },
                month: {
                    common: true,
                    size: 2.628e9,
                    steps: [1, 2, 3]
                },
                quarter: {
                    common: false,
                    size: 7.884e9,
                    steps: [1, 2, 3, 4]
                },
                year: {
                    common: true,
                    size: 3.154e10
                }
            };

            var UNITS = Object.keys(INTERVALS);

            function sorter(a, b) {
                return a - b;
            }

            function arrayUnique(items) {
                var hash = {};
                var out = [];
                var i, ilen, item;

                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    item = items[i];
                    if (!hash[item]) {
                        hash[item] = true;
                        out.push(item);
                    }
                }

                return out;
            }

            /**
             * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
             * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
             * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
             * extremity (left + width or top + height). Note that it would be more optimized to directly
             * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
             * to create the lookup table. The table ALWAYS contains at least two items: min and max.
             *
             * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
             * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
             * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
             * If 'series', timestamps will be positioned at the same distance from each other. In this
             * case, only timestamps that break the time linearity are registered, meaning that in the
             * best case, all timestamps are linear, the table contains only min and max.
             */
            function buildLookupTable(timestamps, min, max, distribution) {
                if (distribution === 'linear' || !timestamps.length) {
                    return [
                        {time: min, pos: 0},
                        {time: max, pos: 1}
                    ];
                }

                var table = [];
                var items = [min];
                var i, ilen, prev, curr, next;

                for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                    curr = timestamps[i];
                    if (curr > min && curr < max) {
                        items.push(curr);
                    }
                }

                items.push(max);

                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    next = items[i + 1];
                    prev = items[i - 1];
                    curr = items[i];

                    // only add points that breaks the scale linearity
                    if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
                        table.push({time: curr, pos: i / (ilen - 1)});
                    }
                }

                return table;
            }

// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
            function lookup(table, key, value) {
                var lo = 0;
                var hi = table.length - 1;
                var mid, i0, i1;

                while (lo >= 0 && lo <= hi) {
                    mid = (lo + hi) >> 1;
                    i0 = table[mid - 1] || null;
                    i1 = table[mid];

                    if (!i0) {
                        // given value is outside table (before first item)
                        return {lo: null, hi: i1};
                    } else if (i1[key] < value) {
                        lo = mid + 1;
                    } else if (i0[key] > value) {
                        hi = mid - 1;
                    } else {
                        return {lo: i0, hi: i1};
                    }
                }

                // given value is outside table (after last item)
                return {lo: i1, hi: null};
            }

            /**
             * Linearly interpolates the given source `value` using the table items `skey` values and
             * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
             * returns the position for a timestamp equal to 42. If value is out of bounds, values at
             * index [0, 1] or [n - 1, n] are used for the interpolation.
             */
            function interpolate(table, skey, sval, tkey) {
                var range = lookup(table, skey, sval);

                // Note: the lookup table ALWAYS contains at least 2 items (min and max)
                var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
                var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

                var span = next[skey] - prev[skey];
                var ratio = span ? (sval - prev[skey]) / span : 0;
                var offset = (next[tkey] - prev[tkey]) * ratio;

                return prev[tkey] + offset;
            }

            /**
             * Convert the given value to a moment object using the given time options.
             * @see http://momentjs.com/docs/#/parsing/
             */
            function momentify(value, options) {
                var parser = options.parser;
                var format = options.parser || options.format;

                if (typeof parser === 'function') {
                    return parser(value);
                }

                if (typeof value === 'string' && typeof format === 'string') {
                    return moment(value, format);
                }

                if (!(value instanceof moment)) {
                    value = moment(value);
                }

                if (value.isValid()) {
                    return value;
                }

                // Labels are in an incompatible moment format and no `parser` has been provided.
                // The user might still use the deprecated `format` option to convert his inputs.
                if (typeof format === 'function') {
                    return format(value);
                }

                return value;
            }

            function parse(input, scale) {
                if (helpers.isNullOrUndef(input)) {
                    return null;
                }

                var options = scale.options.time;
                var value = momentify(scale.getRightValue(input), options);
                if (!value.isValid()) {
                    return null;
                }

                if (options.round) {
                    value.startOf(options.round);
                }

                return value.valueOf();
            }

            /**
             * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
             * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
             */
            function determineStepSize(min, max, unit, capacity) {
                var range = max - min;
                var interval = INTERVALS[unit];
                var milliseconds = interval.size;
                var steps = interval.steps;
                var i, ilen, factor;

                if (!steps) {
                    return Math.ceil(range / (capacity * milliseconds));
                }

                for (i = 0, ilen = steps.length; i < ilen; ++i) {
                    factor = steps[i];
                    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
                        break;
                    }
                }

                return factor;
            }

            /**
             * Figures out what unit results in an appropriate number of auto-generated ticks
             */
            function determineUnitForAutoTicks(minUnit, min, max, capacity) {
                var ilen = UNITS.length;
                var i, interval, factor;

                for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
                    interval = INTERVALS[UNITS[i]];
                    factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

                    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
                        return UNITS[i];
                    }
                }

                return UNITS[ilen - 1];
            }

            /**
             * Figures out what unit to format a set of ticks with
             */
            function determineUnitForFormatting(ticks, minUnit, min, max) {
                var duration = moment.duration(moment(max).diff(moment(min)));
                var ilen = UNITS.length;
                var i, unit;

                for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
                    unit = UNITS[i];
                    if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
                        return unit;
                    }
                }

                return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
            }

            function determineMajorUnit(unit) {
                for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
                    if (INTERVALS[UNITS[i]].common) {
                        return UNITS[i];
                    }
                }
            }

            /**
             * Generates a maximum of `capacity` timestamps between min and max, rounded to the
             * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
             * Important: this method can return ticks outside the min and max range, it's the
             * responsibility of the calling code to clamp values if needed.
             */
            function generate(min, max, capacity, options) {
                var timeOpts = options.time;
                var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
                var major = determineMajorUnit(minor);
                var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
                var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
                var majorTicksEnabled = options.ticks.major.enabled;
                var interval = INTERVALS[minor];
                var first = moment(min);
                var last = moment(max);
                var ticks = [];
                var time;

                if (!stepSize) {
                    stepSize = determineStepSize(min, max, minor, capacity);
                }

                // For 'week' unit, handle the first day of week option
                if (weekday) {
                    first = first.isoWeekday(weekday);
                    last = last.isoWeekday(weekday);
                }

                // Align first/last ticks on unit
                first = first.startOf(weekday ? 'day' : minor);
                last = last.startOf(weekday ? 'day' : minor);

                // Make sure that the last tick include max
                if (last < max) {
                    last.add(1, minor);
                }

                time = moment(first);

                if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
                    // Align the first tick on the previous `minor` unit aligned on the `major` unit:
                    // we first aligned time on the previous `major` unit then add the number of full
                    // stepSize there is between first and the previous major time.
                    time.startOf(major);
                    time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
                }

                for (; time < last; time.add(stepSize, minor)) {
                    ticks.push(+time);
                }

                ticks.push(+time);

                return ticks;
            }

            /**
             * Returns the right and left offsets from edges in the form of {left, right}.
             * Offsets are added when the `offset` option is true.
             */
            function computeOffsets(table, ticks, min, max, options) {
                var left = 0;
                var right = 0;
                var upper, lower;

                if (options.offset && ticks.length) {
                    if (!options.time.min) {
                        upper = ticks.length > 1 ? ticks[1] : max;
                        lower = ticks[0];
                        left = (
                            interpolate(table, 'time', upper, 'pos') -
                            interpolate(table, 'time', lower, 'pos')
                        ) / 2;
                    }
                    if (!options.time.max) {
                        upper = ticks[ticks.length - 1];
                        lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
                        right = (
                            interpolate(table, 'time', upper, 'pos') -
                            interpolate(table, 'time', lower, 'pos')
                        ) / 2;
                    }
                }

                return {left: left, right: right};
            }

            function ticksFromTimestamps(values, majorUnit) {
                var ticks = [];
                var i, ilen, value, major;

                for (i = 0, ilen = values.length; i < ilen; ++i) {
                    value = values[i];
                    major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;

                    ticks.push({
                        value: value,
                        major: major
                    });
                }

                return ticks;
            }

            function determineLabelFormat(data, timeOpts) {
                var i, momentDate, hasTime;
                var ilen = data.length;

                // find the label with the most parts (milliseconds, minutes, etc.)
                // format all labels with the same level of detail as the most specific label
                for (i = 0; i < ilen; i++) {
                    momentDate = momentify(data[i], timeOpts);
                    if (momentDate.millisecond() !== 0) {
                        return 'MMM D, YYYY h:mm:ss.SSS a';
                    }
                    if (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {
                        hasTime = true;
                    }
                }
                if (hasTime) {
                    return 'MMM D, YYYY h:mm:ss a';
                }
                return 'MMM D, YYYY';
            }

            module.exports = function () {

                var defaultConfig = {
                    position: 'bottom',

                    /**
                     * Data distribution along the scale:
                     * - 'linear': data are spread according to their time (distances can vary),
                     * - 'series': data are spread at the same distance from each other.
                     * @see https://github.com/chartjs/Chart.js/pull/4507
                     * @since 2.7.0
                     */
                    distribution: 'linear',

                    /**
                     * Scale boundary strategy (bypassed by min/max time options)
                     * - `data`: make sure data are fully visible, ticks outside are removed
                     * - `ticks`: make sure ticks are fully visible, data outside are truncated
                     * @see https://github.com/chartjs/Chart.js/pull/4556
                     * @since 2.7.0
                     */
                    bounds: 'data',

                    time: {
                        parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
                        format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
                        unit: false, // false == automatic or override with week, month, year, etc.
                        round: false, // none, or override with week, month, year, etc.
                        displayFormat: false, // DEPRECATED
                        isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
                        minUnit: 'millisecond',

                        // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
                        displayFormats: {
                            millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
                            second: 'h:mm:ss a', // 11:20:01 AM
                            minute: 'h:mm a', // 11:20 AM
                            hour: 'hA', // 5PM
                            day: 'MMM D', // Sep 4
                            week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
                            month: 'MMM YYYY', // Sept 2015
                            quarter: '[Q]Q - YYYY', // Q3
                            year: 'YYYY' // 2015
                        },
                    },
                    ticks: {
                        autoSkip: false,

                        /**
                         * Ticks generation input values:
                         * - 'auto': generates "optimal" ticks based on scale size and time options.
                         * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
                         * - 'labels': generates ticks from user given `data.labels` values ONLY.
                         * @see https://github.com/chartjs/Chart.js/pull/4507
                         * @since 2.7.0
                         */
                        source: 'auto',

                        major: {
                            enabled: false
                        }
                    }
                };

                var TimeScale = Scale.extend({
                    initialize: function () {
                        if (!moment) {
                            throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
                        }

                        this.mergeTicksOptions();

                        Scale.prototype.initialize.call(this);
                    },

                    update: function () {
                        var me = this;
                        var options = me.options;

                        // DEPRECATIONS: output a message only one time per update
                        if (options.time && options.time.format) {
                            console.warn('options.time.format is deprecated and replaced by options.time.parser.');
                        }

                        return Scale.prototype.update.apply(me, arguments);
                    },

                    /**
                     * Allows data to be referenced via 't' attribute
                     */
                    getRightValue: function (rawValue) {
                        if (rawValue && rawValue.t !== undefined) {
                            rawValue = rawValue.t;
                        }
                        return Scale.prototype.getRightValue.call(this, rawValue);
                    },

                    determineDataLimits: function () {
                        var me = this;
                        var chart = me.chart;
                        var timeOpts = me.options.time;
                        var unit = timeOpts.unit || 'day';
                        var min = MAX_INTEGER;
                        var max = MIN_INTEGER;
                        var timestamps = [];
                        var datasets = [];
                        var labels = [];
                        var i, j, ilen, jlen, data, timestamp;

                        // Convert labels to timestamps
                        for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
                            labels.push(parse(chart.data.labels[i], me));
                        }

                        // Convert data to timestamps
                        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                            if (chart.isDatasetVisible(i)) {
                                data = chart.data.datasets[i].data;

                                // Let's consider that all data have the same format.
                                if (helpers.isObject(data[0])) {
                                    datasets[i] = [];

                                    for (j = 0, jlen = data.length; j < jlen; ++j) {
                                        timestamp = parse(data[j], me);
                                        timestamps.push(timestamp);
                                        datasets[i][j] = timestamp;
                                    }
                                } else {
                                    timestamps.push.apply(timestamps, labels);
                                    datasets[i] = labels.slice(0);
                                }
                            } else {
                                datasets[i] = [];
                            }
                        }

                        if (labels.length) {
                            // Sort labels **after** data have been converted
                            labels = arrayUnique(labels).sort(sorter);
                            min = Math.min(min, labels[0]);
                            max = Math.max(max, labels[labels.length - 1]);
                        }

                        if (timestamps.length) {
                            timestamps = arrayUnique(timestamps).sort(sorter);
                            min = Math.min(min, timestamps[0]);
                            max = Math.max(max, timestamps[timestamps.length - 1]);
                        }

                        min = parse(timeOpts.min, me) || min;
                        max = parse(timeOpts.max, me) || max;

                        // In case there is no valid min/max, set limits based on unit time option
                        min = min === MAX_INTEGER ? +moment().startOf(unit) : min;
                        max = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;

                        // Make sure that max is strictly higher than min (required by the lookup table)
                        me.min = Math.min(min, max);
                        me.max = Math.max(min + 1, max);

                        // PRIVATE
                        me._horizontal = me.isHorizontal();
                        me._table = [];
                        me._timestamps = {
                            data: timestamps,
                            datasets: datasets,
                            labels: labels
                        };
                    },

                    buildTicks: function () {
                        var me = this;
                        var min = me.min;
                        var max = me.max;
                        var options = me.options;
                        var timeOpts = options.time;
                        var timestamps = [];
                        var ticks = [];
                        var i, ilen, timestamp;

                        switch (options.ticks.source) {
                            case 'data':
                                timestamps = me._timestamps.data;
                                break;
                            case 'labels':
                                timestamps = me._timestamps.labels;
                                break;
                            case 'auto':
                            default:
                                timestamps = generate(min, max, me.getLabelCapacity(min), options);
                        }

                        if (options.bounds === 'ticks' && timestamps.length) {
                            min = timestamps[0];
                            max = timestamps[timestamps.length - 1];
                        }

                        // Enforce limits with user min/max options
                        min = parse(timeOpts.min, me) || min;
                        max = parse(timeOpts.max, me) || max;

                        // Remove ticks outside the min/max range
                        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                            timestamp = timestamps[i];
                            if (timestamp >= min && timestamp <= max) {
                                ticks.push(timestamp);
                            }
                        }

                        me.min = min;
                        me.max = max;

                        // PRIVATE
                        me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
                        me._majorUnit = determineMajorUnit(me._unit);
                        me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
                        me._offsets = computeOffsets(me._table, ticks, min, max, options);
                        me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);

                        return ticksFromTimestamps(ticks, me._majorUnit);
                    },

                    getLabelForIndex: function (index, datasetIndex) {
                        var me = this;
                        var data = me.chart.data;
                        var timeOpts = me.options.time;
                        var label = data.labels && index < data.labels.length ? data.labels[index] : '';
                        var value = data.datasets[datasetIndex].data[index];

                        if (helpers.isObject(value)) {
                            label = me.getRightValue(value);
                        }
                        if (timeOpts.tooltipFormat) {
                            return momentify(label, timeOpts).format(timeOpts.tooltipFormat);
                        }
                        if (typeof label === 'string') {
                            return label;
                        }

                        return momentify(label, timeOpts).format(me._labelFormat);
                    },

                    /**
                     * Function to format an individual tick mark
                     * @private
                     */
                    tickFormatFunction: function (tick, index, ticks, formatOverride) {
                        var me = this;
                        var options = me.options;
                        var time = tick.valueOf();
                        var formats = options.time.displayFormats;
                        var minorFormat = formats[me._unit];
                        var majorUnit = me._majorUnit;
                        var majorFormat = formats[majorUnit];
                        var majorTime = tick.clone().startOf(majorUnit).valueOf();
                        var majorTickOpts = options.ticks.major;
                        var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
                        var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
                        var tickOpts = major ? majorTickOpts : options.ticks.minor;
                        var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

                        return formatter ? formatter(label, index, ticks) : label;
                    },

                    convertTicksToLabels: function (ticks) {
                        var labels = [];
                        var i, ilen;

                        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                            labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
                        }

                        return labels;
                    },

                    /**
                     * @private
                     */
                    getPixelForOffset: function (time) {
                        var me = this;
                        var size = me._horizontal ? me.width : me.height;
                        var start = me._horizontal ? me.left : me.top;
                        var pos = interpolate(me._table, 'time', time, 'pos');

                        return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
                    },

                    getPixelForValue: function (value, index, datasetIndex) {
                        var me = this;
                        var time = null;

                        if (index !== undefined && datasetIndex !== undefined) {
                            time = me._timestamps.datasets[datasetIndex][index];
                        }

                        if (time === null) {
                            time = parse(value, me);
                        }

                        if (time !== null) {
                            return me.getPixelForOffset(time);
                        }
                    },

                    getPixelForTick: function (index) {
                        var ticks = this.getTicks();
                        return index >= 0 && index < ticks.length ?
                            this.getPixelForOffset(ticks[index].value) :
                            null;
                    },

                    getValueForPixel: function (pixel) {
                        var me = this;
                        var size = me._horizontal ? me.width : me.height;
                        var start = me._horizontal ? me.left : me.top;
                        var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
                        var time = interpolate(me._table, 'pos', pos, 'time');

                        return moment(time);
                    },

                    /**
                     * Crude approximation of what the label width might be
                     * @private
                     */
                    getLabelWidth: function (label) {
                        var me = this;
                        var ticksOpts = me.options.ticks;
                        var tickLabelWidth = me.ctx.measureText(label).width;
                        var angle = helpers.toRadians(ticksOpts.maxRotation);
                        var cosRotation = Math.cos(angle);
                        var sinRotation = Math.sin(angle);
                        var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

                        return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
                    },

                    /**
                     * @private
                     */
                    getLabelCapacity: function (exampleTime) {
                        var me = this;

                        var formatOverride = me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation

                        var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
                        var tickLabelWidth = me.getLabelWidth(exampleLabel);
                        var innerWidth = me.isHorizontal() ? me.width : me.height;

                        var capacity = Math.floor(innerWidth / tickLabelWidth);
                        return capacity > 0 ? capacity : 1;
                    }
                });

                scaleService.registerScaleType('time', TimeScale, defaultConfig);
            };

        }, {"26": 26, "33": 33, "34": 34, "46": 46, "6": 6}]
    }, {}, [7])(7)
});

!function (a) {
    "use strict";
    a.sessionTimeout = function (b) {
        function c() {
            n || (a.ajax({type: i.ajaxType, url: i.keepAliveUrl, data: i.ajaxData}), n = !0, setTimeout(function () {
                n = !1
            }, i.keepAliveInterval))
        }

        function d() {
            clearTimeout(g), (i.countdownMessage || i.countdownBar) && f("session", !0), "function" == typeof i.onStart && i.onStart(i), i.keepAlive && c(), g = setTimeout(function () {
                "function" != typeof i.onWarn ? a("#session-timeout-dialog").modal("show") : i.onWarn(i), e()
            }, i.warnAfter)
        }

        function e() {
            clearTimeout(g), a("#session-timeout-dialog").hasClass("in") || !i.countdownMessage && !i.countdownBar || f("dialog", !0), g = setTimeout(function () {
                "function" != typeof i.onRedir ? window.location = i.redirUrl : i.onRedir(i)
            }, i.redirAfter - i.warnAfter)
        }

        function f(b, c) {
            clearTimeout(j.timer), "dialog" === b && c ? j.timeLeft = Math.floor((i.redirAfter - i.warnAfter) / 1e3) : "session" === b && c && (j.timeLeft = Math.floor(i.redirAfter / 1e3)), i.countdownBar && "dialog" === b ? j.percentLeft = Math.floor(j.timeLeft / ((i.redirAfter - i.warnAfter) / 1e3) * 100) : i.countdownBar && "session" === b && (j.percentLeft = Math.floor(j.timeLeft / (i.redirAfter / 1e3) * 100));
            var d = a(".countdown-holder"), e = j.timeLeft >= 0 ? j.timeLeft : 0;
            if (i.countdownSmart) {
                var g = Math.floor(e / 60), h = e % 60, k = g > 0 ? g + "m" : "";
                k.length > 0 && (k += " "), k += h + "s", d.text(k)
            } else d.text(e + "s");
            i.countdownBar && a(".countdown-bar").css("width", j.percentLeft + "%"), j.timeLeft = j.timeLeft - 1, j.timer = setTimeout(function () {
                f(b)
            }, 1e3)
        }

        var g, h = {
            title: "Your Session is About to Expire!",
            message: "Your session is about to expire.",
            logoutButton: "Logout",
            keepAliveButton: "Stay Connected",
            keepAliveUrl: "/keep-alive",
            ajaxType: "POST",
            ajaxData: "",
            redirUrl: "/timed-out",
            logoutUrl: "/log-out",
            warnAfter: 9e5,
            redirAfter: 12e5,
            keepAliveInterval: 5e3,
            keepAlive: !0,
            ignoreUserActivity: !1,
            onStart: !1,
            onWarn: !1,
            onRedir: !1,
            countdownMessage: !1,
            countdownBar: !1,
            countdownSmart: !1
        }, i = h, j = {};
        if (b && (i = a.extend(h, b)), i.warnAfter >= i.redirAfter) return console.error('Bootstrap-session-timeout plugin is miss-configured. Option "redirAfter" must be equal or greater than "warnAfter".'), !1;
        if ("function" != typeof i.onWarn) {
            var k = i.countdownMessage ? "<p>" + i.countdownMessage.replace(/{timer}/g, '<span class="countdown-holder"></span>') + "</p>" : "",
                l = i.countdownBar ? '<div class="progress">                   <div class="progress-bar progress-bar-striped countdown-bar active" role="progressbar" style="min-width: 15px; width: 100%;">                     <span class="countdown-holder"></span>                   </div>                 </div>' : "";
            a("body").append('<div class="modal fade" id="session-timeout-dialog">               <div class="modal-dialog">                 <div class="modal-content">                   <div class="modal-header">                     <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>                     <h4 class="modal-title">' + i.title + '</h4>                   </div>                   <div class="modal-body">                     <p>' + i.message + "</p>                     " + k + "                     " + l + '                   </div>                   <div class="modal-footer">                     <button id="session-timeout-dialog-logout" type="button" class="btn btn-default">' + i.logoutButton + '</button>                     <button id="session-timeout-dialog-keepalive" type="button" class="btn btn-primary" data-dismiss="modal">' + i.keepAliveButton + "</button>                   </div>                 </div>               </div>              </div>"), a("#session-timeout-dialog-logout").on("click", function () {
                window.location = i.logoutUrl
            }), a("#session-timeout-dialog").on("hide.bs.modal", function () {
                d()
            })
        }
        if (!i.ignoreUserActivity) {
            var m = [-1, -1];
            a(document).on("keyup mouseup mousemove touchend touchmove", function (b) {
                if ("mousemove" === b.type) {
                    if (b.clientX === m[0] && b.clientY === m[1]) return;
                    m[0] = b.clientX, m[1] = b.clientY
                }
                d(), a("#session-timeout-dialog").length > 0 && a("#session-timeout-dialog").data("bs.modal") && a("#session-timeout-dialog").data("bs.modal").isShown && (a("#session-timeout-dialog").modal("hide"), a("body").removeClass("modal-open"), a("div.modal-backdrop").remove())
            })
        }
        var n = !1;
        d()
    }
}(jQuery);
/*! Idle Timer v1.1.0 2016-03-21 | https://github.com/thorst/jquery-idletimer | (c) 2016 Paul Irish | Licensed MIT */
!function (a) {
    a.idleTimer = function (b, c) {
        var d;
        "object" == typeof b ? (d = b, b = null) : "number" == typeof b && (d = {timeout: b}, b = null), c = c || document, d = a.extend({
            idle: !1,
            timeout: 3e4,
            events: "mousemove keydown wheel DOMMouseScroll mousewheel mousedown touchstart touchmove MSPointerDown MSPointerMove"
        }, d);
        var e = a(c), f = e.data("idleTimerObj") || {}, g = function (b) {
            var d = a.data(c, "idleTimerObj") || {};
            d.idle = !d.idle, d.olddate = +new Date;
            var e = a.Event((d.idle ? "idle" : "active") + ".idleTimer");
            a(c).trigger(e, [c, a.extend({}, d), b])
        }, h = function (b) {
            var d = a.data(c, "idleTimerObj") || {};
            if (("storage" !== b.type || b.originalEvent.key === d.timerSyncId) && null == d.remaining) {
                if ("mousemove" === b.type) {
                    if (b.pageX === d.pageX && b.pageY === d.pageY) return;
                    if ("undefined" == typeof b.pageX && "undefined" == typeof b.pageY) return;
                    var e = +new Date - d.olddate;
                    if (200 > e) return
                }
                clearTimeout(d.tId), d.idle && g(b), d.lastActive = +new Date, d.pageX = b.pageX, d.pageY = b.pageY, "storage" !== b.type && d.timerSyncId && "undefined" != typeof localStorage && localStorage.setItem(d.timerSyncId, d.lastActive), d.tId = setTimeout(g, d.timeout)
            }
        }, i = function () {
            var b = a.data(c, "idleTimerObj") || {};
            b.idle = b.idleBackup, b.olddate = +new Date, b.lastActive = b.olddate, b.remaining = null, clearTimeout(b.tId), b.idle || (b.tId = setTimeout(g, b.timeout))
        }, j = function () {
            var b = a.data(c, "idleTimerObj") || {};
            null == b.remaining && (b.remaining = b.timeout - (+new Date - b.olddate), clearTimeout(b.tId))
        }, k = function () {
            var b = a.data(c, "idleTimerObj") || {};
            null != b.remaining && (b.idle || (b.tId = setTimeout(g, b.remaining)), b.remaining = null)
        }, l = function () {
            var b = a.data(c, "idleTimerObj") || {};
            clearTimeout(b.tId), e.removeData("idleTimerObj"), e.off("._idleTimer")
        }, m = function () {
            var b = a.data(c, "idleTimerObj") || {};
            if (b.idle) return 0;
            if (null != b.remaining) return b.remaining;
            var d = b.timeout - (+new Date - b.lastActive);
            return 0 > d && (d = 0), d
        };
        if (null === b && "undefined" != typeof f.idle) return i(), e;
        if (null === b) ; else {
            if (null !== b && "undefined" == typeof f.idle) return !1;
            if ("destroy" === b) return l(), e;
            if ("pause" === b) return j(), e;
            if ("resume" === b) return k(), e;
            if ("reset" === b) return i(), e;
            if ("getRemainingTime" === b) return m();
            if ("getElapsedTime" === b) return +new Date - f.olddate;
            if ("getLastActiveTime" === b) return f.lastActive;
            if ("isIdle" === b) return f.idle
        }
        return e.on(a.trim((d.events + " ").split(" ").join("._idleTimer ")), function (a) {
            h(a)
        }), d.timerSyncId && a(window).bind("storage", h), f = a.extend({}, {
            olddate: +new Date,
            lastActive: +new Date,
            idle: d.idle,
            idleBackup: d.idle,
            timeout: d.timeout,
            remaining: null,
            timerSyncId: d.timerSyncId,
            tId: null,
            pageX: null,
            pageY: null
        }), f.idle || (f.tId = setTimeout(g, f.timeout)), a.data(c, "idleTimerObj", f), e
    }, a.fn.idleTimer = function (b) {
        return this[0] ? a.idleTimer(b, this[0]) : this
    }
}(jQuery);
/*!
Waypoints - 4.0.1
Copyright © 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
(function () {
    'use strict'

    var keyCounter = 0
    var allWaypoints = {}

    /* http://imakewebthings.com/waypoints/api/waypoint */
    function Waypoint(options) {
        if (!options) {
            throw new Error('No options passed to Waypoint constructor')
        }
        if (!options.element) {
            throw new Error('No element option passed to Waypoint constructor')
        }
        if (!options.handler) {
            throw new Error('No handler option passed to Waypoint constructor')
        }

        this.key = 'waypoint-' + keyCounter
        this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options)
        this.element = this.options.element
        this.adapter = new Waypoint.Adapter(this.element)
        this.callback = options.handler
        this.axis = this.options.horizontal ? 'horizontal' : 'vertical'
        this.enabled = this.options.enabled
        this.triggerPoint = null
        this.group = Waypoint.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        })
        this.context = Waypoint.Context.findOrCreateByElement(this.options.context)

        if (Waypoint.offsetAliases[this.options.offset]) {
            this.options.offset = Waypoint.offsetAliases[this.options.offset]
        }
        this.group.add(this)
        this.context.add(this)
        allWaypoints[this.key] = this
        keyCounter += 1
    }

    /* Private */
    Waypoint.prototype.queueTrigger = function (direction) {
        this.group.queueTrigger(this, direction)
    }

    /* Private */
    Waypoint.prototype.trigger = function (args) {
        if (!this.enabled) {
            return
        }
        if (this.callback) {
            this.callback.apply(this, args)
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/destroy */
    Waypoint.prototype.destroy = function () {
        this.context.remove(this)
        this.group.remove(this)
        delete allWaypoints[this.key]
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/disable */
    Waypoint.prototype.disable = function () {
        this.enabled = false
        return this
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/enable */
    Waypoint.prototype.enable = function () {
        this.context.refresh()
        this.enabled = true
        return this
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/next */
    Waypoint.prototype.next = function () {
        return this.group.next(this)
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/previous */
    Waypoint.prototype.previous = function () {
        return this.group.previous(this)
    }

    /* Private */
    Waypoint.invokeAll = function (method) {
        var allWaypointsArray = []
        for (var waypointKey in allWaypoints) {
            allWaypointsArray.push(allWaypoints[waypointKey])
        }
        for (var i = 0, end = allWaypointsArray.length; i < end; i++) {
            allWaypointsArray[i][method]()
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/destroy-all */
    Waypoint.destroyAll = function () {
        Waypoint.invokeAll('destroy')
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/disable-all */
    Waypoint.disableAll = function () {
        Waypoint.invokeAll('disable')
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/enable-all */
    Waypoint.enableAll = function () {
        Waypoint.Context.refreshAll()
        for (var waypointKey in allWaypoints) {
            allWaypoints[waypointKey].enabled = true
        }
        return this
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/refresh-all */
    Waypoint.refreshAll = function () {
        Waypoint.Context.refreshAll()
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/viewport-height */
    Waypoint.viewportHeight = function () {
        return window.innerHeight || document.documentElement.clientHeight
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/viewport-width */
    Waypoint.viewportWidth = function () {
        return document.documentElement.clientWidth
    }

    Waypoint.adapters = []

    Waypoint.defaults = {
        context: window,
        continuous: true,
        enabled: true,
        group: 'default',
        horizontal: false,
        offset: 0
    }

    Waypoint.offsetAliases = {
        'bottom-in-view': function () {
            return this.context.innerHeight() - this.adapter.outerHeight()
        },
        'right-in-view': function () {
            return this.context.innerWidth() - this.adapter.outerWidth()
        }
    }

    window.Waypoint = Waypoint
}())
;(function () {
    'use strict'

    function requestAnimationFrameShim(callback) {
        window.setTimeout(callback, 1000 / 60)
    }

    var keyCounter = 0
    var contexts = {}
    var Waypoint = window.Waypoint
    var oldWindowLoad = window.onload

    /* http://imakewebthings.com/waypoints/api/context */
    function Context(element) {
        this.element = element
        this.Adapter = Waypoint.Adapter
        this.adapter = new this.Adapter(element)
        this.key = 'waypoint-context-' + keyCounter
        this.didScroll = false
        this.didResize = false
        this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        }
        this.waypoints = {
            vertical: {},
            horizontal: {}
        }

        element.waypointContextKey = this.key
        contexts[element.waypointContextKey] = this
        keyCounter += 1
        if (!Waypoint.windowContext) {
            Waypoint.windowContext = true
            Waypoint.windowContext = new Context(window)
        }

        this.createThrottledScrollHandler()
        this.createThrottledResizeHandler()
    }

    /* Private */
    Context.prototype.add = function (waypoint) {
        var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical'
        this.waypoints[axis][waypoint.key] = waypoint
        this.refresh()
    }

    /* Private */
    Context.prototype.checkEmpty = function () {
        var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal)
        var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical)
        var isWindow = this.element == this.element.window
        if (horizontalEmpty && verticalEmpty && !isWindow) {
            this.adapter.off('.waypoints')
            delete contexts[this.key]
        }
    }

    /* Private */
    Context.prototype.createThrottledResizeHandler = function () {
        var self = this

        function resizeHandler() {
            self.handleResize()
            self.didResize = false
        }

        this.adapter.on('resize.waypoints', function () {
            if (!self.didResize) {
                self.didResize = true
                Waypoint.requestAnimationFrame(resizeHandler)
            }
        })
    }

    /* Private */
    Context.prototype.createThrottledScrollHandler = function () {
        var self = this

        function scrollHandler() {
            self.handleScroll()
            self.didScroll = false
        }

        this.adapter.on('scroll.waypoints', function () {
            if (!self.didScroll || Waypoint.isTouch) {
                self.didScroll = true
                Waypoint.requestAnimationFrame(scrollHandler)
            }
        })
    }

    /* Private */
    Context.prototype.handleResize = function () {
        Waypoint.Context.refreshAll()
    }

    /* Private */
    Context.prototype.handleScroll = function () {
        var triggeredGroups = {}
        var axes = {
            horizontal: {
                newScroll: this.adapter.scrollLeft(),
                oldScroll: this.oldScroll.x,
                forward: 'right',
                backward: 'left'
            },
            vertical: {
                newScroll: this.adapter.scrollTop(),
                oldScroll: this.oldScroll.y,
                forward: 'down',
                backward: 'up'
            }
        }

        for (var axisKey in axes) {
            var axis = axes[axisKey]
            var isForward = axis.newScroll > axis.oldScroll
            var direction = isForward ? axis.forward : axis.backward

            for (var waypointKey in this.waypoints[axisKey]) {
                var waypoint = this.waypoints[axisKey][waypointKey]
                if (waypoint.triggerPoint === null) {
                    continue
                }
                var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint
                var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint
                var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint
                var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint
                if (crossedForward || crossedBackward) {
                    waypoint.queueTrigger(direction)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
            }
        }

        for (var groupKey in triggeredGroups) {
            triggeredGroups[groupKey].flushTriggers()
        }

        this.oldScroll = {
            x: axes.horizontal.newScroll,
            y: axes.vertical.newScroll
        }
    }

    /* Private */
    Context.prototype.innerHeight = function () {
        /*eslint-disable eqeqeq */
        if (this.element == this.element.window) {
            return Waypoint.viewportHeight()
        }
        /*eslint-enable eqeqeq */
        return this.adapter.innerHeight()
    }

    /* Private */
    Context.prototype.remove = function (waypoint) {
        delete this.waypoints[waypoint.axis][waypoint.key]
        this.checkEmpty()
    }

    /* Private */
    Context.prototype.innerWidth = function () {
        /*eslint-disable eqeqeq */
        if (this.element == this.element.window) {
            return Waypoint.viewportWidth()
        }
        /*eslint-enable eqeqeq */
        return this.adapter.innerWidth()
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-destroy */
    Context.prototype.destroy = function () {
        var allWaypoints = []
        for (var axis in this.waypoints) {
            for (var waypointKey in this.waypoints[axis]) {
                allWaypoints.push(this.waypoints[axis][waypointKey])
            }
        }
        for (var i = 0, end = allWaypoints.length; i < end; i++) {
            allWaypoints[i].destroy()
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-refresh */
    Context.prototype.refresh = function () {
        /*eslint-disable eqeqeq */
        var isWindow = this.element == this.element.window
        /*eslint-enable eqeqeq */
        var contextOffset = isWindow ? undefined : this.adapter.offset()
        var triggeredGroups = {}
        var axes

        this.handleScroll()
        axes = {
            horizontal: {
                contextOffset: isWindow ? 0 : contextOffset.left,
                contextScroll: isWindow ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: 'right',
                backward: 'left',
                offsetProp: 'left'
            },
            vertical: {
                contextOffset: isWindow ? 0 : contextOffset.top,
                contextScroll: isWindow ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: 'down',
                backward: 'up',
                offsetProp: 'top'
            }
        }

        for (var axisKey in axes) {
            var axis = axes[axisKey]
            for (var waypointKey in this.waypoints[axisKey]) {
                var waypoint = this.waypoints[axisKey][waypointKey]
                var adjustment = waypoint.options.offset
                var oldTriggerPoint = waypoint.triggerPoint
                var elementOffset = 0
                var freshWaypoint = oldTriggerPoint == null
                var contextModifier, wasBeforeScroll, nowAfterScroll
                var triggeredBackward, triggeredForward

                if (waypoint.element !== waypoint.element.window) {
                    elementOffset = waypoint.adapter.offset()[axis.offsetProp]
                }

                if (typeof adjustment === 'function') {
                    adjustment = adjustment.apply(waypoint)
                }
                else if (typeof adjustment === 'string') {
                    adjustment = parseFloat(adjustment)
                    if (waypoint.options.offset.indexOf('%') > -1) {
                        adjustment = Math.ceil(axis.contextDimension * adjustment / 100)
                    }
                }

                contextModifier = axis.contextScroll - axis.contextOffset
                waypoint.triggerPoint = Math.floor(elementOffset + contextModifier - adjustment)
                wasBeforeScroll = oldTriggerPoint < axis.oldScroll
                nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll
                triggeredBackward = wasBeforeScroll && nowAfterScroll
                triggeredForward = !wasBeforeScroll && !nowAfterScroll

                if (!freshWaypoint && triggeredBackward) {
                    waypoint.queueTrigger(axis.backward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
                else if (!freshWaypoint && triggeredForward) {
                    waypoint.queueTrigger(axis.forward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
                else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {
                    waypoint.queueTrigger(axis.forward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
            }
        }

        Waypoint.requestAnimationFrame(function () {
            for (var groupKey in triggeredGroups) {
                triggeredGroups[groupKey].flushTriggers()
            }
        })

        return this
    }

    /* Private */
    Context.findOrCreateByElement = function (element) {
        return Context.findByElement(element) || new Context(element)
    }

    /* Private */
    Context.refreshAll = function () {
        for (var contextId in contexts) {
            contexts[contextId].refresh()
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-find-by-element */
    Context.findByElement = function (element) {
        return contexts[element.waypointContextKey]
    }

    window.onload = function () {
        if (oldWindowLoad) {
            oldWindowLoad()
        }
        Context.refreshAll()
    }


    Waypoint.requestAnimationFrame = function (callback) {
        var requestFn = window.requestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            requestAnimationFrameShim
        requestFn.call(window, callback)
    }
    Waypoint.Context = Context
}())
;(function () {
    'use strict'

    function byTriggerPoint(a, b) {
        return a.triggerPoint - b.triggerPoint
    }

    function byReverseTriggerPoint(a, b) {
        return b.triggerPoint - a.triggerPoint
    }

    var groups = {
        vertical: {},
        horizontal: {}
    }
    var Waypoint = window.Waypoint

    /* http://imakewebthings.com/waypoints/api/group */
    function Group(options) {
        this.name = options.name
        this.axis = options.axis
        this.id = this.name + '-' + this.axis
        this.waypoints = []
        this.clearTriggerQueues()
        groups[this.axis][this.name] = this
    }

    /* Private */
    Group.prototype.add = function (waypoint) {
        this.waypoints.push(waypoint)
    }

    /* Private */
    Group.prototype.clearTriggerQueues = function () {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        }
    }

    /* Private */
    Group.prototype.flushTriggers = function () {
        for (var direction in this.triggerQueues) {
            var waypoints = this.triggerQueues[direction]
            var reverse = direction === 'up' || direction === 'left'
            waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)
            for (var i = 0, end = waypoints.length; i < end; i += 1) {
                var waypoint = waypoints[i]
                if (waypoint.options.continuous || i === waypoints.length - 1) {
                    waypoint.trigger([direction])
                }
            }
        }
        this.clearTriggerQueues()
    }

    /* Private */
    Group.prototype.next = function (waypoint) {
        this.waypoints.sort(byTriggerPoint)
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        var isLast = index === this.waypoints.length - 1
        return isLast ? null : this.waypoints[index + 1]
    }

    /* Private */
    Group.prototype.previous = function (waypoint) {
        this.waypoints.sort(byTriggerPoint)
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        return index ? this.waypoints[index - 1] : null
    }

    /* Private */
    Group.prototype.queueTrigger = function (waypoint, direction) {
        this.triggerQueues[direction].push(waypoint)
    }

    /* Private */
    Group.prototype.remove = function (waypoint) {
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        if (index > -1) {
            this.waypoints.splice(index, 1)
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/first */
    Group.prototype.first = function () {
        return this.waypoints[0]
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/last */
    Group.prototype.last = function () {
        return this.waypoints[this.waypoints.length - 1]
    }

    /* Private */
    Group.findOrCreate = function (options) {
        return groups[options.axis][options.name] || new Group(options)
    }

    Waypoint.Group = Group
}())
;(function () {
    'use strict'

    var $ = window.jQuery
    var Waypoint = window.Waypoint

    function JQueryAdapter(element) {
        this.$element = $(element)
    }

    $.each([
        'innerHeight',
        'innerWidth',
        'off',
        'offset',
        'on',
        'outerHeight',
        'outerWidth',
        'scrollLeft',
        'scrollTop'
    ], function (i, method) {
        JQueryAdapter.prototype[method] = function () {
            var args = Array.prototype.slice.call(arguments)
            return this.$element[method].apply(this.$element, args)
        }
    })

    $.each([
        'extend',
        'inArray',
        'isEmptyObject'
    ], function (i, method) {
        JQueryAdapter[method] = $[method]
    })

    Waypoint.adapters.push({
        name: 'jquery',
        Adapter: JQueryAdapter
    })
    Waypoint.Adapter = JQueryAdapter
}())
;(function () {
    'use strict'

    var Waypoint = window.Waypoint

    function createExtension(framework) {
        return function () {
            var waypoints = []
            var overrides = arguments[0]

            if (framework.isFunction(arguments[0])) {
                overrides = framework.extend({}, arguments[1])
                overrides.handler = arguments[0]
            }

            this.each(function () {
                var options = framework.extend({}, overrides, {
                    element: this
                })
                if (typeof options.context === 'string') {
                    options.context = framework(this).closest(options.context)[0]
                }
                waypoints.push(new Waypoint(options))
            })

            return waypoints
        }
    }

    if (window.jQuery) {
        window.jQuery.fn.waypoint = createExtension(window.jQuery)
    }
    if (window.Zepto) {
        window.Zepto.fn.waypoint = createExtension(window.Zepto)
    }
}())
;
/*!
* jquery.counterup.js 1.0
*
* Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
* Released under the GPL v2 License
*
* Date: Nov 26, 2013
*/
!function (t) {
    "use strict";
    t.fn.counterUp = function (e) {
        var u = t.extend({time: 400, delay: 10}, e);
        return this.each(function () {
            var e = t(this), n = u, a = function () {
                var t = n.time / n.delay, u = e.attr("data-value"), a = [u], r = /[0-9]+,[0-9]+/.test(u);
                u = u.replace(/,/g, "");
                for (var o = (/^[0-9]+$/.test(u), /^[0-9]+\.[0-9]+$/.test(u)), c = o ? (u.split(".")[1] || []).length : 0, d = t; d >= 1; d--) {
                    var s = parseInt(u / t * d);
                    if (o && (s = parseFloat(u / t * d).toFixed(c)), r) for (; /(\d+)(\d{3})/.test(s.toString());) s = s.toString().replace(/(\d+)(\d{3})/, "$1,$2");
                    a.unshift(s)
                }
                e.data("counterup-nums", a), e.text("0");
                var i = function () {
                    e.data("counterup-nums") && (e.text(e.data("counterup-nums").shift()), e.data("counterup-nums").length ? setTimeout(e.data("counterup-func"), n.delay) : (delete e.data("counterup-nums"), e.data("counterup-nums", null), e.data("counterup-func", null)))
                };
                e.data("counterup-func", i), setTimeout(e.data("counterup-func"), n.delay)
            };
            e.waypoint(a, {offset: "100%", triggerOnce: !0})
        })
    }
}(jQuery);

(function (t) {
    function z() {
        for (var a = 0; a < g.length; a++) g[a][0](g[a][1]);
        g = [];
        m = !1
    }

    function n(a, b) {
        g.push([a, b]);
        m || (m = !0, A(z, 0))
    }

    function B(a, b) {
        function c(a) {
            p(b, a)
        }

        function h(a) {
            k(b, a)
        }

        try {
            a(c, h)
        } catch (d) {
            h(d)
        }
    }

    function u(a) {
        var b = a.owner, c = b.state_, b = b.data_, h = a[c];
        a = a.then;
        if ("function" === typeof h) {
            c = l;
            try {
                b = h(b)
            } catch (d) {
                k(a, d)
            }
        }
        v(a, b) || (c === l && p(a, b), c === q && k(a, b))
    }

    function v(a, b) {
        var c;
        try {
            if (a === b) throw new TypeError("A promises callback cannot return that same promise.");
            if (b && ("function" ===
                typeof b || "object" === typeof b)) {
                var h = b.then;
                if ("function" === typeof h) return h.call(b, function (d) {
                    c || (c = !0, b !== d ? p(a, d) : w(a, d))
                }, function (b) {
                    c || (c = !0, k(a, b))
                }), !0
            }
        } catch (d) {
            return c || k(a, d), !0
        }
        return !1
    }

    function p(a, b) {
        a !== b && v(a, b) || w(a, b)
    }

    function w(a, b) {
        a.state_ === r && (a.state_ = x, a.data_ = b, n(C, a))
    }

    function k(a, b) {
        a.state_ === r && (a.state_ = x, a.data_ = b, n(D, a))
    }

    function y(a) {
        var b = a.then_;
        a.then_ = void 0;
        for (a = 0; a < b.length; a++) u(b[a])
    }

    function C(a) {
        a.state_ = l;
        y(a)
    }

    function D(a) {
        a.state_ = q;
        y(a)
    }

    function e(a) {
        if ("function" !==
            typeof a) throw new TypeError("Promise constructor takes a function argument");
        if (!1 === this instanceof e) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
        this.then_ = [];
        B(a, this)
    }

    var f = t.Promise, s = f && "resolve" in f && "reject" in f && "all" in f && "race" in f && function () {
        var a;
        new f(function (b) {
            a = b
        });
        return "function" === typeof a
    }();
    "undefined" !== typeof exports && exports ? (exports.Promise = s ? f : e, exports.Polyfill = e) : "function" ==
    typeof define && define.amd ? define(function () {
        return s ? f : e
    }) : s || (t.Promise = e);
    var r = "pending", x = "sealed", l = "fulfilled", q = "rejected", E = function () {
    }, A = "undefined" !== typeof setImmediate ? setImmediate : setTimeout, g = [], m;
    e.prototype = {
        constructor: e, state_: r, then_: null, data_: void 0, then: function (a, b) {
            var c = {owner: this, then: new this.constructor(E), fulfilled: a, rejected: b};
            this.state_ === l || this.state_ === q ? n(u, c) : this.then_.push(c);
            return c.then
        }, "catch": function (a) {
            return this.then(null, a)
        }
    };
    e.all = function (a) {
        if ("[object Array]" !==
            Object.prototype.toString.call(a)) throw new TypeError("You must pass an array to Promise.all().");
        return new this(function (b, c) {
            function h(a) {
                e++;
                return function (c) {
                    d[a] = c;
                    --e || b(d)
                }
            }

            for (var d = [], e = 0, f = 0, g; f < a.length; f++) (g = a[f]) && "function" === typeof g.then ? g.then(h(f), c) : d[f] = g;
            e || b(d)
        })
    };
    e.race = function (a) {
        if ("[object Array]" !== Object.prototype.toString.call(a)) throw new TypeError("You must pass an array to Promise.race().");
        return new this(function (b, c) {
            for (var e = 0, d; e < a.length; e++) (d = a[e]) && "function" ===
            typeof d.then ? d.then(b, c) : b(d)
        })
    };
    e.resolve = function (a) {
        return a && "object" === typeof a && a.constructor === this ? a : new this(function (b) {
            b(a)
        })
    };
    e.reject = function (a) {
        return new this(function (b, c) {
            c(a)
        })
    }
})("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this);

!function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.Sweetalert2 = t()
}(this, function () {
    "use strict";

    function q(e) {
        return (q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e
        } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function s(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    function o(e, t) {
        for (var n = 0; n < t.length; n++) {
            var o = t[n];
            o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
        }
    }

    function i(e, t, n) {
        return t && o(e.prototype, t), n && o(e, n), e
    }

    function r() {
        return (r = Object.assign || function (e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
            }
            return e
        }).apply(this, arguments)
    }

    function a(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }), t && u(e, t)
    }

    function c(e) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function u(e, t) {
        return (u = Object.setPrototypeOf || function (e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }

    function l(e, t, n) {
        return (l = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }() ? Reflect.construct : function (e, t, n) {
            var o = [null];
            o.push.apply(o, t);
            var i = new (Function.bind.apply(e, o));
            return n && u(i, n.prototype), i
        }).apply(null, arguments)
    }

    function d(e, t) {
        return !t || "object" != typeof t && "function" != typeof t ? function (e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function p(e, t, n) {
        return (p = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) {
            var o = function (e, t) {
                for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = c(e));) ;
                return e
            }(e, t);
            if (o) {
                var i = Object.getOwnPropertyDescriptor(o, t);
                return i.get ? i.get.call(n) : i.value
            }
        })(e, t, n || e)
    }

    var t = "SweetAlert2:", f = function (e) {
            return Array.prototype.slice.call(e)
        }, R = function (e) {
            console.warn("".concat(t, " ").concat(e))
        }, I = function (e) {
            console.error("".concat(t, " ").concat(e))
        }, n = [], m = function (e) {
            -1 === n.indexOf(e) && (n.push(e), R(e))
        }, H = function (e) {
            return "function" == typeof e ? e() : e
        }, D = function (e) {
            return e && "object" === q(e) && "function" == typeof e.then
        }, e = Object.freeze({cancel: "cancel", backdrop: "overlay", close: "close", esc: "esc", timer: "timer"}),
        h = function (e) {
            var t = {};
            for (var n in e) t[e[n]] = "swal2-" + e[n];
            return t
        },
        _ = h(["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "toast", "toast-shown", "toast-column", "fade", "show", "hide", "noanimation", "close", "title", "header", "content", "actions", "confirm", "cancel", "footer", "icon", "icon-text", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "validation-message", "progresssteps", "activeprogressstep", "progresscircle", "progressline", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl"]),
        g = h(["success", "warning", "info", "question", "error"]), b = {previousBodyPadding: null},
        v = function (e, t) {
            return e.classList.contains(t)
        }, N = function (e) {
            if (e.focus(), "file" !== e.type) {
                var t = e.value;
                e.value = "", e.value = t
            }
        }, y = function (e, t, n) {
            e && t && ("string" == typeof t && (t = t.split(/\s+/).filter(Boolean)), t.forEach(function (t) {
                e.forEach ? e.forEach(function (e) {
                    n ? e.classList.add(t) : e.classList.remove(t)
                }) : n ? e.classList.add(t) : e.classList.remove(t)
            }))
        }, z = function (e, t) {
            y(e, t, !0)
        }, W = function (e, t) {
            y(e, t, !1)
        }, U = function (e, t) {
            for (var n = 0; n < e.childNodes.length; n++) if (v(e.childNodes[n], t)) return e.childNodes[n]
        }, K = function (e) {
            e.style.opacity = "", e.style.display = e.id === _.content ? "block" : "flex"
        }, F = function (e) {
            e.style.opacity = "", e.style.display = "none"
        }, Z = function (e) {
            return e && (e.offsetWidth || e.offsetHeight || e.getClientRects().length)
        }, w = function () {
            return document.body.querySelector("." + _.container)
        }, C = function (e) {
            var t = w();
            return t ? t.querySelector("." + e) : null
        }, k = function () {
            return C(_.popup)
        }, x = function () {
            var e = k();
            return f(e.querySelectorAll("." + _.icon))
        }, A = function () {
            return C(_.title)
        }, B = function () {
            return C(_.content)
        }, S = function () {
            return C(_.image)
        }, P = function () {
            return C(_.progresssteps)
        }, O = function () {
            return C(_["validation-message"])
        }, E = function () {
            return C(_.confirm)
        }, L = function () {
            return C(_.cancel)
        }, Q = function () {
            return C(_.actions)
        }, Y = function () {
            return C(_.footer)
        }, $ = function () {
            return C(_.close)
        }, J = function () {
            var e = f(k().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort(function (e, t) {
                    return e = parseInt(e.getAttribute("tabindex")), (t = parseInt(t.getAttribute("tabindex"))) < e ? 1 : e < t ? -1 : 0
                }),
                t = f(k().querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex="0"], [contenteditable], audio[controls], video[controls]')).filter(function (e) {
                    return "-1" !== e.getAttribute("tabindex")
                });
            return function (e) {
                for (var t = [], n = 0; n < e.length; n++) -1 === t.indexOf(e[n]) && t.push(e[n]);
                return t
            }(e.concat(t)).filter(function (e) {
                return Z(e)
            })
        }, T = function () {
            return !M() && !document.body.classList.contains(_["no-backdrop"])
        }, M = function () {
            return document.body.classList.contains(_["toast-shown"])
        }, j = function () {
            return "undefined" == typeof window || "undefined" == typeof document
        },
        V = '\n <div aria-labelledby="'.concat(_.title, '" aria-describedby="').concat(_.content, '" class="').concat(_.popup, '" tabindex="-1">\n   <div class="').concat(_.header, '">\n     <ul class="').concat(_.progresssteps, '"></ul>\n     <div class="').concat(_.icon, " ").concat(g.error, '">\n       <span class="swal2-x-mark"><span class="swal2-x-mark-line-left"></span><span class="swal2-x-mark-line-right"></span></span>\n     </div>\n     <div class="').concat(_.icon, " ").concat(g.question, '">\n       <span class="').concat(_["icon-text"], '">?</span>\n      </div>\n     <div class="').concat(_.icon, " ").concat(g.warning, '">\n       <span class="').concat(_["icon-text"], '">!</span>\n      </div>\n     <div class="').concat(_.icon, " ").concat(g.info, '">\n       <span class="').concat(_["icon-text"], '">i</span>\n      </div>\n     <div class="').concat(_.icon, " ").concat(g.success, '">\n       <div class="swal2-success-circular-line-left"></div>\n       <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n       <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n       <div class="swal2-success-circular-line-right"></div>\n     </div>\n     <img class="').concat(_.image, '" />\n     <h2 class="').concat(_.title, '" id="').concat(_.title, '"></h2>\n     <button type="button" class="').concat(_.close, '">×</button>\n   </div>\n   <div class="').concat(_.content, '">\n     <div id="').concat(_.content, '"></div>\n     <input class="').concat(_.input, '" />\n     <input type="file" class="').concat(_.file, '" />\n     <div class="').concat(_.range, '">\n       <input type="range" />\n       <output></output>\n     </div>\n     <select class="').concat(_.select, '"></select>\n     <div class="').concat(_.radio, '"></div>\n     <label for="').concat(_.checkbox, '" class="').concat(_.checkbox, '">\n       <input type="checkbox" />\n       <span class="').concat(_.label, '"></span>\n     </label>\n     <textarea class="').concat(_.textarea, '"></textarea>\n     <div class="').concat(_["validation-message"], '" id="').concat(_["validation-message"], '"></div>\n   </div>\n   <div class="').concat(_.actions, '">\n     <button type="button" class="').concat(_.confirm, '">OK</button>\n     <button type="button" class="').concat(_.cancel, '">Cancel</button>\n   </div>\n   <div class="').concat(_.footer, '">\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, ""),
        X = function (e) {
            var t = w();
            if (t && (t.parentNode.removeChild(t), W([document.documentElement, document.body], [_["no-backdrop"], _["toast-shown"], _["has-column"]])), !j()) {
                var n = document.createElement("div");
                n.className = _.container, n.innerHTML = V;
                var o = "string" == typeof e.target ? document.querySelector(e.target) : e.target;
                o.appendChild(n);
                var i, r = k(), a = B(), s = U(a, _.input), c = U(a, _.file),
                    u = a.querySelector(".".concat(_.range, " input")),
                    l = a.querySelector(".".concat(_.range, " output")), d = U(a, _.select),
                    p = a.querySelector(".".concat(_.checkbox, " input")), f = U(a, _.textarea);
                r.setAttribute("role", e.toast ? "alert" : "dialog"), r.setAttribute("aria-live", e.toast ? "polite" : "assertive"), e.toast || r.setAttribute("aria-modal", "true"), "rtl" === window.getComputedStyle(o).direction && z(w(), _.rtl);
                var m = function (e) {
                    De.isVisible() && i !== e.target.value && De.resetValidationMessage(), i = e.target.value
                };
                return s.oninput = m, c.onchange = m, d.onchange = m, p.onchange = m, f.oninput = m, u.oninput = function (e) {
                    m(e), l.value = u.value
                }, u.onchange = function (e) {
                    m(e), u.nextSibling.value = u.value
                }, r
            }
            I("SweetAlert2 requires document to initialize")
        }, G = function (e, t) {
            if (!e) return F(t);
            if ("object" === q(e)) if (t.innerHTML = "", 0 in e) for (var n = 0; n in e; n++) t.appendChild(e[n].cloneNode(!0)); else t.appendChild(e.cloneNode(!0)); else e && (t.innerHTML = e);
            K(t)
        }, ee = function () {
            if (j()) return !1;
            var e = document.createElement("div"), t = {
                WebkitAnimation: "webkitAnimationEnd",
                OAnimation: "oAnimationEnd oanimationend",
                animation: "animationend"
            };
            for (var n in t) if (t.hasOwnProperty(n) && void 0 !== e.style[n]) return t[n];
            return !1
        }(), te = function (e) {
            var t = Q(), n = E(), o = L();
            if (e.showConfirmButton || e.showCancelButton ? K(t) : F(t), e.showCancelButton ? o.style.display = "inline-block" : F(o), e.showConfirmButton ? n.style.removeProperty("display") : F(n), n.innerHTML = e.confirmButtonText, o.innerHTML = e.cancelButtonText, n.setAttribute("aria-label", e.confirmButtonAriaLabel), o.setAttribute("aria-label", e.cancelButtonAriaLabel), n.className = _.confirm, z(n, e.confirmButtonClass), o.className = _.cancel, z(o, e.cancelButtonClass), e.buttonsStyling) {
                z([n, o], _.styled), e.confirmButtonColor && (n.style.backgroundColor = e.confirmButtonColor), e.cancelButtonColor && (o.style.backgroundColor = e.cancelButtonColor);
                var i = window.getComputedStyle(n).getPropertyValue("background-color");
                n.style.borderLeftColor = i, n.style.borderRightColor = i
            } else W([n, o], _.styled), n.style.backgroundColor = n.style.borderLeftColor = n.style.borderRightColor = "", o.style.backgroundColor = o.style.borderLeftColor = o.style.borderRightColor = ""
        }, ne = function (e) {
            var t = B().querySelector("#" + _.content);
            e.html ? G(e.html, t) : e.text ? (t.textContent = e.text, K(t)) : F(t)
        }, oe = function (e) {
            for (var t = x(), n = 0; n < t.length; n++) F(t[n]);
            if (e.type) if (-1 !== Object.keys(g).indexOf(e.type)) {
                var o = De.getPopup().querySelector(".".concat(_.icon, ".").concat(g[e.type]));
                K(o), e.animation && z(o, "swal2-animate-".concat(e.type, "-icon"))
            } else I('Unknown type! Expected "success", "error", "warning", "info" or "question", got "'.concat(e.type, '"'))
        }, ie = function (e) {
            var t = S();
            e.imageUrl ? (t.setAttribute("src", e.imageUrl), t.setAttribute("alt", e.imageAlt), K(t), e.imageWidth ? t.setAttribute("width", e.imageWidth) : t.removeAttribute("width"), e.imageHeight ? t.setAttribute("height", e.imageHeight) : t.removeAttribute("height"), t.className = _.image, e.imageClass && z(t, e.imageClass)) : F(t)
        }, re = function (i) {
            var r = P(), a = parseInt(null === i.currentProgressStep ? De.getQueueStep() : i.currentProgressStep, 10);
            i.progressSteps && i.progressSteps.length ? (K(r), r.innerHTML = "", a >= i.progressSteps.length && R("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"), i.progressSteps.forEach(function (e, t) {
                var n = document.createElement("li");
                if (z(n, _.progresscircle), n.innerHTML = e, t === a && z(n, _.activeprogressstep), r.appendChild(n), t !== i.progressSteps.length - 1) {
                    var o = document.createElement("li");
                    z(o, _.progressline), i.progressStepsDistance && (o.style.width = i.progressStepsDistance), r.appendChild(o)
                }
            })) : F(r)
        }, ae = function (e) {
            var t = A();
            e.titleText ? t.innerText = e.titleText : e.title && ("string" == typeof e.title && (e.title = e.title.split("\n").join("<br />")), G(e.title, t))
        }, se = function () {
            null === b.previousBodyPadding && document.body.scrollHeight > window.innerHeight && (b.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")), document.body.style.paddingRight = b.previousBodyPadding + function () {
                if ("ontouchstart" in window || navigator.msMaxTouchPoints) return 0;
                var e = document.createElement("div");
                e.style.width = "50px", e.style.height = "50px", e.style.overflow = "scroll", document.body.appendChild(e);
                var t = e.offsetWidth - e.clientWidth;
                return document.body.removeChild(e), t
            }() + "px")
        }, ce = function () {
            return !!window.MSInputMethodContext && !!document.documentMode
        }, ue = function () {
            var e = w(), t = k();
            e.style.removeProperty("align-items"), t.offsetTop < 0 && (e.style.alignItems = "flex-start")
        }, le = {}, de = function (e, t) {
            var n = w(), o = k();
            if (o) {
                null !== e && "function" == typeof e && e(o), W(o, _.show), z(o, _.hide);
                var i = function () {
                    M() ? pe(t) : (new Promise(function (e) {
                        var t = window.scrollX, n = window.scrollY;
                        le.restoreFocusTimeout = setTimeout(function () {
                            le.previousActiveElement && le.previousActiveElement.focus ? (le.previousActiveElement.focus(), le.previousActiveElement = null) : document.body && document.body.focus(), e()
                        }, 100), void 0 !== t && void 0 !== n && window.scrollTo(t, n)
                    }).then(function () {
                        return pe(t)
                    }), le.keydownTarget.removeEventListener("keydown", le.keydownHandler, {capture: le.keydownListenerCapture}), le.keydownHandlerAdded = !1), n.parentNode && n.parentNode.removeChild(n), W([document.documentElement, document.body], [_.shown, _["height-auto"], _["no-backdrop"], _["toast-shown"], _["toast-column"]]), T() && (null !== b.previousBodyPadding && (document.body.style.paddingRight = b.previousBodyPadding, b.previousBodyPadding = null), function () {
                        if (v(document.body, _.iosfix)) {
                            var e = parseInt(document.body.style.top, 10);
                            W(document.body, _.iosfix), document.body.style.top = "", document.body.scrollTop = -1 * e
                        }
                    }(), "undefined" != typeof window && ce() && window.removeEventListener("resize", ue), f(document.body.children).forEach(function (e) {
                        e.hasAttribute("data-previous-aria-hidden") ? (e.setAttribute("aria-hidden", e.getAttribute("data-previous-aria-hidden")), e.removeAttribute("data-previous-aria-hidden")) : e.removeAttribute("aria-hidden")
                    }))
                };
                ee && !v(o, _.noanimation) ? o.addEventListener(ee, function e() {
                    o.removeEventListener(ee, e), v(o, _.hide) && i()
                }) : i()
            }
        }, pe = function (e) {
            null !== e && "function" == typeof e && setTimeout(function () {
                e()
            })
        };

    function fe(e) {
        var t = function e() {
            for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++) n[o] = arguments[o];
            if (!(this instanceof e)) return l(e, n);
            Object.getPrototypeOf(e).apply(this, n)
        };
        return t.prototype = r(Object.create(e.prototype), {constructor: t}), "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e, t
    }

    var me = {
            title: "",
            titleText: "",
            text: "",
            html: "",
            footer: "",
            type: null,
            toast: !1,
            customClass: "",
            target: "body",
            backdrop: !0,
            animation: !0,
            heightAuto: !0,
            allowOutsideClick: !0,
            allowEscapeKey: !0,
            allowEnterKey: !0,
            stopKeydownPropagation: !0,
            keydownListenerCapture: !1,
            showConfirmButton: !0,
            showCancelButton: !1,
            preConfirm: null,
            confirmButtonText: "OK",
            confirmButtonAriaLabel: "",
            confirmButtonColor: null,
            confirmButtonClass: null,
            cancelButtonText: "Cancel",
            cancelButtonAriaLabel: "",
            cancelButtonColor: null,
            cancelButtonClass: null,
            buttonsStyling: !0,
            reverseButtons: !1,
            focusConfirm: !0,
            focusCancel: !1,
            showCloseButton: !1,
            closeButtonAriaLabel: "Close this dialog",
            showLoaderOnConfirm: !1,
            imageUrl: null,
            imageWidth: null,
            imageHeight: null,
            imageAlt: "",
            imageClass: null,
            timer: null,
            width: null,
            padding: null,
            background: null,
            input: null,
            inputPlaceholder: "",
            inputValue: "",
            inputOptions: {},
            inputAutoTrim: !0,
            inputClass: null,
            inputAttributes: {},
            inputValidator: null,
            validationMessage: null,
            grow: !1,
            position: "center",
            progressSteps: [],
            currentProgressStep: null,
            progressStepsDistance: null,
            onBeforeOpen: null,
            onAfterClose: null,
            onOpen: null,
            onClose: null,
            useRejections: !1,
            expectRejections: !1
        }, he = ["useRejections", "expectRejections", "extraParams"],
        ge = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusCancel", "heightAuto", "keydownListenerCapture"],
        be = function (e) {
            return me.hasOwnProperty(e) || "extraParams" === e
        }, ve = function (e) {
            return -1 !== he.indexOf(e)
        }, ye = function (e) {
            for (var t in e) be(t) || R('Unknown parameter "'.concat(t, '"')), e.toast && -1 !== ge.indexOf(t) && R('The parameter "'.concat(t, '" is incompatible with toasts')), ve(t) && m('The parameter "'.concat(t, '" is deprecated and will be removed in the next major release.'))
        },
        we = '"setDefaults" & "resetDefaults" methods are deprecated in favor of "mixin" method and will be removed in the next major release. For new projects, use "mixin". For past projects already using "setDefaults", support will be provided through an additional package.',
        Ce = {};
    var ke = [], xe = function () {
            var e = k();
            e || De(""), e = k();
            var t = Q(), n = E(), o = L();
            K(t), K(n), z([e, t], _.loading), n.disabled = !0, o.disabled = !0, e.setAttribute("data-loading", !0), e.setAttribute("aria-busy", !0), e.focus()
        }, Ae = Object.freeze({
            isValidParameter: be,
            isDeprecatedParameter: ve,
            argsToParams: function (n) {
                var o = {};
                switch (q(n[0])) {
                    case"object":
                        r(o, n[0]);
                        break;
                    default:
                        ["title", "html", "type"].forEach(function (e, t) {
                            switch (q(n[t])) {
                                case"string":
                                    o[e] = n[t];
                                    break;
                                case"undefined":
                                    break;
                                default:
                                    I("Unexpected type of ".concat(e, '! Expected "string", got ').concat(q(n[t])))
                            }
                        })
                }
                return o
            },
            adaptInputValidator: function (n) {
                return function (e, t) {
                    return n.call(this, e, t).then(function () {
                    }, function (e) {
                        return e
                    })
                }
            },
            close: de,
            closePopup: de,
            closeModal: de,
            closeToast: de,
            isVisible: function () {
                return !!k()
            },
            clickConfirm: function () {
                return E().click()
            },
            clickCancel: function () {
                return L().click()
            },
            getContainer: w,
            getPopup: k,
            getTitle: A,
            getContent: B,
            getImage: S,
            getIcons: x,
            getCloseButton: $,
            getButtonsWrapper: function () {
                return m("swal.getButtonsWrapper() is deprecated and will be removed in the next major release, use swal.getActions() instead"), C(_.actions)
            },
            getActions: Q,
            getConfirmButton: E,
            getCancelButton: L,
            getFooter: Y,
            getFocusableElements: J,
            getValidationMessage: O,
            isLoading: function () {
                return k().hasAttribute("data-loading")
            },
            fire: function () {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return l(this, t)
            },
            mixin: function (n) {
                return fe(function (e) {
                    function t() {
                        return s(this, t), d(this, c(t).apply(this, arguments))
                    }

                    return a(t, e), i(t, [{
                        key: "_main", value: function (e) {
                            return p(c(t.prototype), "_main", this).call(this, r({}, n, e))
                        }
                    }]), t
                }(this))
            },
            queue: function (e) {
                var r = this;
                ke = e;
                var a = function () {
                    ke = [], document.body.removeAttribute("data-swal2-queue-step")
                }, s = [];
                return new Promise(function (i) {
                    !function t(n, o) {
                        n < ke.length ? (document.body.setAttribute("data-swal2-queue-step", n), r(ke[n]).then(function (e) {
                            void 0 !== e.value ? (s.push(e.value), t(n + 1, o)) : (a(), i({dismiss: e.dismiss}))
                        })) : (a(), i({value: s}))
                    }(0)
                })
            },
            getQueueStep: function () {
                return document.body.getAttribute("data-swal2-queue-step")
            },
            insertQueueStep: function (e, t) {
                return t && t < ke.length ? ke.splice(t, 0, e) : ke.push(e)
            },
            deleteQueueStep: function (e) {
                void 0 !== ke[e] && ke.splice(e, 1)
            },
            showLoading: xe,
            enableLoading: xe,
            getTimerLeft: function () {
                return le.timeout && le.timeout.getTimerLeft()
            }
        }), Be = "function" == typeof Symbol ? Symbol : function () {
            var t = 0;

            function e(e) {
                return "__" + e + "_" + Math.floor(1e9 * Math.random()) + "_" + ++t + "__"
            }

            return e.iterator = e("Symbol.iterator"), e
        }(), Se = "function" == typeof WeakMap ? WeakMap : function (n, o, t) {
            function e() {
                o(this, n, {value: Be("WeakMap")})
            }

            return e.prototype = {
                delete: function (e) {
                    delete e[this[n]]
                }, get: function (e) {
                    return e[this[n]]
                }, has: function (e) {
                    return t.call(e, this[n])
                }, set: function (e, t) {
                    o(e, this[n], {configurable: !0, value: t})
                }
            }, e
        }(Be("WeakMap"), Object.defineProperty, {}.hasOwnProperty),
        Pe = {promise: new Se, innerParams: new Se, domCache: new Se};

    function Oe() {
        var e = Pe.innerParams.get(this), t = Pe.domCache.get(this);
        e.showConfirmButton || (F(t.confirmButton), e.showCancelButton || F(t.actions)), W([t.popup, t.actions], _.loading), t.popup.removeAttribute("aria-busy"), t.popup.removeAttribute("data-loading"), t.confirmButton.disabled = !1, t.cancelButton.disabled = !1
    }

    function Ee(e) {
        var t = Pe.domCache.get(this);
        t.validationMessage.innerHTML = e;
        var n = window.getComputedStyle(t.popup);
        t.validationMessage.style.marginLeft = "-".concat(n.getPropertyValue("padding-left")), t.validationMessage.style.marginRight = "-".concat(n.getPropertyValue("padding-right")), K(t.validationMessage);
        var o = this.getInput();
        o && (o.setAttribute("aria-invalid", !0), o.setAttribute("aria-describedBy", _["validation-message"]), N(o), z(o, _.inputerror))
    }

    function Le() {
        var e = Pe.domCache.get(this);
        e.validationMessage && F(e.validationMessage);
        var t = this.getInput();
        t && (t.removeAttribute("aria-invalid"), t.removeAttribute("aria-describedBy"), W(t, _.inputerror))
    }

    var Te = function e(t, n) {
        var o, i, r;
        s(this, e);
        var a = n;
        this.start = function () {
            r = !0, i = new Date, o = setTimeout(t, a)
        }, this.stop = function () {
            r = !1, clearTimeout(o), a -= new Date - i
        }, this.getTimerLeft = function () {
            return r && (this.stop(), this.start()), a
        }, this.start()
    }, Me = {
        email: function (e, t) {
            return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(e) ? Promise.resolve() : Promise.reject(t && t.validationMessage ? t.validationMessage : "Invalid email address")
        }, url: function (e, t) {
            return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)$/.test(e) ? Promise.resolve() : Promise.reject(t && t.validationMessage ? t.validationMessage : "Invalid URL")
        }
    };
    var je = function (e) {
        var t = w(), n = k();
        null !== e.onBeforeOpen && "function" == typeof e.onBeforeOpen && e.onBeforeOpen(n), e.animation ? (z(n, _.show), z(t, _.fade), W(n, _.hide)) : W(n, _.fade), K(n), t.style.overflowY = "hidden", ee && !v(n, _.noanimation) ? n.addEventListener(ee, function e() {
            n.removeEventListener(ee, e), t.style.overflowY = "auto"
        }) : t.style.overflowY = "auto", z([document.documentElement, document.body, t], _.shown), e.heightAuto && e.backdrop && !e.toast && z([document.documentElement, document.body], _["height-auto"]), T() && (se(), function () {
            if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream && !v(document.body, _.iosfix)) {
                var e = document.body.scrollTop;
                document.body.style.top = -1 * e + "px", z(document.body, _.iosfix)
            }
        }(), "undefined" != typeof window && ce() && (ue(), window.addEventListener("resize", ue)), f(document.body.children).forEach(function (e) {
            e === w() || e.contains(w()) || (e.hasAttribute("aria-hidden") && e.setAttribute("data-previous-aria-hidden", e.getAttribute("aria-hidden")), e.setAttribute("aria-hidden", "true"))
        }), setTimeout(function () {
            t.scrollTop = 0
        })), M() || le.previousActiveElement || (le.previousActiveElement = document.activeElement), null !== e.onOpen && "function" == typeof e.onOpen && setTimeout(function () {
            e.onOpen(n)
        })
    };
    var Ve, qe = Object.freeze({
        hideLoading: Oe, disableLoading: Oe, getInput: function (e) {
            var t = Pe.innerParams.get(this), n = Pe.domCache.get(this);
            if (!(e = e || t.input)) return null;
            switch (e) {
                case"select":
                case"textarea":
                case"file":
                    return U(n.content, _[e]);
                case"checkbox":
                    return n.popup.querySelector(".".concat(_.checkbox, " input"));
                case"radio":
                    return n.popup.querySelector(".".concat(_.radio, " input:checked")) || n.popup.querySelector(".".concat(_.radio, " input:first-child"));
                case"range":
                    return n.popup.querySelector(".".concat(_.range, " input"));
                default:
                    return U(n.content, _.input)
            }
        }, enableButtons: function () {
            var e = Pe.domCache.get(this);
            e.confirmButton.disabled = !1, e.cancelButton.disabled = !1
        }, disableButtons: function () {
            var e = Pe.domCache.get(this);
            e.confirmButton.disabled = !0, e.cancelButton.disabled = !0
        }, enableConfirmButton: function () {
            Pe.domCache.get(this).confirmButton.disabled = !1
        }, disableConfirmButton: function () {
            Pe.domCache.get(this).confirmButton.disabled = !0
        }, enableInput: function () {
            var e = this.getInput();
            if (!e) return !1;
            if ("radio" === e.type) for (var t = e.parentNode.parentNode.querySelectorAll("input"), n = 0; n < t.length; n++) t[n].disabled = !1; else e.disabled = !1
        }, disableInput: function () {
            var e = this.getInput();
            if (!e) return !1;
            if (e && "radio" === e.type) for (var t = e.parentNode.parentNode.querySelectorAll("input"), n = 0; n < t.length; n++) t[n].disabled = !0; else e.disabled = !0
        }, showValidationMessage: Ee, resetValidationMessage: Le, resetValidationError: function () {
            m("Swal.resetValidationError() is deprecated and will be removed in the next major release, use Swal.resetValidationMessage() instead"), Le.bind(this)()
        }, showValidationError: function (e) {
            m("Swal.showValidationError() is deprecated and will be removed in the next major release, use Swal.showValidationMessage() instead"), Ee.bind(this)(e)
        }, getProgressSteps: function () {
            return Pe.innerParams.get(this).progressSteps
        }, setProgressSteps: function (e) {
            var t = r({}, Pe.innerParams.get(this), {progressSteps: e});
            Pe.innerParams.set(this, t), re(t)
        }, showProgressSteps: function () {
            var e = Pe.domCache.get(this);
            K(e.progressSteps)
        }, hideProgressSteps: function () {
            var e = Pe.domCache.get(this);
            F(e.progressSteps)
        }, _main: function (e) {
            var T = this;
            ye(e);
            var M = r({}, me, e);
            !function (t) {
                var e;
                t.inputValidator || Object.keys(Me).forEach(function (e) {
                    t.input === e && (t.inputValidator = t.expectRejections ? Me[e] : De.adaptInputValidator(Me[e]))
                }), t.validationMessage && ("object" !== q(t.extraParams) && (t.extraParams = {}), t.extraParams.validationMessage = t.validationMessage), (!t.target || "string" == typeof t.target && !document.querySelector(t.target) || "string" != typeof t.target && !t.target.appendChild) && (R('Target parameter is not valid, defaulting to "body"'), t.target = "body"), "function" == typeof t.animation && (t.animation = t.animation.call());
                var n = k(), o = "string" == typeof t.target ? document.querySelector(t.target) : t.target;
                e = n && o && n.parentNode !== o.parentNode ? X(t) : n || X(t), t.width && (e.style.width = "number" == typeof t.width ? t.width + "px" : t.width), t.padding && (e.style.padding = "number" == typeof t.padding ? t.padding + "px" : t.padding), t.background && (e.style.background = t.background);
                for (var i = window.getComputedStyle(e).getPropertyValue("background-color"), r = e.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix"), a = 0; a < r.length; a++) r[a].style.backgroundColor = i;
                var s = w(), c = $(), u = Y();
                if (ae(t), ne(t), "string" == typeof t.backdrop ? w().style.background = t.backdrop : t.backdrop || z([document.documentElement, document.body], _["no-backdrop"]), !t.backdrop && t.allowOutsideClick && R('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`'), t.position in _ ? z(s, _[t.position]) : (R('The "position" parameter is not valid, defaulting to "center"'), z(s, _.center)), t.grow && "string" == typeof t.grow) {
                    var l = "grow-" + t.grow;
                    l in _ && z(s, _[l])
                }
                t.showCloseButton ? (c.setAttribute("aria-label", t.closeButtonAriaLabel), K(c)) : F(c), e.className = _.popup, t.toast ? (z([document.documentElement, document.body], _["toast-shown"]), z(e, _.toast)) : z(e, _.modal), t.customClass && z(e, t.customClass), re(t), oe(t), ie(t), te(t), G(t.footer, u), !0 === t.animation ? W(e, _.noanimation) : z(e, _.noanimation), t.showLoaderOnConfirm && !t.preConfirm && R("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request")
            }(M), Object.freeze(M), Pe.innerParams.set(this, M), le.timeout && (le.timeout.stop(), delete le.timeout), clearTimeout(le.restoreFocusTimeout);
            var j = {
                popup: k(),
                container: w(),
                content: B(),
                actions: Q(),
                confirmButton: E(),
                cancelButton: L(),
                closeButton: $(),
                validationMessage: O(),
                progressSteps: P()
            };
            Pe.domCache.set(this, j);
            var V = this.constructor;
            return new Promise(function (t, n) {
                var o = function (e) {
                    V.closePopup(M.onClose, M.onAfterClose), M.useRejections ? t(e) : t({value: e})
                }, c = function (e) {
                    V.closePopup(M.onClose, M.onAfterClose), M.useRejections ? n(e) : t({dismiss: e})
                }, u = function (e) {
                    V.closePopup(M.onClose, M.onAfterClose), n(e)
                };
                M.timer && (le.timeout = new Te(function () {
                    c("timer"), delete le.timeout
                }, M.timer)), M.input && setTimeout(function () {
                    var e = T.getInput();
                    e && N(e)
                }, 0);
                for (var l = function (t) {
                    if (M.showLoaderOnConfirm && V.showLoading(), M.preConfirm) {
                        T.resetValidationMessage();
                        var e = Promise.resolve().then(function () {
                            return M.preConfirm(t, M.extraParams)
                        });
                        M.expectRejections ? e.then(function (e) {
                            return o(e || t)
                        }, function (e) {
                            T.hideLoading(), e && T.showValidationMessage(e)
                        }) : e.then(function (e) {
                            Z(j.validationMessage) || !1 === e ? T.hideLoading() : o(e || t)
                        }, function (e) {
                            return u(e)
                        })
                    } else o(t)
                }, e = function (e) {
                    var t = e.target, n = j.confirmButton, o = j.cancelButton, i = n && (n === t || n.contains(t)),
                        r = o && (o === t || o.contains(t));
                    switch (e.type) {
                        case"click":
                            if (i && V.isVisible()) if (T.disableButtons(), M.input) {
                                var a = function () {
                                    var e = T.getInput();
                                    if (!e) return null;
                                    switch (M.input) {
                                        case"checkbox":
                                            return e.checked ? 1 : 0;
                                        case"radio":
                                            return e.checked ? e.value : null;
                                        case"file":
                                            return e.files.length ? e.files[0] : null;
                                        default:
                                            return M.inputAutoTrim ? e.value.trim() : e.value
                                    }
                                }();
                                if (M.inputValidator) {
                                    T.disableInput();
                                    var s = Promise.resolve().then(function () {
                                        return M.inputValidator(a, M.extraParams)
                                    });
                                    M.expectRejections ? s.then(function () {
                                        T.enableButtons(), T.enableInput(), l(a)
                                    }, function (e) {
                                        T.enableButtons(), T.enableInput(), e && T.showValidationMessage(e)
                                    }) : s.then(function (e) {
                                        T.enableButtons(), T.enableInput(), e ? T.showValidationMessage(e) : l(a)
                                    }, function (e) {
                                        return u(e)
                                    })
                                } else T.getInput().checkValidity() ? l(a) : (T.enableButtons(), T.showValidationMessage(M.validationMessage))
                            } else l(!0); else r && V.isVisible() && (T.disableButtons(), c(V.DismissReason.cancel))
                    }
                }, i = j.popup.querySelectorAll("button"), r = 0; r < i.length; r++) i[r].onclick = e, i[r].onmouseover = e, i[r].onmouseout = e, i[r].onmousedown = e;
                if (j.closeButton.onclick = function () {
                    c(V.DismissReason.close)
                }, M.toast) j.popup.onclick = function () {
                    M.showConfirmButton || M.showCancelButton || M.showCloseButton || M.input || c(V.DismissReason.close)
                }; else {
                    var a = !1;
                    j.popup.onmousedown = function () {
                        j.container.onmouseup = function (e) {
                            j.container.onmouseup = void 0, e.target === j.container && (a = !0)
                        }
                    }, j.container.onmousedown = function () {
                        j.popup.onmouseup = function (e) {
                            j.popup.onmouseup = void 0, (e.target === j.popup || j.popup.contains(e.target)) && (a = !0)
                        }
                    }, j.container.onclick = function (e) {
                        a ? a = !1 : e.target === j.container && H(M.allowOutsideClick) && c(V.DismissReason.backdrop)
                    }
                }
                M.reverseButtons ? j.confirmButton.parentNode.insertBefore(j.cancelButton, j.confirmButton) : j.confirmButton.parentNode.insertBefore(j.confirmButton, j.cancelButton);
                var s = function (e, t) {
                    for (var n = J(M.focusCancel), o = 0; o < n.length; o++) return (e += t) === n.length ? e = 0 : -1 === e && (e = n.length - 1), n[e].focus();
                    j.popup.focus()
                };
                le.keydownHandlerAdded && (le.keydownTarget.removeEventListener("keydown", le.keydownHandler, {capture: le.keydownListenerCapture}), le.keydownHandlerAdded = !1), M.toast || (le.keydownHandler = function (e) {
                    return function (e, t) {
                        if (t.stopKeydownPropagation && e.stopPropagation(), "Enter" !== e.key || e.isComposing) if ("Tab" === e.key) {
                            for (var n = e.target, o = J(t.focusCancel), i = -1, r = 0; r < o.length; r++) if (n === o[r]) {
                                i = r;
                                break
                            }
                            e.shiftKey ? s(i, -1) : s(i, 1), e.stopPropagation(), e.preventDefault()
                        } else -1 !== ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Left", "Right", "Up", "Down"].indexOf(e.key) ? document.activeElement === j.confirmButton && Z(j.cancelButton) ? j.cancelButton.focus() : document.activeElement === j.cancelButton && Z(j.confirmButton) && j.confirmButton.focus() : "Escape" !== e.key && "Esc" !== e.key || !0 !== H(t.allowEscapeKey) || (e.preventDefault(), c(V.DismissReason.esc)); else if (e.target && T.getInput() && e.target.outerHTML === T.getInput().outerHTML) {
                            if (-1 !== ["textarea", "file"].indexOf(t.input)) return;
                            V.clickConfirm(), e.preventDefault()
                        }
                    }(e, M)
                }, le.keydownTarget = M.keydownListenerCapture ? window : j.popup, le.keydownListenerCapture = M.keydownListenerCapture, le.keydownTarget.addEventListener("keydown", le.keydownHandler, {capture: le.keydownListenerCapture}), le.keydownHandlerAdded = !0), T.enableButtons(), T.hideLoading(), T.resetValidationMessage(), M.toast && (M.input || M.footer || M.showCloseButton) ? z(document.body, _["toast-column"]) : W(document.body, _["toast-column"]);
                for (var d, p, f = ["input", "file", "range", "select", "radio", "checkbox", "textarea"], m = function (e) {
                    e.placeholder && !M.inputPlaceholder || (e.placeholder = M.inputPlaceholder)
                }, h = 0; h < f.length; h++) {
                    var g = _[f[h]], b = U(j.content, g);
                    if (d = T.getInput(f[h])) {
                        for (var v in d.attributes) if (d.attributes.hasOwnProperty(v)) {
                            var y = d.attributes[v].name;
                            "type" !== y && "value" !== y && d.removeAttribute(y)
                        }
                        for (var w in M.inputAttributes) d.setAttribute(w, M.inputAttributes[w])
                    }
                    b.className = g, M.inputClass && z(b, M.inputClass), F(b)
                }
                switch (M.input) {
                    case"text":
                    case"email":
                    case"password":
                    case"number":
                    case"tel":
                    case"url":
                        d = U(j.content, _.input), "string" == typeof M.inputValue || "number" == typeof M.inputValue ? d.value = M.inputValue : R('Unexpected type of inputValue! Expected "string" or "number", got "'.concat(q(M.inputValue), '"')), m(d), d.type = M.input, K(d);
                        break;
                    case"file":
                        m(d = U(j.content, _.file)), d.type = M.input, K(d);
                        break;
                    case"range":
                        var C = U(j.content, _.range), k = C.querySelector("input"), x = C.querySelector("output");
                        k.value = M.inputValue, k.type = M.input, x.value = M.inputValue, K(C);
                        break;
                    case"select":
                        var A = U(j.content, _.select);
                        if (A.innerHTML = "", M.inputPlaceholder) {
                            var B = document.createElement("option");
                            B.innerHTML = M.inputPlaceholder, B.value = "", B.disabled = !0, B.selected = !0, A.appendChild(B)
                        }
                        p = function (e) {
                            e.forEach(function (e) {
                                var t = e[0], n = e[1], o = document.createElement("option");
                                o.value = t, o.innerHTML = n, M.inputValue.toString() === t.toString() && (o.selected = !0), A.appendChild(o)
                            }), K(A), A.focus()
                        };
                        break;
                    case"radio":
                        var S = U(j.content, _.radio);
                        S.innerHTML = "", p = function (e) {
                            e.forEach(function (e) {
                                var t = e[0], n = e[1], o = document.createElement("input"),
                                    i = document.createElement("label");
                                o.type = "radio", o.name = _.radio, o.value = t, M.inputValue.toString() === t.toString() && (o.checked = !0);
                                var r = document.createElement("span");
                                r.innerHTML = n, r.className = _.label, i.appendChild(o), i.appendChild(r), S.appendChild(i)
                            }), K(S);
                            var t = S.querySelectorAll("input");
                            t.length && t[0].focus()
                        };
                        break;
                    case"checkbox":
                        var P = U(j.content, _.checkbox), O = T.getInput("checkbox");
                        O.type = "checkbox", O.value = 1, O.id = _.checkbox, O.checked = Boolean(M.inputValue), P.querySelector("span").innerHTML = M.inputPlaceholder, K(P);
                        break;
                    case"textarea":
                        var E = U(j.content, _.textarea);
                        E.value = M.inputValue, m(E), K(E);
                        break;
                    case null:
                        break;
                    default:
                        I('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'.concat(M.input, '"'))
                }
                if ("select" === M.input || "radio" === M.input) {
                    var L = function (e) {
                        return p((t = e, n = [], "undefined" != typeof Map && t instanceof Map ? t.forEach(function (e, t) {
                            n.push([t, e])
                        }) : Object.keys(t).forEach(function (e) {
                            n.push([e, t[e]])
                        }), n));
                        var t, n
                    };
                    D(M.inputOptions) ? (V.showLoading(), M.inputOptions.then(function (e) {
                        T.hideLoading(), L(e)
                    })) : "object" === q(M.inputOptions) ? L(M.inputOptions) : I("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(q(M.inputOptions)))
                } else -1 !== ["text", "email", "number", "tel", "textarea"].indexOf(M.input) && D(M.inputValue) && (V.showLoading(), F(d), M.inputValue.then(function (e) {
                    d.value = "number" === M.input ? parseFloat(e) || 0 : e + "", K(d), d.focus(), T.hideLoading()
                }).catch(function (e) {
                    I("Error in inputValue promise: " + e), d.value = "", K(d), d.focus(), T.hideLoading()
                }));
                je(M), M.toast || (H(M.allowEnterKey) ? M.focusCancel && Z(j.cancelButton) ? j.cancelButton.focus() : M.focusConfirm && Z(j.confirmButton) ? j.confirmButton.focus() : s(-1, 1) : document.activeElement && document.activeElement.blur()), j.container.scrollTop = 0
            })
        }
    });

    function Re() {
        if ("undefined" != typeof window) {
            "undefined" == typeof Promise && I("This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)");
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            if (0 === t.length) return I("At least 1 argument is expected!"), !1;
            Ve = this;
            var o = Object.freeze(this.constructor.argsToParams(t));
            Object.defineProperties(this, {params: {value: o, writable: !1, enumerable: !0}});
            var i = this._main(this.params);
            Pe.promise.set(this, i)
        }
    }

    Re.prototype.then = function (e, t) {
        return Pe.promise.get(this).then(e, t)
    }, Re.prototype.catch = function (e) {
        return Pe.promise.get(this).catch(e)
    }, Re.prototype.finally = function (e) {
        return Pe.promise.get(this).finally(e)
    }, r(Re.prototype, qe), r(Re, Ae), Object.keys(qe).forEach(function (t) {
        Re[t] = function () {
            var e;
            if (Ve) return (e = Ve)[t].apply(e, arguments)
        }
    }), Re.DismissReason = e, Re.noop = function () {
    };
    var Ie, He, De = fe((Ie = Re, He = function (e) {
        function t() {
            return s(this, t), d(this, c(t).apply(this, arguments))
        }

        return a(t, Ie), i(t, [{
            key: "_main", value: function (e) {
                return p(c(t.prototype), "_main", this).call(this, r({}, Ce, e))
            }
        }], [{
            key: "setDefaults", value: function (t) {
                if (m(we), !t || "object" !== q(t)) throw new TypeError("SweetAlert2: The argument for setDefaults() is required and has to be a object");
                ye(t), Object.keys(t).forEach(function (e) {
                    Ie.isValidParameter(e) && (Ce[e] = t[e])
                })
            }
        }, {
            key: "resetDefaults", value: function () {
                m(we), Ce = {}
            }
        }]), t
    }(), "undefined" != typeof window && "object" === q(window._swalDefaults) && He.setDefaults(window._swalDefaults), He));
    return De.default = De
}), "undefined" != typeof window && window.Sweetalert2 && (window.Sweetalert2.version = "7.29.0", window.swal = window.sweetAlert = window.Swal = window.SweetAlert = window.Sweetalert2);
"use strict";
// Set defaults
swal.setDefaults({
    width: 400,
    heightAuto: false,
    padding: '2.5rem',
    buttonsStyling: false,
    confirmButtonClass: 'btn btn-success',
    confirmButtonColor: null,
    cancelButtonClass: 'btn btn-secondary',
    cancelButtonColor: null
});
var identity = function (x) {
    return x;
};

var isArray = function (value) {
    return $.isArray(value);
};

var isObject = function (value) {
    return !isArray(value) && (value instanceof Object);
};

var isNumber = function (value) {
    return value instanceof Number;
};

var isFunction = function (value) {
    return value instanceof Function;
};

var indexOf = function (object, value) {
    return $.inArray(value, object);
};

var inArray = function (array, value) {
    return indexOf(array, value) !== -1;
};

var foreach = function (collection, callback) {
    for (var i in collection) {
        if (collection.hasOwnProperty(i)) {
            callback(collection[i], i, collection);
        }
    }
};


var last = function (array) {
    return array[array.length - 1];
};

var argumentsToArray = function (args) {
    return Array.prototype.slice.call(args);
};

var extend = function () {
    var extended = {};
    foreach(argumentsToArray(arguments), function (o) {
        foreach(o, function (val, key) {
            extended[key] = val;
        });
    });
    return extended;
};

var mapToArray = function (collection, callback) {
    var mapped = [];
    foreach(collection, function (value, key, coll) {
        mapped.push(callback(value, key, coll));
    });
    return mapped;
};

var mapToObject = function (collection, callback, keyCallback) {
    var mapped = {};
    foreach(collection, function (value, key, coll) {
        key = keyCallback ? keyCallback(key, value) : key;
        mapped[key] = callback(value, key, coll);
    });
    return mapped;
};

var map = function (collection, callback, keyCallback) {
    return isArray(collection) ?
        mapToArray(collection, callback) :
        mapToObject(collection, callback, keyCallback);
};

var pluck = function (arrayOfObjects, key) {
    return map(arrayOfObjects, function (val) {
        return val[key];
    });
};

var filter = function (collection, callback) {
    var filtered;

    if (isArray(collection)) {
        filtered = [];
        foreach(collection, function (val, key, coll) {
            if (callback(val, key, coll)) {
                filtered.push(val);
            }
        });
    }
    else {
        filtered = {};
        foreach(collection, function (val, key, coll) {
            if (callback(val, key, coll)) {
                filtered[key] = val;
            }
        });
    }

    return filtered;
};

var call = function (collection, functionName, args) {
    return map(collection, function (object, name) {
        return object[functionName].apply(object, args || []);
    });
};

//execute callback immediately and at most one time on the minimumInterval,
//ignore block attempts
var throttle = function (minimumInterval, callback) {
    var timeout = null;
    return function () {
        var that = this, args = arguments;
        if (timeout === null) {
            timeout = setTimeout(function () {
                timeout = null;
            }, minimumInterval);
            callback.apply(that, args);
        }
    };
};


var mixinPubSub = function (object) {
    object = object || {};
    var topics = {};

    object.publish = function (topic, data) {
        foreach(topics[topic], function (callback) {
            callback(data);
        });
    };

    object.subscribe = function (topic, callback) {
        topics[topic] = topics[topic] || [];
        topics[topic].push(callback);
    };

    object.unsubscribe = function (callback) {
        foreach(topics, function (subscribers) {
            var index = indexOf(subscribers, callback);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
        });
    };

    return object;
};

// jquery.input version 0.0.0
// https://github.com/DubFriend/jquery.input
// (MIT) 09-04-2014
// Brian Detering <BDeterin@gmail.com> (http://www.briandetering.net/)
(function ($) {
    'use strict';

    var createBaseInput = function (fig, my) {
        var self = mixinPubSub(),
            $self = fig.$;

        self.getType = function () {
            throw 'implement me (return type. "text", "radio", etc.)';
        };

        self.$ = function (selector) {
            return selector ? $self.find(selector) : $self;
        };

        self.disable = function () {
            self.$().prop('disabled', true);
            self.publish('isEnabled', false);
        };

        self.enable = function () {
            self.$().prop('disabled', false);
            self.publish('isEnabled', true);
        };

        my.equalTo = function (a, b) {
            return a === b;
        };

        my.publishChange = (function () {
            var oldValue;
            return function (e, domElement) {
                var newValue = self.get();
                if (!my.equalTo(newValue, oldValue)) {
                    self.publish('change', {e: e, domElement: domElement});
                }
                oldValue = newValue;
            };
        }());

        return self;
    };


    var createInput = function (fig, my) {
        var self = createBaseInput(fig, my);

        self.get = function () {
            return self.$().val();
        };

        self.set = function (newValue) {
            self.$().val(newValue);
        };

        self.clear = function () {
            self.set('');
        };

        my.buildSetter = function (callback) {
            return function (newValue) {
                callback.call(self, newValue);
            };
        };

        return self;
    };

    var inputEqualToArray = function (a, b) {
        a = isArray(a) ? a : [a];
        b = isArray(b) ? b : [b];

        var isEqual = true;
        if (a.length !== b.length) {
            isEqual = false;
        }
        else {
            foreach(a, function (value) {
                if (!inArray(b, value)) {
                    isEqual = false;
                }
            });
        }

        return isEqual;
    };

    var createInputButton = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'button';
        };

        self.$().on('change', function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputCheckbox = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'checkbox';
        };

        self.get = function () {
            var values = [];
            self.$().filter(':checked').each(function () {
                values.push($(this).val());
            });
            return values;
        };

        self.set = function (newValues) {
            newValues = isArray(newValues) ? newValues : [newValues];

            self.$().each(function () {
                $(this).prop('checked', false);
            });

            foreach(newValues, function (value) {
                self.$().filter('[value="' + value + '"]')
                    .prop('checked', true);
            });
        };

        my.equalTo = inputEqualToArray;

        self.$().change(function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputEmail = function (fig) {
        var my = {},
            self = createInputText(fig, my);

        self.getType = function () {
            return 'email';
        };

        return self;
    };

    var createInputFile = function (fig) {
        var my = {},
            self = createBaseInput(fig, my);

        self.getType = function () {
            return 'file';
        };

        self.get = function () {
            return last(self.$().val().split('\\'));
        };

        self.clear = function () {
            // http://stackoverflow.com/questions/1043957/clearing-input-type-file-using-jquery
            this.$().each(function () {
                $(this).wrap('<form>').closest('form').get(0).reset();
                $(this).unwrap();
            });
        };

        self.$().change(function (e) {
            my.publishChange(e, this);
            // self.publish('change', self);
        });

        return self;
    };

    var createInputHidden = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'hidden';
        };

        self.$().change(function (e) {
            my.publishChange(e, this);
        });

        return self;
    };
    var createInputMultipleFile = function (fig) {
        var my = {},
            self = createBaseInput(fig, my);

        self.getType = function () {
            return 'file[multiple]';
        };

        self.get = function () {
            // http://stackoverflow.com/questions/14035530/how-to-get-value-of-html-5-multiple-file-upload-variable-using-jquery
            var fileListObject = self.$().get(0).files || [],
                names = [], i;

            for (i = 0; i < (fileListObject.length || 0); i += 1) {
                names.push(fileListObject[i].name);
            }

            return names;
        };

        self.clear = function () {
            // http://stackoverflow.com/questions/1043957/clearing-input-type-file-using-jquery
            this.$().each(function () {
                $(this).wrap('<form>').closest('form').get(0).reset();
                $(this).unwrap();
            });
        };

        self.$().change(function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputMultipleSelect = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'select[multiple]';
        };

        self.get = function () {
            return self.$().val() || [];
        };

        self.set = function (newValues) {
            self.$().val(
                newValues === '' ? [] : isArray(newValues) ? newValues : [newValues]
            );
        };

        my.equalTo = inputEqualToArray;

        self.$().change(function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputPassword = function (fig) {
        var my = {},
            self = createInputText(fig, my);

        self.getType = function () {
            return 'password';
        };

        return self;
    };

    var createInputRadio = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'radio';
        };

        self.get = function () {
            return self.$().filter(':checked').val() || null;
        };

        self.set = function (newValue) {
            if (!newValue) {
                self.$().each(function () {
                    $(this).prop('checked', false);
                });
            }
            else {
                self.$().filter('[value="' + newValue + '"]').prop('checked', true);
            }
        };

        self.$().change(function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputRange = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'range';
        };

        self.$().change(function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputSelect = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'select';
        };

        self.$().change(function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputText = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'text';
        };

        self.$().on('change keyup keydown', function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputTextarea = function (fig) {
        var my = {},
            self = createInput(fig, my);

        self.getType = function () {
            return 'textarea';
        };

        self.$().on('change keyup keydown', function (e) {
            my.publishChange(e, this);
        });

        return self;
    };

    var createInputURL = function (fig) {
        var my = {},
            self = createInputText(fig, my);

        self.getType = function () {
            return 'url';
        };

        return self;
    };

    var buildFormInputs = function (fig) {
        var inputs = {},
            $self = fig.$;

        var constructor = fig.constructorOverride || {
            button: createInputButton,
            text: createInputText,
            url: createInputURL,
            email: createInputEmail,
            password: createInputPassword,
            range: createInputRange,
            textarea: createInputTextarea,
            select: createInputSelect,
            'select[multiple]': createInputMultipleSelect,
            radio: createInputRadio,
            checkbox: createInputCheckbox,
            file: createInputFile,
            'file[multiple]': createInputMultipleFile,
            hidden: createInputHidden
        };

        var addInputsBasic = function (type, selector) {
            var $input = isObject(selector) ? selector : $self.find(selector);

            $input.each(function () {
                var name = $(this).attr('name');
                inputs[name] = constructor[type]({
                    $: $(this)
                });
            });
        };

        var addInputsGroup = function (type, selector) {
            var names = [],
                $input = isObject(selector) ? selector : $self.find(selector);

            if (isObject(selector)) {
                inputs[$input.attr('name')] = constructor[type]({
                    $: $input
                });
            }
            else {
                // group by name attribute
                $input.each(function () {
                    if (indexOf(names, $(this).attr('name')) === -1) {
                        names.push($(this).attr('name'));
                    }
                });

                foreach(names, function (name) {
                    inputs[name] = constructor[type]({
                        $: $self.find('input[name="' + name + '"]')
                    });
                });
            }
        };


        if ($self.is('input, select, textarea')) {
            if ($self.is('input[type="button"], button, input[type="submit"]')) {
                addInputsBasic('button', $self);
            }
            else if ($self.is('textarea')) {
                addInputsBasic('textarea', $self);
            }
            else if (
                $self.is('input[type="text"]') ||
                $self.is('input') && !$self.attr('type')
            ) {
                addInputsBasic('text', $self);
            }
            else if ($self.is('input[type="password"]')) {
                addInputsBasic('password', $self);
            }
            else if ($self.is('input[type="email"]')) {
                addInputsBasic('email', $self);
            }
            else if ($self.is('input[type="url"]')) {
                addInputsBasic('url', $self);
            }
            else if ($self.is('input[type="range"]')) {
                addInputsBasic('range', $self);
            }
            else if ($self.is('select')) {
                if ($self.is('[multiple]')) {
                    addInputsBasic('select[multiple]', $self);
                }
                else {
                    addInputsBasic('select', $self);
                }
            }
            else if ($self.is('input[type="file"]')) {
                if ($self.is('[multiple]')) {
                    addInputsBasic('file[multiple]', $self);
                }
                else {
                    addInputsBasic('file', $self);
                }
            }
            else if ($self.is('input[type="hidden"]')) {
                addInputsBasic('hidden', $self);
            }
            else if ($self.is('input[type="radio"]')) {
                addInputsGroup('radio', $self);
            }
            else if ($self.is('input[type="checkbox"]')) {
                addInputsGroup('checkbox', $self);
            }
            else {
                //in all other cases default to a "text" input interface.
                addInputsBasic('text', $self);
            }
        }
        else {
            addInputsBasic('button', 'input[type="button"], button, input[type="submit"]');
            addInputsBasic('text', 'input[type="text"]');
            addInputsBasic('password', 'input[type="password"]');
            addInputsBasic('email', 'input[type="email"]');
            addInputsBasic('url', 'input[type="url"]');
            addInputsBasic('range', 'input[type="range"]');
            addInputsBasic('textarea', 'textarea');
            addInputsBasic('select', 'select:not([multiple])');
            addInputsBasic('select[multiple]', 'select[multiple]');
            addInputsBasic('file', 'input[type="file"]:not([multiple])');
            addInputsBasic('file[multiple]', 'input[type="file"][multiple]');
            addInputsBasic('hidden', 'input[type="hidden"]');
            addInputsGroup('radio', 'input[type="radio"]');
            addInputsGroup('checkbox', 'input[type="checkbox"]');
        }

        return inputs;
    };

    $.fn.inputVal = function (newValue) {
        var $self = $(this);

        var inputs = buildFormInputs({$: $self});

        if ($self.is('input, textarea, select')) {
            if (typeof newValue === 'undefined') {
                return inputs[$self.attr('name')].get();
            }
            else {
                inputs[$self.attr('name')].set(newValue);
                return $self;
            }
        }
        else {
            if (typeof newValue === 'undefined') {
                return call(inputs, 'get');
            }
            else {
                foreach(newValue, function (value, inputName) {
                    inputs[inputName].set(value);
                });
                return $self;
            }
        }
    };

    $.fn.inputOnChange = function (callback) {
        var $self = $(this);
        var inputs = buildFormInputs({$: $self});
        foreach(inputs, function (input) {
            input.subscribe('change', function (data) {
                callback.call(data.domElement, data.e);
            });
        });
        return $self;
    };

    $.fn.inputDisable = function () {
        var $self = $(this);
        call(buildFormInputs({$: $self}), 'disable');
        return $self;
    };

    $.fn.inputEnable = function () {
        var $self = $(this);
        call(buildFormInputs({$: $self}), 'enable');
        return $self;
    };

    $.fn.inputClear = function () {
        var $self = $(this);
        call(buildFormInputs({$: $self}), 'clear');
        return $self;
    };

}(jQuery));

$.fn.repeaterVal = function () {
    var parse = function (raw) {
        var parsed = [];

        foreach(raw, function (val, key) {
            var parsedKey = [];
            if (key !== "undefined") {
                parsedKey.push(key.match(/^[^\[]*/)[0]);
                parsedKey = parsedKey.concat(map(
                    key.match(/\[[^\]]*\]/g),
                    function (bracketed) {
                        return bracketed.replace(/[\[\]]/g, '');
                    }
                ));

                parsed.push({
                    val: val,
                    key: parsedKey
                });
            }
        });

        return parsed;
    };

    var build = function (parsed) {
        if (
            parsed.length === 1 &&
            (parsed[0].key.length === 0 || parsed[0].key.length === 1 && !parsed[0].key[0])
        ) {
            return parsed[0].val;
        }

        foreach(parsed, function (p) {
            p.head = p.key.shift();
        });

        var grouped = (function () {
            var grouped = {};

            foreach(parsed, function (p) {
                if (!grouped[p.head]) {
                    grouped[p.head] = [];
                }
                grouped[p.head].push(p);
            });

            return grouped;
        }());

        var built;

        if (/^[0-9]+$/.test(parsed[0].head)) {
            built = [];
            foreach(grouped, function (group) {
                built.push(build(group));
            });
        }
        else {
            built = {};
            foreach(grouped, function (group, key) {
                built[key] = build(group);
            });
        }

        return built;
    };

    return build(parse($(this).inputVal()));
};

$.fn.repeater = function (fig) {
    fig = fig || {};

    var setList;

    $(this).each(function () {

        var $self = $(this);

        var show = fig.show || function () {
            $(this).show();
        };

        var hide = fig.hide || function (removeElement) {
            removeElement();
        };

        var $list = $self.find('[data-repeater-list]').first();

        var $filterNested = function ($items, repeaters) {
            return $items.filter(function () {
                return repeaters ?
                    $(this).closest(
                        pluck(repeaters, 'selector').join(',')
                    ).length === 0 : true;
            });
        };

        var $items = function () {
            return $filterNested($list.find('[data-repeater-item]'), fig.repeaters);
        };

        var $itemTemplate = $list.find('[data-repeater-item]')
            .first().clone().hide();

        var $firstDeleteButton = $filterNested(
            $filterNested($(this).find('[data-repeater-item]'), fig.repeaters)
                .first().find('[data-repeater-delete]'),
            fig.repeaters
        );

        if (fig.isFirstItemUndeletable && $firstDeleteButton) {
            $firstDeleteButton.remove();
        }

        var getGroupName = function () {
            var groupName = $list.data('repeater-list');
            return fig.$parent ?
                fig.$parent.data('item-name') + '[' + groupName + ']' :
                groupName;
        };

        var initNested = function ($listItems) {
            if (fig.repeaters) {
                $listItems.each(function () {
                    var $item = $(this);
                    foreach(fig.repeaters, function (nestedFig) {
                        $item.find(nestedFig.selector).repeater(extend(
                            nestedFig, {$parent: $item}
                        ));
                    });
                });
            }
        };

        var $foreachRepeaterInItem = function (repeaters, $item, cb) {
            if (repeaters) {
                foreach(repeaters, function (nestedFig) {
                    cb.call($item.find(nestedFig.selector)[0], nestedFig);
                });
            }
        };

        var setIndexes = function ($items, groupName, repeaters) {
            $items.each(function (index) {
                var $item = $(this);
                $item.data('item-name', groupName + '[' + index + ']');
                $filterNested($item.find('[name]'), repeaters)
                    .each(function () {
                        var $input = $(this);
                        // match non empty brackets (ex: "[foo]")
                        var matches = $input.attr('name').match(/\[[^\]]+\]/g);

                        var name = matches ?
                            // strip "[" and "]" characters
                            last(matches).replace(/\[|\]/g, '') :
                            $input.attr('name');


                        var newName = groupName + '[' + index + '][' + name + ']' +
                            ($input.is(':checkbox') || $input.attr('multiple') ? '[]' : '');

                        $input.attr('name', newName);

                        $foreachRepeaterInItem(repeaters, $item, function (nestedFig) {
                            var $repeater = $(this);
                            setIndexes(
                                $filterNested($repeater.find('[data-repeater-item]'), nestedFig.repeaters || []),
                                groupName + '[' + index + ']' +
                                '[' + $repeater.find('[data-repeater-list]').first().data('repeater-list') + ']',
                                nestedFig.repeaters
                            );
                        });
                    });
            });

            $list.find('input[name][checked]')
                .removeAttr('checked')
                .prop('checked', true);
        };

        setIndexes($items(), getGroupName(), fig.repeaters);
        initNested($items());
        if (fig.initEmpty) {
            $items().remove();
        }

        if (fig.ready) {
            fig.ready(function () {
                setIndexes($items(), getGroupName(), fig.repeaters);
            });
        }

        var appendItem = (function () {
            var setItemsValues = function ($item, data, repeaters) {
                if (data || fig.defaultValues) {
                    var inputNames = {};
                    $filterNested($item.find('[name]'), repeaters).each(function () {
                        var key = $(this).attr('name').match(/\[([^\]]*)(\]|\]\[\])$/)[1];
                        inputNames[key] = $(this).attr('name');
                    });

                    $item.inputVal(map(
                        filter(data || fig.defaultValues, function (val, name) {
                            return inputNames[name];
                        }),
                        identity,
                        function (name) {
                            return inputNames[name];
                        }
                    ));
                }


                $foreachRepeaterInItem(repeaters, $item, function (nestedFig) {
                    var $repeater = $(this);
                    $filterNested(
                        $repeater.find('[data-repeater-item]'),
                        nestedFig.repeaters
                    )
                        .each(function () {
                            var fieldName = $repeater.find('[data-repeater-list]').data('repeater-list');
                            if (data && data[fieldName]) {
                                var $template = $(this).clone();
                                $repeater.find('[data-repeater-item]').remove();
                                foreach(data[fieldName], function (data) {
                                    var $item = $template.clone();
                                    setItemsValues(
                                        $item,
                                        data,
                                        nestedFig.repeaters || []
                                    );
                                    $repeater.find('[data-repeater-list]').append($item);
                                });
                            }
                            else {
                                setItemsValues(
                                    $(this),
                                    nestedFig.defaultValues,
                                    nestedFig.repeaters || []
                                );
                            }
                        });
                });

            };

            return function ($item, data) {
                $list.append($item);
                setIndexes($items(), getGroupName(), fig.repeaters);
                $item.find('[name]').each(function () {
                    $(this).inputClear();
                });
                setItemsValues($item, data || fig.defaultValues, fig.repeaters);
            };
        }());

        var addItem = function (data) {
            var $item = $itemTemplate.clone();
            appendItem($item, data);
            if (fig.repeaters) {
                initNested($item);
            }
            show.call($item.get(0));
        };

        setList = function (rows) {
            $items().remove();
            foreach(rows, addItem);
        };

        $filterNested($self.find('[data-repeater-create]'), fig.repeaters).click(function () {
            addItem();
        });

        $list.on('click', '[data-repeater-delete]', function () {
            var self = $(this).closest('[data-repeater-item]').get(0);
            hide.call(self, function () {
                $(self).remove();
                setIndexes($items(), getGroupName(), fig.repeaters);
            });
        });
    });

    this.setList = setList;

    return this;
};

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global.DOMPurify = factory());
}(this, (function () {
    'use strict';

    var html = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];

// SVG
    var svg = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern'];

    var svgFilters = ['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence'];

    var mathMl = ['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmuliscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mpspace', 'msqrt', 'mystyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover'];

    var text = ['#text'];

    var html$1 = ['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'crossorigin', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'integrity', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns'];

    var svg$1 = ['accent-height', 'accumulate', 'additivive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan'];

    var mathMl$1 = ['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns'];

    var xml = ['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink'];

    /* Add properties to a lookup table */
    function addToSet(set, array) {
        var l = array.length;
        while (l--) {
            if (typeof array[l] === 'string') {
                array[l] = array[l].toLowerCase();
            }
            set[array[l]] = true;
        }
        return set;
    }

    /* Shallow clone an object */
    function clone(object) {
        var newObject = {};
        var property = void 0;
        for (property in object) {
            if (Object.prototype.hasOwnProperty.call(object, property)) {
                newObject[property] = object[property];
            }
        }
        return newObject;
    }

    var MUSTACHE_EXPR = /\{\{[\s\S]*|[\s\S]*\}\}/gm; // Specify template detection regex for SAFE_FOR_TEMPLATES mode
    var ERB_EXPR = /<%[\s\S]*|[\s\S]*%>/gm;
    var DATA_ATTR = /^data-[\-\w.\u00B7-\uFFFF]/; // eslint-disable-line no-useless-escape
    var ARIA_ATTR = /^aria-[\-\w]+$/; // eslint-disable-line no-useless-escape
    var IS_ALLOWED_URI = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; // eslint-disable-line no-useless-escape
    var IS_SCRIPT_OR_DATA = /^(?:\w+script|data):/i;
    var ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; // eslint-disable-line no-control-regex

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i];
            }
            return arr2;
        } else {
            return Array.from(arr);
        }
    }

    var getGlobal = function getGlobal() {
        return typeof window === 'undefined' ? null : window;
    };

    function createDOMPurify() {
        var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

        var DOMPurify = function DOMPurify(root) {
            return createDOMPurify(root);
        };

        /**
         * Version label, exposed for easier checks
         * if DOMPurify is up to date or not
         */
        DOMPurify.version = '1.0.8';

        /**
         * Array of elements that DOMPurify removed during sanitation.
         * Empty if nothing was removed.
         */
        DOMPurify.removed = [];

        if (!window || !window.document || window.document.nodeType !== 9) {
            // Not running in a browser, provide a factory function
            // so that you can pass your own Window
            DOMPurify.isSupported = false;

            return DOMPurify;
        }

        var originalDocument = window.document;
        var useDOMParser = false; // See comment below
        var removeTitle = false; // See comment below

        var document = window.document;
        var DocumentFragment = window.DocumentFragment,
            HTMLTemplateElement = window.HTMLTemplateElement,
            Node = window.Node,
            NodeFilter = window.NodeFilter,
            _window$NamedNodeMap = window.NamedNodeMap,
            NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
            Text = window.Text,
            Comment = window.Comment,
            DOMParser = window.DOMParser;

        // As per issue #47, the web-components registry is inherited by a
        // new document created via createHTMLDocument. As per the spec
        // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
        // a new empty registry is used when creating a template contents owner
        // document, so we use that as our parent document to ensure nothing
        // is inherited.

        if (typeof HTMLTemplateElement === 'function') {
            var template = document.createElement('template');
            if (template.content && template.content.ownerDocument) {
                document = template.content.ownerDocument;
            }
        }

        var _document = document,
            implementation = _document.implementation,
            createNodeIterator = _document.createNodeIterator,
            getElementsByTagName = _document.getElementsByTagName,
            createDocumentFragment = _document.createDocumentFragment;
        var importNode = originalDocument.importNode;


        var hooks = {};

        /**
         * Expose whether this browser supports running the full DOMPurify.
         */
        DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;

        var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
            ERB_EXPR$$1 = ERB_EXPR,
            DATA_ATTR$$1 = DATA_ATTR,
            ARIA_ATTR$$1 = ARIA_ATTR,
            IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
            ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
        var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
        /**
         * We consider the elements and attributes below to be safe. Ideally
         * don't add any new ones but feel free to remove unwanted ones.
         */

        /* allowed element names */

        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(svgFilters), _toConsumableArray(mathMl), _toConsumableArray(text)));

        /* Allowed attribute names */
        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(mathMl$1), _toConsumableArray(xml)));

        /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
        var FORBID_TAGS = null;

        /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
        var FORBID_ATTR = null;

        /* Decide if ARIA attributes are okay */
        var ALLOW_ARIA_ATTR = true;

        /* Decide if custom data attributes are okay */
        var ALLOW_DATA_ATTR = true;

        /* Decide if unknown protocols are okay */
        var ALLOW_UNKNOWN_PROTOCOLS = false;

        /* Output should be safe for jQuery's $() factory? */
        var SAFE_FOR_JQUERY = false;

        /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
        var SAFE_FOR_TEMPLATES = false;

        /* Decide if document with <html>... should be returned */
        var WHOLE_DOCUMENT = false;

        /* Track whether config is already set on this instance of DOMPurify. */
        var SET_CONFIG = false;

        /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
        var FORCE_BODY = false;

        /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html string.
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
        var RETURN_DOM = false;

        /* Decide if a DOM `DocumentFragment` should be returned, instead of a html string */
        var RETURN_DOM_FRAGMENT = false;

        /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
   * `Node` is imported into the current `Document`. If this flag is not enabled the
   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
   * DOMPurify. */
        var RETURN_DOM_IMPORT = false;

        /* Output should be free from DOM clobbering attacks? */
        var SANITIZE_DOM = true;

        /* Keep element content when removing element? */
        var KEEP_CONTENT = true;

        /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
        var IN_PLACE = false;

        /* Allow usage of profiles like html, svg and mathMl */
        var USE_PROFILES = {};

        /* Tags to ignore content of when KEEP_CONTENT is true */
        var FORBID_CONTENTS = addToSet({}, ['audio', 'head', 'math', 'script', 'style', 'template', 'svg', 'video']);

        /* Tags that are safe for data: URIs */
        var DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image']);

        /* Attributes safe for values like "javascript:" */
        var URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

        /* Keep a reference to config to pass to hooks */
        var CONFIG = null;

        /* Ideally, do not touch anything below this line */
        /* ______________________________________________ */

        var formElement = document.createElement('form');

        /**
         * _parseConfig
         *
         * @param  {Object} cfg optional config literal
         */
            // eslint-disable-next-line complexity
        var _parseConfig = function _parseConfig(cfg) {
                /* Shield configuration object from tampering */
                if ((typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
                    cfg = {};
                }
                /* Set configuration parameters */
                ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
                ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
                FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
                FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
                USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
                ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
                ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
                ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
                SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false
                SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
                WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
                RETURN_DOM = cfg.RETURN_DOM || false; // Default false
                RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
                RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false
                FORCE_BODY = cfg.FORCE_BODY || false; // Default false
                SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
                KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
                IN_PLACE = cfg.IN_PLACE || false; // Default false

                IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;

                if (SAFE_FOR_TEMPLATES) {
                    ALLOW_DATA_ATTR = false;
                }

                if (RETURN_DOM_FRAGMENT) {
                    RETURN_DOM = true;
                }

                /* Parse profile info */
                if (USE_PROFILES) {
                    ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(text)));
                    ALLOWED_ATTR = [];
                    if (USE_PROFILES.html === true) {
                        addToSet(ALLOWED_TAGS, html);
                        addToSet(ALLOWED_ATTR, html$1);
                    }
                    if (USE_PROFILES.svg === true) {
                        addToSet(ALLOWED_TAGS, svg);
                        addToSet(ALLOWED_ATTR, svg$1);
                        addToSet(ALLOWED_ATTR, xml);
                    }
                    if (USE_PROFILES.svgFilters === true) {
                        addToSet(ALLOWED_TAGS, svgFilters);
                        addToSet(ALLOWED_ATTR, svg$1);
                        addToSet(ALLOWED_ATTR, xml);
                    }
                    if (USE_PROFILES.mathMl === true) {
                        addToSet(ALLOWED_TAGS, mathMl);
                        addToSet(ALLOWED_ATTR, mathMl$1);
                        addToSet(ALLOWED_ATTR, xml);
                    }
                }

                /* Merge configuration parameters */
                if (cfg.ADD_TAGS) {
                    if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                        ALLOWED_TAGS = clone(ALLOWED_TAGS);
                    }
                    addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
                }
                if (cfg.ADD_ATTR) {
                    if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                        ALLOWED_ATTR = clone(ALLOWED_ATTR);
                    }
                    addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
                }
                if (cfg.ADD_URI_SAFE_ATTR) {
                    addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
                }

                /* Add #text in case KEEP_CONTENT is set to true */
                if (KEEP_CONTENT) {
                    ALLOWED_TAGS['#text'] = true;
                }

                /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
                if (WHOLE_DOCUMENT) {
                    addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
                }

                /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286 */
                if (ALLOWED_TAGS.table) {
                    addToSet(ALLOWED_TAGS, ['tbody']);
                }

                // Prevent further manipulation of configuration.
                // Not available in IE8, Safari 5, etc.
                if (Object && 'freeze' in Object) {
                    Object.freeze(cfg);
                }

                CONFIG = cfg;
            };

        /**
         * _forceRemove
         *
         * @param  {Node} node a DOM node
         */
        var _forceRemove = function _forceRemove(node) {
            DOMPurify.removed.push({element: node});
            try {
                node.parentNode.removeChild(node);
            } catch (err) {
                node.outerHTML = '';
            }
        };

        /**
         * _removeAttribute
         *
         * @param  {String} name an Attribute name
         * @param  {Node} node a DOM node
         */
        var _removeAttribute = function _removeAttribute(name, node) {
            try {
                DOMPurify.removed.push({
                    attribute: node.getAttributeNode(name),
                    from: node
                });
            } catch (err) {
                DOMPurify.removed.push({
                    attribute: null,
                    from: node
                });
            }
            node.removeAttribute(name);
        };

        /**
         * _initDocument
         *
         * @param  {String} dirty a string of dirty markup
         * @return {Document} a DOM, filled with the dirty markup
         */
        var _initDocument = function _initDocument(dirty) {
            /* Create a HTML document */
            var doc = void 0;

            if (FORCE_BODY) {
                dirty = '<remove></remove>' + dirty;
            }

            /* Use DOMParser to workaround Firefox bug (see comment below) */
            if (useDOMParser) {
                try {
                    doc = new DOMParser().parseFromString(dirty, 'text/html');
                } catch (err) {
                }
            }

            /* Remove title to fix an mXSS bug in older MS Edge */
            if (removeTitle) {
                addToSet(FORBID_TAGS, ['title']);
            }

            /* Otherwise use createHTMLDocument, because DOMParser is unsafe in
    Safari (see comment below) */
            if (!doc || !doc.documentElement) {
                doc = implementation.createHTMLDocument('');
                var _doc = doc,
                    body = _doc.body;

                body.parentNode.removeChild(body.parentNode.firstElementChild);
                body.outerHTML = dirty;
            }

            /* Work on whole document or just its body */
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        };

        // Firefox uses a different parser for innerHTML rather than
        // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)
        // which means that you *must* use DOMParser, otherwise the output may
        // not be safe if used in a document.write context later.
        //
        // So we feature detect the Firefox bug and use the DOMParser if necessary.
        //
        // MS Edge, in older versions, is affected by an mXSS behavior. The second
        // check tests for the behavior and fixes it if necessary.
        if (DOMPurify.isSupported) {
            (function () {
                try {
                    var doc = _initDocument('<svg><p><style><img src="</style><img src=x onerror=alert(1)//">');
                    if (doc.querySelector('svg img')) {
                        useDOMParser = true;
                    }
                } catch (err) {
                }
            })();
            (function () {
                try {
                    var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');
                    if (doc.querySelector('title').textContent.match(/<\/title/)) {
                        removeTitle = true;
                    }
                } catch (err) {
                }
            })();
        }

        /**
         * _createIterator
         *
         * @param  {Document} root document/fragment to create iterator for
         * @return {Iterator} iterator instance
         */
        var _createIterator = function _createIterator(root) {
            return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
                return NodeFilter.FILTER_ACCEPT;
            }, false);
        };

        /**
         * _isClobbered
         *
         * @param  {Node} elm element to check for clobbering attacks
         * @return {Boolean} true if clobbered, false if safe
         */
        var _isClobbered = function _isClobbered(elm) {
            if (elm instanceof Text || elm instanceof Comment) {
                return false;
            }
            if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function') {
                return true;
            }
            return false;
        };

        /**
         * _isNode
         *
         * @param  {Node} obj object to check whether it's a DOM node
         * @return {Boolean} true is object is a DOM node
         */
        var _isNode = function _isNode(obj) {
            return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
        };

        /**
         * _executeHook
         * Execute user configurable hooks
         *
         * @param  {String} entryPoint  Name of the hook's entry point
         * @param  {Node} currentNode node to work on with the hook
         * @param  {Object} data additional hook parameters
         */
        var _executeHook = function _executeHook(entryPoint, currentNode, data) {
            if (!hooks[entryPoint]) {
                return;
            }

            hooks[entryPoint].forEach(function (hook) {
                hook.call(DOMPurify, currentNode, data, CONFIG);
            });
        };

        /**
         * _sanitizeElements
         *
         * @protect nodeName
         * @protect textContent
         * @protect removeChild
         *
         * @param   {Node} currentNode to check for permission to exist
         * @return  {Boolean} true if node was killed, false if left alive
         */
        var _sanitizeElements = function _sanitizeElements(currentNode) {
            var content = void 0;

            /* Execute a hook if present */
            _executeHook('beforeSanitizeElements', currentNode, null);

            /* Check if element is clobbered or can clobber */
            if (_isClobbered(currentNode)) {
                _forceRemove(currentNode);
                return true;
            }

            /* Now let's check the element's type and name */
            var tagName = currentNode.nodeName.toLowerCase();

            /* Execute a hook if present */
            _executeHook('uponSanitizeElement', currentNode, {
                tagName: tagName,
                allowedTags: ALLOWED_TAGS
            });

            /* Remove element if anything forbids its presence */
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                /* Keep content except for black-listed elements */
                if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {
                    try {
                        currentNode.insertAdjacentHTML('AfterEnd', currentNode.innerHTML);
                    } catch (err) {
                    }
                }
                _forceRemove(currentNode);
                return true;
            }

            /* Convert markup to cover jQuery behavior */
            if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && /</g.test(currentNode.textContent)) {
                DOMPurify.removed.push({element: currentNode.cloneNode()});
                if (currentNode.innerHTML) {
                    currentNode.innerHTML = currentNode.innerHTML.replace(/</g, '&lt;');
                } else {
                    currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');
                }
            }

            /* Sanitize element content to be template-safe */
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
                /* Get the element's text content */
                content = currentNode.textContent;
                content = content.replace(MUSTACHE_EXPR$$1, ' ');
                content = content.replace(ERB_EXPR$$1, ' ');
                if (currentNode.textContent !== content) {
                    DOMPurify.removed.push({element: currentNode.cloneNode()});
                    currentNode.textContent = content;
                }
            }

            /* Execute a hook if present */
            _executeHook('afterSanitizeElements', currentNode, null);

            return false;
        };

        /**
         * _isValidAttribute
         *
         * @param  {string} lcTag Lowercase tag name of containing element.
         * @param  {string} lcName Lowercase attribute name.
         * @param  {string} value Attribute value.
         * @return {Boolean} Returns true if `value` is valid, otherwise false.
         */
        var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
            /* Make sure attribute cannot clobber */
            if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
                return false;
            }

            /* Sanitize attribute content to be template-safe */
            if (SAFE_FOR_TEMPLATES) {
                value = value.replace(MUSTACHE_EXPR$$1, ' ');
                value = value.replace(ERB_EXPR$$1, ' ');
            }

            /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
            if (ALLOW_DATA_ATTR && DATA_ATTR$$1.test(lcName)) {
                // This attribute is safe
            } else if (ALLOW_ARIA_ATTR && ARIA_ATTR$$1.test(lcName)) {
                // This attribute is safe
                /* Otherwise, check the name is permitted */
            } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
                return false;

                /* Check value is safe. First, is attr inert? If so, is safe */
            } else if (URI_SAFE_ATTRIBUTES[lcName]) {
                // This attribute is safe
                /* Check no script, data or unknown possibly unsafe URI
        unless we know URI values are safe for that attribute */
            } else if (IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) {
                // This attribute is safe
                /* Keep image data URIs alive if src/xlink:href is allowed */
                /* Further prevent gadget XSS for dynamically built script tags */
            } else if ((lcName === 'src' || lcName === 'xlink:href') && lcTag !== 'script' && value.indexOf('data:') === 0 && DATA_URI_TAGS[lcTag]) {
                // This attribute is safe
                /* Allow unknown protocols: This provides support for links that
        are handled by protocol handlers which may be unknown ahead of
        time, e.g. fb:, spotify: */
            } else if (ALLOW_UNKNOWN_PROTOCOLS && !IS_SCRIPT_OR_DATA$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) {
                // This attribute is safe
                /* Check for binary attributes */
                // eslint-disable-next-line no-negated-condition
            } else if (!value) {
                // Binary attributes are safe at this point
                /* Anything else, presume unsafe, do not add it back */
            } else {
                return false;
            }
            return true;
        };

        /**
         * _sanitizeAttributes
         *
         * @protect attributes
         * @protect nodeName
         * @protect removeAttribute
         * @protect setAttribute
         *
         * @param  {Node} node to sanitize
         */
            // eslint-disable-next-line complexity
        var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
                var attr = void 0;
                var value = void 0;
                var lcName = void 0;
                var idAttr = void 0;
                var l = void 0;
                /* Execute a hook if present */
                _executeHook('beforeSanitizeAttributes', currentNode, null);

                var attributes = currentNode.attributes;

                /* Check if we have attributes; if not we might have a text node */

                if (!attributes) {
                    return;
                }

                var hookEvent = {
                    attrName: '',
                    attrValue: '',
                    keepAttr: true,
                    allowedAttributes: ALLOWED_ATTR
                };
                l = attributes.length;

                /* Go backwards over all attributes; safely remove bad ones */
                while (l--) {
                    attr = attributes[l];
                    var _attr = attr,
                        name = _attr.name,
                        namespaceURI = _attr.namespaceURI;

                    value = attr.value.trim();
                    lcName = name.toLowerCase();

                    /* Execute a hook if present */
                    hookEvent.attrName = lcName;
                    hookEvent.attrValue = value;
                    hookEvent.keepAttr = true;
                    _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
                    value = hookEvent.attrValue;

                    /* Remove attribute */
                    // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
                    // remove a "name" attribute from an <img> tag that has an "id"
                    // attribute at the time.
                    if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {
                        idAttr = attributes.id;
                        attributes = Array.prototype.slice.apply(attributes);
                        _removeAttribute('id', currentNode);
                        _removeAttribute(name, currentNode);
                        if (attributes.indexOf(idAttr) > l) {
                            currentNode.setAttribute('id', idAttr.value);
                        }
                    } else if (
                        // This works around a bug in Safari, where input[type=file]
                    // cannot be dynamically set after type has been removed
                        currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {
                        continue;
                    } else {
                        // This avoids a crash in Safari v9.0 with double-ids.
                        // The trick is to first set the id to be empty and then to
                        // remove the attribute
                        if (name === 'id') {
                            currentNode.setAttribute(name, '');
                        }
                        _removeAttribute(name, currentNode);
                    }

                    /* Did the hooks approve of the attribute? */
                    if (!hookEvent.keepAttr) {
                        continue;
                    }

                    /* Is `value` valid for this attribute? */
                    var lcTag = currentNode.nodeName.toLowerCase();
                    if (!_isValidAttribute(lcTag, lcName, value)) {
                        continue;
                    }

                    /* Handle invalid data-* attribute set by try-catching it */
                    try {
                        if (namespaceURI) {
                            currentNode.setAttributeNS(namespaceURI, name, value);
                        } else {
                            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                            currentNode.setAttribute(name, value);
                        }
                        DOMPurify.removed.pop();
                    } catch (err) {
                    }
                }

                /* Execute a hook if present */
                _executeHook('afterSanitizeAttributes', currentNode, null);
            };

        /**
         * _sanitizeShadowDOM
         *
         * @param  {DocumentFragment} fragment to iterate over recursively
         */
        var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
            var shadowNode = void 0;
            var shadowIterator = _createIterator(fragment);

            /* Execute a hook if present */
            _executeHook('beforeSanitizeShadowDOM', fragment, null);

            while (shadowNode = shadowIterator.nextNode()) {
                /* Execute a hook if present */
                _executeHook('uponSanitizeShadowNode', shadowNode, null);

                /* Sanitize tags and elements */
                if (_sanitizeElements(shadowNode)) {
                    continue;
                }

                /* Deep shadow DOM detected */
                if (shadowNode.content instanceof DocumentFragment) {
                    _sanitizeShadowDOM(shadowNode.content);
                }

                /* Check attributes, sanitize if necessary */
                _sanitizeAttributes(shadowNode);
            }

            /* Execute a hook if present */
            _executeHook('afterSanitizeShadowDOM', fragment, null);
        };

        /**
         * Sanitize
         * Public method providing core sanitation functionality
         *
         * @param {String|Node} dirty string or DOM node
         * @param {Object} configuration object
         */
        // eslint-disable-next-line complexity
        DOMPurify.sanitize = function (dirty, cfg) {
            var body = void 0;
            var importedNode = void 0;
            var currentNode = void 0;
            var oldNode = void 0;
            var returnNode = void 0;
            /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
            if (!dirty) {
                dirty = '<!-->';
            }

            /* Stringify, in case dirty is an object */
            if (typeof dirty !== 'string' && !_isNode(dirty)) {
                // eslint-disable-next-line no-negated-condition
                if (typeof dirty.toString !== 'function') {
                    throw new TypeError('toString is not a function');
                } else {
                    dirty = dirty.toString();
                    if (typeof dirty !== 'string') {
                        throw new TypeError('dirty is not a string, aborting');
                    }
                }
            }

            /* Check we can run. Otherwise fall back or ignore */
            if (!DOMPurify.isSupported) {
                if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
                    if (typeof dirty === 'string') {
                        return window.toStaticHTML(dirty);
                    }
                    if (_isNode(dirty)) {
                        return window.toStaticHTML(dirty.outerHTML);
                    }
                }
                return dirty;
            }

            /* Assign config vars */
            if (!SET_CONFIG) {
                _parseConfig(cfg);
            }

            /* Clean up removed elements */
            DOMPurify.removed = [];

            if (IN_PLACE) {
                /* No special handling necessary for in-place sanitization */
            } else if (dirty instanceof Node) {
                /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
                body = _initDocument('<!-->');
                importedNode = body.ownerDocument.importNode(dirty, true);
                if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
                    /* Node is already a body, use as is */
                    body = importedNode;
                } else {
                    body.appendChild(importedNode);
                }
            } else {
                /* Exit directly if we have nothing to do */
                if (!RETURN_DOM && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {
                    return dirty;
                }

                /* Initialize the document to work on */
                body = _initDocument(dirty);

                /* Check we have a DOM node from the data */
                if (!body) {
                    return RETURN_DOM ? null : '';
                }
            }

            /* Remove first element node (ours) if FORCE_BODY is set */
            if (body && FORCE_BODY) {
                _forceRemove(body.firstChild);
            }

            /* Get node iterator */
            var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

            /* Now start iterating over the created document */
            while (currentNode = nodeIterator.nextNode()) {
                /* Fix IE's strange behavior with manipulated textNodes #89 */
                if (currentNode.nodeType === 3 && currentNode === oldNode) {
                    continue;
                }

                /* Sanitize tags and elements */
                if (_sanitizeElements(currentNode)) {
                    continue;
                }

                /* Shadow DOM detected, sanitize it */
                if (currentNode.content instanceof DocumentFragment) {
                    _sanitizeShadowDOM(currentNode.content);
                }

                /* Check attributes, sanitize if necessary */
                _sanitizeAttributes(currentNode);

                oldNode = currentNode;
            }

            /* If we sanitized `dirty` in-place, return it. */
            if (IN_PLACE) {
                return dirty;
            }

            /* Return sanitized string or DOM */
            if (RETURN_DOM) {
                if (RETURN_DOM_FRAGMENT) {
                    returnNode = createDocumentFragment.call(body.ownerDocument);

                    while (body.firstChild) {
                        returnNode.appendChild(body.firstChild);
                    }
                } else {
                    returnNode = body;
                }

                if (RETURN_DOM_IMPORT) {
                    /* AdoptNode() is not used because internal state is not reset
               (e.g. the past names map of a HTMLFormElement), this is safe
               in theory but we would rather not risk another attack vector.
               The state that is cloned by importNode() is explicitly defined
               by the specs. */
                    returnNode = importNode.call(originalDocument, returnNode, true);
                }

                return returnNode;
            }

            return WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        };

        /**
         * Public method to set the configuration once
         * setConfig
         *
         * @param {Object} cfg configuration object
         */
        DOMPurify.setConfig = function (cfg) {
            _parseConfig(cfg);
            SET_CONFIG = true;
        };

        /**
         * Public method to remove the configuration
         * clearConfig
         *
         */
        DOMPurify.clearConfig = function () {
            CONFIG = null;
            SET_CONFIG = false;
        };

        /**
         * Public method to check if an attribute value is valid.
         * Uses last set config, if any. Otherwise, uses config defaults.
         * isValidAttribute
         *
         * @param  {string} tag Tag name of containing element.
         * @param  {string} attr Attribute name.
         * @param  {string} value Attribute value.
         * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
         */
        DOMPurify.isValidAttribute = function (tag, attr, value) {
            /* Initialize shared config vars if necessary. */
            if (!CONFIG) {
                _parseConfig({});
            }
            var lcTag = tag.toLowerCase();
            var lcName = attr.toLowerCase();
            return _isValidAttribute(lcTag, lcName, value);
        };

        /**
         * AddHook
         * Public method to add DOMPurify hooks
         *
         * @param {String} entryPoint entry point for the hook to add
         * @param {Function} hookFunction function to execute
         */
        DOMPurify.addHook = function (entryPoint, hookFunction) {
            if (typeof hookFunction !== 'function') {
                return;
            }
            hooks[entryPoint] = hooks[entryPoint] || [];
            hooks[entryPoint].push(hookFunction);
        };

        /**
         * RemoveHook
         * Public method to remove a DOMPurify hook at a given entryPoint
         * (pops it from the stack of hooks if more are present)
         *
         * @param {String} entryPoint entry point for the hook to remove
         */
        DOMPurify.removeHook = function (entryPoint) {
            if (hooks[entryPoint]) {
                hooks[entryPoint].pop();
            }
        };

        /**
         * RemoveHooks
         * Public method to remove all DOMPurify hooks at a given entryPoint
         *
         * @param  {String} entryPoint entry point for the hooks to remove
         */
        DOMPurify.removeHooks = function (entryPoint) {
            if (hooks[entryPoint]) {
                hooks[entryPoint] = [];
            }
        };

        /**
         * RemoveAllHooks
         * Public method to remove all DOMPurify hooks
         *
         */
        DOMPurify.removeAllHooks = function () {
            hooks = {};
        };

        return DOMPurify;
    }

    var purify = createDOMPurify();

    return purify;

})));

